[{"content":"0. 背景 在某些时候我们会使用到显卡对视频转码进行加速，此时可以使用 NVIDA 官方提供的 CUDA 镜像来进行加速，在这个 CUDA 镜像里面提供了完整的 NVIDA 驱动等环境，可以直接被 ffmpeg 调用以进行加速。\n1. 配置基础环境 1.1 安装 NVIDIA Container Toolkit 访问网站 https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html 根据你自己系统的发行版选择安装方式，我这里是 Ubuntu Server，默认情况是 APT 包管理器，因此根据 APT 的步骤进行安装即可。 安装完成之后，使用以下命令启用。\n1 2 sudo nvidia-ctk runtime configure --runtime=docker sudo systemctl restart docker 1.2 禁用 Systemd CG Group 在使用过程当中，当某个 CUDA 容器运行一段时间之后就出现错误:\n1 NOTICE: Containers losing access to GPUs with error: \u0026#34;Failed to initialize NVML: Unknown Error\u0026#34; 查询得知是这个 Issue #48 提到的问题，根据里面的描述，最快的解决办法就是修改 /etc/docker/daemon.json 文件，然后在里面加上:\n1 2 3 { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=cgroupfs\u0026#34;] } 随后重启 Docker 服务。\n1 2 sudo systemctl restart docker sudo systemctl daemon-reload 2. 构建新的镜像 默认情况下 nvidia/cuda:12.4.1-runtime-ubuntu22.04 镜像已经包含了 NVIDIA 驱动，但是没有包含编码器和解码器，所以我们要让 ffmpeg 能够正常工作，就需要安装对应的编解码器。\n1 2 3 4 5 6 7 FROM nvidia/cuda:12.4.1-runtime-ubuntu22.04 AS base # Install dependencies RUN apt update \\ \u0026amp;\u0026amp; apt install -y ffmpeg \\ \u0026amp;\u0026amp; apt install -y bash \\ \u0026amp;\u0026amp; apt install -y libnvidia-encode-550 3. 启动容器 docker run 命令要运行指定镜像时，需要加上一些参数，如下:\n1 docker run -it --gpus all -e NVIDIA_DRIVER_CAPABILITIES=all --rm nvidia/cuda:12.4.1-runtime-ubuntu22.04 bash 如果使用 docker compose 文件，下面就是示例:\n1 2 3 4 5 6 7 8 9 10 services: demo: image: demo-image:latest container_name: \u0026#34;demo\u0026#34; restart: always environment: NVIDIA_DRIVER_CAPABILITIES: all runtime: nvidia ","date":"2024-06-27T13:08:00Z","permalink":"https://real-zony.github.io/p/linux-cuda-docker-video-transcoding/","title":"Linux 使用 CUDA Docker 镜像加速视频转码"},{"content":"0. 问题 新版本上线之后，发现内存猛涨，入站流量猛增，不清楚具体原因，部分接口提示 OOM 异常，随后 Pod 直接崩溃无限重启。\n1. 准备 Pod 已经接入了 NewRelic 和 Graylog，但是仍然没有办法找到真正的罪魁祸手，此时只能进入 Pod 容器当中抓取内存 Dump 信息。我们容器的基础镜像是基于 Apline-3.18 的，进入容器之后执行了以下命令开始安装相应的工具。\n1 2 3 4 5 # 我们的镜像是基于 runtime 的，因此需要手动安装一下 SDK，以便后续操作。 # 这里还安装了 bash，后续会使用 bash 进行交互操作，自带的 sh 不好用。 apk add dotnet6-sdk bash # 安装 Dump 工具 dotnet tool install --global dotnet-dump 因为容器的 ENTRYPOINT 就是直接运行的 dotNET 程序，一般来说其 PID 都是 1，如果你不清楚具体的进程 ID，可以执行\n尝试运行 dotnet-dump collect -p 1 收集 Dump 信息，但是得到了以下错误:\n1 2 3 4 /build# dotnet-dump collect -p 1 Writing full to /build/core_20240307_090401 Write dump failed - HRESULT: 0x00000000. 搜索一番之后，得知这是 Pod 没有足够的权限去执行 Dump 操作，因此修改了 Rollouts(或者 Deplotment) 的 YAML 定义，添加对应的 securityContext 应用即可，随后便能够正确地获取 Dump 文件。\n1 2 3 4 5 6 7 securityContext: capabilities: add: - SYS_PTRACE - SYS_ADMIN seccompProfile: type: RuntimeDefault 再次执行 dotnet-dump collect -p 1 获取到了对应的 Dump 文件，将文件拷贝到挂载的 NFS 卷当中，随即下载到本地以便进行调试排查问题。\n2. 调查 得到 Dump 文件之后，我们可以使用多种工具来分析 Dump 文件，这里我使用的是 dotnet-dump 命令。因为我是 macOS 的机器，使用 dotnet-dump 我可以直接开始进行分析，你也可以使用 Visual Studio 、dotnetMemory、WinDBG 来打开 Dump 的文件，具体看你的喜好了。\n使用 dotnet dump analyze \u0026lt;dump file path\u0026gt; 进入交互式页面:\n1 2 3 Loading core dump: D:\\dotNET_Dumps\\\\core_20240307_142201 ... Ready to process analysis commands. Type \u0026#39;help\u0026#39; to list available commands or \u0026#39;help [command]\u0026#39; to get detailed help on a command. Type \u0026#39;quit\u0026#39; or \u0026#39;exit\u0026#39; to exit the session. 首先我们可以看一下目前 GC 堆的信息:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026gt; eeheap -gc ======================================== Number of GC Heaps: 3 ---------------------------------------- Heap 0 (00007faa2a73b6b0) generation 0 starts at 7fa2495932e8 generation 1 starts at 7fa2458279f0 generation 2 starts at 7fa232703000 ephemeral segment allocation context: none Small object heap segment begin allocated committed allocated size committed size 7fa232702000 7fa232703000 7fa249be4020 7fa252174000 0x174e1020 (390991904) 0x1fa72000 (531046400) Large object heap starts at 7fa3b2703000 segment begin allocated committed allocated size committed size 7fa3b2702000 7fa3b2703000 7fa3e3dfc348 7fa3e3dfd000 0x316f9348 (829395784) 0x316fb000 (829403136) Pinned object heap starts at 7fa6b2703000 segment begin allocated committed allocated size committed size 7fa6b2702000 7fa6b2703000 7fa6b27d4bb8 7fa6b27d5000 0xd1bb8 (859064) 0xd3000 (864256) ------------------------------ Heap 1 (00007faa2a68b6e0) generation 0 starts at 7fa2c75ae080 generation 1 starts at 7fa2c40eec00 generation 2 starts at 7fa2b2703000 ephemeral segment allocation context: none Small object heap segment begin allocated committed allocated size committed size 7fa2b2702000 7fa2b2703000 7fa2c9b1ebb0 7fa2d00b8000 0x1741bbb0 (390183856) 0x1d9b6000 (496721920) Large object heap starts at 7fa4b2703000 segment begin allocated committed allocated size committed size 7fa4b2702000 7fa4b2703000 7fa4e3f804f0 7fa4e3f81000 0x3187d4f0 (830985456) 0x3187f000 (830992384) Pinned object heap starts at 7fa7b2703000 segment begin allocated committed allocated size committed size 7fa7b2702000 7fa7b2703000 7fa7b2703018 7fa7b2704000 0x18 (24) 0x2000 (8192) ------------------------------ Heap 2 (00007faa2a5db720) generation 0 starts at 7fa3466d0298 generation 1 starts at 7fa343173ee0 generation 2 starts at 7fa332703000 ephemeral segment allocation context: none Small object heap segment begin allocated committed allocated size committed size 7fa332702000 7fa332703000 7fa348631878 7fa34f736000 0x15f2e878 (368240760) 0x1d034000 (486752256) Large object heap starts at 7fa5b2703000 segment begin allocated committed allocated size committed size 7fa5b2702000 7fa5b2703000 7fa5e519c3b0 7fa5e519d000 0x32a993b0 (849974192) 0x32a9b000 (849981440) Pinned object heap starts at 7fa8b2703000 segment begin allocated committed allocated size committed size 7fa8b2702000 7fa8b2703000 7fa8b270c0f0 7fa8b2714000 0x90f0 (37104) 0x12000 (73728) ------------------------------ GC Allocated Heap Size: Size: 0xda315cf0 (3660668144) bytes. GC Committed Heap Size: Size: 0xeff58000 (4025843712) bytes. 可以看到有 3 个 GC 堆，并且大部分内存占用都在 LOH 上，我们使用 dumpheap -stat -min 85000 搜索一下大小大于 85000 字节的对象有多少？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026gt; dumpheap -stat -min 85000 Statistics: MT Count TotalSize Class Name 7fa9b9be29c0 1 85,112 Serilog.Events.LogEventPropertyValue[] 7fa9ba87d710 1 117,464 Microsoft.AspNetCore.Routing.Matching.DfaState[] 7fa9b327b110 2 261,648 System.Object[] 7fa9b3348080 2 849,380 System.Int32[] 7fa9bb1e29f8 5 1,441,912 ***.Core.***.*************[] 7fa9b334d2e0 6 1,939,370 System.String 7fa9bb3589a0 1 2,097,176 ***.Core.***.***.***[] 7fa9b5200528 9 2,228,440 ***.Core.***.***[] 7fa9b5206200 20 3,670,496 ***.Core.***.***[] 7fa9bb3625e8 1 4,506,048 System.Collections.Generic.Dictionary\u0026lt;System.String, ***.***.***.***.***\u0026gt;+Entry[] 7fa9b338edd0 20 9,716,748 System.Char[] 7faa2cb14350 76 13,295,160 Free 7fa9b3d60c98 1,100 2,464,160,840 System.Byte[] Total 1,244 objects, 2,504,369,794 bytes 可以看到这里面有 1100 个对象的大小都超过了 85000 字节，总共加起来快 2.3GB 了，所以问题出在这里。随后使用 dumpheap -type System.Byte[] 查看这些具体的对象列表，以便得到具体对象的地址:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 7fa5d5175480 7fa9b3d60c98 18,749,311 7fa5d6356c20 7fa9b3d60c98 6,734,857 7fa5d69c3050 7fa9b3d60c98 878,704 7fa5d6a998e0 7fa9b3d60c98 174,565 7fa5d6ad21c0 7fa9b3d60c98 18,749,311 7fa5d7cb3960 7fa9b3d60c98 6,734,857 7fa5d831fd90 7fa9b3d60c98 10,670,254 7fa5d8d4ce60 7fa9b3d60c98 10,670,254 7fa5d9779f30 7fa9b3d60c98 18,749,311 7fa5da95b6d0 7fa9b3d60c98 18,749,311 7fa5dbb3ce70 7fa9b3d60c98 1,931,776 7fa5dbd6b8e0 7fa9b3d60c98 6,842,488 7fa5dc3f2178 7fa9b3d60c98 7,773,830 7fa5dcb5c020 7fa9b3d60c98 7,773,830 7fa5dd2c5ec8 7fa9b3d60c98 7,773,830 7fa5dda2fd70 7fa9b3d60c98 12,585,235 7fa5de6306a8 7fa9b3d60c98 1,889,260 7fa5de7fdab8 7fa9b3d60c98 1,172,106 7fa5de91bd68 7fa9b3d60c98 134,508 7fa5de94dff8 7fa9b3d60c98 8,857,584 7fa5df1c0808 7fa9b3d60c98 6,842,488 7fa5df8470a0 7fa9b3d60c98 6,842,488 7fa5dfecd938 7fa9b3d60c98 6,842,488 7fa5e05541d0 7fa9b3d60c98 8,857,584 7fa5e0dc69e0 7fa9b3d60c98 7,773,449 7fa5e1530710 7fa9b3d60c98 7,773,449 7fa5e1c9a440 7fa9b3d60c98 980,321 7fa5e1d899c8 7fa9b3d60c98 1,052,316 7fa5e1e8a888 7fa9b3d60c98 1,052,316 7fa5e1f8b748 7fa9b3d60c98 7,373,509 7fa5e2693a30 7fa9b3d60c98 7,373,509 7fa5e2d9bd18 7fa9b3d60c98 2,660,027 7fa5e30253f8 7fa9b3d60c98 2,660,027 7fa5e32aead8 7fa9b3d60c98 2,783,326 7fa5e3556358 7fa9b3d60c98 2,783,326 7fa5e37fdbd8 7fa9b3d60c98 2,783,326 7fa5e3aa5458 7fa9b3d60c98 6,840,270 7fa5e412b448 7fa9b3d60c98 17,239,905 7fa6b27706c8 7fa9b3d60c98 4,120 7fa6b27716e0 7fa9b3d60c98 4,120 7fa6b27726f8 7fa9b3d60c98 4,120 7fa6b2773710 7fa9b3d60c98 4,120 7fa6b2774728 7fa9b3d60c98 4,120 7fa6b2775740 7fa9b3d60c98 4,120 7fa6b2776758 7fa9b3d60c98 4,120 7fa6b2777770 7fa9b3d60c98 4,120 7fa6b2778788 7fa9b3d60c98 4,120 7fa6b27797a0 7fa9b3d60c98 4,120 7fa6b277a7b8 7fa9b3d60c98 4,120 7fa6b277b7d0 7fa9b3d60c98 4,120 7fa6b277c7e8 7fa9b3d60c98 4,120 7fa6b277d800 7fa9b3d60c98 4,120 7fa6b277e818 7fa9b3d60c98 4,120 7fa6b277f830 7fa9b3d60c98 4,120 7fa6b2790860 7fa9b3d60c98 4,120 7fa6b2791878 7fa9b3d60c98 4,120 7fa6b2792890 7fa9b3d60c98 4,120 7fa6b27938a8 7fa9b3d60c98 4,120 7fa6b27948c0 7fa9b3d60c98 4,120 7fa6b27958d8 7fa9b3d60c98 4,120 7fa6b27968f0 7fa9b3d60c98 4,120 7fa6b2797908 7fa9b3d60c98 4,120 7fa6b2798920 7fa9b3d60c98 4,120 7fa6b2799938 7fa9b3d60c98 4,120 7fa6b279a950 7fa9b3d60c98 4,120 7fa6b279b968 7fa9b3d60c98 4,120 7fa6b279c980 7fa9b3d60c98 4,120 7fa6b279d998 7fa9b3d60c98 4,120 7fa6b279e9b0 7fa9b3d60c98 4,120 7fa6b279f9c8 7fa9b3d60c98 4,120 7fa6b27a09e0 7fa9b3d60c98 4,120 7fa6b27a19f8 7fa9b3d60c98 4,120 7fa6b27a2a10 7fa9b3d60c98 4,120 7fa6b27a3a28 7fa9b3d60c98 4,120 7fa6b27a4a40 7fa9b3d60c98 4,120 7fa6b27a5a58 7fa9b3d60c98 4,120 7fa6b27a6a70 7fa9b3d60c98 4,120 7fa6b27a7a88 7fa9b3d60c98 4,120 7fa6b27a8aa0 7fa9b3d60c98 4,120 7fa6b27a9ab8 7fa9b3d60c98 4,120 7fa6b27aaad0 7fa9b3d60c98 4,120 7fa6b27abae8 7fa9b3d60c98 4,120 7fa6b27acb00 7fa9b3d60c98 4,120 7fa6b27adb18 7fa9b3d60c98 4,120 7fa6b27aeb30 7fa9b3d60c98 4,120 7fa6b27afb48 7fa9b3d60c98 4,120 7fa6b27b0b60 7fa9b3d60c98 4,120 7fa6b27b1b78 7fa9b3d60c98 4,120 7fa6b27b2b90 7fa9b3d60c98 4,120 7fa6b27b3ba8 7fa9b3d60c98 4,120 7fa8b2703018 7fa9b3d60c98 4,120 7fa8b2704030 7fa9b3d60c98 4,120 7fa8b2705048 7fa9b3d60c98 4,120 7fa8b2706060 7fa9b3d60c98 4,120 7fa8b2707078 7fa9b3d60c98 4,120 7fa8b2708090 7fa9b3d60c98 4,120 7fa8b27090a8 7fa9b3d60c98 4,120 7fa8b270a0c0 7fa9b3d60c98 4,120 7fa8b270b0d8 7fa9b3d60c98 4,120 Statistics: MT Count TotalSize Class Name 7fa9b4c13148 1 24 AutoMapper.Configuration.MemberConfigurationExpression\u0026lt;***.Core.***.***, ***.***.***.***.***, System.Byte[]\u0026gt;+\u0026lt;\u0026gt;c__DisplayClass21_0 7fa9b4c13070 1 32 System.Linq.Expressions.Expression1\u0026lt;System.Func\u0026lt;***.***.***.***, System.Byte[]\u0026gt;\u0026gt; 7fa9bb162720 1 32 System.Collections.Generic.List\u0026lt;System.Byte[]\u0026gt; 7fa9b4c12a38 1 48 AutoMapper.Configuration.MemberConfigurationExpression\u0026lt;***.***.***.***, ***.***.***.***.***, System.Byte[]\u0026gt; 7fa9baa24648 1 64 System.Func\u0026lt;Microsoft.Win32.SafeHandles.SafeX509Handle, System.Byte[]\u0026gt; 7fa9b4199a80 1 64 System.Action\u0026lt;AutoMapper.IMemberConfigurationExpression\u0026lt;***.***.***.***, ***.***.***.***.***, System.Byte[]\u0026gt;\u0026gt; 7fa9ba918cf8 1 64 System.Func\u0026lt;System.String, System.Threading.CancellationToken, System.Byte[]\u0026gt; 7fa9bb7434d0 1 64 System.Buffers.SpanAction\u0026lt;System.Char, System.ValueTuple\u0026lt;System.Byte[], System.Int32, System.Int32\u0026gt;\u0026gt; 7fa9ba21c2f8 1 64 System.Func\u0026lt;System.Byte[], System.Security.Cryptography.HashAlgorithm\u0026gt; 7fa9ba3fb308 1 64 System.Action\u0026lt;System.IntPtr, System.Byte[], System.Int32, System.Net.Sockets.SocketError\u0026gt; 7fa9b98b3e90 67 4,288 System.Action\u0026lt;System.Int32, System.Byte[], System.Int32, System.Net.Sockets.SocketFlags, System.Net.Sockets.SocketError\u0026gt; 7fa9b6ad65e8 55 50,376 System.Byte[][] 7fa9b3d60c98 68,716 3,046,115,321 System.Byte[] Total 68,848 objects, 3,046,170,505 byte 到这一步，你就需要多看看这些对象是什么东西，你可以使用 dumpobj [address] 查看某个对象的具体信息，这里我优先考虑那些比较大的对象，这里我选择了\n7fa5d6ad21c0 看看里面有什么东西。\n1 2 3 4 5 6 7 8 9 10 \u0026gt; dumpobj 7fa5d6ad21c0 Name: System.Byte[] MethodTable: 00007fa9b3d60c98 EEClass: 00007fa9b3d60c28 Tracked Type: false Size: 18749311(0x11e177f) bytes Array: Rank 1, Number of elements 18749287, Type Byte Content: ... ftypisom....isomiso2avc1mp41....free...}mdat..........E....H..,. .#..x264 - core 155 r2917 0a84d98 - H.264/MPEG-4 AVC codec Fields: None 从内容可以看到，这似乎是一个视频文件被加载到了一个字节数组，那么我们需要看看谁在持有它，这里我们可以使用 gcroot [address] 来查看它的引用情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026gt; gcroot 7fa5d6ad21c0 Caching GC roots, this may take a while. Subsequent runs of this command will be faster. Thread da: 7fa21caae740 7fa9ba5849b9 Serilog.Capturing.PropertyValueConverter.TryConvertEnumerable(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) r12: -\u0026gt; 7fa236bd11a8 System.Collections.Generic.List\u0026lt;***.***.***.CompanyManager\u0026gt; -\u0026gt; 7fa5b420b040 ***.***.***.CompanyManager[] -\u0026gt; 7fa236bd1c90 ***.***.***.CompanyManager -\u0026gt; 7fa33f3b91e0 ***.***.***.CompanyTypeManager -\u0026gt; 7fa33fa34ee8 System.Collections.Generic.List\u0026lt;***.***.***.ManualManager\u0026gt; -\u0026gt; 7fa33fa375f0 ***.***.***.ManualManager[] -\u0026gt; 7fa33fa37058 ***.***.***.ManualManager -\u0026gt; 7fa5d6ad21c0 System.Byte[] ... Other Information 7fa21caaf680 7fa9b93b3c34 Serilog.Core.Logger.ForContext(System.String, System.Object, Boolean) r15: -\u0026gt; 7fa2b6278930 ***.***.***.Services.BaseResponse -\u0026gt; 7fa2b627dc18 ***.***.***.ServiceLogItemManager -\u0026gt; 7fa2b627d998 ***.***.***.ServiceLogManager -\u0026gt; 7fa236bcac90 ***.***.***.UserManager -\u0026gt; 7fa236bccbb0 ***.***.***.UserGroupManager -\u0026gt; 7fa236bcd558 ***.***.***.CompanyManager -\u0026gt; 7fa236bcdfb8 ***.***.***.CompanyTypeManager -\u0026gt; 7fa236bd11a8 System.Collections.Generic.List\u0026lt;***.***.***.CompanyManager\u0026gt; -\u0026gt; 7fa5b420b040 ***.***.***.CompanyManager[] -\u0026gt; 7fa236bd1c90 ***.***.***.CompanyManager -\u0026gt; 7fa33f3b91e0 ***.***.***.CompanyTypeManager -\u0026gt; 7fa33fa34ee8 System.Collections.Generic.List\u0026lt;***.***.***.ManualManager\u0026gt; -\u0026gt; 7fa33fa375f0 ***.***.***.ManualManager[] -\u0026gt; 7fa33fa37058 ***.***.***.ManualManager -\u0026gt; 7fa5d6ad21c0 System.Byte[] 7fa21caaf710 7fa9bb62a3a2 ***.***.***.***.SendNewOrderIntegrationBeforeCommit(***.***.***.***, System.Collections.Generic.List`1\u0026lt;***.***.***.***Manager\u0026gt;) rbp-d0: 00007fa21caaf850 -\u0026gt; 7fa2b6278930 ***.***.***.***.BaseResponse -\u0026gt; 7fa2b627dc18 ***.***.***.ServiceLogItemManager -\u0026gt; 7fa2b627d998 ***.***.***.ServiceLogManager -\u0026gt; 7fa236bcac90 ***.***.***.UserManager -\u0026gt; 7fa236bccbb0 ***.***.***.UserGroupManager -\u0026gt; 7fa236bcd558 ***.***.***.CompanyManager -\u0026gt; 7fa236bcdfb8 ***.***.***.CompanyTypeManager -\u0026gt; 7fa236bd11a8 System.Collections.Generic.List\u0026lt;***.***.***.CompanyManager\u0026gt; -\u0026gt; 7fa5b420b040 ***.***.***.CompanyManager[] -\u0026gt; 7fa236bd1c90 ***.***.***.CompanyManager -\u0026gt; 7fa33f3b91e0 ***.***.***.CompanyTypeManager -\u0026gt; 7fa33fa34ee8 System.Collections.Generic.List\u0026lt;***.***.***.ManualManager\u0026gt; -\u0026gt; 7fa33fa375f0 ***.***.***.ManualManager[] -\u0026gt; 7fa33fa37058 ***.***.***.ManualManager -\u0026gt; 7fa5d6ad21c0 System.Byte[] Found 32 unique roots. 看起来这里的 Byte[] 最后是被某个 BaseResponse 所持有的，并且被 7fa21caaf680 7fa9b93b3c34 Serilog.Core.Logger.ForContext(System.String, System.Object, Boolean) 调用，其实到这一步我也猜到大概是什么原因了，如果想要获取更加详细的信息，可以切换到对应线程执行 clrstack 查看调用堆栈。\n这里 Thread Number 是 da，使用 threads 指令查看所有线程:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026gt; threads *0 0x0001 (1) 1 0x0007 (7) 2 0x0008 (8) 3 0x0009 (9) 4 0x000A (10) 5 0x000B (11) 6 0x000C (12) 7 0x000D (13) 8 0x000E (14) 9 0x000F (15) 10 0x0010 (16) 11 0x0011 (17) 12 0x0013 (19) 13 0x0017 (23) 14 0x0018 (24) 15 0x0019 (25) 16 0x001B (27) 17 0x001D (29) 18 0x001E (30) 19 0x001F (31) 20 0x0020 (32) 21 0x0024 (36) 22 0x0025 (37) 23 0x0026 (38) 24 0x002A (42) 25 0x004A (74) 26 0x00BB (187) 27 0x00BC (188) 28 0x00BD (189) 29 0x00CE (206) 30 0x00D1 (209) 31 0x00D2 (210) 32 0x00D4 (212) 33 0x00D5 (213) 34 0x00D6 (214) 35 0x00DA (218) 36 0x00DB (219) 发现 0x00DA 对应的是 35 号线程，使用命令 setthread 35 切换到对应线程，执行 clrstack 指令查看调用堆栈。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 \u0026gt; setthread 35 \u0026gt; clrstack OS Thread Id: 0xda (35) Child SP IP Call Site 00007FA21CAACE00 00007faa2ce99f63 [InlinedCallFrame: 00007fa21caace00] Interop+Sys.ReceiveMessage(System.Runtime.InteropServices.SafeHandle, MessageHeader*, System.Net.Sockets.SocketFlags, Int64*) 00007FA21CAACE00 00007fa9ba5ddc38 [InlinedCallFrame: 00007fa21caace00] Interop+Sys.ReceiveMessage(System.Runtime.InteropServices.SafeHandle, MessageHeader*, System.Net.Sockets.SocketFlags, Int64*) 00007FA21CAACDF0 00007FA9BA5DDC38 ILStubClass.IL_STUB_PInvoke(System.Runtime.InteropServices.SafeHandle, MessageHeader*, System.Net.Sockets.SocketFlags, Int64*) 00007FA21CAACE90 00007FA9BA5DDAE9 System.Net.Sockets.SocketPal.SysReceive(System.Net.Sockets.SafeSocketHandle, System.Net.Sockets.SocketFlags, System.Span`1\u0026lt;Byte\u0026gt;, Byte[], Int32 ByRef, System.Net.Sockets.SocketFlags ByRef, Error ByRef) [/_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs @ 158] 00007FA21CAACF30 00007FA9BA5DD671 System.Net.Sockets.SocketPal.TryCompleteReceiveFrom(System.Net.Sockets.SafeSocketHandle, System.Span`1\u0026lt;Byte\u0026gt;, System.Collections.Generic.IList`1\u0026lt;System.ArraySegment`1\u0026lt;Byte\u0026gt;\u0026gt;, System.Net.Sockets.SocketFlags, Byte[], Int32 ByRef, Int32 ByRef, System.Net.Sockets.SocketFlags ByRef, System.Net.Sockets.SocketError ByRef) [/_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs @ 834] 00007FA21CAACFA0 00007FA9BAD28C59 System.Net.Sockets.SocketAsyncContext.ReceiveFrom(System.Memory`1\u0026lt;Byte\u0026gt;, System.Net.Sockets.SocketFlags ByRef, Byte[], Int32 ByRef, Int32, Int32 ByRef) [/_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs @ 1540] 00007FA21CAAD030 00007FA9BAD28ABB System.Net.Sockets.SocketPal.Receive(System.Net.Sockets.SafeSocketHandle, Byte[], Int32, Int32, System.Net.Sockets.SocketFlags, Int32 ByRef) 00007FA21CAAD0B0 00007FA9BAD28857 System.Net.Sockets.Socket.Receive(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags, System.Net.Sockets.SocketError ByRef) 00007FA21CAAD130 00007FA9BAD28549 System.Net.Sockets.NetworkStream.Read(Byte[], Int32, Int32) [/_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/NetworkStream.cs @ 231] 00007FA21CAAD180 00007FA9BAD2DD75 System.IO.Stream.Read(System.Span`1\u0026lt;Byte\u0026gt;) [/_/src/libraries/System.Private.CoreLib/src/System/IO/Stream.cs @ 667] 00007FA21CAAD1D0 00007FA9BA5DC52B System.Net.Sockets.NetworkStream.Read(System.Span`1\u0026lt;Byte\u0026gt;) [/_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/NetworkStream.cs @ 246] 00007FA21CAAD220 00007FA9BAD2DB78 Microsoft.Data.SqlClient.SNI.SslOverTdsStream.Read(System.Span`1\u0026lt;Byte\u0026gt;) [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/SNI/SslOverTdsStream.NetCoreApp.cs @ 32] 00007FA21CAAD290 00007FA9BAD39691 System.Net.Security.SslStream+\u0026lt;EnsureFullTlsFrameAsync\u0026gt;d__186`1[[System.Net.Security.SyncReadWriteAdapter, System.Net.Security]].MoveNext() 00007FA21CAAD310 00007FA9BAD39477 System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.Net.Security.SslStream+\u0026lt;EnsureFullTlsFrameAsync\u0026gt;d__186`1[[System.Net.Security.SyncReadWriteAdapter, System.Net.Security]], System.Net.Security]](\u0026lt;EnsureFullTlsFrameAsync\u0026gt;d__186`1\u0026lt;System.Net.Security.SyncReadWriteAdapter\u0026gt; ByRef) [/_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs @ 38] 00007FA21CAAD350 00007FA9BAD393D7 System.Net.Security.SslStream.EnsureFullTlsFrameAsync[[System.Net.Security.SyncReadWriteAdapter, System.Net.Security]](System.Net.Security.SyncReadWriteAdapter) 00007FA21CAAD3C0 00007FA9BAD38A39 System.Net.Security.SslStream+\u0026lt;ReadAsyncInternal\u0026gt;d__188`1[[System.Net.Security.SyncReadWriteAdapter, System.Net.Security]].MoveNext() [/_/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs @ 963] 00007FA21CAAD520 00007FA9BAD385D7 System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.Net.Security.SslStream+\u0026lt;ReadAsyncInternal\u0026gt;d__188`1[[System.Net.Security.SyncReadWriteAdapter, System.Net.Security]], System.Net.Security]](\u0026lt;ReadAsyncInternal\u0026gt;d__188`1\u0026lt;System.Net.Security.SyncReadWriteAdapter\u0026gt; ByRef) [/_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs @ 38] 00007FA21CAAD560 00007FA9BAD3847B System.Net.Security.SslStream.Read(Byte[], Int32, Int32) [/_/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.cs @ 767] 00007FA21CAAD620 00007FA9BAD27C43 Microsoft.Data.SqlClient.SNI.SNITCPHandle.Receive(Microsoft.Data.SqlClient.SNI.SNIPacket ByRef, Int32) [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/SNI/SNITcpHandle.cs @ 799] 00007FA21CAAD780 00007FA9BAD279FA Microsoft.Data.SqlClient.SNI.TdsParserStateObjectManaged.ReadSyncOverAsync(Int32, UInt32 ByRef) [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/TdsParserStateObjectManaged.cs @ 219] 00007FA21CAAD7D0 00007FA9BAD276EF Microsoft.Data.SqlClient.TdsParserStateObject.ReadSniSyncOverAsync() [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/TdsParserStateObject.cs @ 1223] 00007FA21CAAD820 00007FA9BAD2760C Microsoft.Data.SqlClient.TdsParserStateObject.TryReadNetworkPacket() [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/TdsParserStateObject.cs @ 1181] 00007FA21CAAD840 00007FA9BAD37E54 Microsoft.Data.SqlClient.TdsParserStateObject.TryPrepareBuffer() [/_/src/Microsoft.Data.SqlClient/src/Microsoft/Data/SqlClient/TdsParserStateObject.cs @ 901] 00007FA21CAAD860 00007FA9BAD3C748 Microsoft.Data.SqlClient.TdsParserStateObject.TryReadUInt32(UInt32 ByRef) [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/TdsParserStateObject.cs @ 632] 00007FA21CAAD890 00007FA9BAD7C73C Microsoft.Data.SqlClient.TdsParserStateObject.TryReadPlpLength(Boolean, UInt64 ByRef) [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/TdsParserStateObject.cs @ 908] 00007FA21CAAD8D0 00007FA9BAD7CA11 Microsoft.Data.SqlClient.TdsParserStateObject.TryReadPlpBytes(Byte[] ByRef, Int32, Int32, Int32 ByRef) [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/TdsParserStateObject.cs @ 1054] 00007FA21CAAD930 00007FA9BAD6D9A8 Microsoft.Data.SqlClient.TdsParser.TryReadSqlValue(Microsoft.Data.SqlClient.SqlBuffer, Microsoft.Data.SqlClient.SqlMetaDataPriv, Int32, Microsoft.Data.SqlClient.TdsParserStateObject, Microsoft.Data.SqlClient.SqlCommandColumnEncryptionSetting, System.String, Microsoft.Data.SqlClient.SqlCommand) [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/TdsParser.cs @ 6054] 00007FA21CAAD9B0 00007FA9BAD6CF76 Microsoft.Data.SqlClient.SqlDataReader.TryReadColumnInternal(Int32, Boolean, Boolean) [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/SqlDataReader.cs @ 3915] 00007FA21CAADA40 00007FA9BAD6C92A Microsoft.Data.SqlClient.SqlDataReader.GetValueInternal(Int32) [/_/src/Microsoft.Data.SqlClient/netcore/src/Microsoft/Data/SqlClient/SqlDataReader.cs @ 2719] 00007FA21CAADA60 00007FA9BAD6C864 Microsoft.Data.SqlClient.SqlDataReader.GetValue(Int32) 00007FA21CAADAA0 00007FA9BAD6C26A ***.DataAccess.NeoBaseDAL`1[[System.__Canon, System.Private.CoreLib]].LoadObject(System.Data.IDataReader) 00007FA21CAADBE0 00007FA9BAD7E4C9 ***.DataAccess.NeoBaseDAL`1[[System.__Canon, System.Private.CoreLib]].LoadObjects(Microsoft.Data.SqlClient.SqlDataReader) 00007FA21CAADC20 00007FA9BAD7D6BB ***.DataAccess.NeoBaseDAL`1[[System.__Canon, System.Private.CoreLib]].GetData(System.__Canon, ***.Domain.FiltroPaginador) 00007FA21CAADCC0 00007FA9BAD7D12E ***.Domain.NeoBaseManager`1[[System.__Canon, System.Private.CoreLib]].GetData(System.__Canon) 00007FA21CAADD10 00007FA9BB66EAFD ***.***.***.***.get_ListManual() 00007FA21CAADFC0 00007faa2c663c13 [DebuggerU2MCatchHandlerFrame: 00007fa21caadfc0] 00007FA21CAAE0C8 00007faa2c663c13 [HelperMethodFrame_PROTECTOBJ: 00007fa21caae0c8] System.RuntimeMethodHandle.InvokeMethod(System.Object, System.Span`1\u0026lt;System.Object\u0026gt; ByRef, System.Signature, Boolean, Boolean) 00007FA21CAAE240 00007FA9B49E9B3C System.Reflection.RuntimeMethodInfo.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) [/_/src/coreclr/System.Private.CoreLib/src/System/Reflection/RuntimeMethodInfo.cs @ 435] 00007FA21CAAE2C0 00007FA9BB644BB8 Serilog.Capturing.PropertyValueConverter+\u0026lt;GetProperties\u0026gt;d__22.MoveNext() 00007FA21CAAE340 00007FA9B49A7C29 System.Collections.Generic.LargeArrayBuilder`1[[System.__Canon, System.Private.CoreLib]].AddRange(System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs @ 116] 00007FA21CAAE3A0 00007FA9B40C0EA5 System.Collections.Generic.EnumerableHelpers.ToArray[[System.__Canon, System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs @ 85] 00007FA21CAAE410 00007FA9BA584DD7 Serilog.Capturing.PropertyValueConverter.TryConvertCompilerGeneratedType(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAE460 00007FA9B93B4090 Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAE4D0 00007FA9BB644CCD Serilog.Capturing.PropertyValueConverter+\u0026lt;GetProperties\u0026gt;d__22.MoveNext() 00007FA21CAAE550 00007FA9B49A7C29 System.Collections.Generic.LargeArrayBuilder`1[[System.__Canon, System.Private.CoreLib]].AddRange(System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs @ 116] 00007FA21CAAE5B0 00007FA9B40C0EA5 System.Collections.Generic.EnumerableHelpers.ToArray[[System.__Canon, System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs @ 85] 00007FA21CAAE620 00007FA9BA584DD7 Serilog.Capturing.PropertyValueConverter.TryConvertCompilerGeneratedType(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAE670 00007FA9B93B4090 Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAE6E0 00007FA9BB66EA50 Serilog.Capturing.PropertyValueConverter+DepthLimiter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring) 00007FA21CAAE740 00007FA9BA5849B9 Serilog.Capturing.PropertyValueConverter.TryConvertEnumerable(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAE7A0 00007FA9B93B403D Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAE810 00007FA9BB644CCD Serilog.Capturing.PropertyValueConverter+\u0026lt;GetProperties\u0026gt;d__22.MoveNext() 00007FA21CAAE890 00007FA9B49A7C29 System.Collections.Generic.LargeArrayBuilder`1[[System.__Canon, System.Private.CoreLib]].AddRange(System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs @ 116] 00007FA21CAAE8F0 00007FA9B40C0EA5 System.Collections.Generic.EnumerableHelpers.ToArray[[System.__Canon, System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs @ 85] 00007FA21CAAE960 00007FA9BA584DD7 Serilog.Capturing.PropertyValueConverter.TryConvertCompilerGeneratedType(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAE9B0 00007FA9B93B4090 Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAEA20 00007FA9BB644CCD Serilog.Capturing.PropertyValueConverter+\u0026lt;GetProperties\u0026gt;d__22.MoveNext() 00007FA21CAAEAA0 00007FA9B49A7C29 System.Collections.Generic.LargeArrayBuilder`1[[System.__Canon, System.Private.CoreLib]].AddRange(System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs @ 116] 00007FA21CAAEB00 00007FA9B40C0EA5 System.Collections.Generic.EnumerableHelpers.ToArray[[System.__Canon, System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs @ 85] 00007FA21CAAEB70 00007FA9BA584DD7 Serilog.Capturing.PropertyValueConverter.TryConvertCompilerGeneratedType(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAEBC0 00007FA9B93B4090 Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAEC30 00007FA9BB644CCD Serilog.Capturing.PropertyValueConverter+\u0026lt;GetProperties\u0026gt;d__22.MoveNext() 00007FA21CAAECB0 00007FA9B49A7C29 System.Collections.Generic.LargeArrayBuilder`1[[System.__Canon, System.Private.CoreLib]].AddRange(System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs @ 116] 00007FA21CAAED10 00007FA9B40C0EA5 System.Collections.Generic.EnumerableHelpers.ToArray[[System.__Canon, System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs @ 85] 00007FA21CAAED80 00007FA9BA584DD7 Serilog.Capturing.PropertyValueConverter.TryConvertCompilerGeneratedType(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAEDD0 00007FA9B93B4090 Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAEE40 00007FA9BB644CCD Serilog.Capturing.PropertyValueConverter+\u0026lt;GetProperties\u0026gt;d__22.MoveNext() 00007FA21CAAEEC0 00007FA9B49A7C29 System.Collections.Generic.LargeArrayBuilder`1[[System.__Canon, System.Private.CoreLib]].AddRange(System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs @ 116] 00007FA21CAAEF20 00007FA9B40C0EA5 System.Collections.Generic.EnumerableHelpers.ToArray[[System.__Canon, System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs @ 85] 00007FA21CAAEF90 00007FA9BA584DD7 Serilog.Capturing.PropertyValueConverter.TryConvertCompilerGeneratedType(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAEFE0 00007FA9B93B4090 Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAF050 00007FA9BB644CCD Serilog.Capturing.PropertyValueConverter+\u0026lt;GetProperties\u0026gt;d__22.MoveNext() 00007FA21CAAF0D0 00007FA9B49A7C29 System.Collections.Generic.LargeArrayBuilder`1[[System.__Canon, System.Private.CoreLib]].AddRange(System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs @ 116] 00007FA21CAAF130 00007FA9B40C0EA5 System.Collections.Generic.EnumerableHelpers.ToArray[[System.__Canon, System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs @ 85] 00007FA21CAAF1A0 00007FA9BA584DD7 Serilog.Capturing.PropertyValueConverter.TryConvertCompilerGeneratedType(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAF1F0 00007FA9B93B4090 Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAF260 00007FA9BB644CCD Serilog.Capturing.PropertyValueConverter+\u0026lt;GetProperties\u0026gt;d__22.MoveNext() 00007FA21CAAF2E0 00007FA9B49A7C29 System.Collections.Generic.LargeArrayBuilder`1[[System.__Canon, System.Private.CoreLib]].AddRange(System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs @ 116] 00007FA21CAAF340 00007FA9B40C0EA5 System.Collections.Generic.EnumerableHelpers.ToArray[[System.__Canon, System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs @ 85] 00007FA21CAAF3B0 00007FA9BA584DD7 Serilog.Capturing.PropertyValueConverter.TryConvertCompilerGeneratedType(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAF400 00007FA9B93B4090 Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAF470 00007FA9BB644CCD Serilog.Capturing.PropertyValueConverter+\u0026lt;GetProperties\u0026gt;d__22.MoveNext() 00007FA21CAAF4F0 00007FA9B49A7C29 System.Collections.Generic.LargeArrayBuilder`1[[System.__Canon, System.Private.CoreLib]].AddRange(System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs @ 116] 00007FA21CAAF550 00007FA9B40C0EA5 System.Collections.Generic.EnumerableHelpers.ToArray[[System.__Canon, System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1\u0026lt;System.__Canon\u0026gt;) [/_/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs @ 85] 00007FA21CAAF5C0 00007FA9BA584DD7 Serilog.Capturing.PropertyValueConverter.TryConvertCompilerGeneratedType(System.Object, System.Type, Serilog.Parsing.Destructuring, Serilog.Events.LogEventPropertyValue ByRef) 00007FA21CAAF610 00007FA9B93B4090 Serilog.Capturing.PropertyValueConverter.CreatePropertyValue(System.Object, Serilog.Parsing.Destructuring, Int32) 00007FA21CAAF680 00007FA9B93B3C34 Serilog.Core.Logger.ForContext(System.String, System.Object, Boolean) 00007FA21CAAF710 00007FA9BB62A3A2 ***.***.***.***.SendNewOrderIntegrationBeforeCommit(***.***.***.***, System.Collections.Generic.List`1\u0026lt;***.***.***.***\u0026gt;) 00007FA21CAAF930 00007FA9BB60EDAD ***.***.***.***.GenerateOrder(***.***.***.***, Boolean) 00007FA21CAAFD90 00007FA9BB60910F ***.***.***.***.GenerateOrderManuallyWithSelectedItems(***.***.***.***, ***.***.***.***) 00007FA21CAAFE20 00007FA9BB608F44 ***.***.***.***.GenerateOrder(***.***.***.***, Int64) 00007FA21CAAFE60 00007FA9BB605B29 ***.***.***.Controllers.OrderController.GenerateOrder(***.***.***.***.*********) ... 省略 00007FA21CAB11F0 00007FA9BA585082 NewRelic.Providers.Wrapper.AspNetCore.WrapPipelineMiddleware.Invoke(Microsoft.AspNetCore.Http.HttpContext) 00007FA21CAB1240 00007FA9BA56EDB1 Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+\u0026lt;ProcessRequests\u0026gt;d__226`1[[System.__Canon, System.Private.CoreLib]].MoveNext() 00007FA21CAB13E0 00007FA9B70753AD System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(System.Threading.Thread, System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object) [/_/src/libraries/System.Private.CoreLib/src/System/Threading/ExecutionContext.cs @ 268] 00007FA21CAB1420 00007FA9BADE97EA System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib],[Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol+\u0026lt;ProcessRequests\u0026gt;d__226`1[[System.__Canon, System.Private.CoreLib]], Microsoft.AspNetCore.Server.Kestrel.Core]].MoveNext(System.Threading.Thread) [/_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilderT.cs @ 332] 00007FA21CAB1470 00007FA9B6FD2073 System.Threading.ThreadPoolWorkQueue.Dispatch() [/_/src/libraries/System.Private.CoreLib/src/System/Threading/ThreadPoolWorkQueue.cs @ 724] 00007FA21CAB14E0 00007FA9B6FD0230 System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart() [/_/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.WorkerThread.cs @ 107] 00007FA21CAB16F0 00007faa2c663c13 [DebuggerU2MCatchHandlerFrame: 00007fa21cab16f0] 找到对应方法 SendNewOrderIntegrationBeforeCommit 里面调用 Serilog.Core.Logger.ForContext 的地方，发现了以下代码:\n1 2 3 result objBaseResponse = ***.***(***, ***.IdOrder); Log..ForContext(\u0026#34;{@Result}\u0026#34;, objBaseResponse, true) .Information(\u0026#34;SendNewOrderIntegration end\u0026#34;); 3. 结论 调查 objBaseResponse 得知，里面手搓了类似于导航属性的玩意儿，而且还有循环依赖，这样一旦走到这个打日志的地方，就会遍历对象的属性，与此同时还会触发从数据库获取数据的操作，也就是会导致入站流量飙升。\n1 2 3 4 5 Create a logger that enriches log events with the specified property. Params: propertyName – The name of the property. Must be non-empty. value – The property value. destructureObjects – If true, the value will be serialized as a structured object if possible; if false, the object will be recorded as a scalar or simple array. 本来不指定 true 值可能都不会有问题，一旦指定了 true 值，序列化对象的时候就会完全遍历里面的子对象。\n4. 资料 .NET Core/NET memory dump issue on Kubernetes dotnet-dump fails HRESULT: 0x00000000 not single file app #3118 Debugging .NET Core memory issues (on Linux) with dotnet dump ","date":"2024-03-08T15:30:00Z","permalink":"https://real-zony.github.io/p/troubleshooting-memory-surge-issues-in-dotnet-core-applications/","title":"排查 dotNET Core 程序内存暴涨的问题"},{"content":"问题 更新了 Paralles Desktop 之后，发现 Windows 虚拟机和 Ubuntu 虚拟机均无法找到网卡，无法连接网络。\n解决 打开 Parallels Desktop 对应虚拟机的设置，找到 网络 选项，点击 高级，重新生成 MAC 地址，然后重启虚拟机即可恢复正常。\n","date":"2023-12-28T22:29:00Z","permalink":"https://real-zony.github.io/p/fix-no-network-issue-in-parallels-desktop/","title":"修复 Parallels Desktop 无网络的问题"},{"content":"背景 起因是朋友在使用深信服的 Easy Connect 连接到内网之后，使用 HttpClient 访问对应内网的 API 站点均返回 System.Net.Sockets.SocketException (10060) 异常。但使用其他语言的原生 HTTP 库，比如 Golang / Python / Java 都可以正常访问，因此怀疑是 HttpClient 的问题。\n原因 经过搜索得知，这是存在于 .NET 5 及其以上版本的问题，在 .NET 3.1 是不存在这种情况的。底层原因是从 .NET 5 开始，HttpClient 的底层实现使用的是双栈套接字(Dual-Stack Sockets)，在某些情况下，你的网卡获得了 IPv6 地址，但是 VPN 处于某种原因不能正确地处理 IPv6 请求时就会导致上述情况的发生。在 PR #55012 中，说明了这种情况:\nIntroduces an AppContext switch System.Net.DisableIPv6 and environment variable DOTNET_SYSTEM_NET_DISABLEIPV6 to emulate the lack of OS-level IPv6 support. This is useful to workaround dual-stack socket issues when the OS reports support of IPv6, but some other underlying infrastructure element (typically VPN) doesn\u0026rsquo;t function well with IPv6 request.\nFor consistency, this switch also impacts NameResolution and Ping, not only Sockets.\n解决 根据 PR 提到的信息，我们只需要在程序启动的时候使用以下代码禁用 IPv6 栈即可解决。\n1 AppContext.SetSwitch(\u0026#34;System.Net.DisableIPv6\u0026#34;,true); 相关 Issue / PR:\nhttps://github.com/dotnet/runtime/issues/47267 https://github.com/dotnet/runtime/issues/52287 https://github.com/dotnet/runtime/issues/44686 https://github.com/dotnet/runtime/commit/067aa165d97372f3e281786801d014fccea8b12c ","date":"2023-06-12T23:43:00Z","permalink":"https://real-zony.github.io/p/net-5-and-later-httpclient-timeout-issues/","title":"在 .NET 5 以后的 HttpClient 超时问题"},{"content":"背景 目前项目当中存有 .NET Framework 和 .NET Core 两种类型的项目，但是都需要进行容器化将其分别部署在 Windows 集群和 Linux 集群当中。在 WCF 进行容器化的时候，遇到了以下几个问题：\n某些服务使用到了 WSHttpBinding 保护服务安全，要在容器里面加载 SSL 证书。 WCF 服务的日志，如何重定向到标准输出流? 解决 问题一 关于第一个问题，最开始我觉得只需要将 WCF 服务打包出来，暴露一个 HTTP 端点。然后在这个 WCF 服务的前面再加一层 NGINX，具体的证书由 NGINX 进行管理。大概的流程就是 API Caller --\u0026gt; (HTTPS)F5 --\u0026gt; (HTTPS)NGINX --\u0026gt; (HTTP)WCF，按照这样的方式部署之后，对应的服务端点无法访问，具体的错误提示的是 Schema 不匹配。因为 WSHttpBinding 强制使用 HTTPS，如果我仅暴露一个 HTTP 端点，是无法绕过 WSHttpBinding 的限制的。\n随后我又在网上找到了 这篇文章，该文章的思路就是实现一个 CustomBinding，然后在里面忽略掉这块验证，经过我的测试无法满足需求。\n上述方法行不通就只有创建一个自签 SSL 证书，并导入到 IIS 当中，随后在 NGINX 启用 SSL 转发，目前看来已经解决这个问题。下面是我的 Dockerfile 以及入口点的 PowerShell 脚本，脚本里面包含了证书生成与导入方法。\ndockerfile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 FROM mcr.microsoft.com/dotnet/framework/sdk:4.8 AS build WORKDIR /build COPY . . RUN cd ./src; nuget restore WORKDIR /build/src/ProjectName RUN msbuild Wcf.csproj /p:Configuration=Release -r:False FROM mcr.microsoft.com/dotnet/framework/wcf:4.8-windowsservercore-ltsc2019 AS runtime WORKDIR /WcfService EXPOSE 443 COPY --from=build /build/wcf-entrypoint.ps1 . COPY --from=build /build/src/ProjectName . ENTRYPOINT [\u0026#34;powershell\u0026#34;, \u0026#34;.\\\\wcf-entrypoint.ps1\u0026#34;] entrypoint.ps1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $hostName = $env:HostName $port = \u0026#34;443\u0026#34; $password = \u0026#34;Your password.\u0026#34; $storeLocation = \u0026#34;Cert:\\LocalMachine\\My\u0026#34; $certificate = New-SelfSignedCertificate -DnsName $hostName -CertStoreLocation $storeLocation $thumbPrint = $certificate.Thumbprint $certificatePath = (\u0026#34;cert:\\localmachine\\my\\\u0026#34; + $certificate.Thumbprint) $bindingInformation = \u0026#34;*:\u0026#34; + $port + \u0026#34;:\u0026#34; + $hostName $securedString = ConvertTo-SecureString -String $password -Force -AsPlainText Export-PfxCertificate -FilePath \u0026#34;C:\\WcfService\\temp.pfx\u0026#34; -Cert $certificatePath -Password $securedString Import-PfxCertificate -FilePath \u0026#34;C:\\WcfService\\temp.pfx\u0026#34; -CertStoreLocation \u0026#34;Cert:\\LocalMachine\\Root\u0026#34; -Password $securedString New-IISSite -Name \u0026#34;WcfService\u0026#34; -PhysicalPath C:\\WcfService -BindingInformation $bindingInformation -CertificateThumbPrint $thumbPrint -CertStoreLocation $storeLocation -Protocol https # Entry point for the application. \u0026amp;C:\\\\ServiceMonitor.exe w3svc 问题二 由于 WCF 是托管在 IIS 里面的，我们的日志信息是无法输出到标准输出流的。所以我们就采取了一个曲线救国的方案，使用一个旁路程序，我们的日志输出到文件当中，由这个旁路程序监控文件变动，然后将变动的内容输出到标准输出流里面。\n这个功能有点像 Logstash，你可能会说我们为什么不直接用 Logstash 收集这些日志呢？因为我们所有项目的日志，都是由基础架构团队统一处理。规范就是我们日志必须输出到标准输出流，并且日志是结构化日志，还需带上一些 ProjectId 之类的标记信息。然后由注入的 Sidecar 容器统一收集、处理、上报到 Garylog 平台。\n回到正题，最开始我找到了微软实现的一个开源工具，它的本意就是为一些 Windows 容器解决日志收集问题的。\n项目的地址是: https://github.com/microsoft/windows-container-tools。\n使用这个工具，指定好路径与需要运行的程序，替换 Dockerfile 的入口点即可解决问题。微软那个工具的核心，就是使用了系统提供的文件监听 API，在 .NET 里面也有提供类似的 API，叫做 FileSystemWatcher，如果有兴趣的话，也可以参考 C++ 的源码和思路自己实现。\n","date":"2022-12-31T09:43:00Z","permalink":"https://real-zony.github.io/p/problems-with-containerizing-a-wcf-service/","title":"WCF 服务容器化的一些问题"},{"content":"部署 acme.sh 的部署我采用的是 docker 方式进行部署，相应的 docker-compose.yaml 文件内容如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 version: \u0026#34;3\u0026#34; services: acme.sh: image: neilpang/acme.sh:latest container_name: acme.sh command: daemon volumes: - \u0026#34;./Volume:/acme.sh\u0026#34; - \u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34; environment: - DEPLOY_DOCKER_CONTAINER_LABEL=__nginx__ - DEPLOY_DOCKER_CONTAINER_RELOAD_CMD=\u0026#34;nginx -s reload -c /etc/nginx/nginx.conf\u0026#34; restart: always networks: - internal-network networks: internal-network: external: true 其中 ./Volume 是用于挂载证书文件夹的。\n证书申请 无论是使用哪种方式申请证书，都需要注册申请人的信息。使用 docker exec -ti \u0026lt;container-name\u0026gt; sh 命令进入到容器内部，随后执行以下命令注册信息。\n1 acme.sh --register-account -m \u0026lt;你的 Email 邮箱地址\u0026gt; 阿里云一键申请 首先登录阿里云的控制台，鼠标移动到右上角头像位置，弹出的下拉中选择 AccessKey 管理。\n在新的页面中，选择 创建 AccessKey 即可创建一个新的密钥，记录好 Key 与 Secret 备用。\n还是来到 acme.sh 的容器内部，执行以下命令，将阿里云相关的密钥信息导出到环境变量，以便 acme.sh 使用。最后调用 acme.sh --issue 方法开始自动申请证书。\n下面的变量以 example.com 域名为例，只要申请成功就是泛解析域名的证书。\n1 2 3 4 5 6 # 导出到环境变量。 export Ali_Key=\u0026#34;Key\u0026#34; export Ali_Secret=\u0026#34;Secret\u0026#34; # 申请证书。 acme.sh --issue --dns dns_ali -d example.com -d *.example.com --debug Godaddy 申请 前置操作也是一样的，需要注册申请人的信息，然后来到 Godaddy 对应的 API Key Managment 页面，选择 Create New API Key，在随后的 Environment 中选择 Production，生成了对应的密钥之后，保存下来。\n这里只会显示一次，请记得复制保存对应的密钥信息。\n最后进入到 acme.sh 容器，键入以下命令开始申请 SSL 证书。\n1 2 3 4 5 6 # 导出到环境变量。 export GD_Key=\u0026#34;Key\u0026#34; export GD_Secret=\u0026#34;Secret\u0026#34; # 申请证书。 acme.sh --issue --dns dns_gd -d example.com -d *.example.com Reference: acme.sh 搭配 GoDaddy 自動續期 Let\u0026rsquo;s Encrypt 免費萬用憑證 - 腳印網頁資訊設計\n","date":"2022-10-01T14:04:00Z","permalink":"https://real-zony.github.io/p/based-on-godaddy-and-alicloud-one-click-to-get-ssl-certificate/","title":"基于 Godaddy 与阿里云, 一键申请 SSL 证书"},{"content":"问题 删除某些文件夹的时候，如果该文件夹正在被某些程序占用，则无法删除。\n解决 方法 1 使用 资源管理器 根据文件句柄找到对应的进程，然后手动结束即可。\n方法 2 管理员权限打开 PowerShell/命令行提示符/终端，然后输入 del 命令强制删除文件/文件夹。\n1 del \u0026lt;file/dir path\u0026gt; Reference:\nWindows 10文件/文件夹正在使用无法删除的6个解决方法 ","date":"2022-09-30T20:44:00Z","permalink":"https://real-zony.github.io/p/solve-the-problem-that-occupied-folders-cannot-be-deleted/","title":"解决被占用的文件夹无法被删除的问题"},{"content":"默认情况下，Docker 容器如果不被销毁的话，那么它的日志会一直保留。如果我们有一个连续运行一年的 NGINX 服务容器，那么它的日志文件就会非常大。 Docker 容器的日志都会挂在到 /var/lib/docker/containers/ 文件夹下，并且以下面的格式进行命名。\n1 /var/lib/docker/containers/\u0026lt;container id\u0026gt;/\u0026lt;container id\u0026gt;-json.log 有三种方式限制日志大小，默认情况是全局设置，这样设置的话会对所有容器进行应用。\n方式一 使用文本编辑器编辑 /etc/docker/daemon.json 文件，并在里面加上限制日志容量的相关参数。\n1 2 3 4 { \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: {\u0026#34;max-size\u0026#34;: \u0026#34;10m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;3\u0026#34;} } 修改完成之后，需要重启 Docker 服务。\n1 sudo systemctl restart docker 方式二 如果我们的容器是通过 docker run 命令启动的，我们也可以添加相关参数进行限制。\n1 docker run --log-opt max-size=10m --log-opt max-file=5 my-app:latest 方式三 如果你使用的是 Docker Compose 启动对应的容器，可以在 docker-compose.yaml 文件里面定义相应的参数。\n1 2 3 4 5 6 7 8 9 10 11 version: \u0026#39;3\u0026#39; services: nginx: container_name: nginx image: nginx restart: always logging: driver: \u0026#34;json-file\u0026#34; options: max-file: \u0026#34;5\u0026#34; max-size: \u0026#34;10m\u0026#34; ","date":"2022-09-27T18:09:00Z","permalink":"https://real-zony.github.io/p/limit-the-size-of-logs-output-by-containers-in-docker/","title":"限制容器在 Docker 输出的日志大小"},{"content":"背景 新的 Blog 是基于 Hugo 搭建的，原始博客内容和生成的静态资源，都是托管在 Github 仓库里面的。但 Github Pages 有时候会抽风，并且访问速度并不是很稳定，因此萌生了使用 NGINX 反向代理 Github Pages 的想法。\n解决 基本原理就是将目标站点(Github Pages) 作为一个 upstream 服务，然后 NGINX 负责将所有流量都转发到 upstream 即可。因此，我们的配置文件编写就比较简单了，只需要注意 Host 等信息需要使用 upstream 站点的信息(Github Pages)。\nblog-proxy.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 server{ listen 80; server_name your.blog.com; return 301 https://your.blog.com$request_uri; } server{ listen 443 ssl http2; server_name your.blog.com; ssl_certificate /opt/cert/sslfile.pem; ssl_certificate_key /opt/cert/sslfile.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_redirect off; proxy_set_header Host yourblog.github.io; # 填写 Github Pages 的地址。 proxy_set_header X-Host yourblog.github.io; # 填写 Github Pages 的地址。 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Cache pages. proxy_cache_valid 200 206 304 301 302 1d; # 配置缓存过期时间。 proxy_cache_valid any 1d; proxy_cache_key $uri; proxy_pass https://yourblog.github.io; # 填写 Github Pages 的地址。 } } ","date":"2022-09-27T17:59:00Z","permalink":"https://real-zony.github.io/p/forward-github-pages-site-with-nginx/","title":"使用 NGINX 转发 Github Pages 站点"},{"content":"现象 部分站点配置启用了 SSL 证书，启动站点的时候提示 warn。\ndefault.conf\n1 2 3 4 5 6 7 8 server{ listen 443 ssl http2; server_name something.example.com; ssl on; # ... } Shell 输出\n1 2022/09/27 09:39:10 [warn] 1#1: the \u0026#34;ssl\u0026#34; directive is deprecated, use the \u0026#34;listen ... ssl\u0026#34; directive instead in /etc/nginx/conf.d/default.conf:5 原因 SSL 不建议作为一个指令使用，而只是 listen 指令的一个参数。\n解决 只需要移除掉 ssl on 即可。\nnew-default.conf\n1 2 3 4 5 6 server{ listen 443 ssl http2; server_name something.example.com; # ... } ","date":"2022-09-27T17:47:00Z","permalink":"https://real-zony.github.io/p/nginx-prompts-warn-when-using-ssl-on/","title":"使用 ssl on 时，NGINX 提示 Warn"},{"content":"背景 在 CI/CD 流程当中，测试是 CI 中很重要的部分。跟开发人员关系最大的就是单元测试，单元测试编写完成之后，我们可以使用 IDE 或者 dot cover 等工具获得单元测试对于业务代码的覆盖率。不过我们需要一个独立的 CLI 工具，这样我们才能够在 Jenkins 的 CI 流程集成。\n端到端测试(End to End Test) 是在 Preview 版本部署完成之后，需要对 Preview 版本进行自动化测试，测试完成之后输出对应的覆盖率报告。根据代码覆盖率报告，我们可以了解 QA 编写的测试用例，是否完整覆盖了所有分支流程。\n实现 工具选型 单元测试框架我选择的是 xUnit，它对于 .NET Core 与 .NET Framework 的支持都不错，并且也提供了独立于 IDE 之外的 Console Runner，可以很方便地同 Jenkins 集成。\n覆盖率收集工具我选择的是 AltCover，因为它能够收集到部署在 IIS 的 ASP.NET MVC 程序覆盖率指标，这样我们就能够对一些 .NET Framework 老项目进行测试覆盖率汇总计算。AltCover 可以生成多种格式的覆盖率报告，默认格式是 OpenCover。\nAltCover 生成的覆盖率报告并不是直接可读的，我们需要一个工具来生成人类可以阅读理解的报告。这里我选择的是 ReportGenerator ，它支持 OpenCover 格式的覆盖率报告，并生成对应的 HTML 文件方便查看。\n.NET Framework 集成 我建立了一个简单的 ASP.NET Web API 项目(.NET Framework 4.8)，提供了一个 ApiTestController 控制器，暴露了一个 HTTP POST 方法 CreateOrder，内部逻辑比较简单，就是创建了一个新的 OrderAggregateRoot 实例，然后返回了一个 Success 文本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /// \u0026lt;summary\u0026gt; /// ApiTestController. /// \u0026lt;/summary\u0026gt; [Route(\u0026#34;api/test\u0026#34;)] public class ApiTestController : ApiController { private readonly IOrderRepository _orderRepository; /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;ApiTestController\u0026#34;/\u0026gt;. /// \u0026lt;/summary\u0026gt; public ApiTestController() { _orderRepository = new FakeOrderRepository(); } /// \u0026lt;summary\u0026gt; /// CreateOrder. /// \u0026lt;/summary\u0026gt; [HttpPost] [Route(\u0026#34;api/test/create\u0026#34;)] public IHttpActionResult CreateOrder(CreateOrderInputDto input) { var newOrder = new OrderAggregateRoot(null, input.Items.Select(x =\u0026gt; new OrderItem(x.Price, x.Number)).ToList()); _orderRepository.InsertAsync(newOrder); return Ok(\u0026#34;Success\u0026#34;); } } 单元测试覆盖率报告 单元测试项目建立比较简单，我建立了一个 AltCoverTestUnitTest 项目，并且添加了 ASP.NET Web API 项目的引用，在内部添加了 AltCover 与 xUnit 相关包的引用。\nAltCover 与 xUnit Console Runner 包安装完成之后，对于 .NET Framework 项目来说，会在对应的解决方案目录下面有一个 packages 文件夹，在里面找到 packages\\altcover.8.3.838\\tools\\net472 目录，在这个目录里面有一个 AltCover.exe 的可执行文件，这个就是 AltCover 的 CLI 工具。\n而 xUnit Console Runner 对应的 CLI 工具则在 packages\\xunit.runner.console.2.4.2\\tools\\net472 中，根据自己的平台使用 xunit.console.exe 或者是 xunit.console.x86.exe 均可。\n随后我们直接使用 MSBuild 命令/IDE 重新编译一下单元测试项目，转到对应的 bin\\Debug 目录。在 .bin\\Debug 目录中，执行以下命令，将会生成一个新的文件夹，里面会包含修改后的 DLL 文件。\n这里 CLI 工具的路径，取决于你的实际路径，就在你解决方案对应的 pacakges 里面。\n1 D:\\CoverageTool\\AltCoverTestRESFul\\packages\\altcover.8.3.838\\tools\\net472\\AltCover.exe /o=./__UnitTestWithAltCover -s=Adapter -s=Shouldly -s=Microsoft -t=\u0026#34;Shouldly.\u0026#34; -s=\u0026#34;AltCover.Monitor\u0026#34; -t=\u0026#34;System.\u0026#34; -s=xunit -e=\u0026#34;EmptyFiles\u0026#34; -e=Tests -r=\u0026#34;.\\_Reports\\UnitTestWithAltCover.xml\u0026#34; 这里我解释以下命令，其中 /o 参数指的是修改后 DLL 的输出目录，这里我指定的当前目录下的 __UnitTestWithAltCover 文件夹。-s 参数指的是需要排除的程序集名称，支持通配符与正则表达式。-e 的作用与 -s 类似，具体可以查看 Usage ，最有一个 -r 参数指定报告的输出路径，也就是 OpenCover 格式的 XML 文件输出路径。\n为什么需要排除？因为我们的项目可能会引用很多第三方库，这个时候我们为了减少报告的噪音，你也不想在报告里面看到一堆 Microsoft 的代码吧，所以需要手动排除掉这些程序集。\n为什么叫做修改后，因为执行命令后，AltCover 会重新生成一个新的 DLL，这个新的 DLL 反编译后可以看到会在每行代码插入 Instance.Visit() 来记录代码的访问路径。\n命令执行完成之后，可以看到对应的覆盖率文件生成了，但是这里面覆盖率是 0，因为我们的单元测试还没开始跑。\n随后我们执行下面的命令，使用 xUnit Console Runner 运行我们的单元测试项目。\n1 D:\\CoverageTool\\AltCoverTestRESFul\\packages\\xunit.runner.console.2.4.2\\tools\\net47\\xunit.console.exe ./__UnitTestWithAltCover/AltCoverTestUnitTest.dll -xml \u0026#34;./_Reports/UnitTestWithAltCoverReport.xml\u0026#34; 第一个参数是需要执行的单元测试 DLL，第二个参数 -xml 说明我们具体的执行结果输出路径，这里我们也输出到了 _Reports 文件夹，这个时候我们就有两个 XML 文件了。\n切换到 _Reports 文件夹，打开终端，我们这个时候需要使用 reportgeneator 工具，根据这两个 XML 文件生成人类可读的 HTML 报告。\n1 reportgenerator \u0026#34;-reports:UnitTestWithAltCover.xml;UnitTestWithAltCoverReport.xml\u0026#34; \u0026#34;-targetdir:coveragereport\u0026#34; -reporttypes:Html 上述命令的意思就是根据这两个 xml ，在当前目录的 coveragereport 文件夹，生成一个新的 HTML 报告。\n关于 reportgenerator 的安装，可以参考官方的 线上工具，它会根据你选择的情况返回适合的安装命令。我自己直接使用的 dotnet tool install --global dotnet-reportgenerator-globaltool 命令进行的安装。\n最后的效果:\nIIS Web API 覆盖率报告 我们建立一个新的 IIS 站点，并将对应的 DLL 文件放到对应的目录下面。首先暂停对应 IIS 站点，并且停止对应的应用程序池。\n随后执行以下命令，将会修改对应的 DLL 文件，以便后续进行覆盖率跟踪，原理跟上面的一样。\n1 D:\\CoverageTool\\AltCoverTestRESFul\\packages\\altcover.8.3.838\\tools\\net472\\AltCover.exe --save --inplace -i \u0026#34;D:\\TempFiles\\IIS\\AltCoverTestWebSite\\bin\u0026#34; -s=Adapter -s=Shouldly -s=\u0026#34;Antlr3.Runtime\u0026#34; -s=Microsoft -t=\u0026#34;Shouldly.\u0026#34; -s=\u0026#34;AltCover.Monitor\u0026#34; -t=\u0026#34;System.\u0026#34; -s=xunit -e=\u0026#34;EmptyFiles\u0026#34; -e=Tests 执行完上述命令以后，将会在终端执行目录下生成两个文件，一个是 coverage.xml ，一个是 coverage.xml.acv 文件，后者是 AltCover 的控制文件，用于记录程序在运行过程中的执行代码路径。\n随后启动对应的 IIS 站点与应用程序池，执行自动化测试，或者调用对应的接口。\n如果需要停止测试了，需要将对应的 IIS 站点与应用程序池停止，只有停止了，AltCover 才会将已执行代码路径信息写入到对应的控制文件当中。\n可以看到 coverage.xml.0.acv 文件已经有内容了，但是我们还需要将控制文件的信息合并到 coverage.xml 当中，这个时候需要执行第二个命令进行合并。\n1 D:\\CoverageTool\\AltCoverTestRESFul\\packages\\altcover.8.3.838\\tools\\net472\\AltCover.exe runner --collect -r \u0026#34;D:\\TempFiles\\IIS\\AltCoverTestWebSite\\bin\u0026#34; output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 ... D:\\TempFiles\\IIS\\AltCoverTestWebSite\\coverage.xml.0.acv (380b) 308 visits recorded in 00:00:00.0171096 (18,002 visits/sec) A total of 308 visits recorded Coverage statistics flushing took 0.04 seconds Visited Classes 10 of 12 (83.33) Visited Methods 14 of 22 (63.64) Visited Points 65 of 93 (69.89) Visited Branches 4 of 30 (13.33) Maximum CRAP score 30 ==== Alternative Results (includes all methods including those without corresponding source) ==== Alternative Visited Classes 13 of 15 (86.67) Alternative Visited Methods 20 of 30 (66.67) Alternative maximum CRAP score 30 可以看到控制台的输出已经有 308 visits recorded，随后我们使用 reportgenerator 工具生成 HTML 报告。\n.NET Core 集成 单元测试覆盖率报告 集成方法同 .NET Framework 一样。\nASP .NET Core 覆盖率报告 这里我使用的是 dotnet tool 安装的 altcover 命令，安装命令如下，前提是你得有 .NET Core 运行时。\n1 dotnet tool install --global altcover.global --version 随后编译对应的 ASP.NET Core 项目，并且在对应的 bin\\Debug 目录打开终端，执行以下命令进行准备工作。\n1 altcover /o=./__UnitTestWithAltCover -i . 随后使用 altcover runner 命令启动对应的程序。\n1 altcover runner -x .\\__UnitTestWithAltCover\\AltCoverTestRESTFulCore.exe -r .\\__UnitTestWithAltCover\\ 如果已经完成了测试，请终止掉对应的进程，否则 AltCover 不会将数据写入到 XML 文件，最后也使用 reportgenerator 工具生成 HTML 报告。\n总结 如果你的项目是基于 .NET Core ，那么可以直接选择微软主推的 coverlet ，AltCover 对于 .NET Framework、Mono、.NET Core 项目都有不错的支持，并且作者维护得也很勤快。\n","date":"2022-08-12T19:00:00Z","permalink":"https://real-zony.github.io/p/csharp-get-code-coverage-with-altcover---e2e-test-and-unit-test/","title":"C# 使用 AltCover 获得代码覆盖率 - E2E Test 和 Unit Test"},{"content":"问题 在 Bitbucket 使用 Linux 机器上 ssh-keygen 工具生成的公钥作为 API KEY，然后在 Jenkins 里面存储对应的 SSH 私钥，最后执行 Job 的时候，Windows Agent 提示 SSH 密钥不正确。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026gt; git fetch --tags --force --progress -- ssh://git@bitbucket.xxxxx.com:7999/xxxx.git +refs/heads/*:refs/remotes/origin/* # timeout=10 ERROR: Error fetching remote repo \u0026#39;origin\u0026#39; hudson.plugins.git.GitException: Failed to fetch from git@bitbucket.xxxxx.com:7999/xxxx.git at hudson.plugins.git.GitSCM.fetchFrom(GitSCM.java:1001) at hudson.plugins.git.GitSCM.retrieveChanges(GitSCM.java:1242) at hudson.plugins.git.GitSCM.checkout(GitSCM.java:1302) at org.jenkinsci.plugins.workflow.steps.scm.SCMStep.checkout(SCMStep.java:129) at org.jenkinsci.plugins.workflow.steps.scm.SCMStep$StepExecutionImpl.run(SCMStep.java:97) at org.jenkinsci.plugins.workflow.steps.scm.SCMStep$StepExecutionImpl.run(SCMStep.java:84) at org.jenkinsci.plugins.workflow.steps.SynchronousNonBlockingStepExecution.lambda$start$0(SynchronousNonBlockingStepExecution.java:47) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.lang.Thread.run(Thread.java:829) Caused by: hudson.plugins.git.GitException: Command \u0026#34;git fetch --tags --force --progress -- ssh://git@bitbucket.xxxxx.com:7999/xxxx.git +refs/heads/*:refs/remotes/origin/*\u0026#34; returned status code 128: stdout: stderr: git@bitbucket.xxxxx.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. at org.jenkinsci.plugins.gitclient.CliGitAPIImpl.launchCommandIn(CliGitAPIImpl.java:2671) at org.jenkinsci.plugins.gitclient.CliGitAPIImpl.launchCommandWithCredentials(CliGitAPIImpl.java:2096) at org.jenkinsci.plugins.gitclient.CliGitAPIImpl.access$500(CliGitAPIImpl.java:84) at org.jenkinsci.plugins.gitclient.CliGitAPIImpl$1.execute(CliGitAPIImpl.java:618) at org.jenkinsci.plugins.gitclient.RemoteGitImpl$CommandInvocationHandler$GitCommandMasterToSlaveCallable.call(RemoteGitImpl.java:158) at org.jenkinsci.plugins.gitclient.RemoteGitImpl$CommandInvocationHandler$GitCommandMasterToSlaveCallable.call(RemoteGitImpl.java:151) at hudson.remoting.UserRequest.perform(UserRequest.java:211) at hudson.remoting.UserRequest.perform(UserRequest.java:54) at hudson.remoting.Request$2.run(Request.java:376) at hudson.remoting.InterceptingExecutorService.lambda$wrap$0(InterceptingExecutorService.java:78) at java.util.concurrent.FutureTask.run(Unknown Source) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at hudson.remoting.Engine$1.lambda$newThread$0(Engine.java:122) at java.lang.Thread.run(Unknown Source) Suppressed: hudson.remoting.Channel$CallSiteStackTrace: Remote call to xxx-xxx-xxx.xxx.xxx at hudson.remoting.Channel.attachCallSiteStackTrace(Channel.java:1797) at hudson.remoting.UserRequest$ExceptionResponse.retrieve(UserRequest.java:356) at hudson.remoting.Channel.call(Channel.java:1001) at org.jenkinsci.plugins.gitclient.RemoteGitImpl$CommandInvocationHandler.execute(RemoteGitImpl.java:143) at jdk.internal.reflect.GeneratedMethodAccessor8221.invoke(Unknown Source) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.jenkinsci.plugins.gitclient.RemoteGitImpl$CommandInvocationHandler.invoke(RemoteGitImpl.java:129) at com.sun.proxy.$Proxy126.execute(Unknown Source) at hudson.plugins.git.GitSCM.fetchFrom(GitSCM.java:999) at hudson.plugins.git.GitSCM.retrieveChanges(GitSCM.java:1242) at hudson.plugins.git.GitSCM.checkout(GitSCM.java:1302) at org.jenkinsci.plugins.workflow.steps.scm.SCMStep.checkout(SCMStep.java:129) at org.jenkinsci.plugins.workflow.steps.scm.SCMStep$StepExecutionImpl.run(SCMStep.java:97) at org.jenkinsci.plugins.workflow.steps.scm.SCMStep$StepExecutionImpl.run(SCMStep.java:84) at org.jenkinsci.plugins.workflow.steps.SynchronousNonBlockingStepExecution.lambda$start$0(SynchronousNonBlockingStepExecution.java:47) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.lang.Thread.run(Thread.java:829) 最后登录到对应的 Windows 节点，直接使用 git clone 命令也是这样，说明不是 Jenkins 的权限问题。\n查询资料得知，出现这种情况需要将对应公钥(id_rsa)与私钥文件(id_rsa.pub) 复制到 Jenkins Agent 执行用户的 HOME 目录下的 .ssh 文件夹。\n普通用户的 HOME 目录就是 echo $HOME，一般也就是 C:\\User\\UserName 的路径。但是 Jenkins Agent 一旦作为服务执行，那么他的执行用户就是 SYSTEM ACCOUNT，它的 HOME 目录路径是 C:\\WINDOWS\\system32\\config\\systemprofile\\.ssh 。\n根据上述情况试了，还是没有解决，不管是 ssh-add xxx，还是更改 Git 的 SSH CONFIG 文件都无法解决。\n原因 我一直以为是自己的问题，结果用 GitHub 试了，是正常的。最后将目光转向了 BitBucket，根据官方的文章，设置了 GIT_SSH_COMMAND 环境变量，并指定 ssh -vvvv 命令，这样能够让我们看到详细的错误信息。\n最后得到了以下输出:\n查询资料得知，根本原因是 BitBucket 现在不支持 RSA SHA-1 生成的密钥。\n解决 官方的解决方案有两种，第一种是使用不安全的 RSA SHA-1 密钥，只需要更改客户端的配置文件，将 ssh-rsa 添加进去即可。不过这种做法并不安全，最好的做法还是使用 ssh-keygen 命令生成更加安全，基于 ED25519 算法的密钥。\n1 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 将这个公钥重新设置在 Bitbucket，然后将私钥替换掉 Jenkins 里面的 Credential，执行 Jenkins Job 成功。\n参考资料 [Blog] Generate SSH Keys for Windows System Account [StackOverflow] Permission denied(publickey) when setting up Jenkins SSH-RSA key rejected with message \u0026ldquo;no mutual signature algorithm\u0026rdquo; ","date":"2022-06-28T20:19:00Z","permalink":"https://real-zony.github.io/p/bitbucket-fails-to-pull-repository-using-ssh/","title":"Bitbucket 使用 SSH 拉取仓库失败的问题"},{"content":"一、简介 ABP vNext 使用 Volo.Abp.Sms 包和 Volo.Abp.Emailing 包将短信和电子邮件作为基础设施进行了抽象，开发人员仅需要在使用的时候注入 ISmsSender 或 IEmailSender 即可实现短信发送和邮件发送。\n二、源码分析 2.1 启动模块 短信发送的抽象层比较简单，AbpSmsModule 模块内部并无任何操作，仅作为空模块进行定义。\n电子邮件的 AbpEmailingModule 模块内，主要添加了一些本地化资源支持。另一个动作就是添加了一个 BackgroundEmailSendingJob 后台作业，这个后台作业主要是用于后续发送电子邮件使用。因为邮件发送这个动作实时性要求并不高，在实际的业务实践当中，我们基本会将其加入到一个后台队列慢慢发送，所以这里 ABP 为我们实现了 BackgroundEmailSendingJob。\nBackgroundEmailSendingJob.cs:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class BackgroundEmailSendingJob : AsyncBackgroundJob\u0026lt;BackgroundEmailSendingJobArgs\u0026gt;, ITransientDependency { protected IEmailSender EmailSender { get; } public BackgroundEmailSendingJob(IEmailSender emailSender) { EmailSender = emailSender; } public override async Task ExecuteAsync(BackgroundEmailSendingJobArgs args) { if (args.From.IsNullOrWhiteSpace()) { await EmailSender.SendAsync(args.To, args.Subject, args.Body, args.IsBodyHtml); } else { await EmailSender.SendAsync(args.From, args.To, args.Subject, args.Body, args.IsBodyHtml); } } } 这个后台任务的逻辑也不复杂，就使用 IEmailSender 发送邮件，我们在任何地方需要后台发送邮件的时，只需要注入 IBackgroundJobManager，使用 BackgroundEmailSendingJobArgs 作为参数添加入队一个后台作业即可。\n使用 IBackgroundJobManager 添加一个新的邮件发送欢迎邮件:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class DemoClass { private readonly IBackgroundJobManager _backgroundJobManager; private readonly IUserInfoRepository _userRep; public DemoClass(IBackgroundJobManager backgroundJobManager, IUserInfoRepository userRep) { _backgroundJobManager = backgroundJobManager; _userRep = userRep; } public async Task SendWelcomeEmailAsync(Guid userId) { var userInfo = await _userRep.GetByIdAsync(userId); await _backgroundJobManager.EnqueueAsync(new BackgroundEmailSendingJobArgs { To = userInfo.EmailAddress, Subject = \u0026#34;Welcome\u0026#34;, Body = \u0026#34;Welcome, Hello World!\u0026#34;, IsBodyHtml = false; }); } } 注意\n目前 BackgroundEmailSendingJobArgs 参数不支持发送附件，ABP 可能在以后的版本会进行实现。\n2.2 Email 的核心组件 ABP 定义了一个 IEmailSender 接口，定义了多个 SendAsync() 方法重载，用于直接发送电子邮件。同时也提供了 QueueAsync() 方法，通过后台任务队列来发送邮件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public interface IEmailSender { Task SendAsync( string to, string subject, string body, bool isBodyHtml = true ); Task SendAsync( string from, string to, string subject, string body, bool isBodyHtml = true ); Task SendAsync( MailMessage mail, bool normalize = true ); Task QueueAsync( string to, string subject, string body, bool isBodyHtml = true ); Task QueueAsync( string from, string to, string subject, string body, bool isBodyHtml = true ); //TODO: 准备添加的 QueueAsync 方法。目前存在的问题: MailMessage 不能够被序列化，所以不能加入到后台任务队列当中。 } ABP 实际拥有两种 Email Sender 实现，分别是 SmtpEmailSender 和 MailkitEmailSender，各个类型的关系如下。\nUML 类图:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 classDiagram class IEmailSender{ \u0026lt;\u0026lt;Interface\u0026gt;\u0026gt; +SendAsync(string,string,string,bool=true) Task +SendAsync(string,string,string,string,bool=true) Task +SendAsync(MailMessage,bool=true) Task +QueueAsync(string,string,string,bool=true) Task +QueueAsync(string,string,string,string,bool=true) Task } class ISmtpEmailSender{ \u0026lt;\u0026lt;Interface\u0026gt;\u0026gt; ...... +BuildClientAsync() Task~SmtpClient~ } class IMailKitSmtpEmailSemder{ \u0026lt;\u0026lt;Interface\u0026gt;\u0026gt; ...... +BuildClientAsync() Task~SmtpClient~ } class EmailSenderBase{ \u0026lt;\u0026lt;Abstract\u0026gt;\u0026gt; ...... } class SmtpEmailSender{ ...... } class MailKitSmtpEmailSender{ ...... } class NullEmailSender{ ...... } ISmtpEmailSender --|\u0026gt; IEmailSender: 继承 IMailKitSmtpEmailSemder --|\u0026gt; IEmailSender: 继承 EmailSenderBase ..|\u0026gt; IEmailSender: 实现 SmtpEmailSender ..|\u0026gt; ISmtpEmailSender: 实现 SmtpEmailSender --|\u0026gt; EmailSenderBase: 继承 NullEmailSender --|\u0026gt; EmailSenderBase: 继承 MailKitSmtpEmailSender ..|\u0026gt; IMailKitSmtpEmailSemder: 实现 MailKitSmtpEmailSender --|\u0026gt; EmailSenderBase: 继承 可以从 UML 类图看出，每个 EmailSender 实现都与一个 IXXXConfiguration 对应，这个配置类存储了基于 Smtp 发件的必须配置。因为 MailKit 本身也是基于 Smtp 发送邮件的，所以没有重新定义新的配置类，而是直接复用的 ISmtpEmailSenderConfiguration 接口与实现。\n在 EmailSenderBase 基类当中，基本实现了 IEmailSender 接口的所有方法的逻辑，只留下了 SendEmailAsync(MailMessage mail) 作为一个抽象方法等待子类实现。也就是说其他的方法最终都是使用该方法来最终发送邮件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public abstract class EmailSenderBase : IEmailSender { protected IEmailSenderConfiguration Configuration { get; } protected IBackgroundJobManager BackgroundJobManager { get; } protected EmailSenderBase(IEmailSenderConfiguration configuration, IBackgroundJobManager backgroundJobManager) { Configuration = configuration; BackgroundJobManager = backgroundJobManager; } // ... 实现的接口方法 protected abstract Task SendEmailAsync(MailMessage mail); // 使用 Configuration 里面的参数，统一处理邮件数据。 protected virtual async Task NormalizeMailAsync(MailMessage mail) { if (mail.From == null || mail.From.Address.IsNullOrEmpty()) { mail.From = new MailAddress( await Configuration.GetDefaultFromAddressAsync(), await Configuration.GetDefaultFromDisplayNameAsync(), Encoding.UTF8 ); } if (mail.HeadersEncoding == null) { mail.HeadersEncoding = Encoding.UTF8; } if (mail.SubjectEncoding == null) { mail.SubjectEncoding = Encoding.UTF8; } if (mail.BodyEncoding == null) { mail.BodyEncoding = Encoding.UTF8; } } } ABP 默认可用的邮件发送组件是 SmtpEmailSender，它使用的是 .NET 自带的邮件发送组件，本质上就是构建了一个 SmtpClient 客户端，然后调用它的发件方法进行邮件发送。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class SmtpEmailSender : EmailSenderBase, ISmtpEmailSender, ITransientDependency { // ... 省略的代码。 public async Task\u0026lt;SmtpClient\u0026gt; BuildClientAsync() { var host = await SmtpConfiguration.GetHostAsync(); var port = await SmtpConfiguration.GetPortAsync(); var smtpClient = new SmtpClient(host, port); // 从 SettingProvider 中获取各个配置参数，构建 Client 进行发送。 try { if (await SmtpConfiguration.GetEnableSslAsync()) { smtpClient.EnableSsl = true; } if (await SmtpConfiguration.GetUseDefaultCredentialsAsync()) { smtpClient.UseDefaultCredentials = true; } else { smtpClient.UseDefaultCredentials = false; var userName = await SmtpConfiguration.GetUserNameAsync(); if (!userName.IsNullOrEmpty()) { var password = await SmtpConfiguration.GetPasswordAsync(); var domain = await SmtpConfiguration.GetDomainAsync(); smtpClient.Credentials = !domain.IsNullOrEmpty() ? new NetworkCredential(userName, password, domain) : new NetworkCredential(userName, password); } } return smtpClient; } catch { smtpClient.Dispose(); throw; } } protected override async Task SendEmailAsync(MailMessage mail) { // 调用构建方法，构建 Client，用于发送 mail 数据。 using (var smtpClient = await BuildClientAsync()) { await smtpClient.SendMailAsync(mail); } } } 针对属性注入失败的情况，ABP 提供了 NullEmailSender 作为默认实现，在发送邮件的时候会使用 Logger 打印具体的信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class NullEmailSender : EmailSenderBase { public ILogger\u0026lt;NullEmailSender\u0026gt; Logger { get; set; } public NullEmailSender(IEmailSenderConfiguration configuration, IBackgroundJobManager backgroundJobManager) : base(configuration, backgroundJobManager) { Logger = NullLogger\u0026lt;NullEmailSender\u0026gt;.Instance; } protected override Task SendEmailAsync(MailMessage mail) { Logger.LogWarning(\u0026#34;USING NullEmailSender!\u0026#34;); Logger.LogDebug(\u0026#34;SendEmailAsync:\u0026#34;); LogEmail(mail); return Task.FromResult(0); } // ... 其他方法。 } 2.3 Email 的配置存储 从 EmailSenderBase 里面可以看到，它从 IEmailSenderConfiguration 当中获取发件人的邮箱地址和展示名称，它的 UML 类图关系如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 classDiagram class IEmailSenderConfiguration{ \u0026lt;\u0026lt;Interface\u0026gt;\u0026gt; +GetDefaultFromAddressAsync() Task~string~ +GetDefaultFromDisplayNameAsync() Task~string~ } class ISmtpEmailSenderConfiguration{ \u0026lt;\u0026lt;Interface\u0026gt;\u0026gt; +GetHostAsync() Task~string~ +GetPortAsync() Task~int~ +GetUserNameAsync() Task~string~ +GetPasswordAsync() Task~string~ +GetDomainAsync() Task~string~ +GetEnableSslAsync() Task~bool~ +GetUseDefaultCredentialsAsync() Task~bool~ } class EmailSenderConfiguration{ #GetNotEmptySettingValueAsync(string name) Task~string~ } class SmtpEmailSenderConfiguration{ } class ISettingProvider{ \u0026lt;\u0026lt;Interface\u0026gt;\u0026gt; +GetOrNullAsync(string name) Task~string~ } ISmtpEmailSenderConfiguration --|\u0026gt; IEmailSenderConfiguration: 继承 EmailSenderConfiguration ..|\u0026gt; IEmailSenderConfiguration: 实现 EmailSenderConfiguration ..\u0026gt; ISettingProvider: 依赖 SmtpEmailSenderConfiguration --|\u0026gt; EmailSenderConfiguration: 继承 SmtpEmailSenderConfiguration ..|\u0026gt; ISmtpEmailSenderConfiguration: 实现 可以看到配置文件时通过 ISettingProvider 获取的，这样就可以保证从不同租户甚至是用户来获取发件人的配置信息。这里值得注意的是在 EmailSenderConfiguration 中，实现了一个 GetNotEmptySettingValueAsync(string name) 方法，该方法主要是封装了获取逻辑，当值不存在的时候抛出 AbpException 异常。\n1 2 3 4 5 6 7 8 9 10 11 protected async Task\u0026lt;string\u0026gt; GetNotEmptySettingValueAsync(string name) { var value = await SettingProvider.GetOrNullAsync(name); if (value.IsNullOrEmpty()) { throw new AbpException($\u0026#34;Setting value for \u0026#39;{name}\u0026#39; is null or empty!\u0026#34;); } return value; } 至于 SmtpEmailSenderConfiguration，只是提供了其他的属性获取(密码、端口等)而已，本质上还是调用的 GetNotEmptySettingValueAsync() 方法从 SettingProvider 中获取具体的配置信息。\n1 2 3 4 5 sequenceDiagram 发送邮件 -\u0026gt;\u0026gt; Smtp 配置类: 1.GetHostAsync() Smtp 配置类 -\u0026gt;\u0026gt; Email 配置类: 2.GetNotEmptySettingValueAsync(\u0026#34;HotsItem\u0026#34;) Email 配置类 -\u0026gt;\u0026gt; Setting Provider: 3.GetOrNullAsync(\u0026#34;HotsItem\u0026#34;) Setting Provider --\u0026gt;\u0026gt; 发送邮件: 4.获得主机数据。 关于配置名称的常量，都在 EmailSettingNames 里面进行定义，并使用 EmailSettingProvider 将其注册到 ABP 的配置模块当中:\nEmailSettingNames.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 namespace Volo.Abp.Emailing { public static class EmailSettingNames { public const string DefaultFromAddress = \u0026#34;Abp.Mailing.DefaultFromAddress\u0026#34;; public const string DefaultFromDisplayName = \u0026#34;Abp.Mailing.DefaultFromDisplayName\u0026#34;; public static class Smtp { public const string Host = \u0026#34;Abp.Mailing.Smtp.Host\u0026#34;; public const string Port = \u0026#34;Abp.Mailing.Smtp.Port\u0026#34;; // ... 其他常量定义。 } } } EmailSettingProvider.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 internal class EmailSettingProvider : SettingDefinitionProvider { public override void Define(ISettingDefinitionContext context) { context.Add( new SettingDefinition( EmailSettingNames.Smtp.Host, \u0026#34;127.0.0.1\u0026#34;, L(\u0026#34;DisplayName:Abp.Mailing.Smtp.Host\u0026#34;), L(\u0026#34;Description:Abp.Mailing.Smtp.Host\u0026#34;)), new SettingDefinition(EmailSettingNames.Smtp.Port, \u0026#34;25\u0026#34;, L(\u0026#34;DisplayName:Abp.Mailing.Smtp.Port\u0026#34;), L(\u0026#34;Description:Abp.Mailing.Smtp.Port\u0026#34;)), // ... 其他配置参数。 ); } private static LocalizableString L(string name) { return LocalizableString.Create\u0026lt;EmailingResource\u0026gt;(name); } } 2.4 邮件模板 文字模板是 ABP 后续提供的一个新的模块，它可以让开发人员预先定义文本模板，然后使用时根据对象数据替换模板中的内容，并且 ABP 提供的文本模板还支持本地化。关于文本模板的功能，我们后续单独会写一篇文章进行说明，在这里只是大概 Mail 是如何使用的。\n在项目当中，ABP 仅定义了两个 *.tpl 的模板文件，分别是控制布局的 Layout.tpl，还有渲染具体消息的 Message.tpl。同权限、Setting 一样，模板也会使用一个 StandardEmailTemplates 类型定义模板的编码常量，并且实现一个 XXXDefinitionProvider 类型将其注入到 ABP 框架当中。\nStandardEmailTemplates.cs\n1 2 3 4 5 public static class StandardEmailTemplates { public const string Layout = \u0026#34;Abp.StandardEmailTemplates.Layout\u0026#34;; public const string Message = \u0026#34;Abp.StandardEmailTemplates.Message\u0026#34;; } StandardEmailTemplateDefinitionProvider.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class StandardEmailTemplateDefinitionProvider : TemplateDefinitionProvider { public override void Define(ITemplateDefinitionContext context) { context.Add( new TemplateDefinition( StandardEmailTemplates.Layout, displayName: LocalizableString.Create\u0026lt;EmailingResource\u0026gt;(\u0026#34;TextTemplate:StandardEmailTemplates.Layout\u0026#34;), isLayout: true ).WithVirtualFilePath(\u0026#34;/Volo/Abp/Emailing/Templates/Layout.tpl\u0026#34;, true) ); context.Add( new TemplateDefinition( StandardEmailTemplates.Message, displayName: LocalizableString.Create\u0026lt;EmailingResource\u0026gt;(\u0026#34;TextTemplate:StandardEmailTemplates.Message\u0026#34;), layout: StandardEmailTemplates.Layout ).WithVirtualFilePath(\u0026#34;/Volo/Abp/Emailing/Templates/Message.tpl\u0026#34;, true) ); } } 2.5 MailKit 集成 MailKit 是一个优秀跨平台的 .NET 邮件操作库，它的官方 GitHub 地址为 https://github.com/jstedfast/MailKit ，支持很多高级特性，这里我就不再详细介绍 MailKit 的其他特性，只是讲解一下 MailKit 同 ABP 自带的邮件模块是如何集成的。\n官方的 Volo.Abp.MailKit 包仅包含 4 个文件，它们分别是 AbpMailKitModule.cs (空模块，占位)、AbpMailKitOptions.cs (MailKit 的特殊配置)、IMailKitSmtpEmailSender.cs (实现了 IEmailSender 基类的一个接口)、MailKitSmtpEmailSender.cs (具体的发送逻辑实现)。\n需要注意一下，这里针对 MailKit 的特殊配置是使用的 IConfiguration 里面的数据(通常是 appsetting.json)，而不是从 Abp.Settings 里面获取的。\nMailKitSmtpEmailSender.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 [Dependency(ServiceLifetime.Transient, ReplaceServices = true)] public class MailKitSmtpEmailSender : EmailSenderBase, IMailKitSmtpEmailSender { protected AbpMailKitOptions AbpMailKitOptions { get; } protected ISmtpEmailSenderConfiguration SmtpConfiguration { get; } // ... 构造函数。 protected override async Task SendEmailAsync(MailMessage mail) { using (var client = await BuildClientAsync()) { // 使用了 mail 参数来构造 MailKit 的对象。 var message = MimeMessage.CreateFromMailMessage(mail); await client.SendAsync(message); await client.DisconnectAsync(true); } } // 构造 MailKit 所需要的 Client 对象。 public async Task\u0026lt;SmtpClient\u0026gt; BuildClientAsync() { var client = new SmtpClient(); try { await ConfigureClient(client); return client; } catch { client.Dispose(); throw; } } // 进行一些基本配置，比如服务器信息和密码信息等。 protected virtual async Task ConfigureClient(SmtpClient client) { await client.ConnectAsync( await SmtpConfiguration.GetHostAsync(), await SmtpConfiguration.GetPortAsync(), await GetSecureSocketOption() ); if (await SmtpConfiguration.GetUseDefaultCredentialsAsync()) { return; } await client.AuthenticateAsync( await SmtpConfiguration.GetUserNameAsync(), await SmtpConfiguration.GetPasswordAsync() ); } // 根据 Option 的值获取一些安全配置。 protected virtual async Task\u0026lt;SecureSocketOptions\u0026gt; GetSecureSocketOption() { if (AbpMailKitOptions.SecureSocketOption.HasValue) { return AbpMailKitOptions.SecureSocketOption.Value; } return await SmtpConfiguration.GetEnableSslAsync() ? SecureSocketOptions.SslOnConnect : SecureSocketOptions.StartTlsWhenAvailable; } } 2.6 短信发送的核心组件 短信发送仅提供了一个 ISmsSender 接口，该接口有提供一个发送方法，ABP 官方提供了 Aliyun 的短信发送功能(Volo.Abp.Sms.Aliyun)。\nUML 图:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 classDiagram class ISmsSender{ \u0026lt;\u0026lt;Interface\u0026gt;\u0026gt; SendAsync(SmsMessage smsMessage) Task } class NullSmsSender{ } class SmsMessage{ +string PhoneNumber +string Text +IDictionary~string, object~ Properties } NullSmsSender ..|\u0026gt; ISmsSender: 实现 ISmsSender ..\u0026gt; SmsMessage: 依赖 功能比较简单，重点是 SmsMessage 里面的参数，第一个是发送的号码，第二个是发送的内容。仅凭上述参数肯定不够，所以 ABP 提供了一个属性字典，便于我们传入一些特定的参数。\n三、总结 ABP 将 Email 这块功能封装成了单独的模块，便于开发人员进行邮件发送。并且官方也提供了 MailKit 的支持，我们可以根据自己的需求来替换不同的实现。只不过针对于一些异步邮件发送的场景，目前还不能很好的支持(主要是使用了 MailMessage 无法序列化)。\n我觉得 ABP 应该自己定义一个 Context 类型，反转依赖，在具体的实现当中确定邮件发送的对象类型。或者是将默认的 Smtp 发送者独立出来一个模块，就跟 MailKit 一样，使用 ABP 的 Context 类型来构造 MailMessage 对象。\n四、总目录 欢迎翻阅作者的其他文章，请 点击我 进行跳转，如果你觉得本篇文章对你有帮助，请点击文章末尾的 推荐按钮。\n最后更新时间: 2021年6月27日 23点31分\n","date":"2021-06-28T01:43:29Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---20-email-and-sms-support/","title":"Abp vNext 源码分析 - 20. 电子邮件与短信支持"},{"content":"简介 ABP vNext 框架使用 xUnit 作为单元测试组件，官方的所有模块都编写了大量的 单元/集成测试 确保功能正常。由于 ABP vNext 模块化系统的原因，开发人员在建立单元测试项目的时候需要集成 Volo.Abp.UnitTest 项目，这样在执行单元测试的时候才不会缺少必要组件。\n分析 ABP vNext 单元测试相关的类型最核心的是集成测试基类 AbpIntegratedTest 和 MVC 专用测试基类 AbpAspNetCoreIntegratedTestBase，这两个基类核心工作就是初始化 IoC 容器并且初始化整个模块系统，只不过后者对 控制器 相关的组件进行了初始化配置，让开发人员可以针对 控制器 进行单元/集成测试。\n从上图可以看到两个基类都继承自 AbpTestBaseWithServiceProvider 基类，在这个基类里面将 IServiceProvider 作为一个抽象成员。这是因为 MVC 和测试基类的 ServiceProvider 来源不一样，一个是 ABP vNext 根据 Application 类已注册 IoC 容器构建的，另一个使用的是 IHost 测试主机内的 ServiceProvider。\n单元测试执行本质上就是将测试类进行实例化，然后调用对应的单元测试方法，所以测试基类的初始化动作都是放在对应的无参构造函数。\n虽然 Volo.Abp.UnitTest 也是单独的一个项目，它的 AbpTestBaseModule 是没有任何动作，仅仅是为了同其他项目保持一致，内部是没有任何代码。\n1 2 3 4 5 6 7 8 9 using Volo.Abp.Modularity; namespace Volo.Abp { public class AbpTestBaseModule : AbpModule { } } 集成测试基类 一般来说，我们会直接从 AbpIntegratedTest 继承并实现我们需要的单元测试基类，包括 ABP vNext 官方的默认模版也是这样。集成测试基类的核心代码很简单，就是在无参构造函数的内部进行初始化动作，且在过程中按顺序执行两个生命周期方法。\n简易流程图:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public abstract class AbpIntegratedTest\u0026lt;TStartupModule\u0026gt; : AbpTestBaseWithServiceProvider, IDisposable where TStartupModule : IAbpModule { protected IAbpApplication Application { get; } protected override IServiceProvider ServiceProvider =\u0026gt; Application.ServiceProvider; protected IServiceProvider RootServiceProvider { get; } protected IServiceScope TestServiceScope { get; } protected AbpIntegratedTest() { var services = CreateServiceCollection(); BeforeAddApplication(services); var application = services.AddApplication\u0026lt;TStartupModule\u0026gt;(SetAbpApplicationCreationOptions); Application = application; AfterAddApplication(services); // 根据已有 IServiceCollection 创建 IoC 容器。 RootServiceProvider = CreateServiceProvider(services); TestServiceScope = RootServiceProvider.CreateScope(); // 使用子容器对 ABP 模块系统进行初始化。 application.Initialize(TestServiceScope.ServiceProvider); } // ... 其他代码。 } 上述代码可以看到默认的测试基类并没有直接使用 RootServiceProvider，而是创建了一个子容器给 ABP vNext 使用，这主要是为了后续可以对容器进行销毁操作，具体可一看下面的 Dispose() 方法。\n1 2 3 4 5 6 public virtual void Dispose() { Application.Shutdown(); TestServiceScope.Dispose(); Application.Dispose(); } 总的来说，测试基类就是构建了一个 IAbpApplication 对象，根据传入的 TStartupModule 模块进入拓扑排序过程，依次执行各个模块的生命周期配置。\nMVC 测试基类 针对我们的 Http Api 层，如果需要对 Controller 进行测试的话，就需要从 MVC 测试基类继承编写单元/集成测试，各个类型的关系如下。\nAbpTestBaseWithServiceProvider#ServiceProvider#GetService() : #GetRequiredService() : AbpIntegratedTest#BeforeAddApplication(IServiceCollection service)#SetAbpApplicationCreationOptions(AbpApplicationCreationOptions options)#AfterAddApplication(IServiceCollection services)#CreateServiceProvider(IServiceCollection service)+Dispose()AbpAspNetCoreIntegratedTestBase#TestServer Server#HttpClient Client-IHost host#CreateHostBuilder() : IHostBuilder#ConfigureServices(HostBuilderContext context, IServiceCollection services)#GetUrl_OfType_TController() : string#GetUrl_OfType_TController(string actionName) : string#GetUrl_OfType_TController(string actionName, object queryStringParamsAsAnonymousObject) : string+Dispose()IDispose\u0026lt;\u0026gt; IDispose\n针对 AspNetCore 来说，ABP 创建了一个新的 Host 主机，在每次执行测试的时候会启动一个新的 Web 服务器。(并不会创建真实服务，不存在端口占用问题)\n在基类当中，ABP 定义了两个属性 Server 和 Client，它们都是 Mock 了对应的接口，方便后续的单元测试，这里的 ITestServerAccessor 接口是用于 Mock AspNetCoreTestDynamicProxyHttpClientFactory 接口所需要的。\nAspNetCoreTestDynamicProxyHttpClientFactory 接口是 ABP 底层进行动态代理所使用的，在请求远程服务的时候会调用这个接口创建 HttpClient 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 protected AbpAspNetCoreIntegratedTestBase() { var builder = CreateHostBuilder(); _host = builder.Build(); _host.Start(); Server = _host.GetTestServer(); Client = _host.GetTestClient(); ServiceProvider = Server.Services; ServiceProvider.GetRequiredService\u0026lt;ITestServerAccessor\u0026gt;().Server = Server; } 从 UML 类图当中，可以看到基类定义了几个 GetUrl() 方法，这几个方法是根据 Controller 获取对应的请求路径。\n这里我以一个 SampleController 控制器为例，它提供了一个 Index 方法，返回了一个页面内容。针对它来说，我们编写集成测试是这样操作的。\n1 2 3 4 5 6 7 public class SimpleController : AbpController { public ActionResult Index() { return Content(\u0026#34;Index-Result\u0026#34;); } } 集成测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class SimpleController_Tests : AbpAspNetCoreIntegratedTestBase\u0026lt;Startup\u0026gt; { protected virtual async Task\u0026lt;HttpResponseMessage\u0026gt; GetResponseAsync(string url, HttpStatusCode expectedStatusCode = HttpStatusCode.OK) { using (var requestMessage = new HttpRequestMessage(HttpMethod.Get, url)) { requestMessage.Headers.Add(\u0026#34;Accept-Language\u0026#34;, CultureInfo.CurrentUICulture.Name); var response = await Client.SendAsync(requestMessage); response.StatusCode.ShouldBe(expectedStatusCode); return response; } } protected virtual async Task\u0026lt;string\u0026gt; GetResponseAsStringAsync(string url, HttpStatusCode expectedStatusCode = HttpStatusCode.OK) { using (var response = await GetResponseAsync(url, expectedStatusCode)) { return await response.Content.ReadAsStringAsync(); } } [Fact] public async Task ActionResult_ContentResult() { var result = await GetResponseAsStringAsync( GetUrl\u0026lt;SimpleController\u0026gt;(nameof(SimpleController.Index)) ); result.ShouldBe(\u0026#34;Index-Result\u0026#34;); } } EF Core 的集成 在执行单元测试过程中，我们难免会对数据库进行操作。这个时候不可能连接真实数据库，就需要我们在测试基类当中进行一些初始化动作，将底层的数据库链接改为 SQLite 的内存模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class SampleEntityFrameworkCoreTestModule : AbpModule { private SqliteConnection _sqliteConnection; public override void ConfigureServices(ServiceConfigurationContext context) { ConfigureInMemorySqlite(context.Services); } private void ConfigureInMemorySqlite(IServiceCollection services) { // 建立链接并执行迁移。 _sqliteConnection = CreateDatabaseAndGetConnection(); // 使用 SQLite 作为 EF Provider。 services.Configure\u0026lt;AbpDbContextOptions\u0026gt;(options =\u0026gt; { options.Configure(context =\u0026gt; { context.DbContextOptions.UseSqlite(_sqliteConnection); }); }); } public override void OnApplicationShutdown(ApplicationShutdownContext context) { _sqliteConnection.Dispose(); } private static SqliteConnection CreateDatabaseAndGetConnection() { // 使用 SQLite 的内存模式链接字符串。 var connection = new SqliteConnection(\u0026#34;Data Source=:memory:\u0026#34;); connection.Open(); var options = new DbContextOptionsBuilder\u0026lt;SampleMigrationsDbContext\u0026gt;() .UseSqlite(connection) .Options; // 执行迁移，构建表结构。 using (var context = new SampleMigrationsDbContext(options)) { context.GetService\u0026lt;IRelationalDatabaseCreator\u0026gt;().CreateTables(); } return connection; } } 总结 ABP 的测试更偏向于集成测试，因为各个功能都依赖于模块，所以在执行单元测试的时候会运行更长的时间。日常开发过程当中，我们更多地还是针对应用层进行测试就可以了，粒度更细的话也可以针对仓储层、领域层、API 层 编写测试即可。\n为了保证项目质量，在开发完成之后编写单元/集成测试是每个开发人员应做的工作。编写单元/集成测试，虽然不能 100% 避免 BUG，但可以保证每次进行业务修改之后接口的正确性。\n四、总目录 欢迎翻阅作者的其他文章，请 点击我 进行跳转，如果你觉得本篇文章对你有帮助，请点击文章末尾的 推荐按钮。\n最后更新时间: 2021年6月27日 23点41分\n","date":"2021-04-27T06:11:00Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---19-unit-testing/","title":"Abp vNext 源码分析 - 19. 单元测试"},{"content":"环境准备 本篇文章使用的 ACME 客户端是基于 Docker 容器使用的，所以需要准备 Docker 运行环境。本文使用的是 CentOS 7.x 与 Docker CE - 19.03.13，且已经安装了 Docker Compose 工具。\n我已经参考官方的 GitHub 文章编写了 acme.sh 需要的 Docker Compose 文件，标准模版如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 version: \u0026#34;3\u0026#34; services: acme.sh: image: neilpang/acme.sh:latest container_name: acme.sh command: daemon volumes: - \u0026#34;\u0026lt;ACME 证书文件的生成目录\u0026gt;:/acme.sh\u0026#34; - \u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34; environment: - Ali_Key=\u0026lt;填写阿里云的 Access Key\u0026gt; - Ali_Secret=\u0026lt;填写阿里云的 Access Secret\u0026gt; - DEPLOY_DOCKER_CONTAINER_LABEL=__nginx__ - DEPLOY_DOCKER_CONTAINER_RELOAD_CMD=\u0026#34;nginx -s reload -c /etc/nginx/nginx.conf\u0026#34; restart: always networks: - internal-network networks: internal-network: external: true 参数配置 针对 ACME 的默认参数，我们只需要提供 DNS 服务商的 API 访问密钥即可，acme.sh 会自动对我们的域名进行配置验证，我这里以阿里云的为例，其他受支持的 DNS 服务商可以前往 Github 文档 查看。\n除开环境变量的配置参数以外，针对 Acme 的证书文件生成目录也需要单独进行配置，这块可以用于。\n具体使用 拉取镜像 执行一下命令拉取 acme.sh 的 Docker 镜像。\n1 docker pull neilpang/acme.sh:latest 运行容器 1 docker-compose up -d 生成证书 由于已经在环境变量配置了阿里云的参数，所以现在只需要指定域名即可生成对应的证书，域名验证等一系列步骤都交由 acme.sh 自动完成。\n进入到 acme.sh 的容器，执行生成命令。\n1 acme.sh --issue --dns dns_ali -d example.com -d www.example.com 等待验证成功以后，就会在 acme.sh 文件夹生成对应的证书文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 [Tue Mar 16 07:07:44 UTC 2021] Using CA: https://acme-v02.api.letsencrypt.org/directory [Tue Mar 16 07:07:45 UTC 2021] Create account key ok. [Tue Mar 16 07:07:45 UTC 2021] Registering account: https://acme-v02.api.letsencrypt.org/directory [Tue Mar 16 07:07:46 UTC 2021] Registered [Tue Mar 16 07:07:46 UTC 2021] ACCOUNT_THUMBPRINT=\u0026#39;账号信息\u0026#39; [Tue Mar 16 07:07:46 UTC 2021] Creating domain key [Tue Mar 16 07:07:47 UTC 2021] The domain key is here: /acme.sh/example.com/example.com.key [Tue Mar 16 07:07:47 UTC 2021] Multi domain=\u0026#39;DNS:example.com,DNS:www.example.com\u0026#39; [Tue Mar 16 07:07:47 UTC 2021] Getting domain auth token for each domain [Tue Mar 16 07:07:49 UTC 2021] Getting webroot for domain=\u0026#39;example.com\u0026#39; [Tue Mar 16 07:07:49 UTC 2021] Getting webroot for domain=\u0026#39;www.example.com\u0026#39; [Tue Mar 16 07:07:49 UTC 2021] Adding txt value: eJ2UJrvi_lAMmY0D-BFrM4WNvDXkICUR0BSJ3EXyBtw for domain: _acme-challenge.example.com [Tue Mar 16 07:07:51 UTC 2021] The txt record is added: Success. [Tue Mar 16 07:07:51 UTC 2021] Adding txt value: u_T1kks2iNU1E_1bAtE8zpz-e81uTISws8o_ZL8YE40 for domain: _acme-challenge.www.example.com [Tue Mar 16 07:07:53 UTC 2021] The txt record is added: Success. [Tue Mar 16 07:07:53 UTC 2021] Let\u0026#39;s check each DNS record now. Sleep 20 seconds first. [Tue Mar 16 07:08:14 UTC 2021] You can use \u0026#39;--dnssleep\u0026#39; to disable public dns checks. [Tue Mar 16 07:08:14 UTC 2021] See: https://github.com/acmesh-official/acme.sh/wiki/dnscheck [Tue Mar 16 07:08:14 UTC 2021] Checking example.com for _acme-challenge.example.com [Tue Mar 16 07:08:16 UTC 2021] Domain example.com \u0026#39;_acme-challenge.example.com\u0026#39; success. [Tue Mar 16 07:08:16 UTC 2021] Checking www.example.com for _acme-challenge.www.example.com [Tue Mar 16 07:08:17 UTC 2021] Domain www.example.com \u0026#39;_acme-challenge.www.example.com\u0026#39; success. [Tue Mar 16 07:08:17 UTC 2021] All success, let\u0026#39;s return [Tue Mar 16 07:08:17 UTC 2021] Verifying: example.com [Tue Mar 16 07:08:21 UTC 2021] Success [Tue Mar 16 07:08:21 UTC 2021] Verifying: www.example.com [Tue Mar 16 07:08:25 UTC 2021] Success [Tue Mar 16 07:08:25 UTC 2021] Removing DNS records. [Tue Mar 16 07:08:25 UTC 2021] Removing txt: eJ2UJrvi_lAMmY0D-BFrM4WNvDXkICUR0BSJ3EXyBtw for domain: _acme-challenge.example.com [Tue Mar 16 07:08:27 UTC 2021] Removed: Success [Tue Mar 16 07:08:27 UTC 2021] Removing txt: u_T1kks2iNU1E_1bAtE8zpz-e81uTISws8o_ZL8YE40 for domain: _acme-challenge.www.example.com [Tue Mar 16 07:08:30 UTC 2021] Removed: Success [Tue Mar 16 07:08:30 UTC 2021] Verify finished, start to sign. [Tue Mar 16 07:08:30 UTC 2021] Lets finalize the order. [Tue Mar 16 07:08:30 UTC 2021] Le_OrderFinalize=\u0026#39;https://acme-v02.api.letsencrypt.org/acme/finalize/123456\u0026#39; [Tue Mar 16 07:08:31 UTC 2021] Downloading cert. [Tue Mar 16 07:08:31 UTC 2021] Le_LinkCert=\u0026#39;https://acme-v02.api.letsencrypt.org/acme/cert/123456123456\u0026#39; [Tue Mar 16 07:08:32 UTC 2021] Cert success. -----BEGIN CERTIFICATE----- 你的证书文件信息。 -----END CERTIFICATE----- [Tue Mar 16 07:08:32 UTC 2021] Your cert is in /acme.sh/example.com/example.com.cer [Tue Mar 16 07:08:32 UTC 2021] Your cert key is in /acme.sh/example.com/example.com.key [Tue Mar 16 07:08:32 UTC 2021] The intermediate CA cert is in /acme.sh/example.com/ca.cer [Tue Mar 16 07:08:32 UTC 2021] And the full chain certs is there: /acme.sh/example.com/fullchain.cer ","date":"2021-03-16T07:15:00Z","permalink":"https://real-zony.github.io/p/acme.sh-free-pan-parsing-certificate-generation/","title":"acme.sh 免费泛解析证书生成"},{"content":"环境 首先需要准备好 Docker + Docker-Compose 环境，Docker 在 CentOS 7.x 的安装教程请参考 这篇文章，后续文章假设你已经安装好了上述环境。\n安装 标准安装 首先从 Harbor 的官方 GitHub Relase 下载最新的安装包，Harbor 本身的运行也是依赖于 Docker Compose ，整个压缩包本质上就是一系列离线镜像，执行安装脚本就是执行 docker load 命令将需要的镜像直接加载。\n下载安装包，请访问 https://github.com/goharbor/harbor/releases/tag/v2.1.2 下载 tgz 压缩包。\n将文件移动到安装文件夹，这里我建立了一个 /opt/harbor 文件夹。\n运行 tar -xvf harbor-offline-installer-v1.10.1.tgz 解压文件包。\n移动到解压完成的文件夹，编辑对应的 harbor.yml 文件，设置域名、SSL 证书等信息。\n注意⚠️:\n这一步的证书文件必须是全链证书(fullchain)，否则后续 docker login 的时候会提示 X509 错误。\n执行 ./install.sh --with-clair 开始安装 Harbor。\n完成上述步骤以后 Harbor 就安装成功了。\n不使用内置 NGINX 在我们的环境当中，NGINX 容器是单独存在的，并且使用的是 docker nework create 创建的外部网络。这个时候就不能够使用 Harbor 安装脚本内提供的 NGINX，需要变更 Harbor 的 Docker Compose 文件。\n执行 docker-compose down 命令，停止所有 Harbor 容器。\n编辑 Harbor 的 docker-compose.yml 文件，引入外部网络，这里我以 internal-network 为例，下面是变更好的 YAML 文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 version: \u0026#39;2.3\u0026#39; services: log: image: goharbor/harbor-log:v2.1.2 container_name: harbor-log restart: always dns_search: . cap_drop: - ALL cap_add: - CHOWN - DAC_OVERRIDE - SETGID - SETUID volumes: - /var/log/harbor/:/var/log/docker/:z - type: bind source: ./common/config/log/logrotate.conf target: /etc/logrotate.d/logrotate.conf - type: bind source: ./common/config/log/rsyslog_docker.conf target: /etc/rsyslog.d/rsyslog_docker.conf ports: - 127.0.0.1:1514:10514 networks: - harbor - internal-network registry: image: goharbor/registry-photon:v2.1.2 container_name: registry restart: always cap_drop: - ALL cap_add: - CHOWN - SETGID - SETUID volumes: - /data/registry:/storage:z - ./common/config/registry/:/etc/registry/:z - type: bind source: /data/secret/registry/root.crt target: /etc/registry/root.crt - type: bind source: ./common/config/shared/trust-certificates target: /harbor_cust_cert networks: - harbor - internal-network dns_search: . depends_on: - log logging: driver: \u0026#34;syslog\u0026#34; options: syslog-address: \u0026#34;tcp://127.0.0.1:1514\u0026#34; tag: \u0026#34;registry\u0026#34; registryctl: image: goharbor/harbor-registryctl:v2.1.2 container_name: registryctl env_file: - ./common/config/registryctl/env restart: always cap_drop: - ALL cap_add: - CHOWN - SETGID - SETUID volumes: - /data/registry:/storage:z - ./common/config/registry/:/etc/registry/:z - type: bind source: ./common/config/registryctl/config.yml target: /etc/registryctl/config.yml - type: bind source: ./common/config/shared/trust-certificates target: /harbor_cust_cert networks: - harbor - internal-network dns_search: . depends_on: - log logging: driver: \u0026#34;syslog\u0026#34; options: syslog-address: \u0026#34;tcp://127.0.0.1:1514\u0026#34; tag: \u0026#34;registryctl\u0026#34; postgresql: image: goharbor/harbor-db:v2.1.2 container_name: harbor-db restart: always cap_drop: - ALL cap_add: - CHOWN - DAC_OVERRIDE - SETGID - SETUID volumes: - /data/database:/var/lib/postgresql/data:z networks: harbor: dns_search: . env_file: - ./common/config/db/env depends_on: - log logging: driver: \u0026#34;syslog\u0026#34; options: syslog-address: \u0026#34;tcp://127.0.0.1:1514\u0026#34; tag: \u0026#34;postgresql\u0026#34; core: image: goharbor/harbor-core:v2.1.2 container_name: harbor-core env_file: - ./common/config/core/env restart: always cap_drop: - ALL cap_add: - SETGID - SETUID volumes: - /data/ca_download/:/etc/core/ca/:z - /data/:/data/:z - ./common/config/core/certificates/:/etc/core/certificates/:z - type: bind source: ./common/config/core/app.conf target: /etc/core/app.conf - type: bind source: /data/secret/core/private_key.pem target: /etc/core/private_key.pem - type: bind source: /data/secret/keys/secretkey target: /etc/core/key - type: bind source: ./common/config/shared/trust-certificates target: /harbor_cust_cert networks: - harbor - internal-network dns_search: . depends_on: - log - registry - redis - postgresql logging: driver: \u0026#34;syslog\u0026#34; options: syslog-address: \u0026#34;tcp://127.0.0.1:1514\u0026#34; tag: \u0026#34;core\u0026#34; portal: image: goharbor/harbor-portal:v2.1.2 container_name: harbor-portal restart: always cap_drop: - ALL cap_add: - CHOWN - SETGID - SETUID - NET_BIND_SERVICE volumes: - type: bind source: ./common/config/portal/nginx.conf target: /etc/nginx/nginx.conf networks: - harbor - internal-network dns_search: . depends_on: - log logging: driver: \u0026#34;syslog\u0026#34; options: syslog-address: \u0026#34;tcp://127.0.0.1:1514\u0026#34; tag: \u0026#34;portal\u0026#34; jobservice: image: goharbor/harbor-jobservice:v2.1.2 container_name: harbor-jobservice env_file: - ./common/config/jobservice/env restart: always cap_drop: - ALL cap_add: - CHOWN - SETGID - SETUID volumes: - /data/job_logs:/var/log/jobs:z - type: bind source: ./common/config/jobservice/config.yml target: /etc/jobservice/config.yml - type: bind source: ./common/config/shared/trust-certificates target: /harbor_cust_cert networks: - harbor - internal-network dns_search: . depends_on: - core logging: driver: \u0026#34;syslog\u0026#34; options: syslog-address: \u0026#34;tcp://127.0.0.1:1514\u0026#34; tag: \u0026#34;jobservice\u0026#34; redis: image: goharbor/redis-photon:v2.1.2 container_name: redis restart: always cap_drop: - ALL cap_add: - CHOWN - SETGID - SETUID volumes: - /data/redis:/var/lib/redis networks: harbor: dns_search: . depends_on: - log logging: driver: \u0026#34;syslog\u0026#34; options: syslog-address: \u0026#34;tcp://127.0.0.1:1514\u0026#34; tag: \u0026#34;redis\u0026#34; networks: harbor: external: false internal-network: external: true 在独立的 NGINX 中创建对应的配置文件，在上一步的 YAML 文件内部，我为每个容器指定了 container_name，确保容器名字唯一不会因为外部原因而变动。这个配置文件我是从之前 Harbor 内部的 NGINX 拷贝出来的，直接拿去改吧改吧就能用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 server{ listen 80; server_name 你的域名; return 301 https://你的域名$request_uri; } server{ listen 443 ssl; server_name 你的域名; # disable any limits to avoid HTTP 413 for large image uploads client_max_body_size 0; # required to avoid HTTP 411: see Issue #1486 (https://github.com/docker/docker/issues/1486) chunked_transfer_encoding on; # Add extra headers add_header Strict-Transport-Security \u0026#34;max-age=31536000; includeSubdomains; preload\u0026#34;; add_header X-Frame-Options DENY; add_header Content-Security-Policy \u0026#34;frame-ancestors \u0026#39;none\u0026#39;\u0026#34;; ssl_certificate /etc/nginx/ssl/你的域名/full.pem; # SSL 证书文件的存放路径 ssl_certificate_key /etc/nginx/ssl/你的域名/key.pem; # SSL 密钥文件的存放路径 ssl_protocols TLSv1.2; ssl_ciphers \u0026#39;!aNULL:kECDH+AESGCM:ECDH+AESGCM:RSA+AESGCM:kECDH+AES:ECDH+AES:RSA+AES:\u0026#39;; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; location / { proxy_pass http://harbor-portal:8080/; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings. proxy_set_header X-Forwarded-Proto $scheme; proxy_cookie_path / \u0026#34;/; HttpOnly; Secure\u0026#34;; proxy_buffering off; proxy_request_buffering off; } location /c/ { proxy_pass http://harbor-core:8080/c/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings. proxy_set_header X-Forwarded-Proto $scheme; proxy_cookie_path / \u0026#34;/; Secure\u0026#34;; proxy_buffering off; proxy_request_buffering off; } location /api/ { proxy_pass http://harbor-core:8080/api/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings. proxy_set_header X-Forwarded-Proto $scheme; proxy_cookie_path / \u0026#34;/; Secure\u0026#34;; proxy_buffering off; proxy_request_buffering off; } location /chartrepo/ { proxy_pass http://harbor-core:8080/chartrepo/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings. proxy_set_header X-Forwarded-Proto $scheme; proxy_cookie_path / \u0026#34;/; Secure\u0026#34;; proxy_buffering off; proxy_request_buffering off; } location /v1/ { return 404; } location /v2/ { proxy_pass http://harbor-core:8080/v2/; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings. proxy_set_header X-Forwarded-Proto $scheme; proxy_buffering off; proxy_request_buffering off; proxy_send_timeout 900; proxy_read_timeout 900; } location /service/ { proxy_pass http://harbor-core:8080/service/; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings. proxy_set_header X-Forwarded-Proto $scheme; proxy_cookie_path / \u0026#34;/; Secure\u0026#34;; proxy_buffering off; proxy_request_buffering off; } location /service/notifications { return 404; } } 这里我使用的是 acme.sh 申请的泛解析 SSL 证书。\n效果 ","date":"2021-01-04T06:22:44Z","permalink":"https://real-zony.github.io/p/harbor-212-installation-and-deployment/","title":"Harbor 2.1.2 安装部署"},{"content":"背景 ABP vNext 默认对异常响应进行了处理，现在某个项目需要自定义异常响应结果。\n问题 在 ABP vNext 的 MVC 模块当中，可以看到是通过 AddService(typeof(AbpExceptionFilter)) 添加的过滤器。最初我的想法是在 ConfigureService() 生命周期方法内，使用 Configure\u0026lt;MvcOptions\u0026gt; 移除已经注册的过滤器。 找到对应的 Remove() 方法，发现需要提供一个 IFilterMetadata 对象，顿时懵逼。\n解决 通过查阅 AddService() 方法的源码，看到底层是通过 ServiceFilterAttribute 将一个过滤器类型包裹起来。最后将其强转为一个 IFilterMetadata 扔进集合，有强转这一步我们翻阅源码可以看到 ServiceFilterAttribute 应该是实现了这个接口的。\n1 2 3 4 5 6 7 8 9 10 11 public IFilterMetadata AddService(Type filterType, int order) { if (filterType == (Type) null) throw new ArgumentNullException(nameof (filterType)); ServiceFilterAttribute serviceFilterAttribute = typeof (IFilterMetadata).IsAssignableFrom(filterType) ? new ServiceFilterAttribute(filterType) { Order = order } : throw new ArgumentException(Resources.FormatTypeMustDeriveFromType((object) filterType.FullName, (object) typeof (IFilterMetadata).FullName), nameof (filterType)); this.Add((IFilterMetadata) serviceFilterAttribute); return (IFilterMetadata) serviceFilterAttribute; } 那么我们只需要在 Remove() 方法当中传递一个 ServiceFilterAttribute 特性包装过滤器即可。\n1 2 3 4 5 context.Services.Configure\u0026lt;MvcOptions\u0026gt;(op =\u0026gt; { var abpExceptionFilter = new ServiceFilterAttribute(typeof(AbpExceptionFilter)); op.Filters.Remove(abpExceptionFilter); }); 如果需要添加自己的过滤器，只需要调用 AddService(typeof(YourFilter)) 注册。\n","date":"2020-11-22T13:23:03Z","permalink":"https://real-zony.github.io/p/aspnet-core-removes-a-registered-filter/","title":"ASP.NET Core 移除已注册的过滤器"},{"content":"一、简介 ABP vNext 提供了全套的本地化字符串支持，具体用法可以参考官方使用文档。vNext 本身是对 Microsoft 提供的本地化组件进行了实现，通过 JSON 文件提供本地化源，这一点与老 ABP 不太一样，老 ABP 框架是全套自己手撸。vNext 针对服务端和客户端都提供了文字本地化的工具类，这样开发人员可以很快速地开发支持多语言的网站程序。\n二、源码分析 本地化涉及的主要模块有 Volo.Abp.Localization.Abstractions 和 Volo.Abp.Localization，可以看到 Volo 针对包的结构也逐渐向 Microsoft 的构建方式靠拢。有直接依赖的模块是 Volo.Abp.VirtualFileSystem，之所以会引用到这个模块，是因为默认的本地化数据源是通过内嵌 JSON 文件实现的，所以会用到虚拟文件系统读取数据。\n2.1 本地化的抽象接口 首先打开 Volo.Abp.Localization.Abstractions 项目，它的基本结构如下图所示，需要注意的核心类型就是 ILocalizableString 接口和它的两个具体实现 FixedLocalizableString 与 LocalizableString。\n这里的 IAbpStringLocalizerFactoryWithDefaultResourceSupport 接口是为 AbpStringLocalizerFactoryExtensions 服务的，后面会详细解释，主要作用是根据默认资源类型快速创建一个 IStringLocalizer 实例。\n2.1.1 本地化字符串对象的封装 可以看到在该项目内部定义了一个 ILocalizableString 的接口，在 ABP vNext 内部需要用到多语言表示的字符串属性，都是定义的 ILocalizableString 类型。本质上它是针对 Microsoft 提供的 LocalizedString 进行了一层包装，这个接口只提供了一个方法 Localize()，具体的签名见下面的代码。\n1 2 3 4 public interface ILocalizableString { LocalizedString Localize(IStringLocalizerFactory stringLocalizerFactory); } 在 ABP vNext 框架当中，拥有两个实现，分别是 LocalizableString 和 FixedLocalizableString，后者用于创建固定字串的显示。例如 ABP vNext 自带的权限系统，针对权限名称和描述必须传递 ILocalizableString 类型的值，但是开发人员暂时没有提供对应的本地化翻译，这个时候就可以使用 FixedLocalizableString 传递固定字符串。\n实现也是很简单，在调用了 Localize() 方法之后，会根据构造函数的 Value 创建一个新的 LocalizedString 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class FixedLocalizableString : ILocalizableString { public string Value { get; } public FixedLocalizableString(string value) { Value = value; } public LocalizedString Localize(IStringLocalizerFactory stringLocalizerFactory) { return new LocalizedString(Value, Value); } } 用法举例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class DataDictionaryDefinitionPermissionProvider : PermissionDefinitionProvider { public override void Define(IPermissionDefinitionContext context) { var dataDictionaryGroup = context.AddGroup(DataDictionaryPermissions.GroupName, L(\u0026#34;Permission:DataDictionary\u0026#34;)); var dataDictionary = dataDictionaryGroup.AddPermission(DataDictionaryPermissions.DataDictionary.Default, L(\u0026#34;Permission:DataDictionary\u0026#34;)); dataDictionary.AddChild(DataDictionaryPermissions.DataDictionary.Create, L(\u0026#34;Permission:Create\u0026#34;)); dataDictionary.AddChild(DataDictionaryPermissions.DataDictionary.Update, L(\u0026#34;Permission:Edit\u0026#34;)); dataDictionary.AddChild(DataDictionaryPermissions.DataDictionary.Delete, L(\u0026#34;Permission:Delete\u0026#34;)); // 这里使用了 FixedLocalizableString 提供本地化字符串。 dataDictionary.AddChild(DataDictionaryPermissions.DataDictionary.Management, new FixedLocalizableString(\u0026#34;字典管理\u0026#34;)); } private static LocalizableString L(string name) { return LocalizableString.Create\u0026lt;DataDictionaryResource\u0026gt;(name); } } 另一个 LocalizableString 就是正常通过 IStringLocalizerFactory 获取的本地化字符串对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class LocalizableString : ILocalizableString { [CanBeNull] public Type ResourceType { get; } [NotNull] public string Name { get; } public LocalizableString(Type resourceType, [NotNull] string name) { Name = Check.NotNullOrEmpty(name, nameof(name)); ResourceType = resourceType; } public LocalizedString Localize(IStringLocalizerFactory stringLocalizerFactory) { return stringLocalizerFactory.Create(ResourceType)[Name]; } public static LocalizableString Create\u0026lt;TResource\u0026gt;([NotNull] string name) { return new LocalizableString(typeof(TResource), name); } } 在类型里面定义了一个静态方法，用于目标类型与 KEY 的 LocalizableString 对象，常见于权限定义的地方，在上面的示例代码中有用到过。\n2.1.2 本地化资源类型的别名 TODO\n2.2 本地化的基础设施 下文指代的基础设施是指 ABP vNext 为了优雅地实现 Microsoft 本地化接口所构建的一系列组件，ABP vNext 的大部分组件都是基于 Microsoft 提供的抽象体系，也是为了更好地兼容。\n2.2.1 模块的启动 具体的实现模块逻辑也不复杂，首先替换了默认的本地化资源容器工厂。接着往 ABP 的虚拟文件系统添加了当前模块，以便后续访问对应的 JSON 文件，最后往本地化的相关配置项添加了两个本地化资源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class AbpLocalizationModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { AbpStringLocalizerFactory.Replace(context.Services); Configure\u0026lt;AbpVirtualFileSystemOptions\u0026gt;(options =\u0026gt; { options.FileSets.AddEmbedded\u0026lt;AbpLocalizationModule\u0026gt;(\u0026#34;Volo.Abp\u0026#34;, \u0026#34;Volo/Abp\u0026#34;); }); Configure\u0026lt;AbpLocalizationOptions\u0026gt;(options =\u0026gt; { options .Resources .Add\u0026lt;DefaultResource\u0026gt;(\u0026#34;en\u0026#34;); options .Resources .Add\u0026lt;AbpLocalizationResource\u0026gt;(\u0026#34;en\u0026#34;) .AddVirtualJson(\u0026#34;/Localization/Resources/AbpLocalization\u0026#34;); }); } } 2.2.2 本地化的配置 AbpLocalizationOptions 内部定义了本地化系统的相关参数，主要由资源集合(Resources)、默认资源(DefaultResourceType)、全局的本地化数据源提供者(GlobalContributors)、支持的语言(Languages)。\n注意:\n当进行本地化操作时，没有指定资源类型的时候会使用默认资源类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class AbpLocalizationOptions { public LocalizationResourceDictionary Resources { get; } public Type DefaultResourceType { get; set; } public ITypeList\u0026lt;ILocalizationResourceContributor\u0026gt; GlobalContributors { get; } public List\u0026lt;LanguageInfo\u0026gt; Languages { get; } public Dictionary\u0026lt;string, List\u0026lt;NameValue\u0026gt;\u0026gt; LanguagesMap { get; } public Dictionary\u0026lt;string, List\u0026lt;NameValue\u0026gt;\u0026gt; LanguageFilesMap { get; } public AbpLocalizationOptions() { Resources = new LocalizationResourceDictionary(); GlobalContributors = new TypeList\u0026lt;ILocalizationResourceContributor\u0026gt;(); Languages = new List\u0026lt;LanguageInfo\u0026gt;(); LanguagesMap = new Dictionary\u0026lt;string, List\u0026lt;NameValue\u0026gt;\u0026gt;(); LanguageFilesMap = new Dictionary\u0026lt;string, List\u0026lt;NameValue\u0026gt;\u0026gt;(); } } 从上述代码我们可以知道，要让本地化系统正常工作，我们会接触到下面这几个类型 LocalizationResourceDictionary、LocalizationResource、ILocalizationResourceContributor、LanguageInfo。\n2.2.3 本地化资源的定义 在使用本地化系统的时候，ABP vNext 文档首先会让我们定义一个类型，并在模块的 ConfigureService() 周期，通过配置项添加到本地化系统当中，就像这样。\n1 2 3 4 5 6 Configure\u0026lt;AbpLocalizationOptions\u0026gt;(options =\u0026gt; { options.Resources .Add\u0026lt;DataDictionaryResource\u0026gt;(\u0026#34;en\u0026#34;) .AddVirtualJson(\u0026#34;/Localization/Resources\u0026#34;); }); 这里可以看到，ABP vNext 实现了一套流畅方法(Fluent Method)，通过这一系列的操作，我们会生成一个 LocalizationResource 实例，添加到配置系统当中，以便后续进行使用。\n这里的 Add() 方法是由 LocalizationResourceDictionary 提供的，它本质上就是一个字典，只不过由 ABP vNext 封装了一些自定义的方法，方便添加字典项数据。可以看到它的实现也很简单，首先判断字典是否存在对应的 Key，如果不存在就使用资源类型和区域文化信息构造一个新的 LocalizationResource 对象，并将其添加到字典当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class LocalizationResourceDictionary : Dictionary\u0026lt;Type, LocalizationResource\u0026gt; { public LocalizationResource Add\u0026lt;TResouce\u0026gt;([CanBeNull] string defaultCultureName = null) { return Add(typeof(TResouce), defaultCultureName); } public LocalizationResource Add(Type resourceType, [CanBeNull] string defaultCultureName = null) { if (ContainsKey(resourceType)) { throw new AbpException(\u0026#34;This resource is already added before: \u0026#34; + resourceType.AssemblyQualifiedName); } return this[resourceType] = new LocalizationResource(resourceType, defaultCultureName); } // ... 其他代码。 } 转到 LocalizationResouce 的定义，内部存储了具体的资源类型、资源名称、当前资源默认的区域文化信息、本地化数据源提供者(与全局的不同，这里仅作用于某个具体本地化资源)、继承的基类资源类型集合。\n资源类型和资源名称用于区分不同的本地化资源。默认区域文化信息代表当前资源，当获取指定语言的本地化字符串失败时，会读取默认的区域文化信息对应的本地化字符串。\n这里的 BaseResouceTypes 是为了复用其他资源的本地化字符串，例如你定义了一个 AppleResouceType，但是你想要获取 FruitResouceType 对应的字符串，那么就需要往这个集合添加需要服用的资源类型。ABP vNext 为 LocalizationResource 提供了一个扩展方法 AddBaseTypes() 便于在模块配置时添加需要复用的类型。除此之外 ABP vNext 也提供了特性支持，跟模块定义一样，在类定义上面添加 InheritResourceAttribute 特性，传入需要复用的类型定义即可。\n1 2 3 4 5 6 7 8 [InheritResource( typeof(LocalizationTestValidationResource), typeof(LocalizationTestCountryNamesResource) )] public sealed class LocalizationTestResource { } 可以看到在下述代码当中，ABP vNext 会扫描当前 ResouceType 的特性，并将其定义的复用类型添加到基类集合当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class LocalizationResource { [NotNull] public Type ResourceType { get; } [NotNull] public string ResourceName =\u0026gt; LocalizationResourceNameAttribute.GetName(ResourceType); [CanBeNull] public string DefaultCultureName { get; set; } [NotNull] public LocalizationResourceContributorList Contributors { get; } [NotNull] public List\u0026lt;Type\u0026gt; BaseResourceTypes { get; } public LocalizationResource( [NotNull] Type resourceType, [CanBeNull] string defaultCultureName = null, [CanBeNull] ILocalizationResourceContributor initialContributor = null) { ResourceType = Check.NotNull(resourceType, nameof(resourceType)); DefaultCultureName = defaultCultureName; BaseResourceTypes = new List\u0026lt;Type\u0026gt;(); Contributors = new LocalizationResourceContributorList(); if (initialContributor != null) { Contributors.Add(initialContributor); } AddBaseResourceTypes(); } protected virtual void AddBaseResourceTypes() { var descriptors = ResourceType .GetCustomAttributes(true) .OfType\u0026lt;IInheritedResourceTypesProvider\u0026gt;(); foreach (var descriptor in descriptors) { foreach (var baseResourceType in descriptor.GetInheritedResourceTypes()) { BaseResourceTypes.AddIfNotContains(baseResourceType); } } } } 当资源类型(Resource Type) 定义好之后，通过上面的一番操作，就能够得到一个 LocalizationResource 实例，并将其添加到了 AbpLocalizationOptions 内的 LocalizationResourceDictionary 对象。开发人员定义了多少个本地化资源类型，就会往这个字典添加多少个 LocaliztaionResource 实例。\n2.2.4 本地化的数据源 不论是配置项还是某个本地化资源定义类，都会存储一组 Contributor 。转到对应的接口定义，这个接口定义了三个公开方法，分别用于初始化(Initialize())、获取某个具体的本地化字符串(LocalizedString())、为指定的字典填充本地化资源数据(Fill())。\n1 2 3 4 5 6 7 8 public interface ILocalizationResourceContributor { void Initialize(LocalizationResourceInitializationContext context); LocalizedString GetOrNull(string cultureName, string name); void Fill(string cultureName, Dictionary\u0026lt;string, LocalizedString\u0026gt; dictionary); } 所有的数据源都是由各个 Contributor 提供的，这里以 VirtualFileLocalizationResourceContributorBase 为例，在内部通过虚拟文件系统获取到了文件数据，通过文件数据构造一系列的字典。这里的 字典有两层，第一层的 Key 是区域文化信息，Value 是对应区域文化信息的本地化字符串字典。第二层的 Key 是本地化字符串的标识，Value 就是具体的 LocalizedString 实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public abstract class VirtualFileLocalizationResourceContributorBase : ILocalizationResourceContributor { // ... 其他代码 public void Initialize(LocalizationResourceInitializationContext context) { _virtualFileProvider = context.ServiceProvider.GetRequiredService\u0026lt;IVirtualFileProvider\u0026gt;(); } public LocalizedString GetOrNull(string cultureName, string name) { return GetDictionaries().GetOrDefault(cultureName)?.GetOrNull(name); } public void Fill(string cultureName, Dictionary\u0026lt;string, LocalizedString\u0026gt; dictionary) { GetDictionaries().GetOrDefault(cultureName)?.Fill(dictionary); } private Dictionary\u0026lt;string, ILocalizationDictionary\u0026gt; GetDictionaries() { // ... 获取本地化资源的字典，这里的字典按区域文化进行分组。 } private Dictionary\u0026lt;string, ILocalizationDictionary\u0026gt; CreateDictionaries() { var dictionaries = new Dictionary\u0026lt;string, ILocalizationDictionary\u0026gt;(); foreach (var file in _virtualFileProvider.GetDirectoryContents(_virtualPath)) { // ... 其他代码。 // 根据文件创建某个区域文化的具体的数据源字典。 var dictionary = CreateDictionaryFromFile(file); if (dictionaries.ContainsKey(dictionary.CultureName)) { throw new AbpException($\u0026#34;{file.GetVirtualOrPhysicalPathOrNull()} dictionary has a culture name \u0026#39;{dictionary.CultureName}\u0026#39; which is already defined!\u0026#34;); } dictionaries[dictionary.CultureName] = dictionary; } return dictionaries; } protected abstract bool CanParseFile(IFileInfo file); protected virtual ILocalizationDictionary CreateDictionaryFromFile(IFileInfo file) { using (var stream = file.CreateReadStream()) { return CreateDictionaryFromFileContent(Utf8Helper.ReadStringFromStream(stream)); } } protected abstract ILocalizationDictionary CreateDictionaryFromFileContent(string fileContent); } 2.2.5 本地化资源字典 具体存储本地化字符串标识和展示文本的对象是 ILocalizationDictionary，它的具体实现是 StaticLocalizationDictionary，在其内部有一个 Dictionary\u0026lt;string, LocalizedString\u0026gt; 字典，这个字典就对应的 JSON 文件当中的本地化数据了。\n1 2 3 4 5 6 7 { \u0026#34;culture\u0026#34;: \u0026#34;zh-Hans\u0026#34;, \u0026#34;texts\u0026#34;: { \u0026#34;DisplayName:Abp.Localization.DefaultLanguage\u0026#34;: \u0026#34;默认语言\u0026#34;, \u0026#34;Description:Abp.Localization.DefaultLanguage\u0026#34;: \u0026#34;应用程序的默认语言.\u0026#34; } } 对应的字典形式就是内部字典的 KEY:Value。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class StaticLocalizationDictionary : ILocalizationDictionary { public string CultureName { get; } protected Dictionary\u0026lt;string, LocalizedString\u0026gt; Dictionary { get; } public StaticLocalizationDictionary(string cultureName, Dictionary\u0026lt;string, LocalizedString\u0026gt; dictionary) { CultureName = cultureName; Dictionary = dictionary; } public virtual LocalizedString GetOrNull(string name) { return Dictionary.GetOrDefault(name); } public void Fill(Dictionary\u0026lt;string, LocalizedString\u0026gt; dictionary) { foreach (var item in Dictionary) { dictionary[item.Key] = item.Value; } } } 当最外层的 Contributor 获取文本的时候，实际是结合区域文化信息(Culture Name) 定义到对应的本地化资源字典，再通过 Name 获取资源字典内部对应的 LocalizedString 对象。\n2.3 同 Microsoft 本地化集成 2.2 节讲完了 ABP vNext 实现的基础设施，结合某个资源类型附带的 Contributor 组就能够获取到具体的本地化字符串数据，在本节主要讲解 ABP vNext 同 Microsoft 的集成。\n2.3.1 IStringLocalizer 工厂 在 AbpLocalizationModule 模块中，第一句就是替换了默认的 String Localizer 工厂，并注入了 ResourceManagerStringLocalizerFactory 类型，这个类型主要用于后续的默认行为。\n1 2 3 4 5 internal static void Replace(IServiceCollection services) { services.Replace(ServiceDescriptor.Singleton\u0026lt;IStringLocalizerFactory, AbpStringLocalizerFactory\u0026gt;()); services.AddSingleton\u0026lt;ResourceManagerStringLocalizerFactory\u0026gt;(); } 在 Microsoft 提供的 IStringLocalizerFactory 接口中，只定义了两个创建 IStringLocalizer 的方法。\n1 2 3 4 5 6 public interface IStringLocalizerFactory { IStringLocalizer Create(Type resourceSource); IStringLocalizer Create(string baseName, string location); } 第二个方法 ABP 是直接调用的默认工厂(ResouceManagerStringLocalizerFactory) 提供的方法，而且还加了个 TODO 注明不知道什么时候会被调用。\n1 2 3 4 5 6 public virtual IStringLocalizer Create(string baseName, string location) { //TODO: Investigate when this is called? return InnerFactory.Create(baseName, location); } 这里我们着重关注第一个方法，ABP 主要实现的也是第一个方法，它会根据传入的 resourceSource 参数从缓存当中获取(不存在则构造)对应的 IStringLocalizer 。如果在 ABP 提供的资源集合当中，没有查找到对应的 Type，则直接调用默认工厂返回 IStringLocalizer。如果存在则会以 Type 作为 Key，StringLocalizerCacheItem(就是 LocalizationResource 的马甲) 作为 Value，从缓存拿，没拿到就构建一个新的并加入到缓存中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public virtual IStringLocalizer Create(Type resourceType) { var resource = AbpLocalizationOptions.Resources.GetOrDefault(resourceType); if (resource == null) { return InnerFactory.Create(resourceType); } if (LocalizerCache.TryGetValue(resourceType, out var cacheItem)) { return cacheItem.Localizer; } lock (LocalizerCache) { return LocalizerCache.GetOrAdd( resourceType, _ =\u0026gt; CreateStringLocalizerCacheItem(resource) ).Localizer; } } private StringLocalizerCacheItem CreateStringLocalizerCacheItem(LocalizationResource resource) { // 构造时会将全局配置的 Contributor 添加到对应的组。 foreach (var globalContributor in AbpLocalizationOptions.GlobalContributors) { resource.Contributors.Add((ILocalizationResourceContributor) Activator.CreateInstance(globalContributor)); } using (var scope = ServiceProvider.CreateScope()) { var context = new LocalizationResourceInitializationContext(resource, scope.ServiceProvider); // 调用各个 Contributor 的初始化方法，进行初始化操作。 foreach (var contributor in resource.Contributors) { contributor.Initialize(context); } } return new StringLocalizerCacheItem( new AbpDictionaryBasedStringLocalizer( resource, resource.BaseResourceTypes.Select(Create).ToList() ) ); } 2.3.2 IStringLocalizer ABP 针对 IStringLocalizer 的默认实现是 AbpDictionaryBasedStringLocalizer，IStringLocalizer 主要包含两个索引器和一个 GetAllStrings() 方法。\n索引器本身直接就调用的 GetLocalizedString() 与 GetLocalizedStringFormatted() 方法。后者用于处理格式化的参数，内部就是利用的 string.Format() 方法替换占位符的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class AbpDictionaryBasedStringLocalizer : IStringLocalizer, IStringLocalizerSupportsInheritance { // ... 其他代码 public virtual LocalizedString this[string name] =\u0026gt; GetLocalizedString(name); public virtual LocalizedString this[string name, params object[] arguments] =\u0026gt; GetLocalizedStringFormatted(name, arguments); // ... 其他代码 protected virtual LocalizedString GetLocalizedString(string name) { return GetLocalizedString(name, CultureInfo.CurrentUICulture.Name); } protected virtual LocalizedString GetLocalizedString(string name, string cultureName) { var value = GetLocalizedStringOrNull(name, cultureName); // 如果没有从当前容器取得对应的本地化字符串，就从复用的基类中获取。 if (value == null) { foreach (var baseLocalizer in BaseLocalizers) { using (CultureHelper.Use(CultureInfo.GetCultureInfo(cultureName))) { var baseLocalizedString = baseLocalizer[name]; if (baseLocalizedString != null \u0026amp;\u0026amp; !baseLocalizedString.ResourceNotFound) { return baseLocalizedString; } } } return new LocalizedString(name, name, resourceNotFound: true); } return value; } } 转到 GetLocalizedStringOrNull() 方法内部，可以看到获取本地化字符串的具体逻辑。\n首先会从本地化资源定义的 Contributors 中获取本地化字符串。 如果没有找到则尝试从类似的区域文化信息字典中获取，例如 zh-Hans(简体中文) 源没有拿到则考虑从 zh-Hant(繁体中文)获取。 还是没有取得，最后会使用默认的区域文化信息匹配对应的本地化字符串，一般来说该值建议设置为 en。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 protected virtual LocalizedString GetLocalizedStringOrNull(string name, string cultureName, bool tryDefaults = true) { //Try to get from original dictionary (with country code) var strOriginal = Resource.Contributors.GetOrNull(cultureName, name); if (strOriginal != null) { return strOriginal; } if (!tryDefaults) { return null; } //Try to get from same language dictionary (without country code) if (cultureName.Contains(\u0026#34;-\u0026#34;)) //Example: \u0026#34;tr-TR\u0026#34; (length=5) { var strLang = Resource.Contributors.GetOrNull(CultureHelper.GetBaseCultureName(cultureName), name); if (strLang != null) { return strLang; } } //Try to get from default language if (!Resource.DefaultCultureName.IsNullOrEmpty()) { var strDefault = Resource.Contributors.GetOrNull(Resource.DefaultCultureName, name); if (strDefault != null) { return strDefault; } } //Not found return null; } 三、总结 点击我跳转到总目录 ","date":"2020-09-25T08:28:00Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---21-localization-of-interface-and-text/","title":"Abp vNext 源码分析 - 21. 界面与文字的本地化"},{"content":"一、背景 最开始准备使用的 Chromely 做一个终端机项目，本来以为挺顺利的一个事情折腾了两天半。由于无法直接控制窗体的属性，最后还是切换到 .NET Framework 4.8 + CefSharp，记录一下遇到的坑和问题。\n二、问题 2.1 输入法无法弹出 终端机系统最开始是 Windows 7，系统自带的输入法无法输入中文，后面使用的多文输入法有时候能够输入有时候不能够输入。最后折腾了半天，咨询厂家可以安装 Windows 10，安装后系统自带输入法可以输入中文。\n新的问题又出现了，如果窗口没有全屏的情况下，输入法是可以将内容输入到网页的文本框。但是窗口置顶且全屏，触摸 输入的内容就像无法获取焦点一样，无法输入。 爬了很多网站，都没有给出个明确的答案，最后在 某篇 Issue 里面说将 browser.FocusHandler 属性设置为 null，解决该问题。\n2.2 重写右键菜单 这个问题比较简单，只需要重新实现 IMenuHandler 接口，替换掉 Cef Browser 的对应组件即可。\n示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class CustomMenuHandler : IContextMenuHandler { public void OnBeforeContextMenu(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IContextMenuParams parameters, IMenuModel model) { model.Clear(); model.AddItem((CefMenuCommand) 21000, \u0026#34;菜单项1\u0026#34;); } public bool OnContextMenuCommand(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IContextMenuParams parameters, CefMenuCommand commandId, CefEventFlags eventFlags) { if (commandId == (CefMenuCommand) 21000) { MessageBox.Show(\u0026#34;我是菜单项1\u0026#34;); } return false; } public void OnContextMenuDismissed(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame) { } public bool RunContextMenu(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IContextMenuParams parameters, IMenuModel model, IRunContextMenuCallback callback) { return false; } } 2.3 身份证读卡器对接 身份证读卡器终端机上面是集成新中新的，跟着 SDK 的 Demo 来，一跑程序就炸。没有跑出任何异常，最后发现是 Chromely 吞掉了异常。实际的错误问题是 DLL 的版本不对，新中新只提供了 x86 的 DLL，但程序编译的是 x64。最后将程序的目标平台改为 x86 解决问题。\n2.4 前端同后端通讯 其实就是 JS 调用后端的接口，之前搜索的文章都是 CefSharp 的老版本代码，最新的是使用 browser.JavascriptObjectRepository.Register() 注入处理器，然后前端再进行调用。具体代码可以参考 CefSharp 的 官方 Demo。\n2.5 打开调试窗口 CefSharp Browser 提供了一个 ShowDevTools() 方法用于打开调试窗口，需要注意的是，必须在浏览器完全初始化之后才能够调用。所以你需要判断一下 CefSharp Browser 的状态。\n1 2 3 4 5 6 7 browser.IsBrowserInitializedChanged += (sender, args) =\u0026gt; { if (browser.IsBrowserInitialized) { browser.ShowDevTools(); } }; 2.6 关于触屏的其他配置 在 Cef 初始化的时候，需要对 Cef 进行一些其他的配置，例如开启触屏事件、禁用 USB 键盘等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static void InitializeCef() { CefSharpSettings.LegacyJavascriptBindingEnabled = true; CefSharpSettings.SubprocessExitIfParentProcessClosed = true; Cef.EnableHighDPISupport(); var settings = new CefSettings(); settings.CefCommandLineArgs.Add(\u0026#34;disable-usb-keyboard-detect\u0026#34;, \u0026#34;1\u0026#34;); settings.CefCommandLineArgs.Add(\u0026#34;enable-media-stream\u0026#34;, \u0026#34;1\u0026#34;); settings.CefCommandLineArgs.Add(\u0026#34;touch-events\u0026#34;, \u0026#34;1\u0026#34;); Cef.Initialize(settings); } 2.7 允许前端跨域和调用摄像头 在 [2.6](#2.6 关于触屏的其他配置) 一节中，我通过添加 enable-media-stream 参数让前端可以直接调用摄像头。如果想要让前端发起跨域请求，就得在 Browser 里面将 WebSecurity 属性设置为 Disabled。\n1 browser.BrowserSettings.WebSecurity = CefState.Disabled; 2.8 下载文件 CefSharp 针对于前端的下载文件动作进行了处理，如果你对于这个动作有自己的处理逻辑，可以实现 IDownloadHandler 接口。然后在 Browser 的对应属性替换成你自己的实现即可。\n","date":"2020-08-24T03:34:00Z","permalink":"https://real-zony.github.io/p/record-of-problems-encountered-in-cefsharp-developing-touch-screen-terminals/","title":"CefSharp 开发触屏终端遇到的问题记录"},{"content":"现象 使用 docker exec -ti \u0026lt;容器名\u0026gt; bash 进入容器，使用 ls 命令列出的数据里面，中文没有正常显示。\n原因 就是对应的 Shell 字符集不正确的问题，调整对应的字符集为 UTF-8 即可。\n解决 首先执行 locale -a，查看输出的内容里面是否有 C.UTF-8 字符集。\n执行 locale 查看当前的字符集，如果均为 POSIX 说明有问题，需要进行变更。\n变更的方法很简单，创建/更改一下环境变量即可。\nexport LC_ALL=\u0026quot;C.UTF-8\u0026quot;\n上面这种方法仅对当前会话有效，如果想永久生效，将上面这句话放到对应的 Shell 的 Profile 里面即可。\n","date":"2020-07-30T07:37:00Z","permalink":"https://real-zony.github.io/p/docker-container-directory-garbled-problem-with-dotnet-core/","title":"dotNET Core 的 Docker 容器目录乱码问题"},{"content":"一、简介 ABP vNext 在 v 2.9.x 版本当中添加了 BLOB 系统，主要用于存储大型二进制文件。ABP 抽象了一套通用的 BLOB 体系，开发人员在存储或读取二进制文件时，可以忽略具体实现，直接使用 IBlobContainer 或 IBlobContainer\u0026lt;T\u0026gt; 进行操作。官方的 BLOB Provider 实现有 Azure、AWS、FileSystem(文件系统存储)、Database(数据库存储)、阿里云 OSS，你也可以自己继承 BlobProviderBase 来实现其他的 Provider。\nBLOB 常用于各类二进制文件存储和管理，基本就是对云服务的 OSS 进行了抽象，在使用当中也会有 Bucket 和 Object Key 的概念，在 BLOB 里面对应的就是 ContainerName 和 BlobName。\n关于 BLOB 的官方使用指南，可以参考 https://docs.abp.io/en/abp/latest/Blob-Storing，本文的阅读前提是建立在你已经阅读过该指南，并有一定的使用经验。\n二、源码分析 2.1 模块分析 看一个 ABP 的库项目，首先从他的 Module 入手，对应的 BLOB 核心库的 Module 就是 AbpBlobStoringModule 类，在其内部，只进行了两个操作，注入了 IBlobContainer 与 IBlobContainer\u0026lt;\u0026gt; 的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddTransient( typeof(IBlobContainer\u0026lt;\u0026gt;), typeof(BlobContainer\u0026lt;\u0026gt;) ); context.Services.AddTransient( typeof(IBlobContainer), serviceProvider =\u0026gt; serviceProvider .GetRequiredService\u0026lt;IBlobContainer\u0026lt;DefaultContainer\u0026gt;\u0026gt;() ); } 从上述代码可以看出来，IBlobContainer 的默认实现还是基于 BlobContainer\u0026lt;T\u0026gt; 的。那么为啥会有个泛型的 Container，从简介中可以看到 OSS 里面对应的 Bucket 其实就是一个 IBlobContainer。假如你会针对某云的多个 Bucket 进行操作，那么就需要类型化的 BlobContainer 了。\n在这里可以看到，IBlobContainer 的实现是一个工厂方法，这一点在后面会进行解释。\n2.2 BLOB 容器 2.2.1 容器的定义 每个容器就是一个 OSS 的 Bucket，开发人员在对 BLOB 进行操作时，会注入 IBlobContainer/IBlobContainer\u0026lt;T\u0026gt;，通过接口提供的 5 种方法进行操作，这五个方法分别是 保存对象、删除对象、判断对象是否存在、获取对象、获取对象(不存在返回 NULL)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public interface IBlobContainer { // 保存对象 Task SaveAsync( string name, Stream stream, bool overrideExisting = false, CancellationToken cancellationToken = default ); // 删除对象 Task\u0026lt;bool\u0026gt; DeleteAsync( string name, CancellationToken cancellationToken = default ); // 判断对象是否存在 Task\u0026lt;bool\u0026gt; ExistsAsync( string name, CancellationToken cancellationToken = default ); // 获取对象 Task\u0026lt;Stream\u0026gt; GetAsync( string name, CancellationToken cancellationToken = default ); // 获取对象(不存在返回 NULL) Task\u0026lt;Stream\u0026gt; GetOrNullAsync( string name, CancellationToken cancellationToken = default ); //TODO: Create shortcut extension methods: GetAsArraryAsync, GetAsStringAsync(encoding) (and null versions) } 泛型的 BLOB 容器也是集成自该接口，内部没有任何特殊的方法。\n1 2 3 4 5 public interface IBlobContainer\u0026lt;TContainer\u0026gt; : IBlobContainer where TContainer: class { } 2.2.2 容器的实现 容器的两种实现都存放在 BlobContainer.cs 文件当中，标注容器实现内部都会有一个 ContainerName，用于标识不同的容器，并且和其他的组件作为 关联键 进行绑定。每个容器都会关联 BlobContainerConfiguration、IBlobProvider 两个组件，它们分别提供了容器的配置信息和容器的具体实现 Provider，在容器构造的时候根据 ContainerName 分别进行初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class BlobContainer : IBlobContainer { protected string ContainerName { get; } protected BlobContainerConfiguration Configuration { get; } protected IBlobProvider Provider { get; } protected ICurrentTenant CurrentTenant { get; } protected ICancellationTokenProvider CancellationTokenProvider { get; } protected IServiceProvider ServiceProvider { get; } // ... 其他代码。 } 可以看到这里还注入了 ICurrentTenant，注入该对象的主要作用是用来处理多租户的情况，如果当前容器启用了多租户，那么会手动 Change()。下面以 SaveAsync() 方法为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public virtual async Task SaveAsync( string name, Stream stream, bool overrideExisting = false, CancellationToken cancellationToken = default) { // 变更当前租户信息，当启用了多租户时，会使用当前租户进行变更。 using (CurrentTenant.Change(GetTenantIdOrNull())) { // 根据 ContainerName 取得对应的标准化容器名称和对象名称。 var (normalizedContainerName, normalizedBlobName) = NormalizeNaming(ContainerName, name); // 使用 ContainerName 匹配的 Provider 存储对象数据。 await Provider.SaveAsync( new BlobProviderSaveArgs( normalizedContainerName, Configuration, normalizedBlobName, stream, overrideExisting, CancellationTokenProvider.FallbackToProvider(cancellationToken) ) ); } } 这里有两个地方需要单独分析，第一个是 NormalizeNaming() 的作用，第二个是 BlobProviderSaveArgs 对象。\n2.2.3.1 名称标准化对象 IBlobNamingNormalizer(BLOB 名称标准化对象)，主要用于将一个字符串进行标准化处理，防止 Provider 无法处理这种名称。各大 OSS 都对容器的名称或对象的名称有命名要求，比如必须全部小写，不能有哪些特殊符号等等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 protected virtual (string, string) NormalizeNaming(string containerName, string blobName) { // 从当前的配置信息中获取对应的标准化器，如果不存在任何标准化工具对象，则直接返回原始名称。 if (!Configuration.NamingNormalizers.Any()) { return (containerName, blobName); } using (var scope = ServiceProvider.CreateScope()) { // 获取所有的标准化器，并依次进行名称的标准化处理。 foreach (var normalizerType in Configuration.NamingNormalizers) { var normalizer = scope.ServiceProvider .GetRequiredService(normalizerType) .As\u0026lt;IBlobNamingNormalizer\u0026gt;(); containerName = normalizer.NormalizeContainerName(containerName); blobName = normalizer.NormalizeBlobName(blobName); } return (containerName, blobName); } } 2.2.3.2 BLOB 上下文 在 BLOB 里面，ABP 分别为每个操作都定义了一个 ***Args 对象，它就是一个上下文对象，用于在整个调用周期中传递参数。\n2.2.3.3 BLOB 配置信息 每个 BLOB 容器都会有一个 BlobContainerConfiguration 用于存储配置信息，它主要有以下几个重要的属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class BlobContainerConfiguration { // 当前 BLOB 容器对应的 Provider 类型。 public Type ProviderType { get; set; } // 当前 BLOB 容器是否启用了多租户。 public bool IsMultiTenant { get; set; } = true; // 当前 BLOB 容器的名称标准化对象。 public ITypeList\u0026lt;IBlobNamingNormalizer\u0026gt; NamingNormalizers { get; } // 当前 BLOB 容器的属性。 [NotNull] private readonly Dictionary\u0026lt;string, object\u0026gt; _properties; // 当尝试获取某些配置属性，但是不存在时，会从这个 Configuration 拿取数据。 [CanBeNull] private readonly BlobContainerConfiguration _fallbackConfiguration; public BlobContainerConfiguration(BlobContainerConfiguration fallbackConfiguration = null) { NamingNormalizers = new TypeList\u0026lt;IBlobNamingNormalizer\u0026gt;(); _fallbackConfiguration = fallbackConfiguration; _properties = new Dictionary\u0026lt;string, object\u0026gt;(); } [CanBeNull] public T GetConfigurationOrDefault\u0026lt;T\u0026gt;(string name, T defaultValue = default) { return (T) GetConfigurationOrNull(name, defaultValue); } [CanBeNull] public object GetConfigurationOrNull(string name, object defaultValue = null) { return _properties.GetOrDefault(name) ?? _fallbackConfiguration?.GetConfigurationOrNull(name, defaultValue) ?? defaultValue; } // ... 其他代码。 } 在后续各种 Provider 里面定义的配置项，本质上就是对 _properties 字典进行操作。\n2.2.3 容器的构造与初始化 BLOB 容器并不是通过 IoC 容器直接解析构造的，而是通过 IBlobContainerFactory 工厂进行创建，与容器相关的配置对象和 BLOB Provider 也是在这个时候进行构造赋值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class BlobContainerFactory : IBlobContainerFactory, ITransientDependency { protected IBlobProviderSelector ProviderSelector { get; } protected IBlobContainerConfigurationProvider ConfigurationProvider { get; } protected ICurrentTenant CurrentTenant { get; } protected ICancellationTokenProvider CancellationTokenProvider { get; } protected IServiceProvider ServiceProvider { get; } public BlobContainerFactory( IBlobContainerConfigurationProvider configurationProvider, ICurrentTenant currentTenant, ICancellationTokenProvider cancellationTokenProvider, IBlobProviderSelector providerSelector, IServiceProvider serviceProvider) { ConfigurationProvider = configurationProvider; CurrentTenant = currentTenant; CancellationTokenProvider = cancellationTokenProvider; ProviderSelector = providerSelector; ServiceProvider = serviceProvider; } public virtual IBlobContainer Create(string name) { // 根据容器的名称，获取对应的配置。 var configuration = ConfigurationProvider.Get(name); // 构造一个新的容器对象。 return new BlobContainer( name, configuration, // 一样的是根据容器名称，获得匹配的 Provider 类型。 ProviderSelector.Get(name), CurrentTenant, CancellationTokenProvider, ServiceProvider ); } } 那么这个工厂方法是在什么时候调用的呢？跳转到工厂方法的实现，发现会被一个静态扩展方法所调用，重要的是这个方法是一个泛型方法，这样就与开头的类型化 BLOB 容器相对应了。\n1 2 3 4 5 6 7 8 9 10 11 12 public static class BlobContainerFactoryExtensions { public static IBlobContainer Create\u0026lt;TContainer\u0026gt;( this IBlobContainerFactory blobContainerFactory ) { // 通过 GetContainerName 方法获取容器的名字。 return blobContainerFactory.Create( BlobContainerNameAttribute.GetContainerName\u0026lt;TContainer\u0026gt;() ); } } GetContainerName() 方法也很简单，如果容器类型没有指定 BlobContainerNameAttribute 特性，那么就会默认使用类型的 FullName 作为名称。\n1 2 3 4 5 6 7 8 9 10 11 public static string GetContainerName(Type type) { var nameAttribute = type.GetCustomAttribute\u0026lt;BlobContainerNameAttribute\u0026gt;(); if (nameAttribute == null) { return type.FullName; } return nameAttribute.GetName(type); } 最后的最后，看一下这个类型化的 BLOB 容器。\n1 2 3 4 5 6 7 8 9 10 11 12 public class BlobContainer\u0026lt;TContainer\u0026gt; : IBlobContainer\u0026lt;TContainer\u0026gt; where TContainer : class { private readonly IBlobContainer _container; public BlobContainer(IBlobContainerFactory blobContainerFactory) { _container = blobContainerFactory.Create\u0026lt;TContainer\u0026gt;(); } // ... 其他代码。 } 对应的是模块初始化的工厂方法：\n1 2 3 4 context.Services.AddTransient( typeof(IBlobContainer), serviceProvider =\u0026gt; serviceProvider .GetRequiredService\u0026lt;IBlobContainer\u0026lt;DefaultContainer\u0026gt;\u0026gt;() 这里的 DefaultContainer 就指定了该特性，所以本质上一个 IBlobContainer 就是一个类型化的容器，它的泛型参数是 DefaultContainer。\n1 2 3 4 5 [BlobContainerName(Name)] public class DefaultContainer { public const string Name = \u0026#34;default\u0026#34;; } 2.2.3.1 BLOB 的配置提供者 BLOB 容器工厂使用 IBlobContainerConfigurationProvider 来匹配对应容器的配置信息，实现比较简单，直接注入了 AbpBlobStoringOptions 并尝试从它的 BlobContainerConfigurations 中获取配置对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class DefaultBlobContainerConfigurationProvider : IBlobContainerConfigurationProvider, ITransientDependency { protected AbpBlobStoringOptions Options { get; } public DefaultBlobContainerConfigurationProvider(IOptions\u0026lt;AbpBlobStoringOptions\u0026gt; options) { Options = options.Value; } public virtual BlobContainerConfiguration Get(string name) { return Options.Containers.GetConfiguration(name); } } 这里的 BlobContainerConfigurations 对象，核心就是一个键值对，键就是 BLOB 容器的名称，值就是容器对应的配置对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class BlobContainerConfigurations { private BlobContainerConfiguration Default =\u0026gt; GetConfiguration\u0026lt;DefaultContainer\u0026gt;(); private readonly Dictionary\u0026lt;string, BlobContainerConfiguration\u0026gt; _containers; public BlobContainerConfigurations() { _containers = new Dictionary\u0026lt;string, BlobContainerConfiguration\u0026gt; { // 添加默认的 BLOB 容器。 [BlobContainerNameAttribute.GetContainerName\u0026lt;DefaultContainer\u0026gt;()] = new BlobContainerConfiguration() }; } // ... 其他代码 public BlobContainerConfigurations Configure( [NotNull] string name, [NotNull] Action\u0026lt;BlobContainerConfiguration\u0026gt; configureAction) { Check.NotNullOrWhiteSpace(name, nameof(name)); Check.NotNull(configureAction, nameof(configureAction)); configureAction( _containers.GetOrAdd( name, () =\u0026gt; new BlobContainerConfiguration(Default) ) ); return this; } public BlobContainerConfigurations ConfigureAll(Action\u0026lt;string, BlobContainerConfiguration\u0026gt; configureAction) { foreach (var container in _containers) { configureAction(container.Key, container.Value); } return this; } // ... 其他代码 } 在使用过程中，我们在模块里面调用的 Configure() 方法，就会在字典添加一个新的 Item，并为其赋值。而 ConfigureAll() 就是遍历这个字典，为每个 BLOB 容器调用委托，以便进行配置。\n2.2.3.2 BLOB 的 Provider 选择器 在构造 BLOB 容器的时候，BLOB 容器工厂通过 IBlobProviderSelector 来选择对应的 BLOB Provider，具体选择哪一个是根据 BlobContainerConfiguration 里面的 ProviderType 决定的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public virtual IBlobProvider Get([NotNull] string containerName) { Check.NotNull(containerName, nameof(containerName)); // 获得当前 BLOB 容器对应的配置信息。 var configuration = ConfigurationProvider.Get(containerName); if (!BlobProviders.Any()) { throw new AbpException(\u0026#34;No BLOB Storage provider was registered! At least one provider must be registered to be able to use the Blog Storing System.\u0026#34;); } foreach (var provider in BlobProviders) { // 通过配置信息匹配对应的 Provider。 if (ProxyHelper.GetUnProxiedType(provider).IsAssignableTo(configuration.ProviderType)) { return provider; } } throw new AbpException( $\u0026#34;Could not find the BLOB Storage provider with the type ({configuration.ProviderType.AssemblyQualifiedName}) configured for the container {containerName} and no default provider was set.\u0026#34; ); } 上面的 BlobProviders 其实就是直接从 IoC 解析的 IEnumerable\u0026lt;IBlobProvider\u0026gt; 对象，我还找了半天是哪个地方进行赋值的。当 ABP 框架自动之后，会自动将已经实现的 BLOB Provider 注入到 IoC 容器中，如果某个容器在使用时指定了对应的配置参数，则会匹配对应的 BLOB Provider。\n2.3 Provider 的实现 2.3.1 File System 文件系统作为 BLOB 的最简化实现，本质就是通过文件夹进行租户隔离动作，所有操作都会将数据持久化到硬盘上。核心代码就一个文件 FileSystemBlobProvider，在这个文件内部定义了具体的执行逻辑，我们这里大概看一下 SaveAsyn() 的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public override async Task SaveAsync(BlobProviderSaveArgs args) { var filePath = FilePathCalculator.Calculate(args); if (!args.OverrideExisting \u0026amp;\u0026amp; await ExistsAsync(filePath)) { throw new BlobAlreadyExistsException($\u0026#34;Saving BLOB \u0026#39;{args.BlobName}\u0026#39; does already exists in the container \u0026#39;{args.ContainerName}\u0026#39;! Set {nameof(args.OverrideExisting)} if it should be overwritten.\u0026#34;); } DirectoryHelper.CreateIfNotExists(Path.GetDirectoryName(filePath)); var fileMode = args.OverrideExisting ? FileMode.Create : FileMode.CreateNew; await Policy.Handle\u0026lt;IOException\u0026gt;() .WaitAndRetryAsync(2, retryCount =\u0026gt; TimeSpan.FromSeconds(retryCount)) .ExecuteAsync(async () =\u0026gt; { using (var fileStream = File.Open(filePath, fileMode, FileAccess.Write)) { await args.BlobStream.CopyToAsync( fileStream, args.CancellationToken ); await fileStream.FlushAsync(); } }); } 很简单，通过 FilePathCalculator 计算出来文件的具体路径，然后结合配置参数来判断文件是否存在，以及是否进入后续操作。通过 Polly 提供的重试机制来创建文件。\n2.3.2 DataBase 数据库 Provider 是利用数据库的 BLOB 类型，将这些大型对象存储到数据库当中，不太建议这样操作。这里不再进行详细介绍，基本大同小异。\n2.3.3 各类 OSS (腾讯云为例) OSS 作为云厂商的标配，基本概念和操作都与 ABP 的 BLOB 相匹配，集成起来也还是比较简单，就是将各个 OSS 的 SDK 塞进来就行。这里注意点的是，每个 BLOB Provider 都会编写一个基于 BlobContainerConfiguration 类型的静态方法，取名都叫做 UseXXX()，并在里面对具体的配置进行赋值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static class TencentCloudBlobContainerConfigurationExtensions { public static TencentCloudBlobProviderConfiguration GetTencentCloudConfiguration( this BlobContainerConfiguration containerConfiguration) { return new TencentCloudBlobProviderConfiguration(containerConfiguration); } public static BlobContainerConfiguration UseTencentCloud( this BlobContainerConfiguration containerConfiguration, Action\u0026lt;TencentCloudBlobProviderConfiguration\u0026gt; tencentCloudConfigureAction) { containerConfiguration.ProviderType = typeof(TencentCloudBlobProvider); containerConfiguration.NamingNormalizers.TryAdd\u0026lt;TencentCloudBlobNamingNormalizer\u0026gt;(); tencentCloudConfigureAction(new TencentCloudBlobProviderConfiguration(containerConfiguration)); return containerConfiguration; } } 可能会对这个 TencentCloudBlobProviderConfiguration 有一些好奇，其实就是个套娃，因为直接传入了 BlobContainerConfiguration 对象，里面的各种属性本质上就是对配置项的那个 Dictionary\u0026lt;string,object\u0026gt; 进行操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class TencentCloudBlobProviderConfiguration { public string AppId { get =\u0026gt; _containerConfiguration.GetConfigurationOrDefault\u0026lt;string\u0026gt;(TencentCloudBlobProviderConfigurationNames.AppId); set =\u0026gt; _containerConfiguration.SetConfiguration(TencentCloudBlobProviderConfigurationNames.AppId, value); } public string SecretId { get =\u0026gt; _containerConfiguration.GetConfigurationOrDefault\u0026lt;string\u0026gt;(TencentCloudBlobProviderConfigurationNames.SecretId); set =\u0026gt; _containerConfiguration.SetConfiguration(TencentCloudBlobProviderConfigurationNames.SecretId, value); } // ... 其他代码 public TencentCloudBlobProviderConfiguration(BlobContainerConfiguration containerConfiguration) { _containerConfiguration = containerConfiguration; } } 腾讯云的 BLOB Provider 仓库：https://github.com/EasyAbp/Abp.BlobStoring.TencentCloud\n2.4 回顾 开发人员可以在模块的 ConfigureService() 阶段为所有容器或者特定容器指定参数。 ABP vNext 框架会注入所有的 BLOB Provider，并注入默认的 IBlobContainer\u0026lt;DefaultContainer\u0026gt; 容器和其他的类型化容器实现。 当需要使用 BLOB 时，开发人员注入了 IBlobContainer 或 IBlobContainer\u0026lt;T\u0026gt;。 BLOB 容器的工厂会根据容器的名称匹配对应的 BLOB Provider 和配置对象。 BLOB Provider 根据 **Args 参数内部附带的配置对象，读取对应的配置信息进行自定义的操作。 三、总结 小型项目直接集成 FileSystem 即可，中大型项目可以使用各种 OSS Provider，BLOB 系统可以简化开发人员对于大量二进制文件的管理操作。最近工作相当杂乱繁忙，下半年希望有时间继续学习更新吧。\n其他相关文章，请参阅 文章目录 。\n","date":"2020-07-27T12:09:00Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---23-binary-large-object-system-blob/","title":"Abp vNext 源码分析 - 23. 二进制大对象系统(BLOB)"},{"content":"一、简介 ABP vNext 原生支持多租户体系，可以让开发人员快速地基于框架开发 SaaS 系统。ABP vNext 实现多租户的思路也非常简单，通过一个 TenantId 来分割各个租户的数据，并且在查询的时候使用统一的全局过滤器(类似于软删除)来筛选数据。\n关于多租户体系的东西，基本定义与核心逻辑存放在 Volo.ABP.MultiTenancy 内部。针对 ASP.NET Core MVC 的集成则是由 Volo.ABP.AspNetCore.MultiTenancy 项目实现的，针对多租户的解析都在这个项目内部。租户数据的存储和管理都由 Volo.ABP.TenantManagement 模块提供，开发人员也可以直接使用该项目快速实现多租户功能。\n二、源码分析 2.1 启动模块 AbpMultiTenancyModule 模块是启用整个多租户功能的核心模块，内部只进行了一个动作，就是从配置类当中读取多租户的基本信息，以 JSON Provider 为例，就需要在 appsettings.json 里面有 Tenants 节。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026#34;Tenants\u0026#34;: [ { \u0026#34;Id\u0026#34;: \u0026#34;446a5211-3d72-4339-9adc-845151f8ada0\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;tenant1\u0026#34; }, { \u0026#34;Id\u0026#34;: \u0026#34;25388015-ef1c-4355-9c18-f6b6ddbaf89d\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;tenant2\u0026#34;, \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;...write tenant2\u0026#39;s db connection string here...\u0026#34; } } ] 2.1.1 默认租户来源 这里的数据将会作为默认租户来源，也就是说在确认当前租户的时候，会从这里面的数据与要登录的租户进行比较，如果不存在则不允许进行操作。\n1 2 3 4 5 6 7 8 9 10 public interface ITenantStore { Task\u0026lt;TenantConfiguration\u0026gt; FindAsync(string name); Task\u0026lt;TenantConfiguration\u0026gt; FindAsync(Guid id); TenantConfiguration Find(string name); TenantConfiguration Find(Guid id); } 默认的存储实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 [Dependency(TryRegister = true)] public class DefaultTenantStore : ITenantStore, ITransientDependency { // 直接从 Options 当中获取租户数据。 private readonly AbpDefaultTenantStoreOptions _options; public DefaultTenantStore(IOptionsSnapshot\u0026lt;AbpDefaultTenantStoreOptions\u0026gt; options) { _options = options.Value; } public Task\u0026lt;TenantConfiguration\u0026gt; FindAsync(string name) { return Task.FromResult(Find(name)); } public Task\u0026lt;TenantConfiguration\u0026gt; FindAsync(Guid id) { return Task.FromResult(Find(id)); } public TenantConfiguration Find(string name) { return _options.Tenants?.FirstOrDefault(t =\u0026gt; t.Name == name); } public TenantConfiguration Find(Guid id) { return _options.Tenants?.FirstOrDefault(t =\u0026gt; t.Id == id); } } 除了从配置文件当中读取租户信息以外，开发人员也可以自己实现 ITenantStore 接口，比如说像 TenantManagement 一样，将租户信息存储到数据库当中。\n2.1.2 基于数据库的租户存储 话接上文，我们说过在 Volo.ABP.TenantManagement 模块内部有提供另一种 ITenantStore 接口的实现，这个类型叫做 TenantStore，内部逻辑也很简单，就是从仓储当中查找租户数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class TenantStore : ITenantStore, ITransientDependency { private readonly ITenantRepository _tenantRepository; private readonly IObjectMapper\u0026lt;AbpTenantManagementDomainModule\u0026gt; _objectMapper; private readonly ICurrentTenant _currentTenant; public TenantStore( ITenantRepository tenantRepository, IObjectMapper\u0026lt;AbpTenantManagementDomainModule\u0026gt; objectMapper, ICurrentTenant currentTenant) { _tenantRepository = tenantRepository; _objectMapper = objectMapper; _currentTenant = currentTenant; } public async Task\u0026lt;TenantConfiguration\u0026gt; FindAsync(string name) { // 变更当前租户为租主。 using (_currentTenant.Change(null)) //TODO: No need this if we can implement to define host side (or tenant-independent) entities! { // 通过仓储查询租户是否存在。 var tenant = await _tenantRepository.FindByNameAsync(name); if (tenant == null) { return null; } // 将查询到的信息转换为核心库定义的租户信息。 return _objectMapper.Map\u0026lt;Tenant, TenantConfiguration\u0026gt;(tenant); } } // ... 其他的代码已经省略。 } 可以看到，最后也是返回的一个 TenantConfiguration 类型。关于这个类型，是 ABP 在多租户核心库定义的一个基本类型之一，主要是用于规定持久化一个租户信息需要包含的属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 [Serializable] public class TenantConfiguration { // 租户的 Guid。 public Guid Id { get; set; } // 租户的名称。 public string Name { get; set; } // 租户对应的数据库连接字符串。 public ConnectionStrings ConnectionStrings { get; set; } public TenantConfiguration() { } public TenantConfiguration(Guid id, [NotNull] string name) { Check.NotNull(name, nameof(name)); Id = id; Name = name; ConnectionStrings = new ConnectionStrings(); } } 2.2 租户的解析 ABP vNext 如果要判断当前的租户是谁，则是通过 AbpTenantResolveOptions 提供的一组 ITenantResolveContributor 进行处理的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class AbpTenantResolveOptions { // 会使用到的这组解析对象。 [NotNull] public List\u0026lt;ITenantResolveContributor\u0026gt; TenantResolvers { get; } public AbpTenantResolveOptions() { TenantResolvers = new List\u0026lt;ITenantResolveContributor\u0026gt; { // 默认的解析对象，会通过 Token 内字段解析当前租户。 new CurrentUserTenantResolveContributor() }; } } 这里的设计与权限一样，都是由一组 解析对象(解析器) 进行处理，在上层开放的入口只有一个 ITenantResolver ，内部通过 foreach 执行这组解析对象的 Resolve() 方法。\n下面就是我们 ITenantResolver 的默认实现 TenantResolver，你可以在任何时候调用它。比如说你在想要获得当前租户 Id 的时候。不过一般不推荐这样做，因为 ABP 已经给我们提供了 MultiTenancyMiddleware 中间件。\n也就是说，在每次请求的时候，都会将这个 Id 通过 ICurrentTenant.Change() 进行变更，那么在这个请求执行完成之前，通过 ICurrentTenant 取得的 Id 都会是解析器解析出来的 Id。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class TenantResolver : ITenantResolver, ITransientDependency { private readonly IServiceProvider _serviceProvider; private readonly AbpTenantResolveOptions _options; public TenantResolver(IOptions\u0026lt;AbpTenantResolveOptions\u0026gt; options, IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; _options = options.Value; } public TenantResolveResult ResolveTenantIdOrName() { var result = new TenantResolveResult(); using (var serviceScope = _serviceProvider.CreateScope()) { // 创建一个解析上下文，用于存储解析器的租户 Id 解析结果。 var context = new TenantResolveContext(serviceScope.ServiceProvider); // 遍历执行解析器。 foreach (var tenantResolver in _options.TenantResolvers) { tenantResolver.Resolve(context); result.AppliedResolvers.Add(tenantResolver.Name); // 如果有某个解析器为上下文设置了值，则跳出。 if (context.HasResolvedTenantOrHost()) { result.TenantIdOrName = context.TenantIdOrName; break; } } } return result; } } 2.2.1 默认的解析对象 如果不使用 Volo.Abp.AspNetCore.MultiTenancy 模块，ABP vNext 会调用 CurrentUserTenantResolveContributor 解析当前操作的租户。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class CurrentUserTenantResolveContributor : TenantResolveContributorBase { public const string ContributorName = \u0026#34;CurrentUser\u0026#34;; public override string Name =\u0026gt; ContributorName; public override void Resolve(ITenantResolveContext context) { // 从 Token 当中获取当前登录用户的信息。 var currentUser = context.ServiceProvider.GetRequiredService\u0026lt;ICurrentUser\u0026gt;(); if (currentUser.IsAuthenticated != true) { return; } // 设置解析上下文，确认当前的租户 Id。 context.Handled = true; context.TenantIdOrName = currentUser.TenantId?.ToString(); } } 在这里可以看到，如果从 Token 当中解析到了租户 Id，会将这个 Id 传递给 解析上下文。这个上下文在最开始已经遇到过了，如果 ABP vNext 在解析的时候发现租户 Id 被确认了，就不会执行剩下的解析器。\n2.2.2 ABP 提供的其他解析器 ABP 在 Volo.Abp.AspNetCore.MultiTenancy 模块当中还提供了其他几种解析器，他们的作用分别如下。\n解析器类型 作用 优先级 QueryStringTenantResolveContributor 通过 Query String 的 __tenant 参数确认租户。 2 RouteTenantResolveContributor 通过路由判断当前租户。 3 HeaderTenantResolveContributor 通过 Header 里面的 __tenant 确认租户。 4 CookieTenantResolveContributor 通过携带的 Cookie 确认租户。 5 DomainTenantResolveContributor 二级域名解析器，通过二级域名确定租户。 第二 2.2.3 域名解析器 这里比较有意思的是 DomainTenantResolveContributor，开发人员可以通过 AbpTenantResolveOptions.AddDomainTenantResolver() 方法添加这个解析器。 域名解析器会通过解析二级域名来匹配对应的租户，例如我针对租户 A 分配了一个二级域名 http://a.system.com，那么这个 a 就会被作为租户名称解析出来，最后传递给 ITenantResolver 解析器作为结果。\n注意：\n在使用 Header 作为租户信息提供者的时候，开发人员使用的是 NGINX 作为反向代理服务器 时，需要在对应的 config 文件内部配置 underscores_in_headers on; 选项。否则 ABP 所需要的 __tenantId 将会被过滤掉，或者你可以指定一个没有下划线的 Key。\n域名解析器的详细代码解释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class DomainTenantResolveContributor : HttpTenantResolveContributorBase { public const string ContributorName = \u0026#34;Domain\u0026#34;; public override string Name =\u0026gt; ContributorName; private static readonly string[] ProtocolPrefixes = { \u0026#34;http://\u0026#34;, \u0026#34;https://\u0026#34; }; private readonly string _domainFormat; // 使用指定的格式来确定租户前缀，例如 “{0}.abp.io”。 public DomainTenantResolveContributor(string domainFormat) { _domainFormat = domainFormat.RemovePreFix(ProtocolPrefixes); } protected override string GetTenantIdOrNameFromHttpContextOrNull( ITenantResolveContext context, HttpContext httpContext) { // 如果 Host 值为空，则不进行任何操作。 if (httpContext.Request?.Host == null) { return null; } // 解析具体的域名信息，并进行匹配。 var hostName = httpContext.Request.Host.Host.RemovePreFix(ProtocolPrefixes); // 这里的 FormattedStringValueExtracter 类型是 ABP 自己实现的一个格式化解析器。 var extractResult = FormattedStringValueExtracter.Extract(hostName, _domainFormat, ignoreCase: true); context.Handled = true; if (!extractResult.IsMatch) { return null; } return extractResult.Matches[0].Value; } } 从上述代码可以知道，域名解析器是基于 HttpTenantResolveContributorBase 基类进行处理的，这个抽象基类会取得当前请求的一个 HttpContext，将这个传递与解析上下文一起传递给子类实现，由子类实现负责具体的解析逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public abstract class HttpTenantResolveContributorBase : TenantResolveContributorBase { public override void Resolve(ITenantResolveContext context) { // 获取当前请求的上下文。 var httpContext = context.GetHttpContext(); if (httpContext == null) { return; } try { ResolveFromHttpContext(context, httpContext); } catch (Exception e) { context.ServiceProvider .GetRequiredService\u0026lt;ILogger\u0026lt;HttpTenantResolveContributorBase\u0026gt;\u0026gt;() .LogWarning(e.ToString()); } } protected virtual void ResolveFromHttpContext(ITenantResolveContext context, HttpContext httpContext) { // 调用抽象方法，获取具体的租户 Id 或名称。 var tenantIdOrName = GetTenantIdOrNameFromHttpContextOrNull(context, httpContext); if (!tenantIdOrName.IsNullOrEmpty()) { // 获得到租户标识之后，填充到解析上下文。 context.TenantIdOrName = tenantIdOrName; } } protected abstract string GetTenantIdOrNameFromHttpContextOrNull([NotNull] ITenantResolveContext context, [NotNull] HttpContext httpContext); } 2.3 租户信息的传递 租户解析器通过一系列的解析对象，获取到了租户或租户 Id 之后，会将这些数据给哪些对象呢？或者说，ABP 在什么地方调用了 租户解析器，答案就是 中间件。\n在 Volo.ABP.AspNetCore.MultiTenancy 模块的内部，提供了一个 MultiTenancyMiddleware 中间件。\n开发人员如果需要使用 ASP.NET Core 的多租户相关功能，也可以引入该模块。并且在模块的 OnApplicationInitialization() 方法当中，使用 IApplicationBuilder.UseMultiTenancy() 进行启用。\n这里在启用的时候，需要注意中间件的顺序和位置，不要放到最末尾进行处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class MultiTenancyMiddleware : IMiddleware, ITransientDependency { private readonly ITenantResolver _tenantResolver; private readonly ITenantStore _tenantStore; private readonly ICurrentTenant _currentTenant; private readonly ITenantResolveResultAccessor _tenantResolveResultAccessor; public MultiTenancyMiddleware( ITenantResolver tenantResolver, ITenantStore tenantStore, ICurrentTenant currentTenant, ITenantResolveResultAccessor tenantResolveResultAccessor) { _tenantResolver = tenantResolver; _tenantStore = tenantStore; _currentTenant = currentTenant; _tenantResolveResultAccessor = tenantResolveResultAccessor; } public async Task InvokeAsync(HttpContext context, RequestDelegate next) { // 通过租户解析器，获取当前请求的租户信息。 var resolveResult = _tenantResolver.ResolveTenantIdOrName(); _tenantResolveResultAccessor.Result = resolveResult; TenantConfiguration tenant = null; // 如果当前请求是属于租户请求。 if (resolveResult.TenantIdOrName != null) { // 查询指定的租户 Id 或名称是否存在，不存在则抛出异常。 tenant = await FindTenantAsync(resolveResult.TenantIdOrName); if (tenant == null) { //TODO: A better exception? throw new AbpException( \u0026#34;There is no tenant with given tenant id or name: \u0026#34; + resolveResult.TenantIdOrName ); } } // 在接下来的请求当中，将会通过 ICurrentTenant.Change() 方法变更当前租户，直到 // 请求结束。 using (_currentTenant.Change(tenant?.Id, tenant?.Name)) { await next(context); } } private async Task\u0026lt;TenantConfiguration\u0026gt; FindTenantAsync(string tenantIdOrName) { // 如果可以格式化为 Guid ，则说明是租户 Id。 if (Guid.TryParse(tenantIdOrName, out var parsedTenantId)) { return await _tenantStore.FindAsync(parsedTenantId); } else { return await _tenantStore.FindAsync(tenantIdOrName); } } } 在取得了租户的标识(Id 或名称)之后，将会通过 ICurrentTenant.Change() 方法变更当前租户的信息，变更了当租户信息以后，在程序的其他任何地方使用 ICurrentTenant.Id 取得的数据都是租户解析器解析出来的数据。\n下面就是这个当前租户的具体实现，可以看到这里采用了一个 经典手法-嵌套。这个手法在工作单元和数据过滤器有见到过，结合 DisposeAction() 在 using 语句块结束的时候把当前的租户 Id 值设置为父级 Id。即在同一个语句当中，可以通过嵌套 using 语句块来处理不同的租户。\n1 2 3 4 5 6 7 8 using(_currentTenant.Change(\u0026#34;A\u0026#34;)) { Logger.LogInformation(_currentTenant.Id); using(_currentTenant.Change(\u0026#34;B\u0026#34;)) { Logger.LogInformation(_currentTenant.Id); } } 具体的实现代码，这里的 ICurrentTenantAccessor 内部实现就是一个 AsyncLocal\u0026lt;BasicTenantInfo\u0026gt; ，用于在一个异步请求内部进行数据传递。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class CurrentTenant : ICurrentTenant, ITransientDependency { public virtual bool IsAvailable =\u0026gt; Id.HasValue; public virtual Guid? Id =\u0026gt; _currentTenantAccessor.Current?.TenantId; public string Name =\u0026gt; _currentTenantAccessor.Current?.Name; private readonly ICurrentTenantAccessor _currentTenantAccessor; public CurrentTenant(ICurrentTenantAccessor currentTenantAccessor) { _currentTenantAccessor = currentTenantAccessor; } public IDisposable Change(Guid? id, string name = null) { return SetCurrent(id, name); } private IDisposable SetCurrent(Guid? tenantId, string name = null) { var parentScope = _currentTenantAccessor.Current; _currentTenantAccessor.Current = new BasicTenantInfo(tenantId, name); return new DisposeAction(() =\u0026gt; { _currentTenantAccessor.Current = parentScope; }); } } 这里的 BasicTenantInfo 与 TenantConfiguraton 不同，前者仅用于在程序当中传递用户的基本信息，而后者是用于定于持久化的标准模型。\n2.4 租户的使用 2.4.1 数据库过滤 租户的核心作用就是隔离不同客户的数据，关于过滤的基本逻辑则是存放在 AbpDbContext\u0026lt;TDbContext\u0026gt; 的。从下面的代码可以看到，在使用的时候会从注入一个 ICurrentTenant 接口，这个接口可以获得从租户解析器里面取得的租户 Id 信息。并且还有一个 IsMultiTenantFilterEnabled() 方法来判定当前 是否应用租户过滤器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public abstract class AbpDbContext\u0026lt;TDbContext\u0026gt; : DbContext, IEfCoreDbContext, ITransientDependency where TDbContext : DbContext { protected virtual Guid? CurrentTenantId =\u0026gt; CurrentTenant?.Id; protected virtual bool IsMultiTenantFilterEnabled =\u0026gt; DataFilter?.IsEnabled\u0026lt;IMultiTenant\u0026gt;() ?? false; // ... 其他的代码。 public ICurrentTenant CurrentTenant { get; set; } // ... 其他的代码。 protected virtual Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; CreateFilterExpression\u0026lt;TEntity\u0026gt;() where TEntity : class { // 定义一个 Lambda 表达式。 Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; expression = null; // 如果聚合根/实体实现了软删除接口，则构建一个软删除过滤器。 if (typeof(ISoftDelete).IsAssignableFrom(typeof(TEntity))) { expression = e =\u0026gt; !IsSoftDeleteFilterEnabled || !EF.Property\u0026lt;bool\u0026gt;(e, \u0026#34;IsDeleted\u0026#34;); } // 如果聚合根/实体实现了多租户接口，则构建一个多租户过滤器。 if (typeof(IMultiTenant).IsAssignableFrom(typeof(TEntity))) { // 筛选 TenantId 为 CurrentTenantId 的数据。 Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; multiTenantFilter = e =\u0026gt; !IsMultiTenantFilterEnabled || EF.Property\u0026lt;Guid\u0026gt;(e, \u0026#34;TenantId\u0026#34;) == CurrentTenantId; expression = expression == null ? multiTenantFilter : CombineExpressions(expression, multiTenantFilter); } return expression; } // ... 其他的代码。 } 2.4.2 种子数据构建 在 Volo.ABP.TenantManagement 模块当中，如果用户创建了一个租户，ABP 不只是在租户表插入一条新数据而已。它还会设置种子数据的 构造上下文，并且执行所有的 种子数据构建者(IDataSeedContributor)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [Authorize(TenantManagementPermissions.Tenants.Create)] public virtual async Task\u0026lt;TenantDto\u0026gt; CreateAsync(TenantCreateDto input) { var tenant = await TenantManager.CreateAsync(input.Name); await TenantRepository.InsertAsync(tenant); using (CurrentTenant.Change(tenant.Id, tenant.Name)) { //TODO: Handle database creation? //TODO: Set admin email \u0026amp; password..? await DataSeeder.SeedAsync(tenant.Id); } return ObjectMapper.Map\u0026lt;Tenant, TenantDto\u0026gt;(tenant); } 这些构建者当中，就包括租户的超级管理员(admin)和角色构建，以及针对超级管理员角色进行权限赋值操作。\n这里需要注意第二点，如果开发人员没有指定超级管理员用户和密码，那么还是会使用默认密码为租户生成超级管理员，具体原因看如下代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class IdentityDataSeedContributor : IDataSeedContributor, ITransientDependency { private readonly IIdentityDataSeeder _identityDataSeeder; public IdentityDataSeedContributor(IIdentityDataSeeder identityDataSeeder) { _identityDataSeeder = identityDataSeeder; } public Task SeedAsync(DataSeedContext context) { return _identityDataSeeder.SeedAsync( context[\u0026#34;AdminEmail\u0026#34;] as string ?? \u0026#34;admin@abp.io\u0026#34;, context[\u0026#34;AdminPassword\u0026#34;] as string ?? \u0026#34;1q2w3E*\u0026#34;, context.TenantId ); } } 所以开发人员要实现为不同租户 生成随机密码，那么就不能够使用 TenantManagement 提供的创建方法，而是需要自己编写一个应用服务进行处理。\n2.4.3 权限的控制 如果开发人员使用了 ABP 提供的 Volo.Abp.PermissionManagement 模块，就会看到在它的种子数据构造者当中会对权限进行判定。因为有一些 超级权限 是租主才能够授予的，例如租户的增加、删除、修改等，这些超级权限在定义的时候就需要说明是否是数据租主独有的。\n关于这点，可以参考租户管理模块在权限定义时，传递的 MultiTenancySides.Host 参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class AbpTenantManagementPermissionDefinitionProvider : PermissionDefinitionProvider { public override void Define(IPermissionDefinitionContext context) { var tenantManagementGroup = context.AddGroup(TenantManagementPermissions.GroupName, L(\u0026#34;Permission:TenantManagement\u0026#34;)); var tenantsPermission = tenantManagementGroup.AddPermission(TenantManagementPermissions.Tenants.Default, L(\u0026#34;Permission:TenantManagement\u0026#34;), multiTenancySide: MultiTenancySides.Host); tenantsPermission.AddChild(TenantManagementPermissions.Tenants.Create, L(\u0026#34;Permission:Create\u0026#34;), multiTenancySide: MultiTenancySides.Host); tenantsPermission.AddChild(TenantManagementPermissions.Tenants.Update, L(\u0026#34;Permission:Edit\u0026#34;), multiTenancySide: MultiTenancySides.Host); tenantsPermission.AddChild(TenantManagementPermissions.Tenants.Delete, L(\u0026#34;Permission:Delete\u0026#34;), multiTenancySide: MultiTenancySides.Host); tenantsPermission.AddChild(TenantManagementPermissions.Tenants.ManageFeatures, L(\u0026#34;Permission:ManageFeatures\u0026#34;), multiTenancySide: MultiTenancySides.Host); tenantsPermission.AddChild(TenantManagementPermissions.Tenants.ManageConnectionStrings, L(\u0026#34;Permission:ManageConnectionStrings\u0026#34;), multiTenancySide: MultiTenancySides.Host); } private static LocalizableString L(string name) { return LocalizableString.Create\u0026lt;AbpTenantManagementResource\u0026gt;(name); } } 下面是权限种子数据构造者的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class PermissionDataSeedContributor : IDataSeedContributor, ITransientDependency { protected ICurrentTenant CurrentTenant { get; } protected IPermissionDefinitionManager PermissionDefinitionManager { get; } protected IPermissionDataSeeder PermissionDataSeeder { get; } public PermissionDataSeedContributor( IPermissionDefinitionManager permissionDefinitionManager, IPermissionDataSeeder permissionDataSeeder, ICurrentTenant currentTenant) { PermissionDefinitionManager = permissionDefinitionManager; PermissionDataSeeder = permissionDataSeeder; CurrentTenant = currentTenant; } public virtual Task SeedAsync(DataSeedContext context) { // 通过 GetMultiTenancySide() 方法判断当前执行 // 种子构造者的租户情况，是租主还是租户。 var multiTenancySide = CurrentTenant.GetMultiTenancySide(); // 根据条件筛选权限。 var permissionNames = PermissionDefinitionManager .GetPermissions() .Where(p =\u0026gt; p.MultiTenancySide.HasFlag(multiTenancySide)) .Select(p =\u0026gt; p.Name) .ToArray(); // 将权限授予具体租户的角色。 return PermissionDataSeeder.SeedAsync( RolePermissionValueProvider.ProviderName, \u0026#34;admin\u0026#34;, permissionNames, context.TenantId ); } } 而 ABP 在判断当前是租主还是租户的方法也很简单，如果当前租户 Id 为 NULL 则说明是租主，如果不为空则说明是具体租户。\n1 2 3 4 5 6 public static MultiTenancySides GetMultiTenancySide(this ICurrentTenant currentTenant) { return currentTenant.Id.HasValue ? MultiTenancySides.Tenant : MultiTenancySides.Host; } 2.4.4 租户的独立设置 关于这块的内容，可以参考之前的 这篇文章 ，ABP 也为我们提供了各个租户独立的自定义参数在，这块功能是由 TenantSettingManagementProvider 实现的，只需要在设置参数值的时候提供租户的 ProviderName 即可。\n例如：\n1 settingManager.SetAsync(\u0026#34;WeChatIsOpen\u0026#34;, \u0026#34;true\u0026#34;, TenantSettingValueProvider.ProviderName, tenantId.ToString(), false); 三、总结 其他相关文章，请参阅 文章目录 。\n","date":"2020-03-03T04:03:15Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---19-multi-tenancy/","title":"Abp vNext 源码分析 - 19. 多租户"},{"content":"安装 首先安装 Docker 与 Docker-Compose 相关的组件，我们这里直接使用准备好的 ELK 镜像，执行以下命令从 Dockerhub 上拉取指定版本的镜像，在本例当中我使用的是 7.40 版本。\n1 docker pull sebp/elk:740 配置 为其编写 docker-compose.yaml 文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 version: \u0026#39;3.7\u0026#39; services: nginx: image: nginx container_name: nginx ports: - 80:80 - 443:443 networks: - internal-network volumes: - /root/Volumes/Nginx/nginx.conf:/etc/nginx/nginx.conf - /root/Volumes/Nginx/Configs:/etc/nginx/conf.d restart: always elk: image: sebp/elk:740 container_name: elk ports: - 9200:9200 - 5044:5044 expose: - 5601 networks: - internal-network volumes: - /opt/elk-data:/var/lib/elasticsearch - /etc/localtime:/etc/localtime depends_on: - nginx ulimits: nproc: 262144 nofile: soft: 262144 hard: 262144 memlock: 9223372036854775807 restart: always networks: internal-network: external: true 上面的 Yaml 文件内容大概意思就是开放 ELK 的 9200 与 5400 端口，然后使用 Nginx 代理 Kibana Dashboard，并且将相关的数据卷挂载了出来。\n这里需要注意的是，我配置了 ulimits 节，这是因为 ELK 在启动的时候会检测相关内核参数，除了在 Yaml 编写还不够，还得变更宿主机的相关参数。关于这些参数的内容变更，请参考以下内容：\n变更 /etc/security/limits.conf 文件，为其追加以下内容：\n1 2 3 4 5 6 7 * soft nofile 204800 * hard nofile 204800 * soft nproc 204800 * hard nproc 204800 * soft memlock unlimited * hard memlock unlimited 跳转到 /etc/security/limits.d 目录下，修改相应的 conf 文件，为其追加以下内容：\n1 2 * soft nproc unlimited * hard nproc unlimited 最后重启服务器，以上内容都是基于 CentOS 7.x 进行编写。\n运行 安装好 docker-compose 工具以后，直接在 Yaml 文件的根目录运行 docker-compose up -d 即可。如果正常的话，访问对应的机器即可。\n","date":"2020-01-17T07:37:13Z","permalink":"https://real-zony.github.io/p/docker-install-elk/","title":"Docker 安装 ELK"},{"content":"一、简要介绍 在以前的文章里面，我们介绍了 ABP vNext 在 DDD 模块定义了仓储的接口定义和基本实现。本章将会介绍，ABP vNext 是如何将 EntityFramework Core 框架跟仓储进行深度集成。\nABP vNext 在集成 EF Core 的时候，不只是简单地实现了仓储模式，除开仓储以外，还提供了一系列的基础设施，如领域事件的发布，数据过滤器的实现。\n二、源码分析 EntityFrameworkCore 相关的模块基本就下面几个，除了第一个是核心 EntityFrameworkCore 模块以外，其他几个都是封装的 EntityFrameworkCore Provider，方便各种数据库进行集成。\n2.1 EF Core 模块集成与初始化 首先从 Volo.Abp.EntityFrameworkCore 的 AbpEntityFrameworkCoreModule 开始分析，该模块只重写了 ConfigureServices() 方法，在内部也只有两句代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public override void ConfigureServices(ServiceConfigurationContext context) { // 调用 AbpDbContextOptions 的预配置方法，为了解决下面的问题。 // https://stackoverflow.com/questions/55369146/eager-loading-include-with-using-uselazyloadingproxies Configure\u0026lt;AbpDbContextOptions\u0026gt;(options =\u0026gt; { options.PreConfigure(abpDbContextConfigurationContext =\u0026gt; { abpDbContextConfigurationContext.DbContextOptions .ConfigureWarnings(warnings =\u0026gt; { warnings.Ignore(CoreEventId.LazyLoadOnDisposedContextWarning); }); }); }); // 注册 IDbContextProvider 组件。 context.Services.TryAddTransient(typeof(IDbContextProvider\u0026lt;\u0026gt;), typeof(UnitOfWorkDbContextProvider\u0026lt;\u0026gt;)); } 首先看第一句代码，它在内部会调用 AbpDbContextOptions 提供的 PreConfigure() 方法。这个方法逻辑很简单，会将传入的 Action\u0026lt;AbpDbContextConfigurationContext\u0026gt; 委托添加到一个 List\u0026lt;Action\u0026lt;AbpDbContextConfigurationContext\u0026gt;\u0026gt; 集合，并且在 DbContextOptionsFactory 工厂中使用。\n第二局代码则比较简单，为 IDbContextProvider\u0026lt;\u0026gt; 类型注入默认实现 UnitOfWorkDbContextProvider\u0026lt;\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class AbpDbContextOptions { internal List\u0026lt;Action\u0026lt;AbpDbContextConfigurationContext\u0026gt;\u0026gt; DefaultPreConfigureActions { get; set; } // ... public void PreConfigure([NotNull] Action\u0026lt;AbpDbContextConfigurationContext\u0026gt; action) { Check.NotNull(action, nameof(action)); DefaultPreConfigureActions.Add(action); } // ... } 从上面的代码可以看出来，这个 AbpDbContextConfigurationContext 就是一个配置上下文，用于 ABP vNext 框架在初始化的时候进行各种配置。\n2.1.1 EF Core Provider 的集成 在翻阅 AbpDbContextOptions 代码的时候，我发现除了预配置方法，它还提供了一个 Configure([NotNull] Action\u0026lt;AbpDbContextConfigurationContext\u0026gt; action) 方法，以及它的泛型重载 Configure\u0026lt;TDbContext\u0026gt;([NotNull] Action\u0026lt;AbpDbContextConfigurationContext\u0026lt;TDbContext\u0026gt;\u0026gt; action)，它们的内部实现与预配置类似。\n这两个方法在 ABP vNext 框架内部的应用，主要在各个 EF Provider 模块当中有体现。\n这里我以 Volo.Abp.EntityFrameworkCore.PostgreSql 模块作为例子，在项目内部只有两个扩展方法的定义类。在 AbpDbContextOptionsPostgreSqlExtensions 当中，就使用到了 Configure() 方法。\n1 2 3 4 5 6 7 8 9 10 public static void UsePostgreSql( [NotNull] this AbpDbContextOptions options, [CanBeNull] Action\u0026lt;NpgsqlDbContextOptionsBuilder\u0026gt; postgreSqlOptionsAction = null) { options.Configure(context =\u0026gt; { // 这里的 context 类型是 AbpDbContextConfigurationContext。 context.UsePostgreSql(postgreSqlOptionsAction); }); } 上面代码中的 UsePostgreSql() 方法很明显不是 EF Core Provider 所定义的扩展方法，跳转到具体实现，发现就是一层简单的封装。由于 AbpDbContextConfigurationContext 内部提供了 DbContextOptionsBuilder ，所以直接使用这个 DbContextOptionsBuilder 调用提供的扩展方法即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static class AbpDbContextConfigurationContextPostgreSqlExtensions { public static DbContextOptionsBuilder UsePostgreSql( [NotNull] this AbpDbContextConfigurationContext context, [CanBeNull] Action\u0026lt;NpgsqlDbContextOptionsBuilder\u0026gt; postgreSqlOptionsAction = null) { if (context.ExistingConnection != null) { return context.DbContextOptions.UseNpgsql(context.ExistingConnection, postgreSqlOptionsAction); } else { return context.DbContextOptions.UseNpgsql(context.ConnectionString, postgreSqlOptionsAction); } } } 2.1.2 数据库上下文的配置工厂 无论是 PreConfigure() 的委托集合，还是 Configure() 配置的委托，都会在 DbContextOptionsFactory 提供的 Create\u0026lt;TDbContext\u0026gt;(IServiceProvider serviceProvider) 方法中被使用。该方法的作用只有一个，执行框架的配置方法，然后生成数据库上下文的配置对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 internal static class DbContextOptionsFactory { public static DbContextOptions\u0026lt;TDbContext\u0026gt; Create\u0026lt;TDbContext\u0026gt;(IServiceProvider serviceProvider) where TDbContext : AbpDbContext\u0026lt;TDbContext\u0026gt; { // 获取一个 DbContextCreationContext 对象。 var creationContext = GetCreationContext\u0026lt;TDbContext\u0026gt;(serviceProvider); // 依据 creationContext 信息构造一个配置上下文。 var context = new AbpDbContextConfigurationContext\u0026lt;TDbContext\u0026gt;( creationContext.ConnectionString, serviceProvider, creationContext.ConnectionStringName, creationContext.ExistingConnection ); // 获取 AbpDbOptions 配置。 var options = GetDbContextOptions\u0026lt;TDbContext\u0026gt;(serviceProvider); // 从 Options 当中获取添加的 PreConfigure 与 Configure 委托，并执行。 PreConfigure(options, context); Configure(options, context); // return context.DbContextOptions.Options; } // ... } 首先我们来看看 GetCreationContext\u0026lt;TDbContext\u0026gt;() 方法是如何构造一个 DbContextCreationContext 对象的，它会优先从 Current 取得一个上下文对象，如果存在则直接返回，不存在则使用连接字符串等信息构建一个新的上下文对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private static DbContextCreationContext GetCreationContext\u0026lt;TDbContext\u0026gt;(IServiceProvider serviceProvider) where TDbContext : AbpDbContext\u0026lt;TDbContext\u0026gt; { // 优先从一个 AsyncLocal 当中获取。 var context = DbContextCreationContext.Current; if (context != null) { return context; } // 从 TDbContext 的 ConnectionStringName 特性获取连接字符串名称。 var connectionStringName = ConnectionStringNameAttribute.GetConnStringName\u0026lt;TDbContext\u0026gt;(); // 使用 IConnectionStringResolver 根据指定的名称获得连接字符串。 var connectionString = serviceProvider.GetRequiredService\u0026lt;IConnectionStringResolver\u0026gt;().Resolve(connectionStringName); // 构造一个新的 DbContextCreationContext 对象。 return new DbContextCreationContext( connectionStringName, connectionString ); } 2.1.3 连接字符串解析器 与老版本的 ABP 一样，ABP vNext 将连接字符串解析的工作，抽象了一个解析器。连接字符串解析器默认有两种实现，适用于普通系统和多租户系统。\n普通的解析器，名字叫做 DefaultConnectionStringResolver，它的连接字符串都是从 AbpDbConnectionOptions 当中获取的，而这个 Option 最终是从 IConfiguration 映射过来的，一般来说就是你 appsetting.json 文件当中的连接字符串配置。\n多租户解析器 的实现叫做 MultiTenantConnectionStringResolver，它的内部核心逻辑就是获得到当前的租户，并查询租户所对应的连接字符串，这样就可以实现每个租户都拥有不同的数据库实例。\n2.1.4 数据库上下文配置工厂的使用 回到最开始的地方，方法 Create\u0026lt;TDbContext\u0026gt;(IServiceProvider serviceProvider) 在什么地方会被使用呢？跳转到唯一的调用点是在 AbpEfCoreServiceCollectionExtensions 静态类的内部，它提供的 AddAbpDbContext\u0026lt;TDbContext\u0026gt;() 方法内部，就使用了 Create\u0026lt;TDbContext\u0026gt;() 作为 DbContextOptions\u0026lt;TDbContext\u0026gt; 的工厂方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public static class AbpEfCoreServiceCollectionExtensions { public static IServiceCollection AddAbpDbContext\u0026lt;TDbContext\u0026gt;( this IServiceCollection services, Action\u0026lt;IAbpDbContextRegistrationOptionsBuilder\u0026gt; optionsBuilder = null) where TDbContext : AbpDbContext\u0026lt;TDbContext\u0026gt; { services.AddMemoryCache(); // 构造一个数据库注册配置对象。 var options = new AbpDbContextRegistrationOptions(typeof(TDbContext), services); // 回调传入的委托。 optionsBuilder?.Invoke(options); // 注入指定 TDbContext 的 DbOptions\u0026lt;TDbContext\u0026gt; ，将会使用 Create\u0026lt;TDbContext\u0026gt; 方法进行瞬时对象构造。 services.TryAddTransient(DbContextOptionsFactory.Create\u0026lt;TDbContext\u0026gt;); // 替换指定类型的 DbContext 为当前 TDbContext。 foreach (var dbContextType in options.ReplacedDbContextTypes) { services.Replace(ServiceDescriptor.Transient(dbContextType, typeof(TDbContext))); } // 构造 EF Core 仓储注册器，并添加仓储。 new EfCoreRepositoryRegistrar(options).AddRepositories(); return services; } } 2.2 仓储的注入与实现 关于仓储的注入，其实在之前的文章就有讲过，这里我就大概说一下情况。\n在上述代码当中，调用了 AddAbpDbContext\u0026lt;TDbContext\u0026gt;() 方法之后，就会通过 Repository Registrar 进行仓储注入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public virtual void AddRepositories() { // 遍历用户添加的自定义仓储。 foreach (var customRepository in Options.CustomRepositories) { // 调用 AddDefaultRepository() 方法注入仓储。 Options.Services.AddDefaultRepository(customRepository.Key, customRepository.Value); } // 判断是否需要注册实体的默认仓储。 if (Options.RegisterDefaultRepositories) { RegisterDefaultRepositories(); } } 可以看到，在注入仓储的时候，分为两种情况。第一种是用户的自定义仓储，这种仓储是通过 AddRepository() 方法添加的，添加之后将会把它的 实体类型 与 仓储类型 放在一个字典内部。在仓储注册器进行初始化的时候，就会遍历这个字典，进行注入动作。\n第二种情况则是用户在设置了 RegisterDefaultRepositories=true 的情况下，ABP vNext 就会从数据库上下文的类型定义上遍历所有实体类型，然后进行默认仓储注册。\n具体的仓储注册实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public static IServiceCollection AddDefaultRepository(this IServiceCollection services, Type entityType, Type repositoryImplementationType) { // 注册 IReadOnlyBasicRepository\u0026lt;TEntity\u0026gt;。 var readOnlyBasicRepositoryInterface = typeof(IReadOnlyBasicRepository\u0026lt;\u0026gt;).MakeGenericType(entityType); // 如果具体实现类型继承了该接口，则进行注入。 if (readOnlyBasicRepositoryInterface.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(readOnlyBasicRepositoryInterface, repositoryImplementationType); // 注册 IReadOnlyRepository\u0026lt;TEntity\u0026gt;。 var readOnlyRepositoryInterface = typeof(IReadOnlyRepository\u0026lt;\u0026gt;).MakeGenericType(entityType); if (readOnlyRepositoryInterface.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(readOnlyRepositoryInterface, repositoryImplementationType); } // 注册 IBasicRepository\u0026lt;TEntity\u0026gt;。 var basicRepositoryInterface = typeof(IBasicRepository\u0026lt;\u0026gt;).MakeGenericType(entityType); if (basicRepositoryInterface.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(basicRepositoryInterface, repositoryImplementationType); // 注册 IRepository\u0026lt;TEntity\u0026gt;。 var repositoryInterface = typeof(IRepository\u0026lt;\u0026gt;).MakeGenericType(entityType); if (repositoryInterface.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(repositoryInterface, repositoryImplementationType); } } } // 获得实体的主键类型，如果不存在则忽略。 var primaryKeyType = EntityHelper.FindPrimaryKeyType(entityType); if (primaryKeyType != null) { // 注册 IReadOnlyBasicRepository\u0026lt;TEntity, TKey\u0026gt;。 var readOnlyBasicRepositoryInterfaceWithPk = typeof(IReadOnlyBasicRepository\u0026lt;,\u0026gt;).MakeGenericType(entityType, primaryKeyType); if (readOnlyBasicRepositoryInterfaceWithPk.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(readOnlyBasicRepositoryInterfaceWithPk, repositoryImplementationType); // 注册 IReadOnlyRepository\u0026lt;TEntity, TKey\u0026gt;。 var readOnlyRepositoryInterfaceWithPk = typeof(IReadOnlyRepository\u0026lt;,\u0026gt;).MakeGenericType(entityType, primaryKeyType); if (readOnlyRepositoryInterfaceWithPk.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(readOnlyRepositoryInterfaceWithPk, repositoryImplementationType); } // 注册 IBasicRepository\u0026lt;TEntity, TKey\u0026gt;。 var basicRepositoryInterfaceWithPk = typeof(IBasicRepository\u0026lt;,\u0026gt;).MakeGenericType(entityType, primaryKeyType); if (basicRepositoryInterfaceWithPk.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(basicRepositoryInterfaceWithPk, repositoryImplementationType); // 注册 IRepository\u0026lt;TEntity, TKey\u0026gt;。 var repositoryInterfaceWithPk = typeof(IRepository\u0026lt;,\u0026gt;).MakeGenericType(entityType, primaryKeyType); if (repositoryInterfaceWithPk.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(repositoryInterfaceWithPk, repositoryImplementationType); } } } } return services; } 回到仓储自动注册的地方，可以看到实现类型是由 GetDefaultRepositoryImplementationType() 方法提供的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 protected virtual void RegisterDefaultRepository(Type entityType) { Options.Services.AddDefaultRepository( entityType, GetDefaultRepositoryImplementationType(entityType) ); } protected virtual Type GetDefaultRepositoryImplementationType(Type entityType) { var primaryKeyType = EntityHelper.FindPrimaryKeyType(entityType); if (primaryKeyType == null) { return Options.SpecifiedDefaultRepositoryTypes ? Options.DefaultRepositoryImplementationTypeWithoutKey.MakeGenericType(entityType) : GetRepositoryType(Options.DefaultRepositoryDbContextType, entityType); } return Options.SpecifiedDefaultRepositoryTypes ? Options.DefaultRepositoryImplementationType.MakeGenericType(entityType, primaryKeyType) : GetRepositoryType(Options.DefaultRepositoryDbContextType, entityType, primaryKeyType); } protected abstract Type GetRepositoryType(Type dbContextType, Type entityType); protected abstract Type GetRepositoryType(Type dbContextType, Type entityType, Type primaryKeyType); 这里的两个 GetRepositoryType() 都是抽象方法，具体的实现分别在 EfCoreRepositoryRegistrar、MemoryDbRepositoryRegistrar、MongoDbRepositoryRegistrar 的内部，这里我们只讲 EF Core 相关的。\n1 2 3 4 protected override Type GetRepositoryType(Type dbContextType, Type entityType) { return typeof(EfCoreRepository\u0026lt;,\u0026gt;).MakeGenericType(dbContextType, entityType); } 可以看到，在方法内部是构造了一个 EfCoreRepository 类型作为默认仓储的实现。\n2.3 数据库上下文提供者 在 Ef Core 仓储的内部，需要操作数据库时，必须要获得一个数据库上下文。在仓储内部的数据库上下文都是由 IDbContextProvider\u0026lt;TDbContext\u0026gt; 提供了，这个东西在 EF Core 模块初始化的时候就已经被注册，它的默认实现是 UnitOfWorkDbContextProvider\u0026lt;TDbContext\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class EfCoreRepository\u0026lt;TDbContext, TEntity\u0026gt; : RepositoryBase\u0026lt;TEntity\u0026gt;, IEfCoreRepository\u0026lt;TEntity\u0026gt; where TDbContext : IEfCoreDbContext where TEntity : class, IEntity { public virtual DbSet\u0026lt;TEntity\u0026gt; DbSet =\u0026gt; DbContext.Set\u0026lt;TEntity\u0026gt;(); DbContext IEfCoreRepository\u0026lt;TEntity\u0026gt;.DbContext =\u0026gt; DbContext.As\u0026lt;DbContext\u0026gt;(); protected virtual TDbContext DbContext =\u0026gt; _dbContextProvider.GetDbContext(); // ... private readonly IDbContextProvider\u0026lt;TDbContext\u0026gt; _dbContextProvider; // ... public EfCoreRepository(IDbContextProvider\u0026lt;TDbContext\u0026gt; dbContextProvider) { _dbContextProvider = dbContextProvider; // ... } // ... } 首先来看一下这个实现类的基本定义，比较简单，注入了两个接口，分别用于获取工作单元和构造 DbContext。需要注意的是，这里通过 where 约束来指定 TDbContext 必须实现 IEfCoreDbContext 接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class UnitOfWorkDbContextProvider\u0026lt;TDbContext\u0026gt; : IDbContextProvider\u0026lt;TDbContext\u0026gt; where TDbContext : IEfCoreDbContext { private readonly IUnitOfWorkManager _unitOfWorkManager; private readonly IConnectionStringResolver _connectionStringResolver; public UnitOfWorkDbContextProvider( IUnitOfWorkManager unitOfWorkManager, IConnectionStringResolver connectionStringResolver) { _unitOfWorkManager = unitOfWorkManager; _connectionStringResolver = connectionStringResolver; } // ... } 接着想下看，接口只定义了一个方法，就是 GetDbContext()，在这个默认实现里面，首先会从缓存里面获取数据库上下文，如果没有获取到，则创建一个新的数据库上下文。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public TDbContext GetDbContext() { // 获得当前的可用工作单元。 var unitOfWork = _unitOfWorkManager.Current; if (unitOfWork == null) { throw new AbpException(\u0026#34;A DbContext can only be created inside a unit of work!\u0026#34;); } // 获得数据库连接上下文的连接字符串名称。 var connectionStringName = ConnectionStringNameAttribute.GetConnStringName\u0026lt;TDbContext\u0026gt;(); // 根据名称解析具体的连接字符串。 var connectionString = _connectionStringResolver.Resolve(connectionStringName); // 构造数据库上下文缓存 Key。 var dbContextKey = $\u0026#34;{typeof(TDbContext).FullName}_{connectionString}\u0026#34;; // 从工作单元的缓存当中获取数据库上下文，不存在则调用 CreateDbContext() 创建。 var databaseApi = unitOfWork.GetOrAddDatabaseApi( dbContextKey, () =\u0026gt; new EfCoreDatabaseApi\u0026lt;TDbContext\u0026gt;( CreateDbContext(unitOfWork, connectionStringName, connectionString) )); return ((EfCoreDatabaseApi\u0026lt;TDbContext\u0026gt;)databaseApi).DbContext; } 回到最开始的数据库上下文配置工厂，在它的内部会优先从一个 Current 获取一个 DbContextCreationContext 实例。而在这里，就是 Current 被赋值的地方，只要调用了 Use() 方法，在释放之前都会获取到同一个实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private TDbContext CreateDbContext(IUnitOfWork unitOfWork, string connectionStringName, string connectionString) { var creationContext = new DbContextCreationContext(connectionStringName, connectionString); using (DbContextCreationContext.Use(creationContext)) { // 这里是重点，真正创建数据库上下文的地方。 var dbContext = CreateDbContext(unitOfWork); if (unitOfWork.Options.Timeout.HasValue \u0026amp;\u0026amp; dbContext.Database.IsRelational() \u0026amp;\u0026amp; !dbContext.Database.GetCommandTimeout().HasValue) { dbContext.Database.SetCommandTimeout(unitOfWork.Options.Timeout.Value.TotalSeconds.To\u0026lt;int\u0026gt;()); } return dbContext; } } // 如果是事务型的工作单元，则调用 CreateDbContextWithTransaction() 进行创建，但不论如何都是通过工作单元提供的 IServiceProvider 解析出来 DbContext 的。 private TDbContext CreateDbContext(IUnitOfWork unitOfWork) { return unitOfWork.Options.IsTransactional ? CreateDbContextWithTransaction(unitOfWork) : unitOfWork.ServiceProvider.GetRequiredService\u0026lt;TDbContext\u0026gt;(); } 以下代码才是在真正地创建 DbContext 实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public TDbContext CreateDbContextWithTransaction(IUnitOfWork unitOfWork) { var transactionApiKey = $\u0026#34;EntityFrameworkCore_{DbContextCreationContext.Current.ConnectionString}\u0026#34;; var activeTransaction = unitOfWork.FindTransactionApi(transactionApiKey) as EfCoreTransactionApi; // 没有取得缓存。 if (activeTransaction == null) { var dbContext = unitOfWork.ServiceProvider.GetRequiredService\u0026lt;TDbContext\u0026gt;(); // 判断是否指定了事务隔离级别，并开始事务。 var dbtransaction = unitOfWork.Options.IsolationLevel.HasValue ? dbContext.Database.BeginTransaction(unitOfWork.Options.IsolationLevel.Value) : dbContext.Database.BeginTransaction(); // 跟工作单元绑定添加一个已经激活的事务。 unitOfWork.AddTransactionApi( transactionApiKey, new EfCoreTransactionApi( dbtransaction, dbContext ) ); // 返回构造好的数据库上下文。 return dbContext; } else { DbContextCreationContext.Current.ExistingConnection = activeTransaction.DbContextTransaction.GetDbTransaction().Connection; var dbContext = unitOfWork.ServiceProvider.GetRequiredService\u0026lt;TDbContext\u0026gt;(); if (dbContext.As\u0026lt;DbContext\u0026gt;().HasRelationalTransactionManager()) { dbContext.Database.UseTransaction(activeTransaction.DbContextTransaction.GetDbTransaction()); } else { dbContext.Database.BeginTransaction(); //TODO: Why not using the new created transaction? } activeTransaction.AttendedDbContexts.Add(dbContext); return dbContext; } } 2.4 数据过滤器 ABP vNext 还提供了数据过滤器机制，可以让你根据指定的标识过滤数据，例如租户 Id 和软删除标记。它的基本接口定义在 Volo.Abp.Data 项目的 IDataFilter.cs 文件中，提供了启用、禁用、检测方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public interface IDataFilter\u0026lt;TFilter\u0026gt; where TFilter : class { IDisposable Enable(); IDisposable Disable(); bool IsEnabled { get; } } public interface IDataFilter { IDisposable Enable\u0026lt;TFilter\u0026gt;() where TFilter : class; IDisposable Disable\u0026lt;TFilter\u0026gt;() where TFilter : class; bool IsEnabled\u0026lt;TFilter\u0026gt;() where TFilter : class; } 默认实现也在该项目下面的 DataFilter.cs 文件，首先看以下 IDataFilter 的默认实现 DataFilter，内部有一个解析器和并发字典。这个并发字典存储了所有的过滤器，其键是真实过滤器的类型(ISoftDelete 或 IMultiTenant)，值是 DataFilter\u0026lt;TFilter\u0026gt;，具体对象根据 TFilter 的不同而不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class DataFilter : IDataFilter, ISingletonDependency { private readonly ConcurrentDictionary\u0026lt;Type, object\u0026gt; _filters; private readonly IServiceProvider _serviceProvider; public DataFilter(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; _filters = new ConcurrentDictionary\u0026lt;Type, object\u0026gt;(); } // ... } 看一下其他的方法，都是对 IDataFilter\u0026lt;Filter\u0026gt; 的包装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class DataFilter : IDataFilter, ISingletonDependency { // ... public IDisposable Enable\u0026lt;TFilter\u0026gt;() where TFilter : class { return GetFilter\u0026lt;TFilter\u0026gt;().Enable(); } public IDisposable Disable\u0026lt;TFilter\u0026gt;() where TFilter : class { return GetFilter\u0026lt;TFilter\u0026gt;().Disable(); } public bool IsEnabled\u0026lt;TFilter\u0026gt;() where TFilter : class { return GetFilter\u0026lt;TFilter\u0026gt;().IsEnabled; } private IDataFilter\u0026lt;TFilter\u0026gt; GetFilter\u0026lt;TFilter\u0026gt;() where TFilter : class { // 并发字典当中获取指定类型的过滤器，如果不存在则从 IoC 中解析。 return _filters.GetOrAdd( typeof(TFilter), () =\u0026gt; _serviceProvider.GetRequiredService\u0026lt;IDataFilter\u0026lt;TFilter\u0026gt;\u0026gt;() ) as IDataFilter\u0026lt;TFilter\u0026gt;; } } 这么看来，IDataFilter 叫做 IDataFilterManager 更加合适一点，最开始我还没搞明白两个接口和实现的区别，真正搞事情的是 DataFilter\u0026lt;Filter\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class DataFilter\u0026lt;TFilter\u0026gt; : IDataFilter\u0026lt;TFilter\u0026gt; where TFilter : class { public bool IsEnabled { get { EnsureInitialized(); return _filter.Value.IsEnabled; } } // 注入数据过滤器配置类。 private readonly AbpDataFilterOptions _options; // 用于存储过滤器的启用状态。 private readonly AsyncLocal\u0026lt;DataFilterState\u0026gt; _filter; public DataFilter(IOptions\u0026lt;AbpDataFilterOptions\u0026gt; options) { _options = options.Value; _filter = new AsyncLocal\u0026lt;DataFilterState\u0026gt;(); } // ... // 确保初始化成功。 private void EnsureInitialized() { if (_filter.Value != null) { return; } // 如果过滤器的默认状态为 NULL，优先从配置类中取得指定过滤器的默认启用状态，如果不存在则默认为启用。 _filter.Value = _options.DefaultStates.GetOrDefault(typeof(TFilter))?.Clone() ?? new DataFilterState(true); } } 数据过滤器在设计的时候，也是按照工作单元的形式进行设计的。不论是启用还是停用都是范围性的，会返回一个用 DisposeAction 包装的可释放对象，这样在离开 using 语句块的时候，就会还原为来的状态。比如调用 Enable() 方法，在离开 using 语句块之后，会调用 Disable() 禁用掉数据过滤器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public IDisposable Enable() { if (IsEnabled) { return NullDisposable.Instance; } _filter.Value.IsEnabled = true; return new DisposeAction(() =\u0026gt; Disable()); } public IDisposable Disable() { if (!IsEnabled) { return NullDisposable.Instance; } _filter.Value.IsEnabled = false; return new DisposeAction(() =\u0026gt; Enable()); } 2.4.1 MongoDb 与 Memory 的集成 可以看到有两处使用，分别是 Volo.Abp.Domain 项目与 Volo.Abp.EntityFrameworkCore 项目。\n首先看第一个项目的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public abstract class RepositoryBase\u0026lt;TEntity\u0026gt; : BasicRepositoryBase\u0026lt;TEntity\u0026gt;, IRepository\u0026lt;TEntity\u0026gt; where TEntity : class, IEntity { public IDataFilter DataFilter { get; set; } // ... // 分别在查询的时候判断实体是否实现了两个接口。 protected virtual TQueryable ApplyDataFilters\u0026lt;TQueryable\u0026gt;(TQueryable query) where TQueryable : IQueryable\u0026lt;TEntity\u0026gt; { // 如果实现了软删除接口，则从 DataFilter 中获取过滤器的开启状态。 // 如果已经开启，则过滤掉被删除的数据。 if (typeof(ISoftDelete).IsAssignableFrom(typeof(TEntity))) { query = (TQueryable)query.WhereIf(DataFilter.IsEnabled\u0026lt;ISoftDelete\u0026gt;(), e =\u0026gt; ((ISoftDelete)e).IsDeleted == false); } // 如果实现了多租户接口，则从 DataFilter 中获取过滤器的开启状态。 // 如果已经开启，则按照租户 Id 过滤数据。 if (typeof(IMultiTenant).IsAssignableFrom(typeof(TEntity))) { var tenantId = CurrentTenant.Id; query = (TQueryable)query.WhereIf(DataFilter.IsEnabled\u0026lt;IMultiTenant\u0026gt;(), e =\u0026gt; ((IMultiTenant)e).TenantId == tenantId); } return query; } // ... } 逻辑比较简单，都是判断实体是否实现某个接口，并且结合启用状态来进行过滤，在原有 IQuerable 拼接 WhereIf() 即可。但是 EF Core 使用这种方式不行，所以上述方法只会在 Memory 和 MongoDb 有使用。\n2.4.2 EF Core 的集成 EF Core 集成数据过滤器则是放在数据库上下文基类 AbpDbContext\u0026lt;TDbContext\u0026gt; 中，在数据库上下文的 OnModelCreating() 方法内通过 ConfigureBasePropertiesMethodInfo 进行反射调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 public abstract class AbpDbContext\u0026lt;TDbContext\u0026gt; : DbContext, IEfCoreDbContext, ITransientDependency where TDbContext : DbContext { // ... protected virtual bool IsMultiTenantFilterEnabled =\u0026gt; DataFilter?.IsEnabled\u0026lt;IMultiTenant\u0026gt;() ?? false; protected virtual bool IsSoftDeleteFilterEnabled =\u0026gt; DataFilter?.IsEnabled\u0026lt;ISoftDelete\u0026gt;() ?? false; // ... public IDataFilter DataFilter { get; set; } // ... private static readonly MethodInfo ConfigureBasePropertiesMethodInfo = typeof(AbpDbContext\u0026lt;TDbContext\u0026gt;) .GetMethod( nameof(ConfigureBaseProperties), BindingFlags.Instance | BindingFlags.NonPublic ); // ... protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); foreach (var entityType in modelBuilder.Model.GetEntityTypes()) { ConfigureBasePropertiesMethodInfo .MakeGenericMethod(entityType.ClrType) .Invoke(this, new object[] { modelBuilder, entityType }); // ... } } // ... protected virtual void ConfigureBaseProperties\u0026lt;TEntity\u0026gt;(ModelBuilder modelBuilder, IMutableEntityType mutableEntityType) where TEntity : class { if (mutableEntityType.IsOwned()) { return; } ConfigureConcurrencyStampProperty\u0026lt;TEntity\u0026gt;(modelBuilder, mutableEntityType); ConfigureExtraProperties\u0026lt;TEntity\u0026gt;(modelBuilder, mutableEntityType); ConfigureAuditProperties\u0026lt;TEntity\u0026gt;(modelBuilder, mutableEntityType); ConfigureTenantIdProperty\u0026lt;TEntity\u0026gt;(modelBuilder, mutableEntityType); // 在这里，配置全局过滤器。 ConfigureGlobalFilters\u0026lt;TEntity\u0026gt;(modelBuilder, mutableEntityType); } // ... protected virtual void ConfigureGlobalFilters\u0026lt;TEntity\u0026gt;(ModelBuilder modelBuilder, IMutableEntityType mutableEntityType) where TEntity : class { // 符合条件则为其创建过滤表达式。 if (mutableEntityType.BaseType == null \u0026amp;\u0026amp; ShouldFilterEntity\u0026lt;TEntity\u0026gt;(mutableEntityType)) { // 创建过滤表达式。 var filterExpression = CreateFilterExpression\u0026lt;TEntity\u0026gt;(); if (filterExpression != null) { // 为指定的实体配置查询过滤器。 modelBuilder.Entity\u0026lt;TEntity\u0026gt;().HasQueryFilter(filterExpression); } } } // ... // 判断实体是否拥有过滤器。 protected virtual bool ShouldFilterEntity\u0026lt;TEntity\u0026gt;(IMutableEntityType entityType) where TEntity : class { if (typeof(IMultiTenant).IsAssignableFrom(typeof(TEntity))) { return true; } if (typeof(ISoftDelete).IsAssignableFrom(typeof(TEntity))) { return true; } return false; } // 构建表达式。 protected virtual Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; CreateFilterExpression\u0026lt;TEntity\u0026gt;() where TEntity : class { Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; expression = null; if (typeof(ISoftDelete).IsAssignableFrom(typeof(TEntity))) { expression = e =\u0026gt; !IsSoftDeleteFilterEnabled || !EF.Property\u0026lt;bool\u0026gt;(e, \u0026#34;IsDeleted\u0026#34;); } if (typeof(IMultiTenant).IsAssignableFrom(typeof(TEntity))) { Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; multiTenantFilter = e =\u0026gt; !IsMultiTenantFilterEnabled || EF.Property\u0026lt;Guid\u0026gt;(e, \u0026#34;TenantId\u0026#34;) == CurrentTenantId; expression = expression == null ? multiTenantFilter : CombineExpressions(expression, multiTenantFilter); } return expression; } // ... } 2.5 领域事件集成 在讲解事件总线与 DDD 这块的时候，我有提到过 ABP vNext 有实现领域事件功能，用户可以在聚合根内部使用 AddLocalEvent(object eventData) 或 AddDistributedEvent(object eventData) 添加了领域事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public abstract class AggregateRoot : Entity, IAggregateRoot, IGeneratesDomainEvents, IHasExtraProperties, IHasConcurrencyStamp { // ... private readonly ICollection\u0026lt;object\u0026gt; _localEvents = new Collection\u0026lt;object\u0026gt;(); private readonly ICollection\u0026lt;object\u0026gt; _distributedEvents = new Collection\u0026lt;object\u0026gt;(); // ... // 添加本地事件。 protected virtual void AddLocalEvent(object eventData) { _localEvents.Add(eventData); } // 添加分布式事件。 protected virtual void AddDistributedEvent(object eventData) { _distributedEvents.Add(eventData); } // 获得所有本地事件。 public virtual IEnumerable\u0026lt;object\u0026gt; GetLocalEvents() { return _localEvents; } // 获得所有分布式事件。 public virtual IEnumerable\u0026lt;object\u0026gt; GetDistributedEvents() { return _distributedEvents; } // 清空聚合需要触发的所有本地事件。 public virtual void ClearLocalEvents() { _localEvents.Clear(); } // 清空聚合需要触发的所有分布式事件。 public virtual void ClearDistributedEvents() { _distributedEvents.Clear(); } } 可以看到，我们在聚合内部执行任何业务行为的时候，可以通过上述的方法发送领域事件。那这些事件是在什么时候被发布的呢？\n发现这几个 Get 方法有被 AbpDbContext 所调用，其实在它的内部，会在每次 SaveChangesAsync() 的时候，遍历所有实体，并获取它们的本地事件与分布式事件集合，最后由 EntityChangeEventHelper 进行触发。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 public abstract class AbpDbContext\u0026lt;TDbContext\u0026gt; : DbContext, IEfCoreDbContext, ITransientDependency where TDbContext : DbContext { // ... public override async Task\u0026lt;int\u0026gt; SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default) { try { var auditLog = AuditingManager?.Current?.Log; List\u0026lt;EntityChangeInfo\u0026gt; entityChangeList = null; if (auditLog != null) { entityChangeList = EntityHistoryHelper.CreateChangeList(ChangeTracker.Entries().ToList()); } var changeReport = ApplyAbpConcepts(); var result = await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken).ConfigureAwait(false); // 触发领域事件。 await EntityChangeEventHelper.TriggerEventsAsync(changeReport).ConfigureAwait(false); if (auditLog != null) { EntityHistoryHelper.UpdateChangeList(entityChangeList); auditLog.EntityChanges.AddRange(entityChangeList); Logger.LogDebug($\u0026#34;Added {entityChangeList.Count} entity changes to the current audit log\u0026#34;); } return result; } catch (DbUpdateConcurrencyException ex) { throw new AbpDbConcurrencyException(ex.Message, ex); } finally { ChangeTracker.AutoDetectChangesEnabled = true; } } // ... protected virtual EntityChangeReport ApplyAbpConcepts() { var changeReport = new EntityChangeReport(); // 遍历所有的实体变更事件。 foreach (var entry in ChangeTracker.Entries().ToList()) { ApplyAbpConcepts(entry, changeReport); } return changeReport; } protected virtual void ApplyAbpConcepts(EntityEntry entry, EntityChangeReport changeReport) { // 根据不同的实体操作状态，执行不同的操作。 switch (entry.State) { case EntityState.Added: ApplyAbpConceptsForAddedEntity(entry, changeReport); break; case EntityState.Modified: ApplyAbpConceptsForModifiedEntity(entry, changeReport); break; case EntityState.Deleted: ApplyAbpConceptsForDeletedEntity(entry, changeReport); break; } // 添加领域事件。 AddDomainEvents(changeReport, entry.Entity); } // ... protected virtual void AddDomainEvents(EntityChangeReport changeReport, object entityAsObj) { var generatesDomainEventsEntity = entityAsObj as IGeneratesDomainEvents; if (generatesDomainEventsEntity == null) { return; } // 获取到所有的本地事件和分布式事件，将其加入到 EntityChangeReport 对象当中。 var localEvents = generatesDomainEventsEntity.GetLocalEvents()?.ToArray(); if (localEvents != null \u0026amp;\u0026amp; localEvents.Any()) { changeReport.DomainEvents.AddRange(localEvents.Select(eventData =\u0026gt; new DomainEventEntry(entityAsObj, eventData))); generatesDomainEventsEntity.ClearLocalEvents(); } var distributedEvents = generatesDomainEventsEntity.GetDistributedEvents()?.ToArray(); if (distributedEvents != null \u0026amp;\u0026amp; distributedEvents.Any()) { changeReport.DistributedEvents.AddRange(distributedEvents.Select(eventData =\u0026gt; new DomainEventEntry(entityAsObj, eventData))); generatesDomainEventsEntity.ClearDistributedEvents(); } } } 转到 `` 的内部，发现有如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // ... public async Task TriggerEventsAsync(EntityChangeReport changeReport) { // 触发领域事件。 await TriggerEventsInternalAsync(changeReport).ConfigureAwait(false); if (changeReport.IsEmpty() || UnitOfWorkManager.Current == null) { return; } await UnitOfWorkManager.Current.SaveChangesAsync().ConfigureAwait(false); } protected virtual async Task TriggerEventsInternalAsync(EntityChangeReport changeReport) { // 触发默认的实体变更事件，例如某个实体被创建、修改、删除。 await TriggerEntityChangeEvents(changeReport.ChangedEntities).ConfigureAwait(false); // 触发用户自己发送的领域事件。 await TriggerLocalEvents(changeReport.DomainEvents).ConfigureAwait(false); await TriggerDistributedEvents(changeReport.DistributedEvents).ConfigureAwait(false); } // ... protected virtual async Task TriggerLocalEvents(List\u0026lt;DomainEventEntry\u0026gt; localEvents) { foreach (var localEvent in localEvents) { await LocalEventBus.PublishAsync(localEvent.EventData.GetType(), localEvent.EventData).ConfigureAwait(false); } } protected virtual async Task TriggerDistributedEvents(List\u0026lt;DomainEventEntry\u0026gt; distributedEvents) { foreach (var distributedEvent in distributedEvents) { await DistributedEventBus.PublishAsync(distributedEvent.EventData.GetType(), distributedEvent.EventData).ConfigureAwait(false); } } 三、系列文章目录 点击我 跳转到文章总目录。\n","date":"2020-01-08T03:09:08Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis-integration-of-entityframework-core/","title":"Abp vNext 源码分析 - 14. EntityFramework Core 的集成"},{"content":"问题 在开发微信支付的小微商户进件接口时，需要通过表单来上传身份证图片等数据。在微信支付接口文档也说明了，需要使用 multipart/form-data 的方式发送请求。.NET 提供了 MultipartFormDataContent 类型，帮助我们构建表单请求，故有以下代码：\n1 2 3 4 5 var form = new MultipartFormDataContent() { {new StringContent(\u0026#34;Value\u0026#34;),\u0026#34;Name}, {new ByteArrayContent(new byte[]{}/*模拟文件数据*/),\u0026#34;File,\u0026#34;FileName} } 按照微信支付官方文档提交之后，一直提示参数错误，百思不得其解。\n原因 通过 Postman 模拟表单提交，捕获数据包，将其与 C# 的提交代码进行对比，发现了两处问题。\nPostman 的原始提交：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 POST http://api.mch.weixin.qq.com/secapi/mch/uploadmedia HTTP/1.1 User-Agent: PostmanRuntime/7.21.0 Accept: */* Cache-Control: no-cache Postman-Token: b6800c0f-3f16-4981-b661-e6d16fc1bb1e Host: api.mch.weixin.qq.com Content-Type: multipart/form-data; boundary=--------------------------639275760242036520206377 Accept-Encoding: gzip, deflate Content-Length: 566 Connection: keep-alive ----------------------------639275760242036520206377 Content-Disposition: form-data; name=\u0026#34;mch_id\u0026#34; 1565111111 ----------------------------639275760242036520206377 Content-Disposition: form-data; name=\u0026#34;media_hash\u0026#34; 7215E92A8F3F3D0256484EFFF53A25F6 ----------------------------639275760242036520206377 Content-Disposition: form-data; name=\u0026#34;sign_type\u0026#34; HMAC-SHA256 ----------------------------639275760242036520206377 Content-Disposition: form-data; name=\u0026#34;sign\u0026#34; A1D8B094FA24BE5531D1AC198DE25550 ----------------------------639275760242036520206377-- C# 代码的提交：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 POST http://api.mch.weixin.qq.com/secapi/mch/uploadmedia HTTP/1.1 Host: api.mch.weixin.qq.com Content-Type: multipart/form-data; boundary=\u0026#34;e9d5712f-7923-4ec5-8bf3-c8d5d3cd3217\u0026#34; Content-Length: 502 --e9d5712f-7923-4ec5-8bf3-c8d5d3cd3217 Content-Type: text/plain; charset=utf-8 Content-Disposition: form-data; name=mch_id --e9d5712f-7923-4ec5-8bf3-c8d5d3cd3217 Content-Type: text/plain; charset=utf-8 Content-Disposition: form-data; name=media_hash 33F15BC2D17D6FFBC18FA566EF65722E --e9d5712f-7923-4ec5-8bf3-c8d5d3cd3217 Content-Type: text/plain; charset=utf-8 Content-Disposition: form-data; name=sign 1E377684F9BD583D2ED26FB367916C0C --e9d5712f-7923-4ec5-8bf3-c8d5d3cd3217-- 1. Boundary 的双引号\n使用 MultipartFormDataContent 提交的表单请求，外部 Content-Type 的 boundary 值带有 \u0026quot; 号。而 Postman 提交的表单请求，它的 boudary 值是没有双引号的。\n那为什么会造成这样的差异呢？参考 这篇 博客的讲解，是由于各个系统/语言针对 RFC 2046 的实现不一致导致的。针对于 MultipartFormDataContent 的行为，如果 Boundary 后面的值带有双引号是符合标准的。\nRFC 2612 原文：\nAlthough RFC 2046 [40] permits the boundary string to be quoted, some existing implementations handle a quoted boundary string incorrectly. Boundary 的作用，是一个随机生成的字符串，在 HTTP 协议当中用于分割内部多个 Content。为什么是随机生成的呢？就是防止这个分割符跟你内部的 Content 产生重复造成意外。(C# 默认使用的是 Guid 作为随机串，你也可以在构造 MultipartFormDataContent 的时候，通过其构造函数手动指定)\n2. 表单内键值对，值的双引号\n第二个问题则是表单内的内容，他们的 name 键值对，其值又没有双引号，所以你得在添加 Content 的时候，得手动指定双引号。\n解决 两个问题都是由于双引号导致的，所以只需要在真正发起调用之前将内部的双引号替换为空，或者将缺失的双引号添加上即可。\n针对问题一，其内部的 ContentType.Parameters ，通过 LINQ 找到 boundary 的键值对，替换内部的双引号即可。\n1 2 var boundaryValue = form.Headers.ContentType.Parameters.Single(p =\u0026gt; p.Name == \u0026#34;boundary\u0026#34;); boundaryValue.Value = boundaryValue.Value.Replace(\u0026#34;\\\u0026#34;\u0026#34;, String.Empty); 针对问题二，在构造内部 Content 的时候，其 Name 手动赋予双引号。\n1 2 3 4 5 6 7 var form = new MultipartFormDataContent { {new StringContent(mchId), \u0026#34;\\\u0026#34;mch_id\\\u0026#34;\u0026#34;}, {new ByteArrayContent(bytes), \u0026#34;media\u0026#34;, $\u0026#34;\\\u0026#34;{HttpUtility.UrlEncode(Path.GetFileName(imagePath))}\\\u0026#34;\u0026#34;}, {new StringContent(mediaHash), \u0026#34;\\\u0026#34;media_hash\\\u0026#34;\u0026#34;}, {new StringContent(sign), \u0026#34;sign\u0026#34;} }; ","date":"2019-12-29T03:37:33Z","permalink":"https://real-zony.github.io/p/problems-encountered-when-using-httpclient-for-form-submission/","title":"使用 HttpClient 进行表单提交时，遇到的问题"},{"content":"一、简要介绍 ABP vNext 封装了两种事件总线结构，第一种是 ABP vNext 自己实现的本地事件总线，这种事件总线无法跨项目发布和订阅。第二种则是分布式事件总线，ABP vNext 自己封装了一个抽象层进行定义，并使用 RabbitMQ 编写了一个基本实现。\n在使用方式上，两种事件总线的作用基本相同。\n事件总线分布在两个模块，在 Volo.Abp.EventBus 模块内部，定义了事件总线的抽象接口，以及本地事件总线 (ILocalEventBus) 的实现。分布式事件总线的具体实现，是在 Volo.Abp.EventBus.RabbitMQ 模块内部进行定义，从项目名称可以看出来，这个模块是基于 RabbitMQ 消息队列实现的。\n但是该项目并不是直接引用 RabbitMQ.Client 包，而是在 Volo.Abp.RabbitMQ 项目内部引用。这是因为除了分布式事件总线以外，ABP 还基于 RabbitMQ 实现了一个后台作业管理器。\nABP vNext 框架便将一些对象抽象出来，放在 Volo.Abp.RabbitMQ 项目内部进行定义和实现。\n二、源码分析 2.1 事件处理器的注册 分析源码，首先从一个项目的模块开始，Volo.Abp.EventBus 库的模块 AbpEventBusModule 只干了一件事情。在组件注册的时候，根据组件的实现接口 (ILocalEventHandler 或 IDistributedEventHandler) 不同，将其赋值给 AbpLocalEventBusOptions 与 AbpDistributedEventBusOptions 的 Handlers 属性。\n也就是说，开发人员定义的事件处理程序 (Handler) 都会在依赖注入的时候，都会将其类型 (Type) 添加到事件总线的配置类当中，方便后续进行使用。\n2.2 事件总线的接口 通过事件总线模块的单元测试我们可以知道，事件的发布与订阅都是通过 IEventBus 的两个子接口 (ILocalEventBus/IDistributedEventBus) 进行的。在 IEventBus 接口的定义中，有三种行为，分别是 发布、订阅、取消订阅。\n对于 ILocalEventBus 接口和 IDistributedEventBus 接口来说，它们都提供了一个，针对本地事件处理器和分布式处理器的特殊订阅方法。\nILocalEventBus：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /// \u0026lt;summary\u0026gt; /// Defines interface of the event bus. /// \u0026lt;/summary\u0026gt; public interface ILocalEventBus : IEventBus { /// \u0026lt;summary\u0026gt; /// Registers to an event. /// Same (given) instance of the handler is used for all event occurrences. /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TEvent\u0026#34;\u0026gt;Event type\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;handler\u0026#34;\u0026gt;Object to handle the event\u0026lt;/param\u0026gt; IDisposable Subscribe\u0026lt;TEvent\u0026gt;(ILocalEventHandler\u0026lt;TEvent\u0026gt; handler) where TEvent : class; } IDistributedEventBus：\n1 2 3 4 5 6 7 8 9 10 11 public interface IDistributedEventBus : IEventBus { /// \u0026lt;summary\u0026gt; /// Registers to an event. /// Same (given) instance of the handler is used for all event occurrences. /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TEvent\u0026#34;\u0026gt;Event type\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;handler\u0026#34;\u0026gt;Object to handle the event\u0026lt;/param\u0026gt; IDisposable Subscribe\u0026lt;TEvent\u0026gt;(IDistributedEventHandler\u0026lt;TEvent\u0026gt; handler) where TEvent : class; } 2.3 事件总线基本流程和实现 同其他模块一样，因为有分布式事件总线和本地事件总线，ABP vNext 同样抽象了一个 EventBusBase 类型，作为它们的基类实现。\n一般的流程，我们是先定义某个事件，然后订阅该事件并指定事件处理器，最后在某个时刻发布事件。例如下面的代码：\n首先定义了一个事件处理器，专门用于处理 EntityChangedEventData\u0026lt;MyEntity\u0026gt; 事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class MyEventHandler : ILocalEventHandler\u0026lt;EntityChangedEventData\u0026lt;MyEntity\u0026gt;\u0026gt; { public int EntityChangedEventCount { get; set; } public Task HandleEventAsync(EntityChangedEventData\u0026lt;MyEntity\u0026gt; eventData) { EntityChangedEventCount++; return Task.CompletedTask; } } var handler = new MyEventHandler(); LocalEventBus.Subscribe\u0026lt;EntityChangedEventData\u0026lt;MyEntity\u0026gt;\u0026gt;(handler); await LocalEventBus.PublishAsync(new EntityCreatedEventData\u0026lt;MyEntity\u0026gt;(new MyEntity())); 2.3.1 事件的订阅 可以看到，这里使用的是 ILocalEventBus 定义的订阅方法，跳转到内部实现，它还是调用的 EventBus 的方法。\n1 2 3 4 5 6 7 8 9 public virtual IDisposable Subscribe\u0026lt;TEvent\u0026gt;(ILocalEventHandler\u0026lt;TEvent\u0026gt; handler) where TEvent : class { // 调用基类的 Subscribe 方法，并传递 TEvent 的类型，和事件处理器。 return Subscribe(typeof(TEvent), handler); } public virtual IDisposable Subscribe(Type eventType, IEventHandler handler) { return Subscribe(eventType, new SingleInstanceHandlerFactory(handler)); } 可以看到，这里传递了一个 SingleInstanceHandlerFactory 对象，这玩意儿是干嘛用的呢？从名字可以看出来，这是一个工厂，是用来创建 Handler (事件处理器) 的工厂，并且是一个单实例的事件处理器工厂。\n下面就是 IEventHandlerFactory 接口的定义，以及 SingleInstanceHandlerFactory 实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface IEventHandlerFactory { // 获得一个事件处理器包装对象，即事件处理器执行完毕之后，可以调用 // IEventHandlerDisposeWrapper.Dispose() 进行释放。 IEventHandlerDisposeWrapper GetHandler(); // 判断在已有的事件处理器工厂集合中，是否已经存在了相同的事件处理器。 bool IsInFactories(List\u0026lt;IEventHandlerFactory\u0026gt; handlerFactories); } public class SingleInstanceHandlerFactory : IEventHandlerFactory { // 构造工厂时，传递的事件处理器实例。 public IEventHandler HandlerInstance { get; } public SingleInstanceHandlerFactory(IEventHandler handler) { HandlerInstance = handler; } // 通过 EventHandlerDisposeWrapper 包装事件处理器实例。 public IEventHandlerDisposeWrapper GetHandler() { return new EventHandlerDisposeWrapper(HandlerInstance); } // 判断针对 HandlerInstance 的事件处理器是否已经存在。 public bool IsInFactories(List\u0026lt;IEventHandlerFactory\u0026gt; handlerFactories) { return handlerFactories .OfType\u0026lt;SingleInstanceHandlerFactory\u0026gt;() .Any(f =\u0026gt; f.HandlerInstance == HandlerInstance); } } 针对 IEventHandlerFactory 工厂，还拥有 3 个不同的实现，下表分别说明它们的应用场景。\n实现类型 作用 IocEventHandlerFactory 每个工厂对应一个事件处理器的的类型，并通过 ScopeFactory 解析具体的事件处理器。生命周期由 scope 控制，当 scope 释放时，对应的事件处理器实例也会被销毁。 SingleInstanceHandlerFactory 每个工厂对应单独的一个事件处理器实例，事件处理器实例是由创建者控制的。 TransientEventHandlerFactory 每个工厂对应一个事件处理器的类型，区别是它不由 IoC 解析实例，而是使用的 Activator.CreateInstance() 方法构造实例，是一个瞬时对象，调用包装器的 Dispose 即会进行释放。 TransientEventHandlerFactory\u0026lt;THandler\u0026gt; 每个工厂对应指定的 THandler 事件处理器，生命周期同上面的工厂一样。 这几种工厂都是在订阅操作时，不同的订阅重载使用不同的工厂，或者是自己指定事件处理器的工厂均可。\n1 2 3 4 5 6 7 8 9 10 11 public virtual IDisposable Subscribe\u0026lt;TEvent, THandler\u0026gt;() where TEvent : class where THandler : IEventHandler, new() { return Subscribe(typeof(TEvent), new TransientEventHandlerFactory\u0026lt;THandler\u0026gt;()); } public virtual IDisposable Subscribe(Type eventType, IEventHandler handler) { return Subscribe(eventType, new SingleInstanceHandlerFactory(handler)); } 不过有一种特殊的行为，开发人员可以 不用显式订阅。在 EventBus 类型中，定义了一个 SubscribeHandlers(ITypeList\u0026lt;IEventHandler\u0026gt; handlers) 方法。该方法接收一个类型集合，通过遍历集合，从事件处理器的定义当中，取得事件处理器监听的事件类型 TEvent。\n在取得了事件类型，并知晓了事件处理器类型以后，事件总线就可以订阅 TEvent 类型的事件，并使用 IocEventHandlerFactory 工厂来构造事件处理器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 protected virtual void SubscribeHandlers(ITypeList\u0026lt;IEventHandler\u0026gt; handlers) { // 遍历事件处理器的类型，其实这里的就是模块启动时，传递给 XXXOptions 的集合。 foreach (var handler in handlers) { // 获得事件处理器的所有接口定义，并遍历接口进行检查。 var interfaces = handler.GetInterfaces(); foreach (var @interface in interfaces) { // 如果接口没有实现 IEventHandler 类型，则忽略。 if (!typeof(IEventHandler).GetTypeInfo().IsAssignableFrom(@interface)) { continue; } // 从泛型参数当中，获得定义的事件类型。 var genericArgs = @interface.GetGenericArguments(); // 泛型参数完全匹配 1 时，才进行订阅操作。 if (genericArgs.Length == 1) { Subscribe(genericArgs[0], new IocEventHandlerFactory(ServiceScopeFactory, handler)); } } } } 这个订阅方法在 EventBus 当中是一个抽象方法，分别在本地事件总线和分布式事件总线有实现，这里我们首先讲解本地事件的逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class LocalEventBus : EventBusBase, ILocalEventBus, ISingletonDependency { protected ConcurrentDictionary\u0026lt;Type, List\u0026lt;IEventHandlerFactory\u0026gt;\u0026gt; HandlerFactories { get; } public LocalEventBus( IOptions\u0026lt;AbpLocalEventBusOptions\u0026gt; options, IServiceScopeFactory serviceScopeFactory) : base(serviceScopeFactory) { Options = options.Value; Logger = NullLogger\u0026lt;LocalEventBus\u0026gt;.Instance; HandlerFactories = new ConcurrentDictionary\u0026lt;Type, List\u0026lt;IEventHandlerFactory\u0026gt;\u0026gt;(); // 调用父类的方法，将模块初始化时扫描到的事件处理器，都尝试进行订阅。 SubscribeHandlers(Options.Handlers); } public override IDisposable Subscribe(Type eventType, IEventHandlerFactory factory) { GetOrCreateHandlerFactories(eventType) // 锁住集合，以确保线程安全。 .Locking(factories =\u0026gt; { // 如果在集合内部，已经有了对应的工厂，则不进行添加。 if (!factory.IsInFactories(factories)) { factories.Add(factory); } } ); // 返回一个事件处理器工厂注销器，当调用 Dispose() 方法时，会取消之前订阅的事件。 return new EventHandlerFactoryUnregistrar(this, eventType, factory); } private List\u0026lt;IEventHandlerFactory\u0026gt; GetOrCreateHandlerFactories(Type eventType) { // 根据事件的类型，从字典中获得该类型的所有事件处理器工厂。 return HandlerFactories.GetOrAdd(eventType, (type) =\u0026gt; new List\u0026lt;IEventHandlerFactory\u0026gt;()); } } 上述流程结合 EventBus 和 LocalEventBus 讲解了事件的订阅流程，事件的订阅操作都是对 HandlerFactories 的操作，往里面添加指定事件的事件处理器工厂，而每个工厂都是跟具体的事件处理器实例/类型进行关联的。\n2.3.2 事件的发布 当开发人员需要发布事件的时候，一般都是通过对应的 EventBus，调用响应的 PublishAsync 方法，传递要触发的事件类型与事件数据。接口和基类当中，定义了两种发布方法的签名与实现：\n1 2 3 4 5 6 public virtual Task PublishAsync\u0026lt;TEvent\u0026gt;(TEvent eventData) where TEvent : class { return PublishAsync(typeof(TEvent), eventData); } public abstract Task PublishAsync(Type eventType, object eventData); 第二种方法一共也分为本地事件总线的实现，和分布式事件总线的实现，本地事件比较简单，我们先分析本地事件总线的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public override async Task PublishAsync(Type eventType, object eventData) { // 定义了一个异常集合，用于接收多个事件处理器执行时，产生的所有异常。 var exceptions = new List\u0026lt;Exception\u0026gt;(); // 触发事件处理器。 await TriggerHandlersAsync(eventType, eventData, exceptions); // 如果有任何异常产生，则抛出到之前的调用栈。 if (exceptions.Any()) { if (exceptions.Count == 1) { exceptions[0].ReThrow(); } throw new AggregateException(\u0026#34;More than one error has occurred while triggering the event: \u0026#34; + eventType, exceptions); } } 可以看到真正的触发行为是在 TriggerHandlersAsync(Type eventType, object eventData, List\u0026lt;Exception\u0026gt; exceptions) 内部进行实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 protected virtual async Task TriggerHandlersAsync(Type eventType, object eventData, List\u0026lt;Exception\u0026gt; exceptions) { // 针对于这个的作用，等同于 ConfigureAwait(false) 。 // 具体可以参考 https://blogs.msdn.microsoft.com/benwilli/2017/02/09/an-alternative-to-configureawaitfalse-everywhere/。 await new SynchronizationContextRemover(); // 根据事件的类型，得到它的所有事件处理器工厂。 foreach (var handlerFactories in GetHandlerFactories(eventType)) { // 遍历所有的事件处理器工厂，通过 Factory 获得事件处理器，调用 Handler 的 HandleEventAsync 方法。 foreach (var handlerFactory in handlerFactories.EventHandlerFactories) { await TriggerHandlerAsync(handlerFactory, handlerFactories.EventType, eventData, exceptions); } } // 如果类型继承了 IEventDataWithInheritableGenericArgument 接口，那么会检测泛型参数是否有父类。 // 如果有父类，则会使用当前的事件数据，为其父类发布一个事件。 if (eventType.GetTypeInfo().IsGenericType \u0026amp;\u0026amp; eventType.GetGenericArguments().Length == 1 \u0026amp;\u0026amp; typeof(IEventDataWithInheritableGenericArgument).IsAssignableFrom(eventType)) { var genericArg = eventType.GetGenericArguments()[0]; var baseArg = genericArg.GetTypeInfo().BaseType; if (baseArg != null) { // 构造基类的事件类型，使用当前一样的泛型定义，只是泛型参数使用基类。 var baseEventType = eventType.GetGenericTypeDefinition().MakeGenericType(baseArg); // 构建类型的构造参数。 var constructorArgs = ((IEventDataWithInheritableGenericArgument)eventData).GetConstructorArgs(); // 通过事件类型和构造参数，构造一个新的事件数据实例。 var baseEventData = Activator.CreateInstance(baseEventType, constructorArgs); // 发布父类的同类事件。 await PublishAsync(baseEventType, baseEventData); } } } 在上述代码内部，都还没有真正执行事件处理器，真正的事件处理器执行程序是在下面的方法进行执行的。ABP vNext 通过引入 IEventDataWithInheritableGenericArgument 接口，实现了 类型继承事件 的触发，该接口提供了一个 GetConstructorArgs() 方法定义，方便后面生成构造参数。\n例如有一个基础事件叫做 EntityEventData\u0026lt;Student\u0026gt;，如果 Student 继承自 Person，那么在触发该事件的时候，也会发布一个 EntityEventData\u0026lt;Person\u0026gt; 事件。\n2.3.3 事件处理器的执行 真正事件处理器的执行，是通过下面的方法实现的，大概思路就是通过事件总线工厂，构建了事件处理器的实例。通过反射，调用事件处理器的 HandleEventAsync() 方法。如果在处理过程当中，出现了异常，则将异常数据放置在 List\u0026lt;Exception\u0026gt; 集合当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 protected virtual async Task TriggerHandlerAsync(IEventHandlerFactory asyncHandlerFactory, Type eventType, object eventData, List\u0026lt;Exception\u0026gt; exceptions) { using (var eventHandlerWrapper = asyncHandlerFactory.GetHandler()) { try { // 获得事件处理器的类型。 var handlerType = eventHandlerWrapper.EventHandler.GetType(); // 判断事件处理器是本地事件还是分布式事件。 if (ReflectionHelper.IsAssignableToGenericType(handlerType, typeof(ILocalEventHandler\u0026lt;\u0026gt;))) { // 获得方法定义。 var method = typeof(ILocalEventHandler\u0026lt;\u0026gt;) .MakeGenericType(eventType) .GetMethod( nameof(ILocalEventHandler\u0026lt;object\u0026gt;.HandleEventAsync), new[] { eventType } ); // 使用工厂创建的实例调用方法。 await (Task)method.Invoke(eventHandlerWrapper.EventHandler, new[] { eventData }); } else if (ReflectionHelper.IsAssignableToGenericType(handlerType, typeof(IDistributedEventHandler\u0026lt;\u0026gt;))) { var method = typeof(IDistributedEventHandler\u0026lt;\u0026gt;) .MakeGenericType(eventType) .GetMethod( nameof(IDistributedEventHandler\u0026lt;object\u0026gt;.HandleEventAsync), new[] { eventType } ); await (Task)method.Invoke(eventHandlerWrapper.EventHandler, new[] { eventData }); } else { // 如果都不是，则说明类型不正确，抛出异常。 throw new AbpException(\u0026#34;The object instance is not an event handler. Object type: \u0026#34; + handlerType.AssemblyQualifiedName); } } // 捕获到异常都统一添加到异常集合当中。 catch (TargetInvocationException ex) { exceptions.Add(ex.InnerException); } catch (Exception ex) { exceptions.Add(ex); } } } 2.4 分布式事件总线 分布式事件总线的实现都存放在 Volo.Abp.EventBus.RabbitMQ，该项目的代码比较少，由三个文件构成。\n在 RabbitMQ 模块的内部，只干了两件事情。首先从 JSON 配置文件当中，获取 AbpRabbitMqEventBusOptions 配置的三个参数，然后解析 RabbitMqDistributedEventBus 实例，并调用初始化方法 (Initialize())。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [DependsOn( typeof(AbpEventBusModule), typeof(AbpRabbitMqModule))] public class AbpEventBusRabbitMqModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { var configuration = context.Services.GetConfiguration(); // 从配置文件读取配置。 Configure\u0026lt;AbpRabbitMqEventBusOptions\u0026gt;(configuration.GetSection(\u0026#34;RabbitMQ:EventBus\u0026#34;)); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { // 调用初始化方法。 context .ServiceProvider .GetRequiredService\u0026lt;RabbitMqDistributedEventBus\u0026gt;() .Initialize(); } } 2.4.1 分布式事件总线的初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public void Initialize() { // 创建一个消费者，并配置交换器和队列。 Consumer = MessageConsumerFactory.Create( new ExchangeDeclareConfiguration( AbpRabbitMqEventBusOptions.ExchangeName, type: \u0026#34;direct\u0026#34;, durable: true ), new QueueDeclareConfiguration( AbpRabbitMqEventBusOptions.ClientName, durable: true, exclusive: false, autoDelete: false ), AbpRabbitMqEventBusOptions.ConnectionName ); // 消费者在消费消息的时候，具体的执行逻辑。 Consumer.OnMessageReceived(ProcessEventAsync); // 调用基类的方法，自动订阅对应的事件。 SubscribeHandlers(AbpDistributedEventBusOptions.Handlers); } 2.4.2 分布式事件的订阅 在定义分布式事件的时候，我们必须使用 EventNameAttribute 为事件声明路由键。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public override IDisposable Subscribe(Type eventType, IEventHandlerFactory factory) { var handlerFactories = GetOrCreateHandlerFactories(eventType); if (factory.IsInFactories(handlerFactories)) { return NullDisposable.Instance; } handlerFactories.Add(factory); if (handlerFactories.Count == 1) //TODO: Multi-threading! { // 为消费者绑定一个路由键，在收到对应的事件时，就会触发之前绑定的方法。 Consumer.BindAsync(EventNameAttribute.GetNameOrDefault(eventType)); } return new EventHandlerFactoryUnregistrar(this, eventType, factory); } 订阅的时候，除了 Consumer.BindAsync() 以外，基本流程和本地事件总线基本一致。\n2.4.3 分布式事件的发布 分布式事件总线一样重写了发布方法，内部首先使用 IRabbitMqSerializer 序列化器 (基于 JSON.NET) 将事件数据进行序列化，然后将消息投递出去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public override Task PublishAsync(Type eventType, object eventData) { var eventName = EventNameAttribute.GetNameOrDefault(eventType); // 序列化事件数据。 var body = Serializer.Serialize(eventData); // 创建一个信道用于通讯。 using (var channel = ConnectionPool.Get(AbpRabbitMqEventBusOptions.ConnectionName).CreateModel()) { channel.ExchangeDeclare( AbpRabbitMqEventBusOptions.ExchangeName, \u0026#34;direct\u0026#34;, durable: true ); // 更改投递模式为持久化模式。 var properties = channel.CreateBasicProperties(); properties.DeliveryMode = RabbitMqConsts.DeliveryModes.Persistent; // 发布一个新的事件。 channel.BasicPublish( exchange: AbpRabbitMqEventBusOptions.ExchangeName, routingKey: eventName, mandatory: true, basicProperties: properties, body: body ); } return Task.CompletedTask; } 2.4.4 分布式事件的执行 执行逻辑都存放在 ProcessEventAsync(IModel channel, BasicDeliverEventArgs ea) 方法内部，基本就是监听到指定的消息，首先反序列化消息，调用父类的 TriggerHandlersAsync 去执行具体的事件处理器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 private async Task ProcessEventAsync(IModel channel, BasicDeliverEventArgs ea) { var eventName = ea.RoutingKey; var eventType = EventTypes.GetOrDefault(eventName); if (eventType == null) { return; } var eventData = Serializer.Deserialize(ea.Body, eventType); await TriggerHandlersAsync(eventType, eventData); } 三、总结 ABP vNext 为我们实现了比较完善的本地事件总线，和基于 RabbitMQ 的分布式事件总线。在平时开发过程中，我们本地事件总线的使用频率应该还是比较高，而分布式事件总线目前仍处于一个半成品，很多高级特性还没实现，例如重试策略等。所以分布式事件总线要使用的话，建议使用较为成熟的 CAP 库替代 ABP vNext 的分布式事件总线。\n","date":"2019-12-10T09:54:06Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---13-local-event-bus-and-distributed-event-bus-rabbit-mq/","title":"Abp vNext 源码分析 - 13. 本地事件总线与分布式事件总线 (Rabbit MQ)"},{"content":"最近做项目的时候，需要对接厂商提供的 IP 摄像头。但是他们只提供了 C++ 的 SDK，没办法，只能开始撸 C# 的 SDK Helper 类。本篇文章主要记录了对接 C++ DLL 需要注意的几个地方，以及常见类型的转换。\n要对接 C++ 的 DLL，首先得知道如何引用 DLL 内的方法。在 C# 当中，只需要编写符合 C++ 的函数签名，再使用 [DllImport] 特性指定 DLL 文件路径和入口点等参数即可。\n假如你需要使用 Win32 API 提供的方法，这里我以 SetProcessDPIAware 函数为例：\n1 2 3 4 5 public static class Win32Helper { [DllImport(\u0026#34;user32.dll\u0026#34;)] public static extern bool SetProcessDPIAware(); } 接下来你只需要像使用静态方法一样，调用 Win32Helper.SetProcessDPIAware() 方法即可。\n对接 DLL 时的问题记录 一般来说，提供 SDK 的厂商都会给你一份 DEMO 项目，或者是包含有函数定义的头文件 (*.h)。你只需要按照转换规则，将头文件里面的函数签名翻译成 C# 版本的即可。\n函数签名不正确 有的时候，你名字直接和头文件一样还不行，得手动指定 EntryPoint 参数。你可以使用 DLL Export Viewer 工具来查看 DLL 的所有开放函数签名，将其复制下来，填写到 EntryPoint 参数即可。\n1 2 [DllImport(@\u0026#34;ThirdFiles\\AlprSDK.dll\u0026#34;, EntryPoint = \u0026#34;AlprSDK_Startup@12\u0026#34;, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Winapi)] public static extern int AlprSDK_Startup(IntPtr hNotifyWnd, uint nCommandId, string pLocalAddress); 传递回调函数 有时第三方 SDK 需要你传递回调函数，一般都只提供了一个 void* 定义，也就是一个函数指针。那我们在 C# 如何将委托传递给该参数作为回调函数呢？\n1 ALPRSDK_API OS_Error WINAPI AlprSDK_SearchAllCameras(unsigned int nTimeout,void* callback, char *pLocalAddr = NULL); 这个时候就需要使用到 [UnmanagedFunctionPointer] 特性来指定函数指针了，只需要将其标注到委托定义上，指定函数的调用方式即可。\n最后我在 C# 里面编写的方法签名如下：\n1 2 3 4 5 6 7 8 [UnmanagedFunctionPointer(CallingConvention.Winapi, CharSet = CharSet.Ansi)] public delegate void SearchAllCamerasCallback(uint deviceType, string deviceName, string deviceIp, byte[] macAddress, ushort wPortWeb, ushort wPortListen, string pSubMask, string pGateway, string pMultiAddress, string pDnsAddress, ushort wMultiPort, int nChannelNum, int nFindCount, uint dwDeviceId); [DllImport(@\u0026#34;ThirdFiles\\AlprSDK.dll\u0026#34;, EntryPoint = \u0026#34;_AlprSDK_SearchAllCameras@12\u0026#34;, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Winapi)] public static extern int AlprSDK_SearchAllCameras(uint nTimeout, SearchAllCamerasCallback callback, string pLocalAddress); 获取摄像头传递的位图 原始 C++ 的函数签名如下：\n1 2 3 4 5 //////////////////////////////////////////////////////////////////////////////////////////// //捕获一张bmp图片. //pBmpBuf:存放数据的缓冲区，传入参数时应该为NULL，内存由SDK自行管理.外面的应用程序不用去释放内存 //len: 数据的长度 ALPRSDK_API OS_Error WINAPI AlprSDK_CaptureBmp(int nHandleID, void **pBmpBuf, int *len); 主要的难点在于参数 void** pbmp 的翻译，这里参数 xx 就是指针的指针。因为这个位图是 SDK 来生成的，所以它会在内存空间开辟一段区域用于位图的存储。所以 void* 指向的是这个位图的起始地址，而我传递 void** 就是让 SDK 将这个起始地址传递给我。\n所以 void* 可以翻译为 IntPtr，而这个地址不是我赋值的，而是 SDK 给我的地址，所以我们需要加上按引用传递关键字 ref 。\n如此，我们便获得了位图在内存空间的起始地址，而且方法也将这个位图的大小给了我们。我们只需要从起始地址读取 N 个字节的数据，将其转储到 byte[] 即可。有了 byte[] 对象，你就可以进行其他的操作了，例如加载，保存等。\n在 C# 内部，我是这样定义方法签名，并进行使用的：\n1 2 [DllImport(@\u0026#34;ThirdFiles\\AlprSDK.dll\u0026#34;, EntryPoint = \u0026#34;_AlprSDK_CaptureBmp@12\u0026#34;, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Winapi)] public static extern uint AlprSDK_CaptureBmp(int nHandleId, ref IntPtr pBmpBuf, ref int len); 读取位图数据，并将其存储到磁盘当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var bitmapPtr = IntPtr.Zero; var length = 0; var result = AlprSdk.AlprSDK_CaptureBmp(0, ref bitmapPtr, ref length); ThrowIfResultNotZero(\u0026#34;无法从摄像头获取位图\u0026#34;,result); var bytes = new byte[length]; Marshal.Copy(bitmapPtr, bytes, 0, length); using (var ms = File.Create(@\u0026#34;D:\\bitmap.bmp\u0026#34;)) { using (var writer = new StreamWriter(ms)) { writer.Write(bytes); } } 附录 1：常用数据类型对照表 C/C++ C# 备注 WORD ushort DWORD uint UCHAR int 或 byte UCHAR* string 或 IntPtr unsigned char* [MarshalAs(UnmanagedType.LPArray)]byte[] char* string LPCTSTR string LPTSTR [MarshalAs(UnmanagedType.LPTStr)] string long int ulong uint HANDLE IntPtr HWND IntPtr void* IntPtr int int int* ref int *int IntPtr unsigned int uint COLORREF uint CHAR char HDC int HGDIOBJ int BOOL bool LPSTR string LPCSTR string BYTE byte 参考文章：C# 与 C++ 数据类型对照\n附录 2：相关工具软件下载 DLL Export Viewer v1.66：https://www.cnblogs.com\n","date":"2019-11-27T11:27:00Z","permalink":"https://real-zony.github.io/p/notes-on-csharp-and-pinvoke-docking-ip-camera/","title":"C# 结合 PInvoke 对接 IP 摄像头的笔记"},{"content":"问题 在使用自定义 Ef Core 仓储和 ABP vNext 注入的默认仓储时，通过两个 Repository 进行 Join 操作，提示 Cannot use multiple DbContext instances within a single query execution. Ensure the query uses a single context instance. 。这个异常信息翻译成中文的大概意思就是，你不能使用两个 DbContext 里面的 DbSet 进行 Join 查询。\n如果将自定义仓储改为 IRepository\u0026lt;TEntity,TKey\u0026gt; 进行注入，是可以与 _courseRepostory 进行关联查询的。\n我在 XXXEntityFrameworkCoreModule 的配置，以及自定义仓储 EfCoreStudentRepository 代码如下。\nXXXEntityFrameworkCoreModule 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 public class XXXEntityFrameworkCoreModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddAbpDbContext\u0026lt;XXXDbContext\u0026gt;(op =\u0026gt; { op.AddDefaultRepositories(); }); Configure\u0026lt;AbpDbContextOptions\u0026gt;(op =\u0026gt; op.UsePostgreSql()); } } EfCoreStudentRepository 代码：\n1 2 3 4 5 6 7 8 9 10 11 public class EfCoreStudentRepository : EfCoreRepository\u0026lt;IXXXDbContext, Student, long\u0026gt;, IStudentRepository { public EfCoreStudentRepository(IDbContextProvider\u0026lt;IXXXDbContext\u0026gt; dbContextProvider) : base(dbContextProvider) { } public Task\u0026lt;int\u0026gt; GetCountWithStudentlIdAsync(long studentId) { return DbSet.CountAsync(x=\u0026gt;x.studentId == studentId); } } 原因 原因在异常信息已经说得十分清楚了，这里我们需要了解两个问题。\n什么原因导致两个仓储内部的 DbContext 不一致？ 为什么 ABP vNext 自己实现的仓储能够进行关联查询呢？ 首先我们得知道，仓储内部的 DbContext 是怎么获取的。我们的自定义仓储都会继承 EfCoreRepository ，而这个仓储是实现了 IQuerable\u0026lt;T\u0026gt; 接口的，最终它会通过一个 IDbContextProvider\u0026lt;TDbContext\u0026gt; 获得一个可用的 DbContext 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class EfCoreRepository\u0026lt;TDbContext, TEntity\u0026gt; : RepositoryBase\u0026lt;TEntity\u0026gt;, IEfCoreRepository\u0026lt;TEntity\u0026gt; where TDbContext : IEfCoreDbContext where TEntity : class, IEntity { public virtual DbSet\u0026lt;TEntity\u0026gt; DbSet =\u0026gt; DbContext.Set\u0026lt;TEntity\u0026gt;(); DbContext IEfCoreRepository\u0026lt;TEntity\u0026gt;.DbContext =\u0026gt; DbContext.As\u0026lt;DbContext\u0026gt;(); // 这里可以看到，是通过 IDbContextProvider 来获得 DbContext 的。 protected virtual TDbContext DbContext =\u0026gt; _dbContextProvider.GetDbContext(); protected virtual AbpEntityOptions\u0026lt;TEntity\u0026gt; AbpEntityOptions =\u0026gt; _entityOptionsLazy.Value; private readonly IDbContextProvider\u0026lt;TDbContext\u0026gt; _dbContextProvider; private readonly Lazy\u0026lt;AbpEntityOptions\u0026lt;TEntity\u0026gt;\u0026gt; _entityOptionsLazy; // ... 其他代码。 } 下面就是 IDbContextProvider\u0026lt;TDbContext\u0026gt; 内部的核心代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class UnitOfWorkDbContextProvider\u0026lt;TDbContext\u0026gt; : IDbContextProvider\u0026lt;TDbContext\u0026gt; where TDbContext : IEfCoreDbContext { private readonly IUnitOfWorkManager _unitOfWorkManager; private readonly IConnectionStringResolver _connectionStringResolver; // ... 其他代码。 public TDbContext GetDbContext() { var unitOfWork = _unitOfWorkManager.Current; if (unitOfWork == null) { throw new AbpException(\u0026#34;A DbContext can only be created inside a unit of work!\u0026#34;); } var connectionStringName = ConnectionStringNameAttribute.GetConnStringName\u0026lt;TDbContext\u0026gt;(); var connectionString = _connectionStringResolver.Resolve(connectionStringName); // 会构造一个 Key，而这个 Key 刚好是泛型类型的 FullName。 var dbContextKey = $\u0026#34;{typeof(TDbContext).FullName}_{connectionString}\u0026#34;; // 内部是从一个字典当中，根据 dbContextKey 获取 DbContext。如果不存在的话则调用工厂方法创建一个新的 DbContext。 var databaseApi = unitOfWork.GetOrAddDatabaseApi( dbContextKey, () =\u0026gt; new EfCoreDatabaseApi\u0026lt;TDbContext\u0026gt;( CreateDbContext(unitOfWork, connectionStringName, connectionString) )); return ((EfCoreDatabaseApi\u0026lt;TDbContext\u0026gt;)databaseApi).DbContext; } // ... 其他代码。 } 通过以上代码我们就可以知道，ABP vNext 在仓储的内部是通过 IDbContextProvider\u0026lt;TDbContext\u0026gt; 中的 TDbContext 泛型，来确定是否构建一个新的 DbContext 对象。\n不论是 ABP vNext 针对 IRepository\u0026lt;TEntity,TKey\u0026gt; ，还是我们自己实现的自定义仓储，它们最终的实现都是基于 EfCoreRepository\u0026lt;TDbContext,TEntity,TKey\u0026gt; 的。而我们 IDbContextProvider\u0026lt;TDbContext\u0026gt; 的泛型，也是这个仓储基类提供的，后者的 TDbContext 就是前者的泛型参数。\n所以当我们在模块添加 DbContext 的过城中，只要调用了 AddDefaultRepositories() 方法，ABP vNext 就会遍历你提供的 TDbContext 所定义的实体，然后为这些实体建立默认的仓储。\n在注入仓储的时候，找到了获得默认仓储实现类型的方法，可以看到这里它使用的是 DefaultRepositoryDbContextType 作为默认的 TDbContext 类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected virtual Type GetDefaultRepositoryImplementationType(Type entityType) { var primaryKeyType = EntityHelper.FindPrimaryKeyType(entityType); // 重点在于构造仓储类型时，传递的 Options.DefaultRepositoryDbContextType 参数，这个参数就是后面 EfCoreRepository 的 TDbContext 泛型。 if (primaryKeyType == null) { return Options.SpecifiedDefaultRepositoryTypes ? Options.DefaultRepositoryImplementationTypeWithoutKey.MakeGenericType(entityType) : GetRepositoryType(Options.DefaultRepositoryDbContextType, entityType); } return Options.SpecifiedDefaultRepositoryTypes ? Options.DefaultRepositoryImplementationType.MakeGenericType(entityType, primaryKeyType) : GetRepositoryType(Options.DefaultRepositoryDbContextType, entityType, primaryKeyType); } 最后我发现这个就是在模块调用 AddAbpContext\u0026lt;TDbContext\u0026gt; 所提供的泛型参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public abstract class AbpCommonDbContextRegistrationOptions : IAbpCommonDbContextRegistrationOptionsBuilder { // ... 其他代码 protected AbpCommonDbContextRegistrationOptions(Type originalDbContextType, IServiceCollection services) { OriginalDbContextType = originalDbContextType; Services = services; DefaultRepositoryDbContextType = originalDbContextType; CustomRepositories = new Dictionary\u0026lt;Type, Type\u0026gt;(); ReplacedDbContextTypes = new List\u0026lt;Type\u0026gt;(); } // ... 其他代码 } public class AbpDbContextRegistrationOptions : AbpCommonDbContextRegistrationOptions, IAbpDbContextRegistrationOptionsBuilder { public Dictionary\u0026lt;Type, object\u0026gt; AbpEntityOptions { get; } public AbpDbContextRegistrationOptions(Type originalDbContextType, IServiceCollection services) : base(originalDbContextType, services) // 之类调用的就是上面的构造方法。 { AbpEntityOptions = new Dictionary\u0026lt;Type, object\u0026gt;(); } } public static class AbpEfCoreServiceCollectionExtensions { public static IServiceCollection AddAbpDbContext\u0026lt;TDbContext\u0026gt;( this IServiceCollection services, Action\u0026lt;IAbpDbContextRegistrationOptionsBuilder\u0026gt; optionsBuilder = null) where TDbContext : AbpDbContext\u0026lt;TDbContext\u0026gt; { // ... 其他代码。 var options = new AbpDbContextRegistrationOptions(typeof(TDbContext), services); // ... 其他代码。 return services; } } 所以，我们的默认仓储的 dbContextKey 是 XXXDbContext，我们的自定义仓储继承 EfCoreRepository\u0026lt;IXXXDbContext,TEntity,TKey\u0026gt; ，所以它的 dbContextKey 就是 IXXXDbContext 。所以自定义仓储获取到的 DbContext 就与自定义仓储的不一致了，从而提示上述异常。\n解决 找到自定自定义仓储的定义，修改它 EfCoreReposiotry\u0026lt;TDbContext,TEntity,TKey\u0026gt; 的 TDbContext 泛型参数，变更为 XXXDbContext 即可。\n1 2 3 4 5 6 7 8 9 10 11 public class EfCoreStudentRepository : EfCoreRepository\u0026lt;XXXDbContext, Student, long\u0026gt;, IStudentRepository { public EfCoreStudentRepository(IDbContextProvider\u0026lt;XXXDbContext\u0026gt; dbContextProvider) : base(dbContextProvider) { } public Task\u0026lt;int\u0026gt; GetCountWithStudentlIdAsync(long studentId) { return DbSet.CountAsync(x=\u0026gt;x.studentId == studentId); } } ","date":"2019-11-14T15:14:00Z","permalink":"https://real-zony.github.io/p/abp-vnext-custom-ef-core-repository-throws-exception/","title":"Abp vNext 自定义 Ef Core 仓储引发异常"},{"content":"一、简要说明 文章信息：\n基于的 ABP vNext 版本：1.0.0\n创作日期：2019 年 10 月 24 日晚\n更新日期：暂无\nABP vNext 提供了后台工作者和后台作业的支持，基本实现与原来的 ABP 框架类似，并且 ABP vNext 还提供了对 HangFire 和 RabbitMQ 的后台作业集成。开发人员在使用这些第三方库的时候，基本就是开箱即用，不需要做其他复杂的配置。\n后台作业在系统开发的过程当中，是比较常用的功能。因为总是有一些长耗时的任务，而这些任务我们不是立即响应的，例如 Excel 文档导入、批量发送短信通知等。\n后台工作者 的话，ABP vNext 的实现就是在 CLR 的 Timer 之上封装了一层，周期性地执行用户逻辑。ABP vNext 默认提供的 后台任务管理器，就是在后台工作者基础之上进行的封装。\n涉及到后台任务、后台工作者的模块一共有 6 个，它们分别是：\nVolo.Abp.Threading ：提供了一些常用的线程组件，其中 AbpTimer 就是在里面实现的。 Volo.Abp.BackgroundWorkers ：后台工作者的定义和实现。 Volo.Abp.BackgroundJobs.Abstractions ：后台任务的一些共有定义。 Volo.Abp.BackgroundJobs ：默认的后台任务管理器实现。 Volo.Abp.BackgroundJobs.HangFire ：基于 Hangfire 库实现的后台任务管理器。 Volo.Abp.BackgroundJobs.RabbitMQ ： 基于 RabbitMQ 实现的后台任务管理器。 二、源码分析 2.1 线程组件 2.1.1 健壮的计时器 CLR 为我们提供了多种计时器，我们一般使用的是 System.Threading.Timer ，它是基于 CLR 线程池的一个周期计时器，会根据我们配置的 Period (周期) 定时执行。在 CLR 线程池中，所有的 Timer 只有 1 个线程为其服务。这个线程直到下一个计时器的触发时间，当下一个 Timer 对象到期时，这个线程就会将 Timer 的回调方法通过 ThreadPool.QueueUserWorkItem() 扔到线程池去执行。\n不过这带来了一个问题，即你的回调方法执行时间超过了计时器的周期，那么就会造成上一个任务还没执行完成又开始执行新的任务。\n解决这个方法其实很简单，即启动之后，将周期设置为 Timeout.Infinite ，这样只会执行一次。当回调方法执行完成之后，就设置 dueTime 参数说明下次执行要等待多久，并且周期还是 Timeout.Infinite。\nABP vNext 已经为我们提供了健壮的计时器，该类型的定义是 AbpTimer ，在内部用到了 volatile 关键字和 Monitor 实现 条件变量模式 解决多线程环境下的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 public class AbpTimer : ITransientDependency { // 回调事件。 public event EventHandler Elapsed; // 执行周期。 public int Period { get; set; } // 定时器启动之后就开始运行，默认为 Fasle。 public bool RunOnStart { get; set; } // 日志记录器。 public ILogger\u0026lt;AbpTimer\u0026gt; Logger { get; set; } private readonly Timer _taskTimer; // 定时器是否在执行任务，默认为 false。 private volatile bool _performingTasks; // 定时器的运行状态，默认为 false。 private volatile bool _isRunning; public AbpTimer() { Logger = NullLogger\u0026lt;AbpTimer\u0026gt;.Instance; // 回调函数是 TimerCallBack，执行周期为永不执行。 _taskTimer = new Timer(TimerCallBack, null, Timeout.Infinite, Timeout.Infinite); } public void Start(CancellationToken cancellationToken = default) { // 如果传递的周期小于等于 0 ，则抛出异常。 if (Period \u0026lt;= 0) { throw new AbpException(\u0026#34;Period should be set before starting the timer!\u0026#34;); } // 使用互斥锁，保证线程安全。 lock (_taskTimer) { // 如果启动之后就需要马上执行，则设置为 0，马上执行任务，否则会等待 Period 毫秒之后再执行（1 个周期）。 _taskTimer.Change(RunOnStart ? 0 : Period, Timeout.Infinite); // 定时器成功运行了。 _isRunning = true; } // 释放 _taskTimer 的互斥锁。 } public void Stop(CancellationToken cancellationToken = default) { // 使用互斥锁。 lock (_taskTimer) { // 将内部定时器设置为永不执行的状态。 _taskTimer.Change(Timeout.Infinite, Timeout.Infinite); // 检测当前是否还有正在执行的任务，如果有则等待任务执行完成。 while (_performingTasks) { // 临时释放锁，阻塞当前线程。但是其他线程可以获取 _timer 的互斥锁。 Monitor.Wait(_taskTimer); } // 需要表示停止状态，所以标记状态为 false。 _isRunning = false; } } private void TimerCallBack(object state) { lock (_taskTimer) { // 如果有任务正在运行，或者内部定时器已经停止了，则不做任何事情。 if (!_isRunning || _performingTasks) { return; } // 临时停止内部定时器。 _taskTimer.Change(Timeout.Infinite, Timeout.Infinite); // 表明马上需要执行任务了。 _performingTasks = true; } try { // 调用绑定的事件。 Elapsed.InvokeSafely(this, new EventArgs()); } catch { // 注意，这里将会吞噬异常。 } finally { lock (_taskTimer) { // 任务执行完成，更改状态。 _performingTasks = false; // 如果定时器还在运行，没有被停止，则启动下一个 Period 周期。 if (_isRunning) { _taskTimer.Change(Period, Timeout.Infinite); } // 解除因为释放锁而阻塞的线程。 // 如果已经调用了 Stop，则会唤醒那个因为 Wait 阻塞的线程，就会使 _isRunning 置为 false。 Monitor.Pulse(_taskTimer); } } } } 这里对 _performingTasks 和 _isRunning 字段设置为 volatile 防止指令重排和寄存器缓存。这是因为在 Stop 方法内部使用到的 _performingTasks 可能会被优化，所以将该字段设置为了易失的。\n2.2.1 IRunnable 接口 ABP vNext 为任务的启动和停止，抽象了一个 IRunnable 接口。虽然描述说的是对线程的行为进行抽象，但千万千万不要手动调用 Thread.Abort() 。关于 Thread.Abort() 的坏处，这里不再多加赘述，可以参考 这篇文章 的描述，或者搜索其他的相关文章。\n1 2 3 4 5 6 7 8 9 10 public interface IRunnable { // 启动这个服务。 Task StartAsync(CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// 停止这个服务。 /// \u0026lt;/summary\u0026gt; Task StopAsync(CancellationToken cancellationToken = default); } 2.2 后台工作者 2.2.1 模块的构造 后台工作者的模块行为比较简单，它定义了在应用程序初始化和销毁时的行为。在初始化时，后台工作者管理器 获得所有 后台工作者，并开始启动它们。在销毁时，后台工作者管理器获得所有后台工作者，并开始停止他们，这样才能够做到优雅退出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 [DependsOn( typeof(AbpThreadingModule) )] public class AbpBackgroundWorkersModule : AbpModule { public override void OnApplicationInitialization(ApplicationInitializationContext context) { var options = context.ServiceProvider.GetRequiredService\u0026lt;IOptions\u0026lt;AbpBackgroundWorkerOptions\u0026gt;\u0026gt;().Value; // 如果启用了后台工作者，那么获得后台工作者管理器的实例，并调用 StartAsync 启动所有后台工作者。 if (options.IsEnabled) { AsyncHelper.RunSync( () =\u0026gt; context.ServiceProvider .GetRequiredService\u0026lt;IBackgroundWorkerManager\u0026gt;() .StartAsync() ); } } public override void OnApplicationShutdown(ApplicationShutdownContext context) { var options = context.ServiceProvider.GetRequiredService\u0026lt;IOptions\u0026lt;AbpBackgroundWorkerOptions\u0026gt;\u0026gt;().Value; // 如果启用了后台工作者，那么获得后台工作者管理器的实例，并调用 StopAsync 停止所有后台工作者。 if (options.IsEnabled) { AsyncHelper.RunSync( () =\u0026gt; context.ServiceProvider .GetRequiredService\u0026lt;IBackgroundWorkerManager\u0026gt;() .StopAsync() ); } } } 2.2.1 后台工作者的定义 首先看看 IBackgroundWorker 接口的定义，是空的。不过继承了 ISingletonDependency 接口，说明我们的每个后台工作者都是 单例 的。\n1 2 3 4 5 6 7 /// \u0026lt;summary\u0026gt; /// 在后台运行，执行某些任务的工作程序（线程）的接口定义。 /// \u0026lt;/summary\u0026gt; public interface IBackgroundWorker : IRunnable, ISingletonDependency { } ABP vNext 为我们定义了一个抽象的后台工作者类型 BackgroundWorkerBase，这个基类的设计目的是提供一些常用组件（和 ApplicationService 一样）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class BackgroundWorkerBase : IBackgroundWorker { //TODO: Add UOW, Localization and other useful properties..? //TODO: 是否应该提供工作单元、本地化以及其他常用的属性？ public ILogger\u0026lt;BackgroundWorkerBase\u0026gt; Logger { protected get; set; } protected BackgroundWorkerBase() { Logger = NullLogger\u0026lt;BackgroundWorkerBase\u0026gt;.Instance; } public virtual Task StartAsync(CancellationToken cancellationToken = default) { Logger.LogDebug(\u0026#34;Started background worker: \u0026#34; + ToString()); return Task.CompletedTask; } public virtual Task StopAsync(CancellationToken cancellationToken = default) { Logger.LogDebug(\u0026#34;Stopped background worker: \u0026#34; + ToString()); return Task.CompletedTask; } public override string ToString() { return GetType().FullName; } } ABP vNext 内部只有一个默认的后台工作者实现 PeriodicBackgroundWorkerBase。从名字上来看，意思是就是周期执行的后台工作者，内部就是用的 AbpTimer 来实现，ABP vNext 将其包装起来是为了实现统一的模式(后台工作者)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public abstract class PeriodicBackgroundWorkerBase : BackgroundWorkerBase { protected readonly AbpTimer Timer; // 也就意味着子类必须在其构造函数，指定 timer 的执行周期。 protected PeriodicBackgroundWorkerBase(AbpTimer timer) { Timer = timer; Timer.Elapsed += Timer_Elapsed; } // 启动后台工作者。 public override async Task StartAsync(CancellationToken cancellationToken = default) { await base.StartAsync(cancellationToken); Timer.Start(cancellationToken); } // 停止后台工作者。 public override async Task StopAsync(CancellationToken cancellationToken = default) { Timer.Stop(cancellationToken); await base.StopAsync(cancellationToken); } // Timer 关联的周期事件，之所以不直接挂载 DoWork，是为了捕获异常。 private void Timer_Elapsed(object sender, System.EventArgs e) { try { DoWork(); } catch (Exception ex) { Logger.LogException(ex); } } // 你要周期执行的任务。 protected abstract void DoWork(); } 我们如果要实现自己的后台工作者，只需要继承该类，实现 DoWork() 方法即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestWorker : PeriodicBackgroundWorkerBase { public TestWorker(AbpTimer timer) : base(timer) { // 每五分钟执行一次。 timer.Period = (int)TimeSpan.FromMinutes(5).TotalMilliseconds; } protected override void DoWork() { Console.WriteLine(\u0026#34;后台工作者被执行了。\u0026#34;); } } 然后在我们自己模块的 OnPreApplicationInitialization() 方法内解析出后台作业管理器(IBackgroundWorkerManager)，调用它的 Add() 方法，将我们定义的 TestWorker 添加到管理器当中即可。\n2.2.2 后台工作者管理器 所有的后台工作者都是通过 IBackgroundWorkerManager 进行管理的，它提供了 StartAsync()、StopAsync()、Add() 方法。前面两个方法就是 IRunnable 接口定义的，后台工作者管理器直接集成了该接口，后面的 Add() 方法就是用来动态添加我们的后台工作者。\n后台工作者管理器的默认实现是 BackgroundWorkerManager 类型，它内部做的事情很简单，就是维护一个后台工作者集合。每当调用 StartAsync() 或 StopAsync() 方法的时候，都从这个集合遍历后台工作者，执行他们的启动和停止方法。\n这里值得注意的一点是，当我们调用 Add() 方法添加了一个后台工作者之后，后台工作者管理器就会启动这个后台工作者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class BackgroundWorkerManager : IBackgroundWorkerManager, ISingletonDependency, IDisposable { protected bool IsRunning { get; private set; } private bool _isDisposed; private readonly List\u0026lt;IBackgroundWorker\u0026gt; _backgroundWorkers; public BackgroundWorkerManager() { _backgroundWorkers = new List\u0026lt;IBackgroundWorker\u0026gt;(); } public virtual void Add(IBackgroundWorker worker) { _backgroundWorkers.Add(worker); // 如果当前后台工作者管理器还处于运行状态，则调用工作者的 StartAsync() 方法启动。 if (IsRunning) { AsyncHelper.RunSync( () =\u0026gt; worker.StartAsync() ); } } public virtual void Dispose() { if (_isDisposed) { return; } _isDisposed = true; //TODO: ??? } // 启动，则遍历集合启动。 public virtual async Task StartAsync(CancellationToken cancellationToken = default) { IsRunning = true; foreach (var worker in _backgroundWorkers) { await worker.StartAsync(cancellationToken); } } // 停止， 则遍历集合停止。 public virtual async Task StopAsync(CancellationToken cancellationToken = default) { IsRunning = false; foreach (var worker in _backgroundWorkers) { await worker.StopAsync(cancellationToken); } } } 上述代码其实存在一个问题，即后台工作者被释放以后，是否还能执行 Add() 操作。参考我 之前的文章 ，其实当对象被释放之后，就应该抛出 ObjectDisposedException 异常。\n2.3 后台作业 比起后台工作者，我们执行一次性任务的时候，一般会使用后台作业进行处理。比起只能设置固定周期的 PeriodicBackgroundWorkerBase ，集成了 Hangfire 的后台作业管理器，能够让我们使用 Cron 表达式，更加灵活地设置任务的执行周期。\n2.3.1 模块的构造 关于后台作业的模块，我们需要说道两处。第一处是位于 Volo.Abp.BackgroundJobs.Abstractions 项目的 AbpBackgroundJobsAbstractionsModule ，第二出则是位于 Volo.Abp.BackgroundJobs 项目的 AbpBackgroundJobsModule 。\nAbpBackgroundJobsAbstractionsModule 的主要行为是将符合条件的后台作业，添加到 AbpBackgroundJobOptions 配置当中，以便后续进行使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public override void PreConfigureServices(ServiceConfigurationContext context) { RegisterJobs(context.Services); } private static void RegisterJobs(IServiceCollection services) { var jobTypes = new List\u0026lt;Type\u0026gt;(); // 如果注册的类型符合 IBackgroundJob\u0026lt;\u0026gt; 泛型，则添加到集合当中。 services.OnRegistred(context =\u0026gt; { if (ReflectionHelper.IsAssignableToGenericType(context.ImplementationType, typeof(IBackgroundJob\u0026lt;\u0026gt;))) { jobTypes.Add(context.ImplementationType); } }); services.Configure\u0026lt;AbpBackgroundJobOptions\u0026gt;(options =\u0026gt; { // 将数据赋值给配置类。 foreach (var jobType in jobTypes) { options.AddJob(jobType); } }); } Volo.Abp.BackgroundJobs 内部是 ABP vNext 为我们提供的 默认后台作业管理器，这个后台作业管理器 本质上是一个后台工作者。\n这个后台工作者会周期性(取决于 AbpBackgroundJobWorkerOptions.JobPollPeriod 值，默认为 5 秒种)地从 IBackgroundJobStore 捞出一堆后台任务，并且在后台执行。至于每次执行多少个后台任务，这也取决于 AbpBackgroundJobWorkerOptions.MaxJobFetchCount 的值，默认值是 1000 个。\n注意：\n这里的 Options 类是 AbpBackgroundJobWorkerOptions，别和 AbpBackgroundWorkerOptions 混淆了。\n所以在 AbpBackgroundJobsModule 模块里面，只做了一件事情，就是将负责后台作业的后台工作者，添加到后台工作者管理器种，并开始周期性地执行。\n1 2 3 4 5 6 7 8 9 10 11 12 public override void OnApplicationInitialization(ApplicationInitializationContext context) { var options = context.ServiceProvider.GetRequiredService\u0026lt;IOptions\u0026lt;AbpBackgroundJobOptions\u0026gt;\u0026gt;().Value; if (options.IsJobExecutionEnabled) { // 获得后台工作者管理器，并将负责后台作业的工作者添加进去。 context.ServiceProvider .GetRequiredService\u0026lt;IBackgroundWorkerManager\u0026gt;() .Add(context.ServiceProvider.GetRequiredService\u0026lt;IBackgroundJobWorker\u0026gt;() ); } } 2.3.2 后台作业的定义 在上一节里面看到，只要是实现 IBackgroundJob\u0026lt;TArgs\u0026gt; 类型的都视为一个后台作业。这个后台作业接口，只定义了一个行为，那就是执行(Execute(TArgs))。这里的 TArgs 泛型作为执行后台作业时，需要传递的参数类型。\n1 2 3 4 5 // 因为是传入的参数，所以泛型参数是逆变的。 public interface IBackgroundJob\u0026lt;in TArgs\u0026gt; { void Execute(TArgs args); } 检查源码，发现 ABP vNext 的邮箱模块定义了一个邮件发送任务 BackgroundEmailSendingJob，它的实现大概如下。\n1 2 3 4 5 6 7 8 9 public class BackgroundEmailSendingJob : BackgroundJob\u0026lt;BackgroundEmailSendingJobArgs\u0026gt;, ITransientDependency { // ... public override void Execute(BackgroundEmailSendingJobArgs args) { AsyncHelper.RunSync(() =\u0026gt; EmailSender.SendAsync(args.To, args.Subject, args.Body, args.IsBodyHtml)); } } 2.3.3 后台作业管理器 后台作业都是通过一个后台作业管理器(IBackgroundJobManager)进行管理的，这个接口定义了一个入队方法(EnqueueAsync())，注意，我们的后台作业在入队后，不是马上执行的。\n说一下这个入队处理逻辑：\n首先我们会通过参数的类型，获取到任务的名称。(假设任务上面没有标注 BackgroundJobNameAttribute 特性，那么任务的名称就是参数类型的 FullName 。) 构造一个 BackgroundJobInfo 对象。 通过 IBackgroundJobStore 持久化任务信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public virtual async Task\u0026lt;string\u0026gt; EnqueueAsync\u0026lt;TArgs\u0026gt;(TArgs args, BackgroundJobPriority priority = BackgroundJobPriority.Normal, TimeSpan? delay = null) { // 获取任务名称。 var jobName = BackgroundJobNameAttribute.GetName\u0026lt;TArgs\u0026gt;(); var jobId = await EnqueueAsync(jobName, args, priority, delay); return jobId.ToString(); } protected virtual async Task\u0026lt;Guid\u0026gt; EnqueueAsync(string jobName, object args, BackgroundJobPriority priority = BackgroundJobPriority.Normal, TimeSpan? delay = null) { var jobInfo = new BackgroundJobInfo { Id = GuidGenerator.Create(), JobName = jobName, // 通过序列化器，序列化参数值，方便存储。这里内部其实使用的是 JSON.NET 进行序列化。 JobArgs = Serializer.Serialize(args), Priority = priority, CreationTime = Clock.Now, NextTryTime = Clock.Now }; // 如果任务有执行延迟，则任务的初始执行时间要加上这个延迟。 if (delay.HasValue) { jobInfo.NextTryTime = Clock.Now.Add(delay.Value); } // 持久化任务信息，方便后面执行后台作业的工作者能够取到。 await Store.InsertAsync(jobInfo); return jobInfo.Id; } BackgroundJobNameAttribute 相关的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static string GetName\u0026lt;TJobArgs\u0026gt;() { return GetName(typeof(TJobArgs)); } public static string GetName([NotNull] Type jobArgsType) { Check.NotNull(jobArgsType, nameof(jobArgsType)); // 判断参数类型上面是否标注了特性，并且特性实现了 IBackgroundJobNameProvider 接口。 return jobArgsType .GetCustomAttributes(true) .OfType\u0026lt;IBackgroundJobNameProvider\u0026gt;() .FirstOrDefault() ?.Name // 拿不到名字，则使用类型的 FullName。 ?? jobArgsType.FullName; } 2.3.4 后台作业的存储 后台作业的存储默认是放在内存的，这点可以从 InMemoryBackgroundJobStore 类型实现看出来。在它的内部使用了一个并行字典，通过作业的 Guid 与作业进行关联绑定。\n除了内存实现，在 Volo.Abp.BackgroundJobs.Domain 模块还有一个 BackgroundJobStore 实现，基本套路与 SettingStore 一样，都是存储到数据库里面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class BackgroundJobStore : IBackgroundJobStore, ITransientDependency { protected IBackgroundJobRepository BackgroundJobRepository { get; } // ... public BackgroundJobInfo Find(Guid jobId) { return ObjectMapper.Map\u0026lt;BackgroundJobRecord, BackgroundJobInfo\u0026gt;( BackgroundJobRepository.Find(jobId) ); } // ... public void Insert(BackgroundJobInfo jobInfo) { BackgroundJobRepository.Insert( ObjectMapper.Map\u0026lt;BackgroundJobInfo, BackgroundJobRecord\u0026gt;(jobInfo) ); } // ... } 2.3.5 后台作业的执行 默认的后台作业管理器是通过一个后台工作者来执行后台任务的，这个实现叫做 BackgroundJobWorker，这个后台工作者的生命周期也是单例的。后台作业的具体执行逻辑里面，涉及到了以下几个类型的交互。\n类型 作用 AbpBackgroundJobOptions 提供每个后台任务的配置信息，包括任务的类型、参数类型、任务名称数据。 AbpBackgroundJobWorkerOptions 提供后台作业工作者的配置信息，例如每个周期 最大执行的作业数量、后台 工作者的 执行周期、作业执行 超时时间 等。 BackgroundJobConfiguration 后台任务的配置信息，作用是将持久化存储的作业信息与运行时类型进行绑定 和实例化，以便 ABP vNext 来执行具体的任务。 IBackgroundJobExecuter 后台作业的执行器，当我们从持久化存储获取到后台作业信息时，将会通过 这个执行器来执行具体的后台作业。 IBackgroundJobSerializer 后台作业序列化器，用于后台作业持久化时进行序列化的工具，默认采用的 是 JSON.NET 进行实现。 JobExecutionContext 执行器在执行后台作业时，是通过这个上下文参数进行执行的，在这个上下 文内部，包含了后台作业的具体类型、后台作业的参数值。 IBackgroundJobStore 前面已经讲过了，这个是用于后台作业的持久化存储，默认实现是存储在内存。 BackgroundJobPriority 后台作业的执行优先级定义，ABP vNext 在执行后台任务时，会根据任务的优 先级进行排序，以便在后面执行的时候优先级高的任务先执行。 我们来按照逻辑顺序走一遍它的实现，首先后台作业的执行工作者会从持久化存储内，获取 MaxJobFetchCount 个任务用于执行。从持久化存储获取后台作业信息(BackgroundJobInfo)，是由 IBackgroundJobStore 提供的。\n1 2 3 4 5 6 7 8 9 var store = scope.ServiceProvider.GetRequiredService\u0026lt;IBackgroundJobStore\u0026gt;(); var waitingJobs = store.GetWaitingJobs(WorkerOptions.MaxJobFetchCount); // 不存在任何后台作业，则直接结束本次调用。 if (!waitingJobs.Any()) { return; } InMemoryBackgroundJobStore 的相关实现：\n1 2 3 4 5 6 7 8 9 10 public List\u0026lt;BackgroundJobInfo\u0026gt; GetWaitingJobs(int maxResultCount) { return _jobs.Values .Where(t =\u0026gt; !t.IsAbandoned \u0026amp;\u0026amp; t.NextTryTime \u0026lt;= Clock.Now) .OrderByDescending(t =\u0026gt; t.Priority) .ThenBy(t =\u0026gt; t.TryCount) .ThenBy(t =\u0026gt; t.NextTryTime) .Take(maxResultCount) .ToList(); } 上面的代码可以看出来，首先排除 被放弃的任务 ，包含达到执行时间的任务，，然后根据任务的优先级从高到低进行排序。重试次数少的优先执行，预计执行时间越早的越先执行。最后从这些数据中，筛选出 maxResultCount 结果并返回。\n说到这里，我们来看一下这个 NextTryTime 是如何被计算出来的？回想起最开始的后台作业管理器，我们在添加一个后台任务的时候，就会设置这个后台任务的 预计执行时间。第一个任务被添加到执行队列中时，它的值一般是 Clock.Now ，也就是它被添加到队列的时间。\n不过 ABP vNext 为了让那些经常执行失败的任务，有比较低的优先级再执行，就在每次任务执行失败之后，会将 NextTryTime 的值指数级进行增加。这块代码可以在 CalculateNextTryTime 里面看到，也就是说某个任务的执行 失败次数越高，那么它下一次的预期执行时间就会越远。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 protected virtual DateTime? CalculateNextTryTime(BackgroundJobInfo jobInfo, IClock clock) { // 一般来说，这个 DefaultWaitFactor 因子的值是 2.0 。 var nextWaitDuration = WorkerOptions.DefaultFirstWaitDuration * (Math.Pow(WorkerOptions.DefaultWaitFactor, jobInfo.TryCount - 1)); // 同执行失败的次数进行挂钩。 var nextTryDate = jobInfo.LastTryTime?.AddSeconds(nextWaitDuration) ?? clock.Now.AddSeconds(nextWaitDuration); if (nextTryDate.Subtract(jobInfo.CreationTime).TotalSeconds \u0026gt; WorkerOptions.DefaultTimeout) { return null; } return nextTryDate; } 当预期的执行时间都超过 DefaultTimeout 的超时时间时(默认为 2 天)，说明这个任务确实没救了，就不要再执行了。\n我们之前说到，从 IBackgroundJobStore 拿到了需要执行的后台任务信息集合，接下来我们就要开始执行后台任务了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 foreach (var jobInfo in waitingJobs) { jobInfo.TryCount++; jobInfo.LastTryTime = clock.Now; try { // 根据任务名称获取任务的配置参数。 var jobConfiguration = JobOptions.GetJob(jobInfo.JobName); // 根据配置里面存储的任务类型，将参数值进行反序列化。 var jobArgs = serializer.Deserialize(jobInfo.JobArgs, jobConfiguration.ArgsType); // 构造一个新的执行上下文，让执行器执行任务。 var context = new JobExecutionContext(scope.ServiceProvider, jobConfiguration.JobType, jobArgs); try { jobExecuter.Execute(context); // 如果任务执行成功则删除该任务。 store.Delete(jobInfo.Id); } catch (BackgroundJobExecutionException) { // 发生任务执行失败异常时，根据指定的公式计算下一次的执行时间。 var nextTryTime = CalculateNextTryTime(jobInfo, clock); if (nextTryTime.HasValue) { jobInfo.NextTryTime = nextTryTime.Value; } else { // 超过超时时间的时候，公式计算函数返回 null，该任务置为废弃任务。 jobInfo.IsAbandoned = true; } TryUpdate(store, jobInfo); } } catch (Exception ex) { // 执行过程中，产生了未知异常，设置为废弃任务，并打印日志。 Logger.LogException(ex); jobInfo.IsAbandoned = true; TryUpdate(store, jobInfo); } } 执行后台任务的时候基本分为 5 步，它们分别是：\n获得任务关联的配置参数，默认不用提供，因为在之前模块初始化的时候就已经配置了（你也可以显式指定）。 通过之前存储的配置参数，将参数值反序列化出来，构造具体实例。 构造一个执行上下文。 后台任务执行器执行具体的后台任务。 成功则删除任务，失败则更新任务下次的执行状态。 至于执行器里面的真正执行操作，你都拿到了参数值和任务类型了。就可以通过类型用 IoC 获取后台任务对象的实例，然后通过反射匹配方法签名，在实例上调用这个方法传入参数即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public virtual void Execute(JobExecutionContext context) { // 构造具体的后台作业实例对象。 var job = context.ServiceProvider.GetService(context.JobType); if (job == null) { throw new AbpException(\u0026#34;The job type is not registered to DI: \u0026#34; + context.JobType); } // 获得需要执行的方法签名。 var jobExecuteMethod = context.JobType.GetMethod(nameof(IBackgroundJob\u0026lt;object\u0026gt;.Execute)); if (jobExecuteMethod == null) { throw new AbpException($\u0026#34;Given job type does not implement {typeof(IBackgroundJob\u0026lt;\u0026gt;).Name}. The job type was: \u0026#34; + context.JobType); } try { // 直接通过 MethodInfo 的 Invoke 方法调用，传入具体的实例对象和参数值即可。 jobExecuteMethod.Invoke(job, new[] { context.JobArgs }); } catch (Exception ex) { Logger.LogException(ex); // 如果是执行方法内的异常，则包装进行处理，然后抛出。 throw new BackgroundJobExecutionException(\u0026#34;A background job execution is failed. See inner exception for details.\u0026#34;, ex) { JobType = context.JobType.AssemblyQualifiedName, JobArgs = context.JobArgs }; } } 2.3.5 集成 Hangfire ABP vNext 对于 Hangfire 的集成代码分布在 Volo.Abp.HangFire 和 Volo.Abp.BackgroundJobs.HangFire 模块内部，前者是在模块配置里面，调用 Hangfire 库的相关方法，注入组件到 IoC 容器当中。后者则是对后台作业进行了适配处理，替换了默认的 IBackgroundJobManager 实现。\n在 AbpHangfireModule 模块内部，通过工厂创建出来一个 BackgroudJobServer 实例，并将它的生命周期与应用程序的生命周期进行绑定，以便进行销毁处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class AbpHangfireModule : AbpModule { private BackgroundJobServer _backgroundJobServer; public override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddHangfire(configuration =\u0026gt; { context.Services.ExecutePreConfiguredActions(configuration); }); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var options = context.ServiceProvider.GetRequiredService\u0026lt;IOptions\u0026lt;AbpHangfireOptions\u0026gt;\u0026gt;().Value; _backgroundJobServer = options.BackgroundJobServerFactory.Invoke(context.ServiceProvider); } public override void OnApplicationShutdown(ApplicationShutdownContext context) { //TODO: ABP may provide two methods for application shutdown: OnPreApplicationShutdown \u0026amp; OnApplicationShutdown _backgroundJobServer.SendStop(); _backgroundJobServer.Dispose(); } } 我们直奔主题，看一下基于 Hangfire 的后台作业管理器是怎么实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class HangfireBackgroundJobManager : IBackgroundJobManager, ITransientDependency { public Task\u0026lt;string\u0026gt; EnqueueAsync\u0026lt;TArgs\u0026gt;(TArgs args, BackgroundJobPriority priority = BackgroundJobPriority.Normal, TimeSpan? delay = null) { // 如果没有延迟参数，则直接通过 Enqueue() 方法扔进执行对了。 if (!delay.HasValue) { return Task.FromResult( BackgroundJob.Enqueue\u0026lt;HangfireJobExecutionAdapter\u0026lt;TArgs\u0026gt;\u0026gt;( adapter =\u0026gt; adapter.Execute(args) ) ); } else { return Task.FromResult( BackgroundJob.Schedule\u0026lt;HangfireJobExecutionAdapter\u0026lt;TArgs\u0026gt;\u0026gt;( adapter =\u0026gt; adapter.Execute(args), delay.Value ) ); } } 上述代码中使用 HangfireJobExecutionAdapter 进行了一个适配操作，因为 Hangfire 要将一个后台任务扔进队列执行，不是用 TArgs 就能解决的。\n转到这个适配器定义，提供了一个 Execute(TArgs) 方法，当被添加到 Hangfire 队列执行的时候。实际 Hangfire 会调用适配器的 Excetue(TArgs) 方法，然后内部还是使用的 IBackgroundJobExecuter 来执行具体定义的任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class HangfireJobExecutionAdapter\u0026lt;TArgs\u0026gt; { protected AbpBackgroundJobOptions Options { get; } protected IServiceScopeFactory ServiceScopeFactory { get; } protected IBackgroundJobExecuter JobExecuter { get; } public HangfireJobExecutionAdapter( IOptions\u0026lt;AbpBackgroundJobOptions\u0026gt; options, IBackgroundJobExecuter jobExecuter, IServiceScopeFactory serviceScopeFactory) { JobExecuter = jobExecuter; ServiceScopeFactory = serviceScopeFactory; Options = options.Value; } public void Execute(TArgs args) { using (var scope = ServiceScopeFactory.CreateScope()) { var jobType = Options.GetJob(typeof(TArgs)).JobType; var context = new JobExecutionContext(scope.ServiceProvider, jobType, args); JobExecuter.Execute(context); } } } 2.3.6 集成 RabbitMQ 基于 RabbitMQ 的后台作业实现，我想放在分布式事件总线里面，对其一起进行讲解。\n三、总结 ABP vNext 为我们提供了多种后台作业管理器的实现，你可以根据自己的需求选用不同的后台作业管理器，又或者是自己动手造轮子。\n需要看其他的 ABP vNext 相关文章？点击我 即可跳转到总目录。\n","date":"2019-10-25T08:27:00Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---12-background-jobs-and-background-workers/","title":"Abp vNext 源码分析 - 12. 后台作业与后台工作者"},{"content":"一、简要说明 文章信息：\n基于的 ABP vNext 版本：1.0.0\n创作日期：2019 年 10 月 23 日晚\n更新日期：暂无\nABP vNext 针对用户可编辑的配置，提供了单独的 Volo.Abp.Settings 模块，本篇文章的后面都将这种用户可变更的配置，叫做 参数。所谓可编辑的配置，就是我们在系统页面上，用户可以动态更改的参数值。\n例如你做的系统是一个门户网站，那么前端页面上展示的 Title ，你可以在后台进行配置。这个时候你就可以将网站这种全局配置作为一个参数，在程序代码中进行定义。通过 GlobalSettingValueProvider(后面会讲) 作为这个参数的值提供者，用户就可以随时对 Title 进行更改。又或者是某些通知的开关，你也可以定义一堆参数，让用户可以动态的进行变更。\n二、源码分析 2.1 模块启动流程 AbpSettingsModule 模块干的事情只有两件，第一是扫描所有 ISettingDefinitionProvider (参数定义提供者)，第二则是往配置参数添加一堆参数值提供者(ISettingValueProvider)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class AbpSettingsModule : AbpModule { public override void PreConfigureServices(ServiceConfigurationContext context) { // 自动扫描所有实现了 ISettingDefinitionProvider 的类型。 AutoAddDefinitionProviders(context.Services); } public override void ConfigureServices(ServiceConfigurationContext context) { // 配置默认的一堆参数值提供者。 Configure\u0026lt;AbpSettingOptions\u0026gt;(options =\u0026gt; { options.ValueProviders.Add\u0026lt;DefaultValueSettingValueProvider\u0026gt;(); options.ValueProviders.Add\u0026lt;GlobalSettingValueProvider\u0026gt;(); options.ValueProviders.Add\u0026lt;TenantSettingValueProvider\u0026gt;(); options.ValueProviders.Add\u0026lt;UserSettingValueProvider\u0026gt;(); }); } private static void AutoAddDefinitionProviders(IServiceCollection services) { var definitionProviders = new List\u0026lt;Type\u0026gt;(); services.OnRegistred(context =\u0026gt; { if (typeof(ISettingDefinitionProvider).IsAssignableFrom(context.ImplementationType)) { definitionProviders.Add(context.ImplementationType); } }); // 将扫描到的数据添加到 Options 中。 services.Configure\u0026lt;AbpSettingOptions\u0026gt;(options =\u0026gt; { options.DefinitionProviders.AddIfNotContains(definitionProviders); }); } } 2.2 参数的定义 2.2.1 参数的基本定义 ABP vNext 关于参数的定义在类型 SettingDefinition 可以找到，内部的结构与 PermissionDefine 类似。。开发人员需要先定义有哪些可配置的参数，然后 ABP vNext 会自动进行管理，在网站运行期间，用户、租户可以根据自己的需要随时变更参数值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public class SettingDefinition { /// \u0026lt;summary\u0026gt; /// 参数的唯一标识。 /// \u0026lt;/summary\u0026gt; [NotNull] public string Name { get; } // 参数的显示名称，是一个多语言字符串。 [NotNull] public ILocalizableString DisplayName { get =\u0026gt; _displayName; set =\u0026gt; _displayName = Check.NotNull(value, nameof(value)); } private ILocalizableString _displayName; // 参数的描述信息，也是一个多语言字符串。 [CanBeNull] public ILocalizableString Description { get; set; } /// \u0026lt;summary\u0026gt; /// 参数的默认值。 /// \u0026lt;/summary\u0026gt; [CanBeNull] public string DefaultValue { get; set; } /// \u0026lt;summary\u0026gt; /// 指定参数与其参数的值，是否能够在客户端进行显示。对于某些密钥设置来说是很危险的，默认值为 Fasle。 /// \u0026lt;/summary\u0026gt; public bool IsVisibleToClients { get; set; } /// \u0026lt;summary\u0026gt; /// 允许更改本参数的值提供者，为空则允许所有提供者提供参数值。 /// \u0026lt;/summary\u0026gt; public List\u0026lt;string\u0026gt; Providers { get; } //TODO: 考虑重命名为 AllowedProviders。 /// \u0026lt;summary\u0026gt; /// 当前参数是否能够继承父类的 Scope 信息，默认值为 True。 /// \u0026lt;/summary\u0026gt; public bool IsInherited { get; set; } /// \u0026lt;summary\u0026gt; /// 参数相关连的一些扩展属性，通过一个字典进行存储。 /// \u0026lt;/summary\u0026gt; [NotNull] public Dictionary\u0026lt;string, object\u0026gt; Properties { get; } /// \u0026lt;summary\u0026gt; /// 参数的值是否以加密的形式存储，默认值为 False。 /// \u0026lt;/summary\u0026gt; public bool IsEncrypted { get; set; } public SettingDefinition( string name, string defaultValue = null, ILocalizableString displayName = null, ILocalizableString description = null, bool isVisibleToClients = false, bool isInherited = true, bool isEncrypted = false) { Name = name; DefaultValue = defaultValue; IsVisibleToClients = isVisibleToClients; DisplayName = displayName ?? new FixedLocalizableString(name); Description = description; IsInherited = isInherited; IsEncrypted = isEncrypted; Properties = new Dictionary\u0026lt;string, object\u0026gt;(); Providers = new List\u0026lt;string\u0026gt;(); } // 设置附加数据值。 public virtual SettingDefinition WithProperty(string key, object value) { Properties[key] = value; return this; } // 设置 Provider 属性的值。 public virtual SettingDefinition WithProviders(params string[] providers) { if (!providers.IsNullOrEmpty()) { Providers.AddRange(providers); } return this; } } 上面的参数定义值得注意的就是 DefaultValue 、IsVisibleToClients、IsEncrypted 这三个属性。默认值一般适用于某些系统配置，例如当前系统的默认语言。后面两个属性则更加注重于 安全问题，因为某些参数存储的是一些重要信息，这个时候就需要进行特殊处理了。\n如果参数值是加密的，那么在获取参数值的时候就会进行解密操作，例如下面的代码。\nSettingProvider 类中的相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // ... public class SettingProvider : ISettingProvider, ITransientDependency { // ... public virtual async Task\u0026lt;string\u0026gt; GetOrNullAsync(string name) { // ... var value = await GetOrNullValueFromProvidersAsync(providers, setting); // 对值进行解密处理。 if (setting.IsEncrypted) { value = SettingEncryptionService.Decrypt(setting, value); } return value; } // ... } 参数不对客户端可见的话，在默认的 AbpApplicationConfigurationAppService 服务类中，获取参数值的时候就会跳过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private async Task\u0026lt;ApplicationSettingConfigurationDto\u0026gt; GetSettingConfigAsync() { var result = new ApplicationSettingConfigurationDto { Values = new Dictionary\u0026lt;string, string\u0026gt;() }; foreach (var settingDefinition in _settingDefinitionManager.GetAll()) { // 不会展示这些属性为 False 的参数。 if (!settingDefinition.IsVisibleToClients) { continue; } result.Values[settingDefinition.Name] = await _settingProvider.GetOrNullAsync(settingDefinition.Name); } return result; } 2.2.2 参数定义的扫描 跟权限定义类似，所有的参数定义都被放在了 SettingDefinitionProvider 里面，如果你需要定义一堆参数，只需要继承并实现 Define(ISettingDefinitionContext) 抽象方法就可以了。\n1 2 3 4 5 6 7 8 9 10 11 public class TestSettingDefinitionProvider : SettingDefinitionProvider { public override void Define(ISettingDefinitionContext context) { context.Add( new SettingDefinition(TestSettingNames.TestSettingWithoutDefaultValue), new SettingDefinition(TestSettingNames.TestSettingWithDefaultValue, \u0026#34;default-value\u0026#34;), new SettingDefinition(TestSettingNames.TestSettingEncrypted, isEncrypted: true) ); } } 因为我们的 SettingDefinitionProvider 实现了 ISettingDefinitionProvider 和 ITransientDependency 接口，所以这些 Provider 都会在组件注册的时候(模块里面有定义)，添加到对应的 AbpSettingOptions 内部，方便后续进行调用。\n2.2.3 参数定义的管理 我们的 参数定义提供者 和 参数值提供者 都赋值给 AbpSettingOptions 了，首先看有哪些地方使用到了 参数定义提供者。\n第二个我们已经看过，是在模块启动时有用到。第一个则是有一个 SettingDefinitionManager ，顾名思义就是管理所有的 SettingDefinition 的管理器。这个管理器提供了三个方法，都是针对 SettingDefinition 的查询功能。\n1 2 3 4 5 6 7 8 9 10 11 12 public interface ISettingDefinitionManager { // 根据参数定义的标识查询，不存在则抛出 AbpException 异常。 [NotNull] SettingDefinition Get([NotNull] string name); // 获得所有的参数定义。 IReadOnlyList\u0026lt;SettingDefinition\u0026gt; GetAll(); // 根据参数定义的标识查询，如果不存在则返回 null。 SettingDefinition GetOrNull(string name); } 接下来我们看一下它的默认实现 SettingDefinitionManager ，它的内部没什么说的，只是注意 SettingDefinitions 的填充方式，这里使用了线程安全的 懒加载模式。只有当用到的时候，才会调用 CreateSettingDefinitions() 方法填充数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class SettingDefinitionManager : ISettingDefinitionManager, ISingletonDependency { protected Lazy\u0026lt;IDictionary\u0026lt;string, SettingDefinition\u0026gt;\u0026gt; SettingDefinitions { get; } protected AbpSettingOptions Options { get; } protected IServiceProvider ServiceProvider { get; } public SettingDefinitionManager( IOptions\u0026lt;AbpSettingOptions\u0026gt; options, IServiceProvider serviceProvider) { ServiceProvider = serviceProvider; Options = options.Value; // 填充的时候，调用 CreateSettingDefinitions 方法进行填充。 SettingDefinitions = new Lazy\u0026lt;IDictionary\u0026lt;string, SettingDefinition\u0026gt;\u0026gt;(CreateSettingDefinitions, true); } // ... protected virtual IDictionary\u0026lt;string, SettingDefinition\u0026gt; CreateSettingDefinitions() { var settings = new Dictionary\u0026lt;string, SettingDefinition\u0026gt;(); using (var scope = ServiceProvider.CreateScope()) { // 从 Options 中得到类型，然后通过 IoC 进行实例化。 var providers = Options .DefinitionProviders .Select(p =\u0026gt; scope.ServiceProvider.GetRequiredService(p) as ISettingDefinitionProvider) .ToList(); // 执行每个 Provider 的 Define 方法填充数据。 foreach (var provider in providers) { provider.Define(new SettingDefinitionContext(settings)); } } return settings; } } 2.3 参数值的管理 当我们构建好参数的定义之后，我们要设置某个参数的值，或者说获取某个参数的值应该怎么操作呢？查看相关的单元测试，看到了 ABP vNext 自身是注入 ISettingProvider ，调用它的 GetOrNullAsync() 获取参数值。\n1 2 3 private readonly ISettingProvider _settingProvider; var settingValue = await _settingProvider.GetOrNullAsync(\u0026#34;WebSite.Title\u0026#34;) 跳转到接口，发现它有两个实现，这里我们只讲解一下 SettingProvider 类的实现。\n2.3.1 获取参数值 直奔主题，来看一下 ISettingProvider.GetOrNullAsync(string) 方法是怎么来获取参数值的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public class SettingProvider : ISettingProvider, ITransientDependency { protected ISettingDefinitionManager SettingDefinitionManager { get; } protected ISettingEncryptionService SettingEncryptionService { get; } protected ISettingValueProviderManager SettingValueProviderManager { get; } public SettingProvider( ISettingDefinitionManager settingDefinitionManager, ISettingEncryptionService settingEncryptionService, ISettingValueProviderManager settingValueProviderManager) { SettingDefinitionManager = settingDefinitionManager; SettingEncryptionService = settingEncryptionService; SettingValueProviderManager = settingValueProviderManager; } public virtual async Task\u0026lt;string\u0026gt; GetOrNullAsync(string name) { // 根据名称获取参数定义。 var setting = SettingDefinitionManager.Get(name); // 从参数值提供者管理器，获得一堆参数值提供者。 var providers = Enumerable .Reverse(SettingValueProviderManager.Providers); // 过滤符合参数定义的提供者，这里就是用到了之前参数定义的 List\u0026lt;string\u0026gt; Providers 属性。 if (setting.Providers.Any()) { providers = providers.Where(p =\u0026gt; setting.Providers.Contains(p.Name)); } //TODO: How to implement setting.IsInherited? //TODO: 如何实现 setting.IsInherited 功能? var value = await GetOrNullValueFromProvidersAsync(providers, setting); // 如果参数是加密的，则需要进行解密操作。 if (setting.IsEncrypted) { value = SettingEncryptionService.Decrypt(setting, value); } return value; } protected virtual async Task\u0026lt;string\u0026gt; GetOrNullValueFromProvidersAsync(IEnumerable\u0026lt;ISettingValueProvider\u0026gt; providers, SettingDefinition setting) { // 只要从任意 Provider 中，读取到了参数值，就直接进行返回。 foreach (var provider in providers) { var value = await provider.GetOrNullAsync(setting); if (value != null) { return value; } } return null; } // ... } 所以真正干活的还是 ISettingValueProviderManager 里面存放的一堆 ISettingValueProvider ，这个 参数值管理器 的接口很简单，只提供了一个 List\u0026lt;ISettingValueProvider\u0026gt; Providers { get; } 的定义。\n它会从模块配置的 ValueProviders 属性内部，通过 IoC 实例化对应的参数值提供者。\n1 2 3 4 5 6 _lazyProviders = new Lazy\u0026lt;List\u0026lt;ISettingValueProvider\u0026gt;\u0026gt;( () =\u0026gt; Options .ValueProviders .Select(type =\u0026gt; serviceProvider.GetRequiredService(type) as ISettingValueProvider) .ToList(), true 2.3.2 参数值提供者 参数值提供者的接口定义是 ISettingValueProvider，它定义了一个名称和 GetOrNullAsync(SettingDefinition) 方法，后者可以通过参数定义获取存储的值。\n1 2 3 4 5 6 public interface ISettingValueProvider { string Name { get; } Task\u0026lt;string\u0026gt; GetOrNullAsync([NotNull] SettingDefinition setting); } 注意这里的返回值是 Task\u0026lt;string\u0026gt; ，也就是说我们的参数值类型必须是 string 类型的，如果需要存储其他的类型可能就需要从 string 进行类型转换了。\n在这里的 SettingValueProvider 其实类似于我们之前讲过的 权限提供者。因为 ABP vNext 考虑到了多种情况，我们的参数值有可能是根据用户获取的，同时也有可能是根据不同的租户进行获取的。所以 ABP vNext 为我们预先定义了四种参数值提供器，他们分别是 DefaultValueSettingValueProvider、GlobalSettingValueProvider、TenantSettingValueProvider、UserSettingValueProvider 。\n下面我们就来讲讲这几个不同的参数提供者有啥不一样。\nDefaultValueSettingValueProvider：\n顾名思义，默认值参数提供者就是使用的参数定义里面的 DefaultValue 属性，当你查询某个参数值的时候，就直接返回了。\n1 2 3 4 public override Task\u0026lt;string\u0026gt; GetOrNullAsync(SettingDefinition setting) { return Task.FromResult(setting.DefaultValue); } GlobalSettingValueProvider：\n这是一种全局的提供者，它没有对应的 Key，也就是说如果数据库能查到 ProviderName 是 G 的记录，就直接返回它的值了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class GlobalSettingValueProvider : SettingValueProvider { public const string ProviderName = \u0026#34;G\u0026#34;; public override string Name =\u0026gt; ProviderName; public GlobalSettingValueProvider(ISettingStore settingStore) : base(settingStore) { } public override Task\u0026lt;string\u0026gt; GetOrNullAsync(SettingDefinition setting) { return SettingStore.GetOrNullAsync(setting.Name, Name, null); } } TenantSettingValueProvider：\n租户提供者，则是会将当前登录租户的 Id 结合 T 进行查询，也就是参数值是按照不同的租户进行隔离的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TenantSettingValueProvider : SettingValueProvider { public const string ProviderName = \u0026#34;T\u0026#34;; public override string Name =\u0026gt; ProviderName; protected ICurrentTenant CurrentTenant { get; } public TenantSettingValueProvider(ISettingStore settingStore, ICurrentTenant currentTenant) : base(settingStore) { CurrentTenant = currentTenant; } public override async Task\u0026lt;string\u0026gt; GetOrNullAsync(SettingDefinition setting) { return await SettingStore.GetOrNullAsync(setting.Name, Name, CurrentTenant.Id?.ToString()); } } UserSettingValueProvider：\n用户提供者，则是会将当前用户的 Id 作为查询条件，结合 U 在数据库进行查询匹配的参数值，参数值是根据不同的用户进行隔离的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class UserSettingValueProvider : SettingValueProvider { public const string ProviderName = \u0026#34;U\u0026#34;; public override string Name =\u0026gt; ProviderName; protected ICurrentUser CurrentUser { get; } public UserSettingValueProvider(ISettingStore settingStore, ICurrentUser currentUser) : base(settingStore) { CurrentUser = currentUser; } public override async Task\u0026lt;string\u0026gt; GetOrNullAsync(SettingDefinition setting) { if (CurrentUser.Id == null) { return null; } return await SettingStore.GetOrNullAsync(setting.Name, Name, CurrentUser.Id.ToString()); } } 2.3.3 参数值的存储 除了 DefaultValueSettingValueProvider 是直接从参数定义获取值以外，其他的参数值提供者都是通过 ISettingStore 读取参数值的。在该模块的默认实现当中，是直接返回 null 的，只有当你使用了 Volo.Abp.SettingManagement 模块，你的参数值才是存储到数据库当中的。\n我这里不再详细解析 Volo.Abp.SettingManagement 模块的其他实现，只说一下 ISettingStore 在它内部的实现 SettingStore。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class SettingStore : ISettingStore, ITransientDependency { protected ISettingManagementStore ManagementStore { get; } public SettingStore(ISettingManagementStore managementStore) { ManagementStore = managementStore; } public Task\u0026lt;string\u0026gt; GetOrNullAsync(string name, string providerName, string providerKey) { return ManagementStore.GetOrNullAsync(name, providerName, providerKey); } } 我们可以看到它也只是个包装，真正的操作类型是 ISettingManagementStore。\n2.3.4 参数值的设置 在 ABP vNext 的核心模块当中，是没有提供对参数值的变更的。只有在 Volo.Abp.SettingManagement 模块内部，它提供了 ISettingManager 管理器，可以进行参数值的变更。原理很简单，就是对数据库对应的表进行修改而已。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public async Task SetAsync(string name, string value, string providerName, string providerKey) { // 操作仓储，查询记录。 var setting = await SettingRepository.FindAsync(name, providerName, providerKey); // 新增或者更新记录。 if (setting == null) { setting = new Setting(GuidGenerator.Create(), name, value, providerName, providerKey); await SettingRepository.InsertAsync(setting); } else { setting.Value = value; await SettingRepository.UpdateAsync(setting); } } 三、总结 ABP vNext 提供了多种参数值提供者，我们可以根据自己的需要灵活选择。如果不能够满足你的需求，你也可以自己实现一个参数值提供者。我建议对于用户在界面可更改的参数，都可以使用 SettingDefinition 定义成参数，可以根据不同的情况进行配置读取。\nABP vNext 其他模块用到的许多参数，也都是使用的 SettingDefinition 进行定义。例如 Identity 模块用到的密码验证规则，就是通过 ISettingProvider 进行读取的，还有当前程序的默认语言。\n需要看其他的 ABP vNext 相关文章？点击我 即可跳转到总目录。\n","date":"2019-10-24T04:26:50Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---11-user-defined-parameters-and-configuration/","title":"Abp vNext 源码分析 - 11. 用户的自定义参数与配置"},{"content":"一、简要说明 ABP vNext 针对接口参数的校验工作，分别由过滤器和拦截器两步完成。过滤器内部使用的 ASP.NET Core MVC 所提供的 IModelStateValidator 进行处理，而拦截器使用的是 ABP vNext 自己提供的一套 IObjectValidator 进行校验工作。\n关于参数验证相关的代码，分布在以下三个项目当中：\nVolo.Abp.AspNetCore.Mvc Volo.Abp.Validation Volo.Abp.FluentValidation 通过 MVC 的过滤器和 ABP vNext 提供的拦截器，我们能够快速地对接口的参数、对象的属性进行统一的验证处理，而不会将这些代码扩散到业务层当中。\n文章信息：\n基于的 ABP vNext 版本：1.0.0\n创作日期：2019 年 10 月 22 日晚\n更新日期：暂无\n二、源码分析 2.1 模型验证过滤器 模型验证过滤器是直接使用的 MVC 那一套模型验证机制，基于数据注解的方式进行校验。数据注解也就是存放在 System.ComponentModel.DataAnnotations 命名空间下面的一堆特性定义，例如我们经常在 DTO 上面使用的 [Required] 、[StringLength] 特性等，如果想知道更多的数据注解用法，可以前往 MSDN 进行学习。\n2.1.1 过滤器的注入 模型验证过滤器 (AbpValidationActionFilter) 的定义存放在 Volo.Abp.AspNetCore.Mvc 项目内部，它是在模块的 ConfigureService() 方法中被注入到 IoC 容器的。\nAbpAspNetCoreMvcModule 里面的相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 namespace Volo.Abp.AspNetCore.Mvc { [DependsOn( typeof(AbpAspNetCoreModule), typeof(AbpLocalizationModule), typeof(AbpApiVersioningAbstractionsModule), typeof(AbpAspNetCoreMvcContractsModule), typeof(AbpUiModule) )] public class AbpAspNetCoreMvcModule : AbpModule { // public override void ConfigureServices(ServiceConfigurationContext context) { // ... Configure\u0026lt;MvcOptions\u0026gt;(mvcOptions =\u0026gt; { mvcOptions.AddAbp(context.Services); }); } // ... } } 上述代码是调用对 MvcOptions 编写的 AddAbp(this MvcOptions, IServiceCollection) 扩展方法，传入了我们的 IoC 注册容器(IServiceCollection)。\nAbpMvcOptionsExtensions 里面的相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 internal static class AbpMvcOptionsExtensions { public static void AddAbp(this MvcOptions options, IServiceCollection services) { AddConventions(options, services); // 注册过滤器。 AddFilters(options); AddModelBinders(options); AddMetadataProviders(options, services); } // ... private static void AddFilters(MvcOptions options) { options.Filters.AddService(typeof(AbpAuditActionFilter)); options.Filters.AddService(typeof(AbpFeatureActionFilter)); // 我们的参数验证过滤器。 options.Filters.AddService(typeof(AbpValidationActionFilter)); options.Filters.AddService(typeof(AbpUowActionFilter)); options.Filters.AddService(typeof(AbpExceptionFilter)); } // ... } 到这一步，我们的 AbpValidationActionFilter 会被添加到 IoC 容器当中，以供 ASP.NET Core Mvc 框架进行使用。\n2.1.2 过滤器的验证流程 我们的验证过滤器通过上述步骤，已经被注入到 IoC 容器当中了，以后我们每次的接口调用都会进入 AbpValidationActionFilter 的 OnActionExecutionAsync() 方法内部。在这个过滤器的内部实现代码中，我们看到 ABP 为我们注入了一个 IModelStateValidator 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class AbpValidationActionFilter : IAsyncActionFilter, ITransientDependency { private readonly IModelStateValidator _validator; public AbpValidationActionFilter(IModelStateValidator validator) { _validator = validator; } public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) { //TODO: Configuration to disable validation for controllers..? //TODO: 是否应该增加一个配置项，以便开发人员禁用验证功能 ？ // 判断当前请求是否是一个控制器行为，是则返回 true。 // 第二个条件会判断当前的接口返回值是 IActionResult、JsonResult、ObjectResult、NoContentResult 的一种，是则返回 true。 // 这里则会忽略不是控制器的方法，控制器类型不是上述类型任意一种也会被忽略。 if (!context.ActionDescriptor.IsControllerAction() || !context.ActionDescriptor.HasObjectResult()) { await next(); return; } // 调用验证器进行验证操作。 _validator.Validate(context.ModelState); await next(); } } 过滤器的行为很简单，判断当前的 API 请求是否符合条件，不符合则不进行参数验证，否则调用 IModelStateValidator 的 Validate 方法，将模型状态传递给它进行处理。\n这个接口从名字上看，应该是模型状态验证器。因为我们接口上面的参数，在 ASP.NET Core MVC 的使用当中，会进行模型绑定，即建立对象到 Http 请求参数的映射。\n1 2 3 4 5 6 public interface IModelStateValidator { void Validate(ModelStateDictionary modelState); void AddErrors(IAbpValidationResult validationResult, ModelStateDictionary modelState); } ABP vNext 的默认实现是 ModelStateValidator ，它的内部实现也很简单。就是遍历 ModelStateDictionary 对象的错误信息，将其添加到一个 AbpValidationResult 对象内部的 List 集合。这样做的目的，是方便后面 ABP vNext 进行错误抛出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class ModelStateValidator : IModelStateValidator, ITransientDependency { public virtual void Validate(ModelStateDictionary modelState) { var validationResult = new AbpValidationResult(); AddErrors(validationResult, modelState); if (validationResult.Errors.Any()) { throw new AbpValidationException( \u0026#34;ModelState is not valid! See ValidationErrors for details.\u0026#34;, validationResult.Errors ); } } public virtual void AddErrors(IAbpValidationResult validationResult, ModelStateDictionary modelState) { if (modelState.IsValid) { return; } foreach (var state in modelState) { foreach (var error in state.Value.Errors) { validationResult.Errors.Add(new ValidationResult(error.ErrorMessage, new[] { state.Key })); } } } } 2.1.3 结果的包装 当过滤器抛出了 AbpValidationException 异常之后，ABP vNext 会在异常过滤器 (AbpExceptionFilter) 内部捕获这个特定异常 (取决于异常继承的 IHasValidationErrors 接口)，并对其进行特殊的包装。\n1 2 3 4 5 6 7 8 9 [Serializable] public class AbpValidationException : AbpException, IHasLogLevel, // 注意这个接口。 IHasValidationErrors, IExceptionWithSelfLogging { // ... } 2.1.4 数据注解的验证 这一节相当于是一个扩展知识，帮助我们了解数据注解的工作机制，以及 ModelStateDictionary 是怎么被填充的。\n扩展阅读：\nASP.NET Core 模型验证详解 .NET Core 开发日志 \u0026ndash; Model Binding 2.2 对象验证拦截器 ABP vNext 除了使用 ASP.NET Core MVC 提供的模型验证功能，自己也提供了一个单独的验证模块。我们先来看看模块类型内部所执行的操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class AbpValidationModule : AbpModule { public override void PreConfigureServices(ServiceConfigurationContext context) { // 添加拦截器注册类。 context.Services.OnRegistred(ValidationInterceptorRegistrar.RegisterIfNeeded); // 添加对象验证拦截器的辅助对象。 AutoAddObjectValidationContributors(context.Services); } private static void AutoAddObjectValidationContributors(IServiceCollection services) { var contributorTypes = new List\u0026lt;Type\u0026gt;(); // 在类型注册的时候，如果类型实现了 IObjectValidationContributor 接口，则认定是验证器的辅助类。 services.OnRegistred(context =\u0026gt; { if (typeof(IObjectValidationContributor).IsAssignableFrom(context.ImplementationType)) { contributorTypes.Add(context.ImplementationType); } }); // 最后向 Options 类型添加辅助类的类型定义。 services.Configure\u0026lt;AbpValidationOptions\u0026gt;(options =\u0026gt; { options.ObjectValidationContributors.AddIfNotContains(contributorTypes); }); } } 模块在启动时进行了两个操作，第一是为框架注册对象验证拦截器，第二则是添加 辅助类型(IObjectValidationContributor) 的定义到配置类中，方便后续进行使用。\n2.2.1 拦截器的注入 拦截器的注入行为很简单，主要注册的类型实现了 IValidationEnabled 接口，就会为其注入拦截器。\n1 2 3 4 5 6 7 8 9 10 public static class ValidationInterceptorRegistrar { public static void RegisterIfNeeded(IOnServiceRegistredContext context) { if (typeof(IValidationEnabled).IsAssignableFrom(context.ImplementationType)) { context.Interceptors.TryAdd\u0026lt;ValidationInterceptor\u0026gt;(); } } } 2.2.2 拦截器的行为 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class ValidationInterceptor : AbpInterceptor, ITransientDependency { private readonly IMethodInvocationValidator _methodInvocationValidator; public ValidationInterceptor(IMethodInvocationValidator methodInvocationValidator) { _methodInvocationValidator = methodInvocationValidator; } public override void Intercept(IAbpMethodInvocation invocation) { Validate(invocation); invocation.Proceed(); } public override async Task InterceptAsync(IAbpMethodInvocation invocation) { Validate(invocation); await invocation.ProceedAsync(); } protected virtual void Validate(IAbpMethodInvocation invocation) { _methodInvocationValidator.Validate( new MethodInvocationValidationContext( invocation.TargetObject, invocation.Method, invocation.Arguments ) ); } } 拦截器内部只会调用 IMethodInvocationValidator 对象提供的 Validate() 方法，在调用时会将方法的参数，方法类型等数据封装到 MethodInvocationValidationContext 。\n这个上下文类型，本身就继承了前面提到的 AbpValidationResult 类型，在其内部增加了存储参数信息的属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MethodInvocationValidationContext : AbpValidationResult { public object TargetObject { get; } // 方法的元数据信息。 public MethodInfo Method { get; } // 方法的具体参数值。 public object[] ParameterValues { get; } // 方法的参数信息。 public ParameterInfo[] Parameters { get; } public MethodInvocationValidationContext(object targetObject, MethodInfo method, object[] parameterValues) { TargetObject = targetObject; Method = method; ParameterValues = parameterValues; Parameters = method.GetParameters(); } } 接下来我们看一下真正的 对象验证器 ，也就是 IMethodInvocationValidator 的默认实现 MethodInvocationValidator 当中具体的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // ... public virtual void Validate(MethodInvocationValidationContext context) { // ... AddMethodParameterValidationErrors(context); if (context.Errors.Any()) { ThrowValidationError(context); } } // ... protected virtual void AddMethodParameterValidationErrors(MethodInvocationValidationContext context) { // 循环调用 IObjectValidator 的 GetErrors 方法，捕获参数的具体错误。 for (var i = 0; i \u0026lt; context.Parameters.Length; i++) { AddMethodParameterValidationErrors(context, context.Parameters[i], context.ParameterValues[i]); } } protected virtual void AddMethodParameterValidationErrors(IAbpValidationResult context, ParameterInfo parameterInfo, object parameterValue) { var allowNulls = parameterInfo.IsOptional || parameterInfo.IsOut || TypeHelper.IsPrimitiveExtended(parameterInfo.ParameterType, includeEnums: true); // 添加错误信息到 Errors 里面，方便后面抛出。 context.Errors.AddRange( _objectValidator.GetErrors( parameterValue, parameterInfo.Name, allowNulls ) ); } 2.2.3 “真正”的参数验证器 我们看到，即便是在 IMethodInvocationValidator 内部，也没有真正地进行参数验证工作，而是调用了 IObjectValidator 进行对象验证处理，其接口定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface IObjectValidator { void Validate( object validatingObject, string name = null, bool allowNull = false ); List\u0026lt;ValidationResult\u0026gt; GetErrors( object validatingObject, // 待验证的值。 string name = null,\t// 参数的名字。 bool allowNull = false\t// 是否允许可空。 ); } 它的默认实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public class ObjectValidator : IObjectValidator, ITransientDependency { protected IHybridServiceScopeFactory ServiceScopeFactory { get; } protected AbpValidationOptions Options { get; } public ObjectValidator(IOptions\u0026lt;AbpValidationOptions\u0026gt; options, IHybridServiceScopeFactory serviceScopeFactory) { ServiceScopeFactory = serviceScopeFactory; Options = options.Value; } public virtual void Validate(object validatingObject, string name = null, bool allowNull = false) { var errors = GetErrors(validatingObject, name, allowNull); if (errors.Any()) { throw new AbpValidationException( \u0026#34;Object state is not valid! See ValidationErrors for details.\u0026#34;, errors ); } } public virtual List\u0026lt;ValidationResult\u0026gt; GetErrors(object validatingObject, string name = null, bool allowNull = false) { // 如果待验证的值为空。 if (validatingObject == null) { // 如果参数本身是允许可空的，那么直接返回。 if (allowNull) { return new List\u0026lt;ValidationResult\u0026gt;(); //TODO: Returning an array would be more performent } else { // 否则在错误信息里面加入不能为空的错误。 return new List\u0026lt;ValidationResult\u0026gt; { name == null ? new ValidationResult(\u0026#34;Given object is null!\u0026#34;) : new ValidationResult(name + \u0026#34; is null!\u0026#34;, new[] {name}) }; } } // 构造一个新的上下文，将其分派给辅助类进行验证。 var context = new ObjectValidationContext(validatingObject); using (var scope = ServiceScopeFactory.CreateScope()) { // 遍历之前模块启动的辅助类型。 foreach (var contributorType in Options.ObjectValidationContributors) { // 通过 IoC 创建实例。 var contributor = (IObjectValidationContributor) scope.ServiceProvider.GetRequiredService(contributorType); // 调用辅助类型进行具体认证。 contributor.AddErrors(context); } } return context.Errors; } } 所以我们的对象验证，还没有真正的进行验证处理，所有的验证操作都是由各个 验证辅助类型 处理的。而这些辅助类型有两种，第一是基于数据注解 的 验证辅助类型，第二种则是基于 FluentValidation 库编写的一种验证辅助类。\n虽然 ABP vNext 套了三层，最终只是为了方便我们开发人员重写各个阶段的实现，也就更加地灵活可控。\n2.2.4 默认的数据注解验证 ABP vNext 为了降低我们的学习成本，本身也是支持 ASP.NET Core MVC 那一套数据注解校验。你可以在某个非控制器类型的参数上，使用 [Required] 等数据注解特性。\n它的默认实现我就不再多加赘述，基本就是通过反射得到参数对象上面的所有 ValidationAttribute 特性，显式地调用 GetValidationResult() 方法，获取到具体的错误信息，然后添加到上下文结果当中。\n1 2 3 4 5 6 7 8 foreach (var attribute in validationAttributes) { var result = attribute.GetValidationResult(property.GetValue(validatingObject), validationContext); if (result != null) { errors.Add(result); } } 另外注意，这个递归验证的深度是 8 级，在辅助类型的 MaxRecursiveParameterValidationDepth 常量中进行了定义。也就是说，你这个对象图的逻辑层级不能超过 8 级。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class A1 { [Required] public string Name { get; set;} public B2 B2 { get; set;} } public class B2 { [StringLength(8)] public string Name { get; set;} } 如果你方法参数是 A1 类型的话，那么这就有 2 层了。\n2.3 流畅验证库 回想上一节说的验证辅助类，还有一个基于 FluentValidation 库的类型，这里对于该库的使用方法参考单元测试即可。我这里只讲解一下，这个辅助类型是如何进行验证的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class FluentObjectValidationContributor : IObjectValidationContributor, ITransientDependency { private readonly IServiceProvider _serviceProvider; public FluentObjectValidationContributor( IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; } public void AddErrors(ObjectValidationContext context) { // 构造泛型类型，如果你对 Person 写了个验证器，那么验证器类型就是 IValidator\u0026lt;Person\u0026gt;。 var serviceType = typeof(IValidator\u0026lt;\u0026gt;).MakeGenericType(context.ValidatingObject.GetType()); // 通过 IoC 获得一个实例。 var validator = _serviceProvider.GetService(serviceType) as IValidator; if (validator == null) { return; } // 调用验证器的方法进行验证。 var result = validator.Validate(context.ValidatingObject); if (!result.IsValid) { // 获得错误数据，将 FluentValidation 的错误转换为标准的错误信息。 context.Errors.AddRange( result.Errors.Select( error =\u0026gt; new ValidationResult(error.ErrorMessage) ) ); } } } 单元测试当中的基本用法：\n1 2 3 4 5 6 7 8 9 public class MyMethodInputValidator : AbstractValidator\u0026lt;MyMethodInput\u0026gt; { public MyMethodInputValidator() { RuleFor(x =\u0026gt; x.MyStringValue).Equal(\u0026#34;aaa\u0026#34;); RuleFor(x =\u0026gt; x.MyMethodInput2.MyStringValue2).Equal(\u0026#34;bbb\u0026#34;); RuleFor(customer =\u0026gt; customer.MyMethodInput3).SetValidator(new MyMethodInput3Validator()); } } 三、总结 总的来说 ABP vNext 为我们提供了多种参数验证方法，一般来说使用 MVC 过滤器配合数据注解就够了。如果你确实有一些特殊的需求，那也可以使用自己的方式对参数进行验证，只需要实现 IObjectValidationContributor 接口就行。\n需要看其他的 ABP vNext 相关文章？点击我 即可跳转到总目录。\n","date":"2019-10-23T04:06:17Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---9-authentication-of-interface-parameters/","title":"Abp vNext 源码分析 - 9. 接口参数的认证"},{"content":"一、背景 最近在精读 《CLR Via C#》和 《Effective C#》 的时候，发现的一个问题点。一般来说，我们实现 IDisposable 接口，是为了释放托管资源和非托管资源。不过在 C# 类型定义里面有一个功能类似的东西，那就是 终结器。\n最开始我是学 C++ 的，之后学 C# 的时候发现这玩意儿不论是写法和作用，都跟 C++ 里面的 析构函数 一样。在 C++ 里面的析构函数是在对象释放的时候会被调用，之后这个观点一直被我带到 C#，认为资源释放的动作放在终结器不就行了么。为什么还要我实现 IDisposable 接口，然后让使用者手动释放呢？\nC++ 版本的析构函数：\n1 2 3 4 5 6 7 8 9 class Line { public: Line(); ~Line(); private: double length; }; C# 版本的终结器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Line { private double _length; public Line() { } ~Line() { } } 二、原因 说起这个原因，首先得从 C# 终结器的 调用时机 说起。终结器的调用是 CLR 在进行 GC 时，如果某个对象写有终结器，即便它应该被释放，也不会马上回收该对象。而 C++ 的析构函数是确定性析构，取决于你调用 delete 的时机。\nGC 会将其添加到一个队列当中，单独使用了一个 高优先级 线程去调用对象的终结器。因为要保证线程能够访问到终结器对象，所以本该释放的对象，以及对象相关的资源就 会被提升 1 代 ，会 增加内存占用。\n一旦终结器方法带有死循环，那么 GC 将永远无法释放该资源，造成 内存泄漏。\n除开内存占用增大的原因，如果你在终结器方法内部引用了其他带终结器对象，GC 无法保证终结器调用顺序，所以你可能访问到的对象是已经终结了的。\n还有一种情况会导致尴尬的内存泄漏，本来对象 A 应该被释放了，结果你在终结器内部又让其他的根保持对象的引用，又会让这个对象复活。因为 GC 只会执行一次带终结器对象的终结器。执行一次过后，就再也不会执行对象的终结器了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class BadClass { private static readonly List\u0026lt;BadClass\u0026gt; _list = new List\u0026lt;BadClass\u0026gt;(); private string _msg; public BadClass(string msg) { _msg = (string)msg.Clone(); } ~BadClass() { // 造成 _msg 的内存不会被释放。 _list.Add(this); } } 三、最佳实践 针对 Effective C# 所提出的最佳实践，你应该为对象实现 IDisposable 接口，以释放托管资源。如果你对象确实使用了非托管资源，那么你也应该为其编写终结器。因为非托管资源的，你不能保证调用者能够显示调用 Dispose() 方法，所以你得通过终结器来处理。\n一个典型的 Dispose() 方法应该将托管资源、非托管资源全部进行释放，设置对应的标识表明对象已经被释放了，阻止垃圾回收器重复清理该对象、保证方法的 幂等性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class FatherClass : IDisposable { private bool isDisposed = false; public void Dispose() { Dispose(true); // 通知 GC，这个对象已经完全被清理。 GC.SuppressFinalize(this); } ~FatherClass() { Dispose(false); } protected virtual Dispose(bool isDisposing) { if(isDisposed) return; if(isDisposing) { // 释放托管资源。 } // 释放非托管资源。 isDisposed = true; } public void TestMethod() { if(isDisposed) { throw new ObjectDisposedException(\u0026#34;对象已经被释放。\u0026#34;); } } } public class ChildClass : FatherClass { private bool isDisposed = false; protected override void Dispose(bool isDisposing) { if(isDisposed) return; if(isDisposing) { // 释放托管资源。 } base.Dispose(isDisposing); isDisposed = true; } } 在上面的实践中，我们提炼出了一个 void Dispose(bool) 方法，并将其设置为虚函数。这样做的好处有两点，第一点是方便子类重写释放逻辑，第二点是可以将终结器和 Dispose() 方法内部重复的代码提炼出来。\n","date":"2019-10-22T01:59:50Z","permalink":"https://real-zony.github.io/p/why-implement-the-idisposable-interface/","title":"为什么要实现 IDisposable 接口?"},{"content":"一、问题 该问题经常出现在 ABP vNext 框架当中，要复现该问题十分简单，只需要你注入一个 IRepository\u0026lt;T,TKey\u0026gt; 仓储，在任意一个地方调用 IRepository\u0026lt;T,TKey\u0026gt;.ToList() 方法。\n1 2 3 4 5 6 7 [Fact] public void TestMethod() { var rep = GetRequiredService\u0026lt;IHospitalRepository\u0026gt;(); var result = rep.ToList(); } 例如上面的测试代码，不出意外就会提示 System.ObjectDisposedException 异常，具体的异常内容信息：\n1 System.ObjectDisposedException : Cannot access a disposed object. A common cause of this error is disposing a context that was resolved from dependency injection and then later trying to use the same context instance elsewhere in your application. This may occur if you are calling Dispose() on the context, or wrapping the context in a using statement. If you are using dependency injection, you should let the dependency injection container take care of disposing context instances. 其实已经说得十分明白了，因为你要调用的 DbContext 已经被释放了，所以会出现这个异常信息。\n二、原因 2.1 为什么能够调用 LINQ 扩展? 我们之所以能够在 IRepository\u0026lt;TEntity,TKey\u0026gt; 接口上面，调用 LINQ 相关的流畅接口，是因为其父级接口 IReadOnlyRepository\u0026lt;TEntity,TKey\u0026gt; 继承了 IQueryable\u0026lt;TEntity\u0026gt; 接口。如果使用的是 Entity Framework Core 框架，那么在解析 IRepository\u0026lt;T,Key\u0026gt; 的时候，我们得到的是一个 EfCoreRepository\u0026lt;TDbContext, TEntity,TKey\u0026gt; 实例。\n针对这个实例，类型 EfCoreRepository\u0026lt;TDbContext, TEntity\u0026gt; 则是它的基类型，继续跳转到其基类 RepositoryBase\u0026lt;TEntity\u0026gt; 我们就能看到它实现了 IQueryable\u0026lt;T\u0026gt; 接口必备的几个属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public abstract class RepositoryBase\u0026lt;TEntity\u0026gt; : BasicRepositoryBase\u0026lt;TEntity\u0026gt;, IRepository\u0026lt;TEntity\u0026gt; where TEntity : class, IEntity { // ... 忽略的代码。 public virtual Type ElementType =\u0026gt; GetQueryable().ElementType; public virtual Expression Expression =\u0026gt; GetQueryable().Expression; public virtual IQueryProvider Provider =\u0026gt; GetQueryable().Provider; // ... 忽略的代码。 IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public IEnumerator\u0026lt;TEntity\u0026gt; GetEnumerator() { return GetQueryable().GetEnumerator(); } protected abstract IQueryable\u0026lt;TEntity\u0026gt; GetQueryable(); // ... 忽略的代码。 } 2.2 IQueryable 使用的 DbContext 上一个小节的代码中，我们可以看出最后的 IQueryable\u0026lt;TEntity\u0026gt; 是通过抽象方法 GetQueryable() 取得的。这个抽象方法，在 EF Core 当中的实现如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class EfCoreRepository\u0026lt;TDbContext, TEntity\u0026gt; : RepositoryBase\u0026lt;TEntity\u0026gt;, IEfCoreRepository\u0026lt;TEntity\u0026gt; where TDbContext : IEfCoreDbContext where TEntity : class, IEntity { public virtual DbSet\u0026lt;TEntity\u0026gt; DbSet =\u0026gt; DbContext.Set\u0026lt;TEntity\u0026gt;(); DbContext IEfCoreRepository\u0026lt;TEntity\u0026gt;.DbContext =\u0026gt; DbContext.As\u0026lt;DbContext\u0026gt;(); protected virtual TDbContext DbContext =\u0026gt; _dbContextProvider.GetDbContext(); private readonly IDbContextProvider\u0026lt;TDbContext\u0026gt; _dbContextProvider; // ... 忽略的代码。 public EfCoreRepository(IDbContextProvider\u0026lt;TDbContext\u0026gt; dbContextProvider) { _dbContextProvider = dbContextProvider; // ... 忽略的代码。 } // ... 忽略的代码。 protected override IQueryable\u0026lt;TEntity\u0026gt; GetQueryable() { return DbSet.AsQueryable(); } // ... 忽略的代码。 } 所以我们就可以知道，当调用 IQueryable\u0026lt;TEntity\u0026gt;.ToList() 方法时，实际是使用的 IDbContextProvider\u0026lt;TDbContext\u0026gt; 解析出来的数据库上下文对象。\n跳转到这个 DbContextProvider 的具体实现，可以看到他是通过 IUnitOfWorkManager(工作单元管理器) 得到可用的工作单元，然后通过工作单元提供的 IServiceProvider 解析所需要的数据库上下文对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class UnitOfWorkDbContextProvider\u0026lt;TDbContext\u0026gt; : IDbContextProvider\u0026lt;TDbContext\u0026gt; where TDbContext : IEfCoreDbContext { private readonly IUnitOfWorkManager _unitOfWorkManager; public UnitOfWorkDbContextProvider( IUnitOfWorkManager unitOfWorkManager) { _unitOfWorkManager = unitOfWorkManager; } // ... 上述代码有所精简。 public TDbContext GetDbContext() { var unitOfWork = _unitOfWorkManager.Current; // ... 忽略部分代码。 // 重点在 CreateDbContext() 方法内部。 var databaseApi = unitOfWork.GetOrAddDatabaseApi( dbContextKey, () =\u0026gt; new EfCoreDatabaseApi\u0026lt;TDbContext\u0026gt;( CreateDbContext(unitOfWork, connectionStringName, connectionString) )); return ((EfCoreDatabaseApi\u0026lt;TDbContext\u0026gt;)databaseApi).DbContext; } private TDbContext CreateDbContext(IUnitOfWork unitOfWork, string connectionStringName, string connectionString) { // ... 忽略部分代码。 using (DbContextCreationContext.Use(creationContext)) { var dbContext = CreateDbContext(unitOfWork); // ... 忽略部分代码。 return dbContext; } } private TDbContext CreateDbContext(IUnitOfWork unitOfWork) { return unitOfWork.Options.IsTransactional ? CreateDbContextWithTransaction(unitOfWork) // 重点 ！！！ : unitOfWork.ServiceProvider.GetRequiredService\u0026lt;TDbContext\u0026gt;(); } public TDbContext CreateDbContextWithTransaction(IUnitOfWork unitOfWork) { // ... 忽略部分代码。 if (activeTransaction == null) { // 重点 ！！！ var dbContext = unitOfWork.ServiceProvider.GetRequiredService\u0026lt;TDbContext\u0026gt;(); // ... 忽略部分代码。 return dbContext; } else { // ... 忽略部分代码。 // 重点 ！！！ var dbContext = unitOfWork.ServiceProvider.GetRequiredService\u0026lt;TDbContext\u0026gt;(); // ... 忽略部分代码。 return dbContext; } } } 2.3 DbContext 和工作单元的销毁 可以看到，仓储使用到的数据库上下文对象是通过工作单元的 IServiceProvider 进行解析的。回想之前关于工作单元的文章讲解，不论是手动开启工作单元，还是通过拦截器或者特性的方式开启，最终都是使用的 IUnitOfWorkManager.Begin() 进行构建的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class UnitOfWorkManager : IUnitOfWorkManager, ISingletonDependency { // ... 省略的不相关的代码。 private readonly IHybridServiceScopeFactory _serviceScopeFactory; // ... 省略的不相关的代码。 public IUnitOfWork Begin(UnitOfWorkOptions options, bool requiresNew = false) { // ... 省略的不相关的代码。 var unitOfWork = CreateNewUnitOfWork(); // ... 省略的不相关的代码。 return unitOfWork; } // ... 省略的不相关的代码。 private IUnitOfWork CreateNewUnitOfWork() { var scope = _serviceScopeFactory.CreateScope(); try { // ... 省略的不相关的代码。 // 所以 IUnitOfWork 里面获得的 ServiceProvider 是一个子容器。 var unitOfWork = scope.ServiceProvider.GetRequiredService\u0026lt;IUnitOfWork\u0026gt;(); // ... 省略的不相关的代码。 // 工作单元被释放的动作。 unitOfWork.Disposed += (sender, args) =\u0026gt; { _ambientUnitOfWork.SetUnitOfWork(outerUow); // 子容器被释放时，通过子容器解析的 DbContext 也被释放了。 scope.Dispose(); }; return unitOfWork; } catch { scope.Dispose(); throw; } } } 工作单元的 ServiceProvider 是通过继承 IServiceProviderAccessor 得到的，也就是说在构建工作单元的时候，这个 Provider 就是工作单元管理器创建的子容器。\n那么回到之前的代码，我们得知 DbContext 是通过工作单元的 ServiceProvider 创建的，当工作单元被释放的时候，也会连带这个子容器被释放。那么我们之前解析出来的 DbContext ，也就会随着子容器的释放而被释放。如果要验证上述猜想，只需要编写类似代码即可。\n1 2 3 4 5 6 7 8 9 [Fact] public void TestMethod() { using (var scope = GetRequiredService\u0026lt;IServiceProvider\u0026gt;().CreateScope()) { var dbContext = scope.ServiceProvider.GetRequiredService\u0026lt;IHospitalDbContext\u0026gt;(); scope.Dispose(); } } 既然如此，工作单元是什么时候被释放的呢\u0026hellip;因为拦截器默认是为仓储建立了拦截器，所以在获得到 DbContext 的时候，拦截器已经将之前的 DbContext 释放掉了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public override void Intercept(IAbpMethodInvocation invocation) { if (!UnitOfWorkHelper.IsUnitOfWorkMethod(invocation.Method, out var unitOfWorkAttribute)) { invocation.Proceed(); return; } // 我在这里... using (var uow = _unitOfWorkManager.Begin(CreateOptions(invocation, unitOfWorkAttribute))) { invocation.Proceed(); uow.Complete(); } } 要验证 DbContext 是随工作单元一起释放，也十分简单，编写以下代码即可进行测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 [Fact] public void TestMethod() { var rep = GetRequiredService\u0026lt;IHospitalRepository\u0026gt;(); var mgr = GetRequiredService\u0026lt;IUnitOfWorkManager\u0026gt;(); using (var uow = mgr.Begin()) { var count = rep.Count(); uow.Dispose(); uow.Complete(); } } 三、解决 解决方法很简单，在有类似操作的外部通过 [UnitOfWork] 特性或者 IUnitOfManager.Begin 开启一个新的工作单元即可。\n1 2 3 4 5 6 7 8 9 10 11 12 [Fact] public void TestMethod() { var rep = GetRequiredService\u0026lt;IHospitalRepository\u0026gt;(); var mgr = GetRequiredService\u0026lt;IUnitOfWorkManager\u0026gt;(); using (var uow = mgr.Begin()) { var count = rep.Count(); uow.Complete(); } } ","date":"2019-10-15T13:12:10Z","permalink":"https://real-zony.github.io/p/why-does-abp-vnext-throw-an-exception-if-it-does-not-use-the-unit-of-work/","title":"ABP vNext 不使用工作单元为什么会抛出异常"},{"content":"一、简要说明 ABP vNext 当中的审计模块早在 **依赖注入与拦截器**一文中有所提及，但没有详细的对其进行分析。\n审计模块是 ABP vNext 框架的一个基本组件，它能够提供一些实用日志记录。不过这里的日志不是说系统日志，而是说接口每次调用之后的执行情况（执行时间、传入参数、异常信息、请求 IP）。\n除了常规的日志功能以外，关于 实体 和 聚合 的审计字段接口也是存放在审计模块当中的。（创建人、创建时间、修改人、修改时间、删除人、删除时间）\n二、源码分析 2.1. 审计日志拦截器 2.1.1 审计日志拦截器的注册 Volo.Abp.Auditing 的模块定义十分简单，主要是提供了 审计日志拦截器 的注册功能。下面代码即在组件注册的时候，会调用 AuditingInterceptorRegistrar.RegisterIfNeeded 方法来判定是否为实现类型(ImplementationType) 注入审计日志拦截器。\n1 2 3 4 5 6 7 public class AbpAuditingModule : AbpModule { public override void PreConfigureServices(ServiceConfigurationContext context) { context.Services.OnRegistred(AuditingInterceptorRegistrar.RegisterIfNeeded); } } 跳转到具体的实现，可以看到内部会结合三种类型进行判断。分别是 AuditedAttribute 、IAuditingEnabled、DisableAuditingAttribute 。\n前两个作用是，只要类型标注了 AuditedAttribute 特性，或者是实现了 IAuditingEnable 接口，都会为该类型注入审计日志拦截器。\n而 DisableAuditingAttribute 类型则相反，只要类型上标注了该特性，就不会启用审计日志拦截器。某些接口需要 提升性能 的话，可以尝试使用该特性禁用掉审计日志功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public static class AuditingInterceptorRegistrar { public static void RegisterIfNeeded(IOnServiceRegistredContext context) { // 满足条件时，将会为该类型注入审计日志拦截器。 if (ShouldIntercept(context.ImplementationType)) { context.Interceptors.TryAdd\u0026lt;AuditingInterceptor\u0026gt;(); } } private static bool ShouldIntercept(Type type) { // 首先判断类型上面是否使用了辅助类型。 if (ShouldAuditTypeByDefault(type)) { return true; } // 如果任意方法上面标注了 AuditedAttribute 特性，则仍然为该类型注入拦截器。 if (type.GetMethods().Any(m =\u0026gt; m.IsDefined(typeof(AuditedAttribute), true))) { return true; } return false; } //TODO: Move to a better place public static bool ShouldAuditTypeByDefault(Type type) { // 下面就是根据三种辅助类型进行判断，是否为当前 type 注入审计日志拦截器。 if (type.IsDefined(typeof(AuditedAttribute), true)) { return true; } if (type.IsDefined(typeof(DisableAuditingAttribute), true)) { return false; } if (typeof(IAuditingEnabled).IsAssignableFrom(type)) { return true; } return false; } } 2.1.2 审计日志拦截器的实现 审计日志拦截器的内部实现，主要使用了三个类型进行协同工作。它们分别是负责管理审计日志信息的 IAuditingManager，负责创建审计日志信息的 IAuditingHelper，还有统计接口执行时常的 Stopwatch 。\n整个审计日志拦截器的大体流程如下：\n首先是判定 MVC 审计日志过滤器是否进行处理。 再次根据特性，和类型进行二次验证是否应该创建审计日志信息。 根据调用信息，创建 AuditLogInfo 和 AuditLogActionInfo 审计日志信息。 调用 StopWatch 的计时方法，如果出现了异常则将异常信息添加到刚才构建的 AuditLogInfo 对象中。 无论是否出现异常，都会进入 finally 语句块，这个时候会调用 StopWatch 实例的停止方法，并统计完成执行时间。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public override async Task InterceptAsync(IAbpMethodInvocation invocation) { if (!ShouldIntercept(invocation, out var auditLog, out var auditLogAction)) { await invocation.ProceedAsync(); return; } // 开始进行计时操作。 var stopwatch = Stopwatch.StartNew(); try { await invocation.ProceedAsync(); } catch (Exception ex) { // 如果出现了异常，一样的将异常信息添加到审计日志结果中。 auditLog.Exceptions.Add(ex); throw; } finally { // 统计完成，并将信息加入到审计日志结果中。 stopwatch.Stop(); auditLogAction.ExecutionDuration = Convert.ToInt32(stopwatch.Elapsed.TotalMilliseconds); auditLog.Actions.Add(auditLogAction); } } 可以看到，只有当 ShouldIntercept() 方法返回 true 的时候，下面的统计等操作才会被执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 protected virtual bool ShouldIntercept( IAbpMethodInvocation invocation, out AuditLogInfo auditLog, out AuditLogActionInfo auditLogAction) { auditLog = null; auditLogAction = null; if (AbpCrossCuttingConcerns.IsApplied(invocation.TargetObject, AbpCrossCuttingConcerns.Auditing)) { return false; } // 如果没有获取到 Scop，则返回 false。 var auditLogScope = _auditingManager.Current; if (auditLogScope == null) { return false; } // 进行二次判断是否需要存储审计日志。 if (!_auditingHelper.ShouldSaveAudit(invocation.Method)) { return false; } // 构建审计日志信息。 auditLog = auditLogScope.Log; auditLogAction = _auditingHelper.CreateAuditLogAction( auditLog, invocation.TargetObject.GetType(), invocation.Method, invocation.Arguments ); return true; } 2.2 审计日志的持久化 大体流程和我们上面说的一样，不过好像缺少了重要的一步，那就是 持久化操作。你可以在 Volo.Abp.Auditing 模块发现有 IAuditingStore 接口的定义，但是它的 SaveAsync() 方法却没有在拦截器内部被调用。同样在 MVC 的审计日志过滤器实现，你也会发现没有调用持久化方法。\n那么我们的审计日志是在什么时候被持久化的呢？找到 SaveAsync() 被调用的地方，发现 ABP vNext 实现了一个审计日志的 ASP.NET Core 中间件。\n在这个中间件内部的实现比较简单，首先通过一个判定方法，决定是否为本次请求执行 IAuditingManager.BeginScope() 方法。如果判定通过，则执行，否则不仅行任何操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public async Task InvokeAsync(HttpContext context, RequestDelegate next) { if (!ShouldWriteAuditLog(context)) { await next(context); return; } using (var scope = _auditingManager.BeginScope()) { try { await next(context); } finally { await scope.SaveAsync(); } } } 可以看到，在这里 ABP vNext 使用 IAuditingManager 构建，调用其 BeginScope() 构建了一个 IAuditLogSaveHandle 对象，并使用其提供的 SaveAsync() 方法进行持久化操作。\n2.2.1 嵌套的持久化操作 在构造出来的 IAuditLogSaveHandle 对象里面，还是使用的 IAuditingManager 的默认实现 AuditingManager 所提供的 SaveAsync() 方法进行持久化。\n阅读源码之后，发现了下面两个问题：\nIAuditingManager 没有将持久化方法公开 出来，而是作为一个 protected 级别的方法。 为什么还要借助 IAuditLogSaveHandle 间接地调用 管理器的持久化方法。 这就要从中间件的代码说起了，可以看到它是构造出了一个可以被释放的 IAuditLogSaveHandle 对象。ABP vNext 这样做的目的，就是可以嵌套多个 Scope，即 只在某个范围内 才将审计日志记录下来。这种特性类似于 工作单元 的用法，其底层实现是 之前文章 讲过的 IAmbientScopeProvider 对象。\n例如在某个应用服务内部，我可以这样写代码：\n1 2 3 4 5 6 7 8 9 10 using (var scope = _auditingManager.BeginScope()) { await myAuditedObject1.DoItAsync(new InputObject { Value1 = \u0026#34;我是内部嵌套测试方法1。\u0026#34;, Value2 = 5000 }); using (var scope2 = _auditingManager.BeginScope()) { await myAuditedObject1.DoItAsync(new InputObject {Value1 = \u0026#34;我是内部嵌套测试方法2。\u0026#34;, Value2 = 10000}); await scope2.SaveAsync(); } await scope.SaveAsync(); } 想一下之前的代码，在拦截器内部，我们是通过 IAuditingManager.Current 拿到当前可用的 IAuditLogScope ，而这个 Scope 就是在调用 IAuditingManager.BeginScope() 之后生成的。\n2.2.3 最终的持久化代码 通过上述的流程，我们得知最后的审计日志信息会通过 IAuditingStore 进行持久化。ABP vNext 为我们提供了一个默认的 SimpleLogAuditingStore 实现，其内部就是调用 ILogger 将信息输出。如果需要将审计日志持久化到数据库，你可以实现 IAUditingStore 接口，覆盖原有实现 ，或者使用 ABP vNext 提供的 Volo.Abp.AuditLogging 模块。\n2.3 审计日志的序列化 审计日志的序列化处理是在 IAuditingHelper 的默认实现内部被使用，可以看到构建审计日志的方法内部，通过自定义的序列化器来将 Action 的参数进行序列化处理，方便存储。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public virtual AuditLogActionInfo CreateAuditLogAction( AuditLogInfo auditLog, Type type, MethodInfo method, IDictionary\u0026lt;string, object\u0026gt; arguments) { var actionInfo = new AuditLogActionInfo { ServiceName = type != null ? type.FullName : \u0026#34;\u0026#34;, MethodName = method.Name, // 序列化参数信息。 Parameters = SerializeConvertArguments(arguments), ExecutionTime = Clock.Now }; //TODO Execute contributors return actionInfo; } protected virtual string SerializeConvertArguments(IDictionary\u0026lt;string, object\u0026gt; arguments) { try { if (arguments.IsNullOrEmpty()) { return \u0026#34;{}\u0026#34;; } var dictionary = new Dictionary\u0026lt;string, object\u0026gt;(); foreach (var argument in arguments) { // 忽略的代码，主要作用是构建参数字典。 } // 调用序列化器，序列化 Action 的调用参数。 return AuditSerializer.Serialize(dictionary); } catch (Exception ex) { Logger.LogException(ex, LogLevel.Warning); return \u0026#34;{}\u0026#34;; } } 下面就是具体序列化器的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class JsonNetAuditSerializer : IAuditSerializer, ITransientDependency { protected AbpAuditingOptions Options; public JsonNetAuditSerializer(IOptions\u0026lt;AbpAuditingOptions\u0026gt; options) { Options = options.Value; } public string Serialize(object obj) { // 使用 JSON.NET 进行序列化操作。 return JsonConvert.SerializeObject(obj, GetSharedJsonSerializerSettings()); } // ... 省略的代码。 } 2.4 审计日志的配置参数 针对审计日志相关的配置参数的定义，都存放在 AbpAuditingOptions 当中。下面我会针对各个参数的用途，对其进行详细的说明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class AbpAuditingOptions { //TODO: Consider to add an option to disable auditing for application service methods? // 该参数目前版本暂未使用，为保留参数。 public bool HideErrors { get; set; } // 是否启用审计日志功能，默认值为 true。 public bool IsEnabled { get; set; } // 审计日志的应用程序名称，默认值为 null，主要在构建 AuditingInfo 被使用。 public string ApplicationName { get; set; } // 是否为匿名请求记录审计日志默认值 true。 public bool IsEnabledForAnonymousUsers { get; set; } // 审计日志功能的协作者集合，默认添加了 AspNetCoreAuditLogContributor 实现。 public List\u0026lt;AuditLogContributor\u0026gt; Contributors { get; } // 默认的忽略类型，主要在序列化时使用。 public List\u0026lt;Type\u0026gt; IgnoredTypes { get; } // 实体类型选择器。 public IEntityHistorySelectorList EntityHistorySelectors { get; } //TODO: Move this to asp.net core layer or convert it to a more dynamic strategy? // 是否为 Get 请求记录审计日志，默认值 false。 public bool IsEnabledForGetRequests { get; set; } public AbpAuditingOptions() { IsEnabled = true; IsEnabledForAnonymousUsers = true; HideErrors = true; Contributors = new List\u0026lt;AuditLogContributor\u0026gt;(); IgnoredTypes = new List\u0026lt;Type\u0026gt; { typeof(Stream), typeof(Expression) }; EntityHistorySelectors = new EntityHistorySelectorList(); } } 2.4 实体相关的审计信息 在文章开始就谈到，除了对 HTTP 请求有审计日志记录以外，ABP vNext 还提供了实体审计信息的记录功能。所谓的实体的审计信息，指的就是实体继承了 ABP vNext 提供的接口之后，ABP vNext 会自动维护实现的接口字段，不需要开发人员自己再进行处理。\n这些接口包括创建实体操作的相关信息 IHasCreationTime、IMayHaveCreator、ICreationAuditedObject 以及删除实体时，需要记录的相关信息接口 IHasDeletionTime、IDeletionAuditedObject 等。除了审计日志模块定义的类型以外，在 Volo.Abp.Ddd.Domain 模块的 Auditing 里面也有很多审计实体的默认实现。\n我在这里就不再一一列举，下面仅快速讲解一下 ABP vNext 是如何通过这些接口，实现对审计字段的自动维护的。\n在审计日志模块的内部，我们看到一个接口名字叫做 IAuditPropertySetter，它提供了三个方法，分别是：\n1 2 3 4 5 6 7 8 public interface IAuditPropertySetter { void SetCreationProperties(object targetObject); void SetModificationProperties(object targetObject); void SetDeletionProperties(object targetObject); } 所以，这几个方法就是用于设置创建信息、修改信息、删除信息的。现在跳转到默认实现 AuditPropertySetter，随便找一个 SetCreationTime() 方法。该方法内部首先是判断传入的 object 是否实现了 IHasCreationTime 接口，如果实现了对其进行强制类型转换，然后赋值即可。\n1 2 3 4 5 6 7 8 9 10 11 12 private void SetCreationTime(object targetObject) { if (!(targetObject is IHasCreationTime objectWithCreationTime)) { return; } if (objectWithCreationTime.CreationTime == default) { objectWithCreationTime.CreationTime = Clock.Now; } } 其他几个 Set 方法大同小异，那我们看一下有哪些地方使用到了上述三个方法。\n可以看到使用者就包含有 EF Core 模块和 MongoDB 模块，这里我以 EF Core 模块为例，猜测应该是传入了实体对象过来。\n果不其然\u0026hellip;查看这个方法的调用链，发现是 DbContext 每次进行 SaveChanges/SaveChangesAsync 的时候，就会对实体进行审计字段自动赋值操作。\n三、总结 审计日志是 ABP vNext 为我们提供的一个可选组件，当开启审计日志功能后，我们可以根据审计日志信息快速定位问题。但审计日志的开启，也会较大的影响性能，因为每次请求都会创建审计日志信息，之后再进行持久化。因此在使用审计日志功能时，可以结合 DisableAuditingAttribute 特性和 IAuditingManager.BeginScope()，按需开启审计日志功能。\n","date":"2019-10-08T03:53:07Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---8-audit-log/","title":"Abp vNext 源码分析 - 8. 审计日志"},{"content":"随着项目的不断增多，最开始单体项目手动执行 docker build 命令，手动发布项目就不再适用了。一两个项目可能还吃得消，10 多个项目每天让你构建一次还是够呛。即便你的项目少，每次花费在发布上面的时间累计起来都够你改几个 BUG 了。\n所以我们需要自动化这个流程，让项目的发布和测试不再这么繁琐。在这里我使用了 Jenkins 作为基础的 CI/CD Pipeline 工具，关于 Jenkins 的具体介绍这里就不再赘述。在版本管理、构建项目、单元测试、集成测试、环境部署我分别使用到了 Gogs、Docker、Docker Swarm(已与 Docker 整合) 这几个软件协同工作。\n以下步骤我参考了 Continuous Integration with Jenkins and Docker 一文，并使用了作者提供的 groovy 文件和 slave.py 文件。\n关于 Docker-CE 的安装，请参考我的另一篇博文 《Linux 下的 Docker 安装与使用》 。\n一、Jenkins 的部署 既然都用了 Docker，我是不想在实体机上面安装一堆环境，所以我使用了 Docker 的形式来部署 Jenkins 的 Master 和 Slave，省时省力。Master 就是调度管道任务的主机，也是唯一有 UI 供用户操作的。而 Slave 就是具体的工作节点，用于执行具体的管道任务。\n1.1 构建 Master 镜像 第一步，我们在主机上建立一个 master 文件夹，并使用 vi 创建两个 groovy 文件，这两个文件在后面的 Dockerfile 会被使用到，下面是 default-user.groovy 文件的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import jenkins.model.* import hudson.security.* def env = System.getenv() def jenkins = Jenkins.getInstance() jenkins.setSecurityRealm(new HudsonPrivateSecurityRealm(false)) jenkins.setAuthorizationStrategy(new GlobalMatrixAuthorizationStrategy()) def user = jenkins.getSecurityRealm().createAccount(env.JENKINS_USER, env.JENKINS_PASS) user.save() jenkins.getAuthorizationStrategy().add(Jenkins.ADMINISTER, env.JENKINS_USER) jenkins.save() 接着再用 vi 创建一个新的 executors.groovy 文件，并输入以下内容：\n1 2 import jenkins.model.* Jenkins.instance.setNumExecutors(0) 以上动作完成之后，在 master 文件夹下面应该有两个 groovy 文件。\n两个 master 所需要的 groovy 文件已经编写完成，下面来编写 master 镜像的 Dockerfile 文件，每一步的作用我已经用中文进行了标注。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 使用官方的 Jenkins 镜像作为基础镜像。 FROM jenkins/jenkins:latest # 使用内置的 install-plugins.sh 来安装插件。 RUN /usr/local/bin/install-plugins.sh git matrix-auth workflow-aggregator docker-workflow blueocean credentials-binding # 设置 Jenkins 的管理员账户和密码。 ENV JENKINS_USER admin ENV JENKINS_PASS admin # 跳过初始化安装向导。 ENV JAVA_OPTS -Djenkins.install.runSetupWizard=false # 将刚刚编写的两个 groovy 脚本复制到初始化文件夹内。 COPY executors.groovy /usr/share/jenkins/ref/init.groovy.d/ COPY default-user.groovy /usr/share/jenkins/ref/init.groovy.d/ # 挂载 jenkins_home 目录到 Docker 卷。 VOLUME /var/jenkins_home 接着我们通过命令构建出 Master 镜像。\n1 docker build -t jenkins-master . 1.2 构建 Slave 镜像 Slave 镜像的核心是一个 slave.py 的 python 脚本，它主要执行的动作是运行 slave.jar 并和 Master 建立通信，这样你的管道任务就能够交给 Slave 进行执行。这个脚本所做的工作流程如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 st=\u0026gt;start: 脚本执行 stop=\u0026gt;end: 容器停止 op1=\u0026gt;operation: 导入 \u0026#34;jenkins\u0026#34; 的 python 模块 op2=\u0026gt;operation: 等待 Master 启动 cond1=\u0026gt;condition: Master 是否可用 op3=\u0026gt;operation: 下载 slave.jar 文件到容器内 op4=\u0026gt;operation: 通过 JLNP 连接到 Master 节点 op5=\u0026gt;operation: 使用凭据通过授权验证 op6=\u0026gt;operation: 成功运行 Slave st-\u0026gt;op1-\u0026gt;op2-\u0026gt;cond1 cond1(no)-\u0026gt;op2 cond1(yes)-\u0026gt;op3-\u0026gt;op4-\u0026gt;op5-\u0026gt;op6-\u0026gt;stop 我们再建立一个 slave 文件夹，并使用 vi 将 python 脚本复制进去。\nslave.py 的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 from jenkins import Jenkins, JenkinsError, NodeLaunchMethod import os import signal import sys import urllib import subprocess import shutil import requests import time slave_jar = \u0026#39;/var/lib/jenkins/slave.jar\u0026#39; slave_name = os.environ[\u0026#39;SLAVE_NAME\u0026#39;] if os.environ[\u0026#39;SLAVE_NAME\u0026#39;] != \u0026#39;\u0026#39; else \u0026#39;docker-slave-\u0026#39; + os.environ[\u0026#39;HOSTNAME\u0026#39;] jnlp_url = os.environ[\u0026#39;JENKINS_URL\u0026#39;] + \u0026#39;/computer/\u0026#39; + slave_name + \u0026#39;/slave-agent.jnlp\u0026#39; slave_jar_url = os.environ[\u0026#39;JENKINS_URL\u0026#39;] + \u0026#39;/jnlpJars/slave.jar\u0026#39; print(slave_jar_url) process = None def clean_dir(dir): for root, dirs, files in os.walk(dir): for f in files: os.unlink(os.path.join(root, f)) for d in dirs: shutil.rmtree(os.path.join(root, d)) def slave_create(node_name, working_dir, executors, labels): j = Jenkins(os.environ[\u0026#39;JENKINS_URL\u0026#39;], os.environ[\u0026#39;JENKINS_USER\u0026#39;], os.environ[\u0026#39;JENKINS_PASS\u0026#39;]) j.node_create(node_name, working_dir, num_executors = int(executors), labels = labels, launcher = NodeLaunchMethod.JNLP) def slave_delete(node_name): j = Jenkins(os.environ[\u0026#39;JENKINS_URL\u0026#39;], os.environ[\u0026#39;JENKINS_USER\u0026#39;], os.environ[\u0026#39;JENKINS_PASS\u0026#39;]) j.node_delete(node_name) def slave_download(target): if os.path.isfile(slave_jar): os.remove(slave_jar) loader = urllib.URLopener() loader.retrieve(os.environ[\u0026#39;JENKINS_URL\u0026#39;] + \u0026#39;/jnlpJars/slave.jar\u0026#39;, \u0026#39;/var/lib/jenkins/slave.jar\u0026#39;) def slave_run(slave_jar, jnlp_url): params = [ \u0026#39;java\u0026#39;, \u0026#39;-jar\u0026#39;, slave_jar, \u0026#39;-jnlpUrl\u0026#39;, jnlp_url ] if os.environ[\u0026#39;JENKINS_SLAVE_ADDRESS\u0026#39;] != \u0026#39;\u0026#39;: params.extend([ \u0026#39;-connectTo\u0026#39;, os.environ[\u0026#39;JENKINS_SLAVE_ADDRESS\u0026#39; ] ]) if os.environ[\u0026#39;SLAVE_SECRET\u0026#39;] == \u0026#39;\u0026#39;: params.extend([ \u0026#39;-jnlpCredentials\u0026#39;, os.environ[\u0026#39;JENKINS_USER\u0026#39;] + \u0026#39;:\u0026#39; + os.environ[\u0026#39;JENKINS_PASS\u0026#39;] ]) else: params.extend([ \u0026#39;-secret\u0026#39;, os.environ[\u0026#39;SLAVE_SECRET\u0026#39;] ]) return subprocess.Popen(params, stdout=subprocess.PIPE) def signal_handler(sig, frame): if process != None: process.send_signal(signal.SIGINT) signal.signal(signal.SIGINT, signal_handler) signal.signal(signal.SIGTERM, signal_handler) def master_ready(url): try: r = requests.head(url, verify=False, timeout=None) return r.status_code == requests.codes.ok except: return False while not master_ready(slave_jar_url): print(\u0026#34;Master not ready yet, sleeping for 10sec!\u0026#34;) time.sleep(10) slave_download(slave_jar) print \u0026#39;Downloaded Jenkins slave jar.\u0026#39; if os.environ[\u0026#39;SLAVE_WORING_DIR\u0026#39;]: os.setcwd(os.environ[\u0026#39;SLAVE_WORING_DIR\u0026#39;]) if os.environ[\u0026#39;CLEAN_WORKING_DIR\u0026#39;] == \u0026#39;true\u0026#39;: clean_dir(os.getcwd()) print \u0026#34;Cleaned up working directory.\u0026#34; if os.environ[\u0026#39;SLAVE_NAME\u0026#39;] == \u0026#39;\u0026#39;: slave_create(slave_name, os.getcwd(), os.environ[\u0026#39;SLAVE_EXECUTORS\u0026#39;], os.environ[\u0026#39;SLAVE_LABELS\u0026#39;]) print \u0026#39;Created temporary Jenkins slave.\u0026#39; process = slave_run(slave_jar, jnlp_url) print \u0026#39;Started Jenkins slave with name \u0026#34;\u0026#39; + slave_name + \u0026#39;\u0026#34; and labels [\u0026#39; + os.environ[\u0026#39;SLAVE_LABELS\u0026#39;] + \u0026#39;].\u0026#39; process.wait() print \u0026#39;Jenkins slave stopped.\u0026#39; if os.environ[\u0026#39;SLAVE_NAME\u0026#39;] == \u0026#39;\u0026#39;: slave_delete(slave_name) print \u0026#39;Removed temporary Jenkins slave.\u0026#39; 上述脚本的工作基本与流程图的一致，因为 Jenkins 针对 Python 提供了 SDK ，所以原作者使用 Python 来编写的 “代理” 程序。不过 Jenkins 也有 RESTful API，你也可以使用 .NET Core 编写类似的 “代理” 程序。\n接着我们来编写 Slave 镜像的 Dockerfile 文件，因为国内服务器访问 Ubuntu 的源很慢，经常因为超时导致构建失败，这里切换成了阿里云的源，其内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 FROM ubuntu:16.04 # 安装 Docker CLI。 RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list \u0026amp;\u0026amp; apt-get clean RUN apt-get update --fix-missing \u0026amp;\u0026amp; apt-get install -y apt-transport-https ca-certificates curl openjdk-8-jre python python-pip git # 使用阿里云的镜像源。 RUN curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - RUN echo \u0026#34;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial stable\u0026#34; \u0026gt; /etc/apt/sources.list.d/docker.list RUN apt-get update --fix-missing \u0026amp;\u0026amp; apt-get install -y docker-ce --allow-unauthenticated RUN easy_install jenkins-webapi # 安装 Docker-Compose 工具。 RUN curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose \u0026amp;\u0026amp; chmod +x /usr/local/bin/docker-compose RUN mkdir -p /home/jenkins RUN mkdir -p /var/lib/jenkins # 将 slave.py 文件添加到容器。 ADD slave.py /var/lib/jenkins/slave.py WORKDIR /home/jenkins # 配置 Jenkins Master 的一些连接参数和 Slave 信息。 ENV JENKINS_URL \u0026#34;http://jenkins\u0026#34; ENV JENKINS_SLAVE_ADDRESS \u0026#34;\u0026#34; ENV JENKINS_USER \u0026#34;admin\u0026#34; ENV JENKINS_PASS \u0026#34;admin\u0026#34; ENV SLAVE_NAME \u0026#34;\u0026#34; ENV SLAVE_SECRET \u0026#34;\u0026#34; ENV SLAVE_EXECUTORS \u0026#34;1\u0026#34; ENV SLAVE_LABELS \u0026#34;docker\u0026#34; ENV SLAVE_WORING_DIR \u0026#34;\u0026#34; ENV CLEAN_WORKING_DIR \u0026#34;true\u0026#34; CMD [ \u0026#34;python\u0026#34;, \u0026#34;-u\u0026#34;, \u0026#34;/var/lib/jenkins/slave.py\u0026#34; ] 继续使用 docker build 构建 Slave 镜像：\n1 docker build -t jenkins-slave . 1.3 编写 Docker Compose 文件 这里的 Docker Compose 文件，我取名叫 docker-compose.jenkins.yaml ，主要工作是为了启动 Master 和 Slave 容器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 version: \u0026#39;3.1\u0026#39; services: jenkins: container_name: jenkins ports: - \u0026#39;8080:8080\u0026#39; - \u0026#39;50000:50000\u0026#39; image: jenkins-master jenkins-slave: container_name: jenkins-slave restart: always environment: - \u0026#39;JENKINS_URL=http://jenkins:8080\u0026#39; image: jenkins-slave volumes: - /var/run/docker.sock:/var/run/docker.sock # 将宿主机的 Docker Daemon 挂载到容器内部。 - /home/jenkins:/home/jenkins # 将数据挂载出来，方便后续进行释放。 depends_on: - jenkins 执行 Docker Compose 之后，我们通过 宿主机 IP:8080 就可以访问到 Jenkins 内部了，如下图。\n二、Gogs 的部署 我们内部开发使用的 Git 仓库是使用 Gogs 进行搭建的，Gogs 官方提供了 Docker 镜像，那我们可以直接编写一个 Docker Compose 快速部署 Gogs。\ndocker-compose.gogs.yaml 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 version: \u0026#39;3.1\u0026#39; services: gogs: image: gogs/gogs container_name: \u0026#39;gogs\u0026#39; expose: - \u0026#39;3000:3000\u0026#39; expose: - 22 volumes: - /var/lib/docker/Persistence/Gogs:/data\t# 挂载数据卷。 restart: always 执行以下命令后，即可启动 Gogs 程序，访问 宿主机 IP:3000 按照配置说明安装 Gogs 即可，之后你就可以创建远程仓库了。\n三、Gogs 与 Jenkins 的集成 虽然大部分都推荐 Jenkins 的 Gogs Webhook 插件，不过这个插件很久不更新了，而且不支持 版本发布 事件。针对于该问题虽然官方有 PR #62，但一直没有合并，等到合并的时候都是猴年马月了。这里还是建议使用 Generic Webhook Trigger ，用这个插件来触发 Jenkins 的管道任务。\n3.1 创建流水线项目 首先找到 Jenkins 的插件中心，搜索 Generic Webhook Trigger 插件，并进行安装。\n继续新建一个管道任务，取名叫做 TestProject，类型选择 Pipeline 。\n首先配置项目的数据来源，选择 SCM，并且配置 Git 远程仓库的地址，如果是私有仓库则还需要设置用户名和密码。\n3.2 Jenkins 的 Webhook 配置 流水线项目建立完成后，我们就可以开始设置 Generic WebHook Trigger 的一些参数，以便让远程的 Gogs 能够触发构建任务。\n我们为 TestProject 创建一个 Token，这个 Token 是跟流水线任务绑定了，说白了就是流水线任务的一个标识。建议使用随机 Guid 作为 Token，不然其他人都可以随便触发你的流水线任务进行构建了。\n3.3 Gogs 的 Webhook 配置 接着来到刚刚我们建好的仓库，找到 仓库设置-\u0026gt;管理 Web 钩子-\u0026gt;添加 Web 钩子-\u0026gt;Gogs 。\n因为触发构建不可能每次提交都触发，一般来说都是创建了某个合并请求，或者发布新版本的时候就会触发流水线任务。因此这里你可以根据自己的情况来选择触发事件，这里我以合并请求为例，你可以在钩子设置页面点击 测试推送。这样就可以看到 Gogs 发送给 Jenkins 的 JSON 结构是怎样的，你就能够在 Jenkins 那边有条件的进行处理。\n不过测试推送只能够针对普通的 push 事件进行测试，像 合并请求 或者 版本发布 这种事件只能自己模拟操作了。在这里我新建了一个用户，Fork 了另一个帐号建立的 TestProject 仓库。\n在 Fork 的仓库里面，我新建了一个 Readme.md 文件，然后点击创建合并，这个时候你看 Gogs 的 WebHook 推送记录就有一条新的数据推送给 Jenkins，同时你也可以在 Jenkins 看到流水线任务被触发了。\n3.4 限定任务触发条件 通过上面的步骤，我们已经将 Gogs 和 Jenkins 中的具体任务进行了绑定。不过还有一个比较尴尬的问题是，Gogs 的合并事件不仅仅包括创建合并，它的原始描述是这样说的。\n合并请求事件包括合并被开启、关闭、重新开启、编辑、指派、取消指派、更新标签、清除标签、设置里程碑、取消设置里程碑或代码同步。\n如果我们仅仅是依靠上面的配置，那么上述所有行为都会触发构建操作，这肯定不是我们想要的效果。还好 Generic Webhook 为我们提供了变量获取，以及 Webhook 过滤。\n我们从 Gogs 发往 Jenkins 的请求中可以看到，在 JSON 内部包含了一个 action 字段，里面就是本次的操作标识。那么我们就可以想到通过判断 action 字段是否等于 opened 来触发流水线任务。\n首先，我们增加 4 个 Post content parameters 参数，分别获取到 Gogs 传递过来的 action 和 PR 的 Id，这里我解释一下几个文本框的意思。\n除了这两个 Post 参数以外，在请求头中，Gogs 还携带了具体事件，我们将其一起作为过滤条件。需要注意的是，针对于请求头的参数，在转换成变量时，插件会将字符转为小写，并会使用 \u0026lsquo;_\u0026rsquo; 代替 \u0026lsquo;-\u0026rsquo;。\n最后我们编写一个 Optional filter ，它的 Expression 参数是正则表达式，下面的 Text 即是源字符串。实现很简单，当 Text 里面的内容满足正则表达式的时候，就会触发流水线任务。\n所以我们的 Text 字符串就是由上面三个变量的值组成，然后和我们预期的值进行匹配即可。\n当然，你还想整一些更加炫酷的功能，可以使用 Jenkins 提供的 Http Request 之类的插件。因为 Gogs 提供了 API 接口，你就可以在构建完成之后，回写给 Gogs，用于提示构建结果。\n这样的话，这种功能就有点像 Github 上面的机器人帐号了。\n四、完整的项目示例 在上一节我们通过 Jenkins 的插件完成了远程仓库推送通知，当我们合并代码时，Jenkins 会自动触发执行我们的管道任务。接下来我将建立一个 .NET Core 项目，该项目拥有一个 Controller，接收到请求之后输出 “Hello World”。随后为该项目建立一个 xUnit 的测试项目，用于执行单元测试。\n整个项目的结构如下图：\n我们需要编写一个 UnitTest.Dockerfile 镜像，用于执行 xUnit 单元测试。\n1 2 3 4 5 6 7 8 FROM mcr.microsoft.com/dotnet/core/sdk:2.2 # 还原 NuGet 包。 WORKDIR /home/app COPY ./ ./ RUN dotnet restore ENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;test\u0026#34; , \u0026#34;--verbosity=normal\u0026#34;] 之后为部署操作编写一个 Deploy.Dockerfile ，这个 Dockerfile 首先还原了 NuGet 包，然后通过 dotnet publish 命令发布了我们的网站。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 FROM mcr.microsoft.com/dotnet/core/sdk:2.2 as build-image # 还原 NuGet 包。 WORKDIR /home/app COPY ./ ./ RUN dotnet restore # 发布镜像。 COPY ./ ./ RUN dotnet publish ./TestProject.WebApi/TestProject.WebApi.csproj -o /publish/ FROM mcr.microsoft.com/dotnet/core/aspnet:2.2 WORKDIR /publish COPY --from=build-image /publish . ENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;TestProject.WebApi.dll\u0026#34;] 两个 Dockerfile 编写完成之后，将其存放在项目的根目录，以便 Slave 进行构建。\nDockerfile 编写好了，那么我们还要分别为两个镜像编写 Docker Compose 文件，用于执行单元测试和部署行为，用于部署的文件名称叫做 docker-compose.Deploy.yaml，内容如下：\n1 2 3 4 5 6 7 8 9 version: \u0026#39;3.1\u0026#39; services: backend: container_name: dev-test-backend image: dev-test:B${BUILD_NUMBER} ports: - \u0026#39;5000:5000\u0026#39; restart: always 然后我们需要编写运行单元测试的 Docker Compose 文件，名字叫做 docker-compose.UnitTest.yaml，内容如下：\n1 2 3 4 5 6 version: \u0026#39;3.1\u0026#39; services: backend: container_name: dev-test-unit-test image: dev-test:TEST${BUILD_NUMBER} 五、编写 Jenkinsfile 1 2 3 4 5 6 7 8 9 10 11 12 node(\u0026#39;docker\u0026#39;) { stage \u0026#39;签出代码\u0026#39; checkout scm stage \u0026#39;单元测试\u0026#39; sh \u0026#34;docker build -t dev-test:TEST${BUILD_NUMBER} -f UnitTest.Dockerfile .\u0026#34; sh \u0026#34;docker-compose -f docker-compose.UnitTest.yaml up --force-recreate --abort-on-container-exit\u0026#34; sh \u0026#34;docker-compose -f docker-compose.UnitTest.yaml down -v\u0026#34; stage \u0026#39;部署项目\u0026#39; sh \u0026#34;docker build -t dev-test:B${BUILD_NUMBER} -f Deploy.Dockerfile .\u0026#34; sh \u0026#39;docker-compose -f docker-compose.Deploy.yaml up -d\u0026#39; } 六、最后的效果 上述操作完成之后，将这些文件放在项目根目录。\n回到 Jenkins，你可以手动执行一下任务，然后项目就被成功执行了。\n至此，我们的 “低配版” CI、CD 环境就搭建成功了。\n","date":"2019-09-25T04:42:11Z","permalink":"https://real-zony.github.io/p/jenkins-combines-docker-to-implement-low-level-ci/","title":"Jenkins 结合 Docker 实现低配版的 CI\u0026CD"},{"content":"一、问题 新项目是基于 ABP vNext 框架进行开发的，所以我要求为每层编写单元测试。在同事为某个仓储编写单元测试的时候，发现了一个奇怪的问题。他的对某个聚合根的 A 字段进行了更新，随后对某个导航属性 B 也进行了变更，最后通过仓储提供的 UpdateAsync() 方法对变更的数据进行持久化。\n结果再次查出来的时候，发现聚合根的 A 字段倒是更新了，但是导航属性 B 的内部字段没有进行变更。例如在下面的实例当中，聚合根的 Name 字段变更成功，但是导航属性的 Street 字段变更失败了。\n二、原因 数据没有更新到，说明问题肯定出在 UpdateAsync 方法内部，通过打断点单步步入之后，也没发现有什么奇怪的地方，是使用的 ABP vNext 提供的默认仓储实现。\n又在想是否跟实体追踪有关，然后看同事写得单元测试代码，发现他是先使用的 GetAsync() 方法获取到实体，然后手动变更了实体的属性。变更完成之后，通过仓储提供的 UpdateAsync() 方法进行更新。\n看了很久发现它们并不是公用的一个工作单元，这就导致 GetAsync() 和 UpdateAsync() 方法内部得到的 DbContext 是不一样的。在 EF Core 内部针对这种情况，称之为 Disconnected entities 即断开连接的实体，这个时候需要用户手动 Attch 追踪导航属性。\n三、解决 所以有两种解决办法，第一种方法是保证使用 GetAsync() 和 UpdateAsync() 方法时，它们都处于一个工作单元下，例如下面的伪代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private readonly IUnitOfWorkManager _uowMgr; private readonly IRepository\u0026lt;TestUser, Guid\u0026gt; _repository; [Fact] public async Task Resolve1() { // 创建初始数据。 var entityId = Guid.NewGuid(); await _repository.InsertAsync(new TestUser { Id = entityId, Name = \u0026#34;张三\u0026#34;, Address = new TestUserAddress { City = \u0026#34;成都市\u0026#34;, Street = \u0026#34;春熙路\u0026#34; } }); using (var outerUow = _uowMgr.Begin()) { var entity = await _repository.GetAsync(entityId); entity.Name = \u0026#34;李四\u0026#34;; entity.Address.Street = \u0026#34;琴台路\u0026#34;; await _repository.UpdateAsync(entity); await outerUow.CompleteAsync(); } // 最后查询街道是否成功修改。 var result = await _repository.GetAsync(entityId); result.Name.ShouldBe(\u0026#34;李四\u0026#34;); result.Address.Street.ShouldBe(\u0026#34;琴台路\u0026#34;); } 第二种方法变动则要大一些， 导航属性没有更新的根本原因，是因为在第二个工作单元中没有追踪到这个属性，你只需要手动附加该导航属性即可。在下面的例子中，我们重写了 UpdateAsync() 方法，手动跟踪导航属性，也能够达到上述效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class TestUserRepository : EfCoreRepository\u0026lt;XXXDbContext,TestUser,Guid\u0026gt; { public TestUserRepository(IDbContextProvider\u0026lt;XXXDbContext\u0026gt; dbContextProvider) : base(dbContextProvider) { } public override IQueryable\u0026lt;TestUser\u0026gt; WithDetails() { return GetQueryable().Include(x =\u0026gt; x.Address); } public override Task\u0026lt;TestUser\u0026gt; UpdateAsync(TestUser entity, bool autoSave = false, CancellationToken cancellationToken = new CancellationToken()) { DbContext.Attach(entity.Address).State = EntityState.Modified; return base.UpdateAsync(entity, autoSave, cancellationToken); } } 四、参考资料 StackOverflow - Entity Framework disconnected graph and navigation property MSDN - Disconnected entities ","date":"2019-09-18T02:54:17Z","permalink":"https://real-zony.github.io/p/a-problem-with-writing-repository-unit-tests-in-abp-vnext/","title":"在 ABP vNext 中编写仓储单元测试的问题一则"},{"content":"一、安装基本组件 首先执行 yum 命令来安装需要的 zsh 原始程序与 git 程序来 pull 代码。\n1 yum install -y zsh git 安装 oh my zsh 脚本 (这一步需要安装 git)。\n1 wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 使用 which zsh 查看 zsh 的安装目录，一般都存储在 /usr/bin/zsh 目录下。\n1 which zsh 使用 chsh 命令切换使用的 shell 程序。\n1 chsh -s /usr/bin/zsh 二、进行可选配置 2.1 安装 ZSH 图标字体 执行以下命令在当前目录拉取图标的仓库，并切换到其目录下，执行 ./install.sh 脚本即可安装成功。\n1 git clone https://github.com/powerline/fonts.git 2.2 更换 ZSH 主题 使用 vi 工具编辑 /root/.zshrc 文件，更改 ZSH_THEME=\u0026quot;robbyussell\u0026quot; 字段为 ZSH_THEME=\u0026quot;agnoster\u0026quot; 字段，并通过 source ~/.zshrc 命令更新它们的配置文件。\n2.3 安装插件 使用 ZSH 替换原有的 SHELL 最主要的原因就是要使用其功能强大的插件，这里只推荐安装三个插件，它们分别是 wd、zsh-syntax-highlighting、zsh-autosuggestions 。\n首先依次执行下列的命令，将后面两个插件的仓库克隆到 Oh My Zsh 的插件目录下。\n1 2 3 cd ~/.oh-my-zsh/custom/plugins git clone https://github.com/zsh-users/zsh-syntax-highlighting.git git clone https://github.com/zsh-users/zsh-autosuggestions.git 完成克隆操作之后，那么两个插件的全路径分别是：\n1 2 /root/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-syntax-highlighting.zsh /root/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh 继续使用 vi 编辑 ~/.zshrc 文件。\n1 2 3 4 5 6 7 8 9 10 11 12 # 其他内容 plugins=( git wd zsh-syntax-highlighting zsh-autosuggestions ) source /root/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh source /root/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh source $ZSH/oh-my-zsh.sh # 其他内容 编辑完成之后，执行 source ~/.zshrc 命令更新 ZSH 配置，最后的效果如下图。\n","date":"2019-08-26T11:46:52Z","permalink":"https://real-zony.github.io/p/install-zsh-terminal-on-centos-7x/","title":"CentOS 7.x 安装 ZSH 终端"},{"content":"一、简要说明 在上篇文章里面，我们在 ApplicationService 当中看到了权限检测代码，通过注入 IAuthorizationService 就可以实现权限检测。不过跳转到源码才发现，这个接口是 ASP.NET Core 原生提供的 “基于策略” 的权限验证接口，这就说明 ABP vNext 基于原生的授权验证框架进行了自定义扩展。\n让我们来看一下 Volo.Abp.Ddd.Application 项目的依赖结构(权限相关)。\n本篇文章下面的内容基本就会围绕上述框架模块展开，本篇文章通篇较长，因为还涉及到 .NET Core Identity 与 IdentityServer4 这两部分。关于这两部分的内容，我会在本篇文章大概讲述 ABP vNext 的实现，关于更加详细的内容，请查阅官方文档或其他博主的博客。\n二、源码分析 ABP vNext 关于权限验证和权限定义的部分，都存放在 Volo.Abp.Authorization 和 Volo.Abp.Security 模块内部。源码分析我都比较喜欢倒推，即通过实际的使用场景，反向推导 基础实现，所以后面文章编写的顺序也将会以这种方式进行。\n2.1 Security 基础组件库 这里我们先来到 Volo.Abp.Security，因为这个模块代码和类型都是最少的。这个项目都没有模块定义，说明里面的东西都是定义的一些基础组件。\n2.1.1 Claims 与 Identity 的快捷访问 先从第一个扩展方法开始，这个扩展方法里面比较简单，它主要是提供对 ClaimsPrincipal 和 IIdentity 的快捷访问方法。比如我要从 ClaimsPrincipal / IIdentity 获取租户 Id、用户 Id 等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static class AbpClaimsIdentityExtensions { public static Guid? FindUserId([NotNull] this ClaimsPrincipal principal) { Check.NotNull(principal, nameof(principal)); // 根据 AbpClaimTypes.UserId 查找对应的值。 var userIdOrNull = principal.Claims?.FirstOrDefault(c =\u0026gt; c.Type == AbpClaimTypes.UserId); if (userIdOrNull == null || userIdOrNull.Value.IsNullOrWhiteSpace()) { return null; } // 返回 Guid 对象。 return Guid.Parse(userIdOrNull.Value); } 2.1.2 未授权异常的定义 这个异常我们在老版本 ABP 里面也见到过，它就是 AbpAuthorizationException 。只要有任何未授权的操作，都会导致该异常被抛出。后面我们在讲解 ASP.NET Core MVC 的时候就会知道，在默认的错误码处理中，针对于程序抛出的 AbpAuthorizationException ，都会视为 403 或者 401 错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class DefaultHttpExceptionStatusCodeFinder : IHttpExceptionStatusCodeFinder, ITransientDependency { // ... 其他代码 public virtual HttpStatusCode GetStatusCode(HttpContext httpContext, Exception exception) { // ... 其他代码 // 根据 HTTP 协议对于状态码的定义，401 表示的是没有登录的用于尝试访问受保护的资源。而 403 则表示用户已经登录，但他没有目标资源的访问权限。 if (exception is AbpAuthorizationException) { return httpContext.User.Identity.IsAuthenticated ? HttpStatusCode.Forbidden : HttpStatusCode.Unauthorized; } // ... 其他代码 } // ... 其他代码 } 就 AbpAuthorizationException 异常来说，它本身并不复杂，只是一个简单的异常而已。只是因为它的特殊含义，在 ABP vNext 处理异常时都会进行特殊处理。\n只是在这里我说明一下，ABP vNext 将它所有的异常都设置为可序列化的，这里的可序列化不仅仅是将 Serialzable 标签打在类上就行了。ABP vNext 还创建了基于 StreamingContext 的构造函数，方便我们后续对序列化操作进行定制化处理。\n关于运行时序列化的相关文章，可以参考 《CLR Via C#》第 24 章，我也编写了相应的 读书笔记 。\n2.1.3 当前用户与客户端 开发人员经常会在各种地方需要获取当前的用户信息，ABP vNext 将当前用户封装到 ICurrentUser 与其实现 CurrentUser 当中，使用时只需要注入 ICurrentUser 接口即可。\n我们首先康康 ICurrentUser 接口的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public interface ICurrentUser { bool IsAuthenticated { get; } [CanBeNull] Guid? Id { get; } [CanBeNull] string UserName { get; } [CanBeNull] string PhoneNumber { get; } bool PhoneNumberVerified { get; } [CanBeNull] string Email { get; } bool EmailVerified { get; } Guid? TenantId { get; } [NotNull] string[] Roles { get; } [CanBeNull] Claim FindClaim(string claimType); [NotNull] Claim[] FindClaims(string claimType); [NotNull] Claim[] GetAllClaims(); bool IsInRole(string roleName); } 那么这些值是从哪儿来的呢？从带有 Claim 返回值的方法来看，肯定就是从 HttpContext.User 或者 Thread.CurrentPrincipal 里面拿到的。\n那么它的实现就非常简单了，只需要注入 ABP vNext 为我们提供的 ICurrentPrincipalAccessor 访问器，我们就能够拿到这个身份容器(ClaimsPrincipal)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class CurrentUser : ICurrentUser, ITransientDependency { // ... 其他代码 public virtual string[] Roles =\u0026gt; FindClaims(AbpClaimTypes.Role).Select(c =\u0026gt; c.Value).ToArray(); private readonly ICurrentPrincipalAccessor _principalAccessor; public CurrentUser(ICurrentPrincipalAccessor principalAccessor) { _principalAccessor = principalAccessor; } // ... 其他代码 public virtual Claim[] FindClaims(string claimType) { // 直接使用 LINQ 查询对应的 Type 就能拿到上述信息。 return _principalAccessor.Principal?.Claims.Where(c =\u0026gt; c.Type == claimType).ToArray() ?? EmptyClaimsArray; } // ... 其他代码 } 至于 CurrentUserExtensions 扩展类，里面只是对 ClaimsPrincipal 的搜索方法进行了多种封装而已。\nPS：\n除了 ICurrentUser 与 ICurrentClient 之外，在 ABP vNext 里面还有 ICurrentTenant 来获取当前租户信息。通过这三个组件，取代了老 ABP 框架的 IAbpSession 组件，三个组件都没有 IAbpSession.Use() 扩展方法帮助我们临时更改当前用户/租户。\n2.1.4 ClaimsPrincipal 访问器 关于 ClaimsPrincipal 的内容，可以参考杨总的 《ASP.NET Core 之 Identity 入门》 进行了解，大致来说就是存有 Claim 信息的聚合对象。\n关于 ABP vNext 框架预定义的 Claim Type 都存放在 AbpClaimTypes 类型里面的，包括租户 Id、用户 Id 等数据，这些玩意儿最终会被放在 JWT(JSON Web Token) 里面去。\n一般来说 ClaimsPrincipal 里面都是从 HttpContext.User 或者 Thread.CurrentPrincipal 得到的，ABP vNext 为我们抽象出了一个快速访问接口 ICurrentPrincipalAccessor。开发人员注入之后，就可以获得当前用户的 ClaimsPrincipal 对象。\n1 2 3 4 public interface ICurrentPrincipalAccessor { ClaimsPrincipal Principal { get; } } 对于 Thread.CurrentPrincipal 的实现：\n1 2 3 4 public class ThreadCurrentPrincipalAccessor : ICurrentPrincipalAccessor, ISingletonDependency { public virtual ClaimsPrincipal Principal =\u0026gt; Thread.CurrentPrincipal as ClaimsPrincipal; } 而针对于 Http 上下文的实现，则是放在 Volo.Abp.AspNetCore 模块里面的。\n1 2 3 4 5 6 7 8 9 10 11 12 public class HttpContextCurrentPrincipalAccessor : ThreadCurrentPrincipalAccessor { // 如果没有获取到数据，则使用 Thread.CurrentPrincipal。 public override ClaimsPrincipal Principal =\u0026gt; _httpContextAccessor.HttpContext?.User ?? base.Principal; private readonly IHttpContextAccessor _httpContextAccessor; public HttpContextCurrentPrincipalAccessor(IHttpContextAccessor httpContextAccessor) { _httpContextAccessor = httpContextAccessor; } } 扩展知识：两者的区别？ Thread.CurrentPrincipal 可以设置/获得当前线程的 ClaimsPrincipal 数据，而 HttpContext?.User 一般都是被 ASP.NET Core 中间件所填充的。\n最新的 ASP.NET Core 开发建议是不要使用 Thread.CurrentPrincipal 和 ClaimsPrincipal.Current (内部实现还是使用的前者)。这是因为 Thread.CurrentPrincipal 是一个静态成员\u0026hellip;而这个静态成员在异步代码中会出现各种问题，例如有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Create a ClaimsPrincipal and set Thread.CurrentPrincipal var identity = new ClaimsIdentity(); identity.AddClaim(new Claim(ClaimTypes.Name, \u0026#34;User1\u0026#34;)); Thread.CurrentPrincipal = new ClaimsPrincipal(identity); // Check the current user Console.WriteLine($\u0026#34;Current user: {Thread.CurrentPrincipal?.Identity.Name}\u0026#34;); // For the method to complete asynchronously await Task.Yield(); // Check the current user after Console.WriteLine($\u0026#34;Current user: {Thread.CurrentPrincipal?.Identity.Name}\u0026#34;); 当 await 执行完成之后会产生线程切换，这个时候 Thread.CurrentPrincipal 的值就是 null 了，这就会产生不可预料的后果。\n如果你还想了解更多信息，可以参考以下两篇博文：\nDAVID PINE - 《WHAT HAPPENED TO MY THREAD.CURRENTPRINCIPAL》 SCOTT HANSELMAN - 《System.Threading.Thread.CurrentPrincipal vs. System.Web.HttpContext.Current.User or why FormsAuthentication can be subtle》 2.1.5 字符串加密工具 这一套东西就比较简单了，是 ABP vNext 为我们提供的一套开箱即用组件。开发人员可以使用 IStringEncryptionService 来加密/解密你的字符串，默认实现是基于 Rfc2898DeriveBytes 的。关于详细信息，你可以阅读具体的代码，这里不再赘述。\n2.2 权限与校验 在 Volo.Abp.Authorization 模块里面就对权限进行了具体定义，并且基于 ASP.NET Core Authentication 进行无缝集成。如果读者对于 ASP.NET Core 认证和授权不太了解，可以去学习一下 雨夜朦胧 大神的**《ASP.NET Core 认证于授权》**系列文章，这里就不再赘述。\n2.2.1 权限的注册 在 ABP vNext 框架里面，所有用户定义的权限都是通过继承 PermissionDefinitionProvider，在其内部进行注册的。\n1 2 3 4 public abstract class PermissionDefinitionProvider : IPermissionDefinitionProvider, ITransientDependency { public abstract void Define(IPermissionDefinitionContext context); } 开发人员继承了这个 Provider 之后，在 Define() 方法里面就可以注册自己的权限了，这里我以 Blog 模块的简化 Provider 为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class BloggingPermissionDefinitionProvider : PermissionDefinitionProvider { public override void Define(IPermissionDefinitionContext context) { var bloggingGroup = context.AddGroup(BloggingPermissions.GroupName, L(\u0026#34;Permission:Blogging\u0026#34;)); // ... 其他代码。 var tags = bloggingGroup.AddPermission(BloggingPermissions.Tags.Default, L(\u0026#34;Permission:Tags\u0026#34;)); tags.AddChild(BloggingPermissions.Tags.Update, L(\u0026#34;Permission:Edit\u0026#34;)); tags.AddChild(BloggingPermissions.Tags.Delete, L(\u0026#34;Permission:Delete\u0026#34;)); tags.AddChild(BloggingPermissions.Tags.Create, L(\u0026#34;Permission:Create\u0026#34;)); var comments = bloggingGroup.AddPermission(BloggingPermissions.Comments.Default, L(\u0026#34;Permission:Comments\u0026#34;)); comments.AddChild(BloggingPermissions.Comments.Update, L(\u0026#34;Permission:Edit\u0026#34;)); comments.AddChild(BloggingPermissions.Comments.Delete, L(\u0026#34;Permission:Delete\u0026#34;)); comments.AddChild(BloggingPermissions.Comments.Create, L(\u0026#34;Permission:Create\u0026#34;)); } // 使用本地化字符串进行文本显示。 private static LocalizableString L(string name) { return LocalizableString.Create\u0026lt;BloggingResource\u0026gt;(name); } } 从上面的代码就可以看出来，权限被 ABP vNext 分成了 权限组定义 和 权限定义，这两个东西我们后面进行重点讲述。那么这些 Provider 在什么时候被执行呢？找到权限模块的定义，可以看到如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 [DependsOn( typeof(AbpSecurityModule), typeof(AbpLocalizationAbstractionsModule), typeof(AbpMultiTenancyModule) )] public class AbpAuthorizationModule : AbpModule { public override void PreConfigureServices(ServiceConfigurationContext context) { // 在 AutoFac 进行组件注册的时候，根据组件的类型定义视情况绑定拦截器。 context.Services.OnRegistred(AuthorizationInterceptorRegistrar.RegisterIfNeeded); // 在 AutoFac 进行组件注册的时候，根据组件的类型，判断是否是 Provider。 AutoAddDefinitionProviders(context.Services); } public override void ConfigureServices(ServiceConfigurationContext context) { // 注册认证授权服务。 context.Services.AddAuthorization(); // 替换掉 ASP.NET Core 提供的权限处理器，转而使用 ABP vNext 提供的权限处理器。 context.Services.AddSingleton\u0026lt;IAuthorizationHandler, PermissionRequirementHandler\u0026gt;(); // 这一部分是添加内置的一些权限值检查，后面我们在将 PermissionChecker 的时候会提到。 Configure\u0026lt;PermissionOptions\u0026gt;(options =\u0026gt; { options.ValueProviders.Add\u0026lt;UserPermissionValueProvider\u0026gt;(); options.ValueProviders.Add\u0026lt;RolePermissionValueProvider\u0026gt;(); options.ValueProviders.Add\u0026lt;ClientPermissionValueProvider\u0026gt;(); }); } private static void AutoAddDefinitionProviders(IServiceCollection services) { var definitionProviders = new List\u0026lt;Type\u0026gt;(); services.OnRegistred(context =\u0026gt; { if (typeof(IPermissionDefinitionProvider).IsAssignableFrom(context.ImplementationType)) { definitionProviders.Add(context.ImplementationType); } }); // 将获取到的 Provider 传递给 PermissionOptions 。 services.Configure\u0026lt;PermissionOptions\u0026gt;(options =\u0026gt; { options.DefinitionProviders.AddIfNotContains(definitionProviders); }); } } 可以看到在注册组件的时候，ABP vNext 就会将这些 Provider 传递给 PermissionOptions ，我们根据 DefinitionProviders 字段找到有一个地方会使用到它，就是 PermissionDefinitionManager 类型的 CreatePermissionGroupDefinitions() 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 protected virtual Dictionary\u0026lt;string, PermissionGroupDefinition\u0026gt; CreatePermissionGroupDefinitions() { // 创建一个权限定义上下文。 var context = new PermissionDefinitionContext(); // 创建一个临时范围用于解析 Provider，Provider 解析完成之后即被释放。 using (var scope = _serviceProvider.CreateScope()) { // 根据之前的类型，通过 IoC 进行解析出实例，指定各个 Provider 的 Define() 方法，会向权限上下文填充权限。 var providers = Options .DefinitionProviders .Select(p =\u0026gt; scope.ServiceProvider.GetRequiredService(p) as IPermissionDefinitionProvider) .ToList(); foreach (var provider in providers) { provider.Define(context); } } // 返回权限组名称 - 权限组定义的字典。 return context.Groups; } 你可能会奇怪，为什么返回的是一个权限组名字和定义的键值对，而不是返回的权限数据，我们之前添加的权限去哪儿了呢？\n2.2.2 权限和权限组的定义 要搞清楚这个问题，我们首先要知道权限与权限组之间的关系是怎样的。回想我们之前在 Provider 里面添加权限的代码，首先我们是构建了一个权限组，然后往权限组里面添加的权限。权限组的作用就是将权限按照组的形式进行划分，方便代码进行访问于管理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 public class PermissionGroupDefinition { /// \u0026lt;summary\u0026gt; /// 唯一的权限组标识名称。 /// \u0026lt;/summary\u0026gt; public string Name { get; } // 开发人员针对权限组的一些自定义属性。 public Dictionary\u0026lt;string, object\u0026gt; Properties { get; } // 权限所对应的本地化名称。 public ILocalizableString DisplayName { get =\u0026gt; _displayName; set =\u0026gt; _displayName = Check.NotNull(value, nameof(value)); } private ILocalizableString _displayName; /// \u0026lt;summary\u0026gt; /// 权限的适用范围，默认是租户/租主都适用。 /// 默认值: \u0026lt;see cref=\u0026#34;MultiTenancySides.Both\u0026#34;/\u0026gt; /// \u0026lt;/summary\u0026gt; public MultiTenancySides MultiTenancySide { get; set; } // 权限组下面的所属权限。 public IReadOnlyList\u0026lt;PermissionDefinition\u0026gt; Permissions =\u0026gt; _permissions.ToImmutableList(); private readonly List\u0026lt;PermissionDefinition\u0026gt; _permissions; // 针对于自定义属性的快捷索引器。 public object this[string name] { get =\u0026gt; Properties.GetOrDefault(name); set =\u0026gt; Properties[name] = value; } protected internal PermissionGroupDefinition( string name, ILocalizableString displayName = null, MultiTenancySides multiTenancySide = MultiTenancySides.Both) { Name = name; // 没有传递多语言串，则使用权限组的唯一标识作为显示内容。 DisplayName = displayName ?? new FixedLocalizableString(Name); MultiTenancySide = multiTenancySide; Properties = new Dictionary\u0026lt;string, object\u0026gt;(); _permissions = new List\u0026lt;PermissionDefinition\u0026gt;(); } // 像权限组添加属于它的权限。 public virtual PermissionDefinition AddPermission( string name, ILocalizableString displayName = null, MultiTenancySides multiTenancySide = MultiTenancySides.Both) { var permission = new PermissionDefinition(name, displayName, multiTenancySide); _permissions.Add(permission); return permission; } // 递归构建权限集合，因为定义的某个权限内部还拥有子权限。 public virtual List\u0026lt;PermissionDefinition\u0026gt; GetPermissionsWithChildren() { var permissions = new List\u0026lt;PermissionDefinition\u0026gt;(); foreach (var permission in _permissions) { AddPermissionToListRecursively(permissions, permission); } return permissions; } // 递归构建方法。 private void AddPermissionToListRecursively(List\u0026lt;PermissionDefinition\u0026gt; permissions, PermissionDefinition permission) { permissions.Add(permission); foreach (var child in permission.Children) { AddPermissionToListRecursively(permissions, child); } } public override string ToString() { return $\u0026#34;[{nameof(PermissionGroupDefinition)} {Name}]\u0026#34;; } } 通过权限组的定义代码你就会知道，现在我们的所有权限都会归属于某个权限组，这一点从之前 Provider 的 IPermissionDefinitionContext 就可以看出来。在权限上下文内部只允许我们通过 AddGroup() 来添加一个权限组，之后再通过权限组的 AddPermission() 方法添加它里面的权限。\n权限的定义类叫做 PermissionDefinition，这个类型的构造与权限组定义类似，没有什么好说的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 public class PermissionDefinition { /// \u0026lt;summary\u0026gt; /// 唯一的权限标识名称。 /// \u0026lt;/summary\u0026gt; public string Name { get; } /// \u0026lt;summary\u0026gt; /// 当前权限的父级权限，这个属性的值只可以通过 AddChild() 方法进行设置。 /// \u0026lt;/summary\u0026gt; public PermissionDefinition Parent { get; private set; } /// \u0026lt;summary\u0026gt; /// 权限的适用范围，默认是租户/租主都适用。 /// 默认值: \u0026lt;see cref=\u0026#34;MultiTenancySides.Both\u0026#34;/\u0026gt; /// \u0026lt;/summary\u0026gt; public MultiTenancySides MultiTenancySide { get; set; } /// \u0026lt;summary\u0026gt; /// 适用的权限值提供者，这块我们会在后面进行讲解，为空的时候则使用所有的提供者进行校验。 /// \u0026lt;/summary\u0026gt; public List\u0026lt;string\u0026gt; Providers { get; } //TODO: Rename to AllowedProviders? // 权限的多语言名称。 public ILocalizableString DisplayName { get =\u0026gt; _displayName; set =\u0026gt; _displayName = Check.NotNull(value, nameof(value)); } private ILocalizableString _displayName; // 获取权限的子级权限。 public IReadOnlyList\u0026lt;PermissionDefinition\u0026gt; Children =\u0026gt; _children.ToImmutableList(); private readonly List\u0026lt;PermissionDefinition\u0026gt; _children; /// \u0026lt;summary\u0026gt; /// 开发人员针对权限的一些自定义属性。 /// \u0026lt;/summary\u0026gt; public Dictionary\u0026lt;string, object\u0026gt; Properties { get; } // 针对于自定义属性的快捷索引器。 public object this[string name] { get =\u0026gt; Properties.GetOrDefault(name); set =\u0026gt; Properties[name] = value; } protected internal PermissionDefinition( [NotNull] string name, ILocalizableString displayName = null, MultiTenancySides multiTenancySide = MultiTenancySides.Both) { Name = Check.NotNull(name, nameof(name)); DisplayName = displayName ?? new FixedLocalizableString(name); MultiTenancySide = multiTenancySide; Properties = new Dictionary\u0026lt;string, object\u0026gt;(); Providers = new List\u0026lt;string\u0026gt;(); _children = new List\u0026lt;PermissionDefinition\u0026gt;(); } public virtual PermissionDefinition AddChild( [NotNull] string name, ILocalizableString displayName = null, MultiTenancySides multiTenancySide = MultiTenancySides.Both) { var child = new PermissionDefinition( name, displayName, multiTenancySide) { Parent = this }; _children.Add(child); return child; } /// \u0026lt;summary\u0026gt; /// 设置指定的自定义属性。 /// \u0026lt;/summary\u0026gt; public virtual PermissionDefinition WithProperty(string key, object value) { Properties[key] = value; return this; } /// \u0026lt;summary\u0026gt; /// 添加一组权限值提供者集合。 /// \u0026lt;/summary\u0026gt; public virtual PermissionDefinition WithProviders(params string[] providers) { if (!providers.IsNullOrEmpty()) { Providers.AddRange(providers); } return this; } public override string ToString() { return $\u0026#34;[{nameof(PermissionDefinition)} {Name}]\u0026#34;; } } 2.2.3 权限管理器 继续回到权限管理器，权限管理器的接口定义是 IPermissionDefinitionManager ，从接口的方法定义来看，都是获取权限的方法，说明权限管理器主要提供给其他组件进行权限校验操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public interface IPermissionDefinitionManager { // 根据权限定义的唯一标识获取权限，一旦不存在就会抛出 AbpException 异常。 [NotNull] PermissionDefinition Get([NotNull] string name); // 根据权限定义的唯一标识获取权限，如果权限不存在，则返回 null。 [CanBeNull] PermissionDefinition GetOrNull([NotNull] string name); // 获取所有的权限。 IReadOnlyList\u0026lt;PermissionDefinition\u0026gt; GetPermissions(); // 获取所有的权限组。 IReadOnlyList\u0026lt;PermissionGroupDefinition\u0026gt; GetGroups(); } 接着我们来回答 2.2.1 末尾提出的问题，权限组是根据 Provider 自动创建了，那么权限呢？其实我们在权限管理器里面拿到了权限组，权限定义就很好构建了，直接遍历所有权限组拿它们的 Permissions 属性构建即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 protected virtual Dictionary\u0026lt;string, PermissionDefinition\u0026gt; CreatePermissionDefinitions() { var permissions = new Dictionary\u0026lt;string, PermissionDefinition\u0026gt;(); // 遍历权限定义组，这个东西在之前就已经构建好了。 foreach (var groupDefinition in PermissionGroupDefinitions.Values) { // 递归子级权限。 foreach (var permission in groupDefinition.Permissions) { AddPermissionToDictionaryRecursively(permissions, permission); } } // 返回权限唯一标识 - 权限定义 的字典。 return permissions; } protected virtual void AddPermissionToDictionaryRecursively( Dictionary\u0026lt;string, PermissionDefinition\u0026gt; permissions, PermissionDefinition permission) { if (permissions.ContainsKey(permission.Name)) { throw new AbpException(\u0026#34;Duplicate permission name: \u0026#34; + permission.Name); } permissions[permission.Name] = permission; foreach (var child in permission.Children) { AddPermissionToDictionaryRecursively(permissions, child); } } 2.2.4 授权策略提供者的实现 我们发现 ABP vNext 自己实现了 IAbpAuthorizationPolicyProvider 接口，实现的类型就是 AbpAuthorizationPolicyProvider 。\n这个类型它是继承的 DefaultAuthorizationPolicyProvider ，重写了 GetPolicyAsync() 方法，目的就是将 PermissionDefinition 转换为 AuthorizationPolicy 。\n如果去看了 雨夜朦胧 大神的博客，就知道我们一个授权策略可以由多个条件构成。也就是说某一个 AuthorizationPolicy 可以拥有多个限定条件，当所有限定条件被满足之后，才能算是通过权限验证，例如以下代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public void ConfigureService(IServiceCollection services) { services.AddAuthorization(options =\u0026gt; { options.AddPolicy(\u0026#34;User\u0026#34;, policy =\u0026gt; policy .RequireAssertion(context =\u0026gt; context.User.HasClaim(c =\u0026gt; (c.Type == \u0026#34;EmployeeNumber\u0026#34; || c.Type == \u0026#34;Role\u0026#34;))) ); // 这里的意思是，用户角色必须是 Admin，并且他的用户名是 Alice，并且必须要有类型为 EmployeeNumber 的 Claim。 options.AddPolicy(\u0026#34;Employee\u0026#34;, policy =\u0026gt; policy .RequireRole(\u0026#34;Admin\u0026#34;) .RequireUserName(\u0026#34;Alice\u0026#34;) .RequireClaim(\u0026#34;EmployeeNumber\u0026#34;) .Combine(commonPolicy)); }); } 这里的 RequireRole() 、RequireUserName()、RequireClaim() 都会生成一个 IAuthorizationRequirement 对象，它们在内部有不同的实现规则。\n1 2 3 4 5 6 7 8 9 10 11 public AuthorizationPolicyBuilder RequireClaim(string claimType) { if (claimType == null) { throw new ArgumentNullException(nameof(claimType)); } // 构建了一个 ClaimsAuthorizationRequirement 对象，并添加到策略的 Requirements 组。 Requirements.Add(new ClaimsAuthorizationRequirement(claimType, allowedValues: null)); return this; } 这里我们 ABP vNext 则是使用的 PermissionRequirement 作为一个限定条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public override async Task\u0026lt;AuthorizationPolicy\u0026gt; GetPolicyAsync(string policyName) { var policy = await base.GetPolicyAsync(policyName); if (policy != null) { return policy; } var permission = _permissionDefinitionManager.GetOrNull(policyName); if (permission != null) { // TODO: 可以使用缓存进行优化。 // 通过 Builder 构建一个策略。 var policyBuilder = new AuthorizationPolicyBuilder(Array.Empty\u0026lt;string\u0026gt;()); // 创建一个 PermissionRequirement 对象添加到限定条件组中。 policyBuilder.Requirements.Add(new PermissionRequirement(policyName)); return policyBuilder.Build(); } return null; } 与 ClaimsAuthorizationRequirement 不同的是，ABP vNext 并没有将限定条件处理器和限定条件定义放在一起实现，而是分开的，分别构成了 PermissionRequirement 和 PermissionRequirementHandler ，后者在模块配置的时候被注入到 IoC 里面。\nPS：\n对于 Handler 来说，我们可以编写多个 Handler 注入到 IoC 容器内部，如下代码：\n1 2 services.AddSingleton\u0026lt;IAuthorizationHandler, BadgeEntryHandler\u0026gt;(); services.AddSingleton\u0026lt;IAuthorizationHandler, HasTemporaryStickerHandler\u0026gt;(); 首先看限定条件 PermissionRequirement 的定义，非常简单。\n1 2 3 4 5 6 7 8 9 10 11 public class PermissionRequirement : IAuthorizationRequirement { public string PermissionName { get; } public PermissionRequirement([NotNull]string permissionName) { Check.NotNull(permissionName, nameof(permissionName)); PermissionName = permissionName; } } 在限定条件内部，我们只用了权限的唯一标识来进行处理，接下来看一下权限处理器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class PermissionRequirementHandler : AuthorizationHandler\u0026lt;PermissionRequirement\u0026gt; { // 这里通过权限检查器来确定当前用户是否拥有某个权限。 private readonly IPermissionChecker _permissionChecker; public PermissionRequirementHandler(IPermissionChecker permissionChecker) { _permissionChecker = permissionChecker; } protected override async Task HandleRequirementAsync( AuthorizationHandlerContext context, PermissionRequirement requirement) { // 如果当前用户拥有某个权限，则通过 Contxt.Succeed() 通过授权验证。 if (await _permissionChecker.IsGrantedAsync(context.User, requirement.PermissionName)) { context.Succeed(requirement); } } } 2.2.5 权限检查器 在上面的处理器我们看到了，ABP vNext 是通过权限检查器来校验某个用户是否满足某个授权策略，先看一下 IPermissionChecker 接口的定义，基本都是传入身份证(ClaimsPrincipal)和需要校验的权限进行处理。\n1 2 3 4 5 6 public interface IPermissionChecker { Task\u0026lt;bool\u0026gt; IsGrantedAsync([NotNull]string name); Task\u0026lt;bool\u0026gt; IsGrantedAsync([CanBeNull] ClaimsPrincipal claimsPrincipal, [NotNull]string name); } 第一个方法内部就是调用的第二个方法，只不过传递的身份证是通过 ICurrentPrincipalAccessor 拿到的，所以我们的核心还是看第二个方法的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public virtual async Task\u0026lt;bool\u0026gt; IsGrantedAsync(ClaimsPrincipal claimsPrincipal, string name) { Check.NotNull(name, nameof(name)); var permission = PermissionDefinitionManager.Get(name); var multiTenancySide = claimsPrincipal?.GetMultiTenancySide() ?? CurrentTenant.GetMultiTenancySide(); // 检查传入的权限是否允许当前的用户模式（租户/租主）进行访问。 if (!permission.MultiTenancySide.HasFlag(multiTenancySide)) { return false; } var isGranted = false; // 这里是重点哦，这个权限值检测上下文是之前没有说过的东西，说白了就是针对不同维度的权限检测。 // 之前这部分东西是通过权限策略下面的 Requirement 提供的，这里 ABP vNext 将其抽象为 PermissionValueProvider。 var context = new PermissionValueCheckContext(permission, claimsPrincipal); foreach (var provider in PermissionValueProviderManager.ValueProviders) { // 如果指定的权限允许的权限值提供者集合不包含当前的 Provider，则跳过处理。 if (context.Permission.Providers.Any() \u0026amp;\u0026amp; !context.Permission.Providers.Contains(provider.Name)) { continue; } // 调用 Provider 的检测方法，传入身份证明和权限定义进行具体校验。 var result = await provider.CheckAsync(context); // 根据返回的结果，判断是否通过了权限校验。 if (result == PermissionGrantResult.Granted) { isGranted = true; } else if (result == PermissionGrantResult.Prohibited) { return false; } } // 返回 true 说明已经授权，返回 false 说明是没有授权的。 return isGranted; } 2.2.6 PermissionValueProvider 在模块配置方法内部，可以看到通过 Configure\u0026lt;PermissionOptions\u0026gt;() 方法添加了三个 PermissionValueProvider ，即 UserPermissionValueProvider、RolePermissionValueProvider、ClientPermissionValueProvider 。在它们的内部实现，都是通过 IPermissionStore 从持久化存储 检查传入的用户是否拥有某个权限。\n这里我们以 UserPermissionValueProvider 为例，来看看它的实现方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class UserPermissionValueProvider : PermissionValueProvider { // 提供者的名称。 public const string ProviderName = \u0026#34;User\u0026#34;; public override string Name =\u0026gt; ProviderName; public UserPermissionValueProvider(IPermissionStore permissionStore) : base(permissionStore) { } public override async Task\u0026lt;PermissionGrantResult\u0026gt; CheckAsync(PermissionValueCheckContext context) { // 从传入的 Principal 中查找 UserId，不存在则说明没有定义，视为未授权。 var userId = context.Principal?.FindFirst(AbpClaimTypes.UserId)?.Value; if (userId == null) { return PermissionGrantResult.Undefined; } // 调用 IPermissionStore 从持久化存储中，检测指定权限在某个提供者下面是否已经被授予了权限。 // 如果被授予了权限， 则返回 true，没有则返回 false。 return await PermissionStore.IsGrantedAsync(context.Permission.Name, Name, userId) ? PermissionGrantResult.Granted : PermissionGrantResult.Undefined; } } 这里我们先不讲 IPermissionStore 的具体实现，就上述代码来看，ABP vNext 是将权限定义放在了一个管理容器(IPermissionDeftiionManager)。然后又实现了自定义的策略处理器和策略，在处理器的内部又通过 IPermissionChecker 根据不同的 PermissionValueProvider 结合 IPermissionStore 实现了指定用户标识到权限的检测功能。\n2.2.7 权限验证拦截器 权限验证拦截器的注册都是在 AuthorizationInterceptorRegistrar 的 RegisterIfNeeded() 方法内实现的，只要类型的任何一个方法标注了 AuthorizeAttribute 特性，就会被关联拦截器。\n1 2 3 4 5 6 7 8 9 10 11 private static bool AnyMethodHasAuthorizeAttribute(Type implementationType) { return implementationType .GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) .Any(HasAuthorizeAttribute); } private static bool HasAuthorizeAttribute(MemberInfo methodInfo) { return methodInfo.IsDefined(typeof(AuthorizeAttribute), true); } 拦截器和类型关联之后，会通过 IMethodInvocationAuthorizationService 的 CheckAsync() 方法校验调用者是否拥有指定权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public override async Task InterceptAsync(IAbpMethodInvocation invocation) { // 防止重复检测。 if (AbpCrossCuttingConcerns.IsApplied(invocation.TargetObject, AbpCrossCuttingConcerns.Authorization)) { await invocation.ProceedAsync(); return; } // 将被调用的方法传入，验证是否允许访问。 await AuthorizeAsync(invocation); await invocation.ProceedAsync(); } protected virtual async Task AuthorizeAsync(IAbpMethodInvocation invocation) { await _methodInvocationAuthorizationService.CheckAsync( new MethodInvocationAuthorizationContext( invocation.Method ) ); } 在具体的实现当中，首先检测方法是否标注了 IAllowAnonymous 特性，标注了则说明允许匿名访问，直接返回不做任何处理。否则就会从方法获取实现了 IAuthorizeData 接口的特性，从里面拿到 Policy 值，并通过 IAuthorizationService 进行验证。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected async Task CheckAsync(IAuthorizeData authorizationAttribute) { if (authorizationAttribute.Policy == null) { // 如果当前调用者没有进行认证，则抛出未登录的异常。 if (!_currentUser.IsAuthenticated \u0026amp;\u0026amp; !_currentClient.IsAuthenticated) { throw new AbpAuthorizationException(\u0026#34;Authorization failed! User has not logged in.\u0026#34;); } } else { // 通过 IAuthorizationService 校验当前用户是否拥有 authorizationAttribute.Policy 权限。 await _authorizationService.CheckAsync(authorizationAttribute.Policy); } } 针对于 IAuthorizationService ，ABP vNext 还是提供了自己的实现 AbpAuthorizationService，里面没有重写什么方法，而是提供了两个新的属性，这两个属性是为了方便实现 AbpAuthorizationServiceExtensions 提供的扩展方法，这里不再赘述。\n三、总结 关于权限与验证部分我就先讲到这儿，后续文章我会更加详细地为大家分析 ABP vNext 是如何进行权限管理，又是如何将 ABP vNext 和 ASP.NET Identity 、IdentityServer4 进行集成的。\n","date":"2019-08-10T12:36:14Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---7-permissions-and-verification/","title":"Abp vNext 源码分析 - 7. 权限与验证"},{"content":"问题 在使用 DevExpress 开发 WinForm 程序时，我是使用的默认皮肤进行开发。但客户要求标题栏背景色改为蓝色，标题文字颜色改为白色。\n改颜色比较简单，参考了 DevExpress Support 的说明，通过获取皮肤更改 BackColor 和 ForeColor 就可以实现。不过更改之后，发现在低分屏下面，标题文字出现模糊的情况。\n原因 初步猜想应该是文字阴影的问题，但搜索了大部分资料没有找到解决方案，最后在 DevExpress Support 的这篇文章看到了自定义 FormPainter 。起初我认为是重载 DrawText() 解决，不过没有找到相关的参数，之后发现它有一个 DrawTextShadow() 方法，应该就是它了。\n解决 解决方法很简单，就是重写 DrawTextShadow() 方法，将其作为一个空方法就行了，不做任何阴影处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class ReplaceFontFormPainter : FormPainter { public ReplaceFontFormPainter(Control owner, ISkinProvider provider) : base(owner, provider) { } // 不再绘制标题文字阴影。 protected override void DrawTextShadow(GraphicsCache cache, AppearanceObject appearance, Rectangle bounds) { } } 来到你需要更改的窗体，重载窗体的 CreateFormBorderPainter() 方法，使用你自己创建的 FormPainter 。\n1 2 3 4 public partial class MainForm : XtraForm { protected override FormPainter CreateFormBorderPainter() =\u0026gt; new ReplaceFontFormPainter(this, LookAndFeel); } 最后的效果：\n","date":"2019-07-31T06:24:18Z","permalink":"https://real-zony.github.io/p/remove-xtraform-title-text-shadow-from-devexpress/","title":"移除 DevExpress 的 XtraForm 标题文字阴影"},{"content":"一、简要介绍 ABP vNext 针对于应用服务层，为我们单独设计了一个模块进行实现，即 Volo.Abp.Ddd.Application 模块。\nPS：最近博主也是在恶补 DDD 相关的知识，这里推荐大家看一下 ThoughtWorks 的 DDD 相关文章。\n关于 DDD 相关的著作，我这儿还是推荐经典的那三本**《领域驱动设计：软件核心复杂性应对之道》、《实现领域驱动设计》、《领域驱动设计精粹》**。\nDDD 的学习整体来说是比较枯燥的，而且偏理论化的知识。所以需要结合大量实例来看，反复对照书中的概念加深理解。不仅要看别人的实例，自己也要尝试运用 DDD 的战略方法和战术方法进行设计。\n应用服务层在 DDD 分层架构里面是最顶层的，一般与前端（展示层）打交道的都是应用服务层。常规的开发人员，如果没有遵循 DDD 理论来进行开发的话，应用服务层是十分臃肿的，里面全是业务逻辑。而领域层里面则是空无一物，全是贫血的领域模型对象。这种模式被称之为 贫血领域模型模式，这是一个 反模式。\n这里我就不再赘述应用服务层与 DDD 之间的关系了，在这里你可以看作它是一个 API 接口实现类，你所有对外开放的接口都是通过应用服务层暴露的，接口的方法应该与用例相对应。\n二、源码分析 应用服务层模块里面比较简单，只有两个文件夹，分别存放了数据传输模型（Dtos）和应用服务基类定义（Services）。\n2.1 启动模块 首先我们还是按照之前的顺序，看一个模块先看他的模块类。这里我们先看一下 AbpDddApplicationModule 的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [DependsOn( typeof(AbpDddDomainModule), typeof(AbpSecurityModule), typeof(AbpObjectMappingModule), typeof(AbpValidationModule), typeof(AbpAuthorizationModule), typeof(AbpHttpAbstractionsModule), typeof(AbpSettingsModule), typeof(AbpFeaturesModule) )] // 不要看上面依赖这么多模块，主要是因为基类会用到很多基础组件。 public class AbpDddApplicationModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { // 配置接口类型。 Configure\u0026lt;ApiDescriptionModelOptions\u0026gt;(options =\u0026gt; { options.IgnoredInterfaces.AddIfNotContains(typeof(IRemoteService)); options.IgnoredInterfaces.AddIfNotContains(typeof(IApplicationService)); options.IgnoredInterfaces.AddIfNotContains(typeof(IUnitOfWorkEnabled)); }); } } 可以看到，在上述代码里面，只做了一件事情，就是调用 ApiDescriptionModelOptions ，往里面添加了 IRemoteService、IApplicationService、IUnitOfWOrkEnabled 三种接口类型。添加了三种类型之后，ABP vNext 根据应用服务类创建控制器时，就会从这个 IgnoredInterfaces 判断哪些类型不被忽略 (即只会自动注册实现了三种接口的类型成为控制器)。\n2.2 应用服务基类 ABP vNext 提供了标准基类 ApplicationService 和简单 Crud 基类 CrudAppService 给我们使用，前者只是继承了 IApplicationService 接口，并提供了基本组件的简单基类。而后者则是定义了 Crud 操作所需要的所有 API 方法，你只需要继承这个基类对象，填充相应的泛型参数，就可以快速实现一个 Crud 接口。\n2.2.1 简单基类 简单基类里面我们首先需要注意的是它实现的接口，你可以发现 ApplicationService 实现了诸多接口，不过这些接口更多的是类似于标识接口。\n1 2 3 4 5 6 7 8 9 10 public abstract class ApplicationService : IApplicationService, IAvoidDuplicateCrossCuttingConcerns, IValidationEnabled, IUnitOfWorkEnabled, IAuditingEnabled, ITransientDependency { // ... 其他代码 } 所有应用服务都必须继承 IApplicationService，这个是肯定的，不然 ABP vNext 不会为我们生成需要的控制器。\n其次是 IAvoidDuplicateCrossCuttingConcerns 接口，这个接口最早可以追溯到老版本 ABP 框架里面。它的主要作用是防止拦截器进行重复执行。\n1 2 3 4 public interface IAvoidDuplicateCrossCuttingConcerns { List\u0026lt;string\u0026gt; AppliedCrossCuttingConcerns { get; } } 例如调用购买这个 API 接口，首先会进入 ASP.NET Core 的审计日志 Filter，在 Filter 里面会将这个 API 接口归属的类型的 List 容器(接口里面定义的 List )里面写入一条记录，说明已经通过审计日志过滤器记录了。\n写了审计日志之后，又会进入审计日志拦截器，这个时候拦截器就会对指定的类型进行判断，看是否已经被执行过了，因为这个类型的 List 容器有了之前过滤器的记录，所以不会重复执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public override void Intercept(IAbpMethodInvocation invocation) { if (!ShouldIntercept(invocation, out var auditLog, out var auditLogAction)) { invocation.Proceed(); return; } // ... 审计日志记录。 } protected virtual bool ShouldIntercept( IAbpMethodInvocation invocation, out AuditLogInfo auditLog, out AuditLogActionInfo auditLogAction) { // 判断实例的 List 容器里面，是否写入了 AbpCrossCuttingConcerns.Auditing。 if (AbpCrossCuttingConcerns.IsApplied(invocation.TargetObject, AbpCrossCuttingConcerns.Auditing)) { return false; } // ... 其他代码 return true; } 剩余的 IValidationEnabled、IUnitOfWorkEnabled、IAuditingEnabled、ITransientDependency 接口类似于一个启用标识，只要类型继承了该接口，就会执行一些特殊的操作。\n回到之前的简单基类里面，ABP vNext 为我们注入了大量基础设施，例如获取当前用户的 ICurrentUser 组件，获取当前租户的 ICurrentTenant 组件，还有日志组件等。\n除了基础组件，ABP vNext 在简单基类里面还提供了一个权限检测方法，用户检测当前用户是否具备某些权限。\n1 2 3 4 5 6 7 8 9 protected virtual async Task CheckPolicyAsync([CanBeNull] string policyName) { if (string.IsNullOrEmpty(policyName)) { return; } await AuthorizationService.CheckAsync(policyName); } 在不具备权限的时候，ABP vNext 会抛出 AbpAuthorizationException 异常。\n2.2.2 Crud 基类 Crud 基类可以极大减少对于某些简单对象的代码编写，例如我有个客户管理接口，只需要简单地增删改查操作。那么我就可以直接继承自 Crud 基类，给它填写和是的泛型参数之后，ABP vNext 就会为我们生成带有增删改查操作的应用服务对象。\n这个 Crud 基类拥有多个泛型定义与实现，除了真正的实现以外，其他的都是简单的调用基类方法而已。我们直接进入主题，看一下类型签名为 public abstract class CrudAppService\u0026lt;TEntity, TGetOutputDto, TGetListOutputDto, TKey, TGetListInput, TCreateInput, TUpdateInput\u0026gt; 的基类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public abstract class CrudAppService\u0026lt;TEntity, TGetOutputDto, TGetListOutputDto, TKey, TGetListInput, TCreateInput, TUpdateInput\u0026gt; : ApplicationService, ICrudAppService\u0026lt;TGetOutputDto, TGetListOutputDto, TKey, TGetListInput, TCreateInput, TUpdateInput\u0026gt; where TEntity : class, IEntity\u0026lt;TKey\u0026gt; where TGetOutputDto : IEntityDto\u0026lt;TKey\u0026gt; where TGetListOutputDto : IEntityDto\u0026lt;TKey\u0026gt; { public virtual async Task\u0026lt;TGetOutputDto\u0026gt; GetAsync(TKey id) { // 具体代码。 } public virtual async Task\u0026lt;PagedResultDto\u0026lt;TGetListOutputDto\u0026gt;\u0026gt; GetListAsync(TGetListInput input) { // 具体代码。 } public virtual async Task\u0026lt;TGetOutputDto\u0026gt; CreateAsync(TCreateInput input) { // 具体代码。 } public virtual async Task\u0026lt;TGetOutputDto\u0026gt; UpdateAsync(TKey id, TUpdateInput input) { // 具体代码。 } public virtual async Task DeleteAsync(TKey id) { // 具体代码。 } } 从上述代码可以看到基类根据传入的泛型参数，将会为我们实现常规的增删改查逻辑。我们也可以随时重写这些方法，来达到一些个性化的操作。\nABP vNext 抽象了公用接口以外，在内部还编写了诸如 MapToEntity() 和 MapToEntity() 等内部共用方法，这里就不再详细赘述，这些方法都是 protected 修饰的，你也可以随时重写来达到自己的目的。\n2.3 数据传输对象 一般来说，应用服务层返回给展示层的数据肯定是某个实体对象的部分属性，或者是多个聚合的整体，这个时候就需要 DTO 来帮我们处理应用服务层与外部的数据交换了。\nABP vNext 在应用服务模块定义了常用的一些 DTO 对象，例如实体 DTO 和分页查询 DTO，关于这些 DTO 你只需将其看作一个数据容器即可，不需要太多关注，这里也没有太多要讲的。\n三、总结 ABP vNext 提供的应用服务层模块还是比较简单的，里面主要是针对应用服务基类进行了预定义。方便我们开发人员进行业务开发，而不需要自己实现这些繁杂的基类。\n在 DDD 当中，应用服务是表达 用户用例 和 用户故事 的主要手段，应用服务只是通过领域对象/领域服务来表达需求用例的一个组件。不要将业务逻辑泄漏到应用服务当中，这种设计最终会导致贫血领域模型。\n","date":"2019-07-25T12:10:32Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---6-ddd-application-layer-support-application-service/","title":"Abp vNext 源码分析 - 6. DDD 的应用层支持 (应用服务)"},{"content":"一、简要介绍 ABP vNext 框架本身就是围绕着 DDD 理念进行设计的，所以在 DDD 里面我们能够见到的实体、仓储、值对象、领域服务，ABP vNext 框架都为我们进行了实现，这些基础设施都存放在 Volo.Abp.Ddd.Domain 项目当中。\n本篇文章将会侧重于理论讲解，但也只是一个抛砖引玉的作用，关于 DDD 相关的知识可以阅读 Eric Evans 所编写的 《领域驱动设计：软件核心复杂性应对之道》。\nPS：\n该书也是目前我正在阅读的 DDD 理论书籍，因为基于 DDD 理论，我们能够精准地划分微服务的业务边界，为后续微服务架构的可扩展性提供坚实的基础。\n二、源码分析 Volo.Abp.Ddd.Domain 分为 Volo 和 Microsoft 两个文件夹，在 Microsoft 文件夹当中主要是针对仓储和实体进行自动注入。\n2.1 实体 (Entity) 2.1.1 基本概念 只要用过 EF Core 框架的人，基本都知道什么是实体。不过很多人就跟我一样，只是将实体作为数据库表在 C# 语言当中的另一种展现方式，认为它跟普通的对象没什么不一样。\nPS：虽然每个对象都会有一个内在的 对象引用指针 来作为唯一标识。\n在 DDD 的概念当中，通过标识定义的对象被称为实体(Entity)。虽然它们的属性可能因为不同的操作而被改变（多种生命周期），但必须保证一种内在的连续性。为了保证这种内在的连续性，就需要一个有意义并且唯一的属性。\n标识是否重要则完全取决于它是否有用，例如有个演唱会订票程序，你可以将座位与观众都当作一个实体处理。那么在分配座位时，每个座位肯定都会有一个唯一的座位号(唯一标识)，可也能拥有其他描述属性(是否是 VIP 座位、价格等\u0026hellip;)。\n那么座位是否需要唯一标识，是否为一个实体，就取决于不同的入场方式。假如说是一人一票制，并且每张门票上面都有固定的座位号，这个时候座位就是一个实体，因为它需要座位号来区分不同的座位。\n另一种方式就是入场卷方式，门票上没有座位号，你想坐哪儿就坐哪儿。这个时候座位号就不需要与门票建立关联，在这种情况下座位就不是一个实体，所以不需要唯一标识。\n* 上述例子与描述改编自 《领域驱动设计：软件核心复杂性应对之道》的 ENTITY 一节。\n2.1.2 如何实现 了解了 DDD 概念里面的实体描述之后，我们就来看一下 ABP vNext 为我们准备了怎样的基础设施。\n首先看 Entities 文件夹下关于实体的基础定义，在实体的基础定义类里面，为每个实体定义了唯一标识。并且在某些情况下，我们需要确保 ID 在多个计算机系统之间具有唯一性。\n尤其是在多个系统/平台进行对接的时候，如果每个系统针对于 “张三” 这个用户的 ID 不是一致的，都是自己生成 ID ，那么就需要介入一个新的抽象层进行关系映射。\n在 IEntity\u0026lt;TKey\u0026gt; 的默认实现 Entity\u0026lt;TKey\u0026gt; 中，不仅提供了标识定义，也重写了 Equals() 比较方法和 == \\ != 操作符，用于区别不同实体。它为对象统一定义了一个 TKey 属性，该属性将会作为实体的唯一标识字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public override bool Equals(object obj) { // 比较的对象为 NULL 或者对象不是派生自 Entity\u0026lt;T\u0026gt; 都视为不相等。 if (obj == null || !(obj is Entity\u0026lt;TKey\u0026gt;)) { return false; } // 比较的对象与当前对象属于同一个引用，视为相等的。 if (ReferenceEquals(this, obj)) { return true; } // 当前比较主要适用于 EF Core，如果任意对象是使用的默认 Id，即临时对象，则其默认 ID 都为负数，视为不相等。 var other = (Entity\u0026lt;TKey\u0026gt;)obj; if (EntityHelper.HasDefaultId(this) \u0026amp;\u0026amp; EntityHelper.HasDefaultId(other)) { return false; } // 主要判断当前对象与比较对象的类型信息，看他们两个是否属于 IS-A 关系，如果不是，则视为不相等。 var typeOfThis = GetType().GetTypeInfo(); var typeOfOther = other.GetType().GetTypeInfo(); if (!typeOfThis.IsAssignableFrom(typeOfOther) \u0026amp;\u0026amp; !typeOfOther.IsAssignableFrom(typeOfThis)) { return false; } // 如果两个实体他们的租户 Id 不同，也视为不相等。 if (this is IMultiTenant \u0026amp;\u0026amp; other is IMultiTenant \u0026amp;\u0026amp; this.As\u0026lt;IMultiTenant\u0026gt;().TenantId != other.As\u0026lt;IMultiTenant\u0026gt;().TenantId) { return false; } // 通过泛型的 Equals 方法进行最后的比较。 return Id.Equals(other.Id); } 实体本身是支持序列化的，所以特别标注了 [Serializable] 特性。\n1 2 3 4 5 [Serializable] public abstract class Entity\u0026lt;TKey\u0026gt; : Entity, IEntity\u0026lt;TKey\u0026gt; { // ... 其他代码。 } 针对于某些实体可能是 复合主键 的情况，ABP vNext 则推荐使用 IEntity 和 Entity 进行处理。\n1 2 3 4 5 6 7 8 9 10 11 /// \u0026lt;summary\u0026gt; /// 定义一个实体，但它的主键可能不是 “Id”，也有可能是否复合主键。 /// 开发人员应该尽可能使用 \u0026lt;see cref=\u0026#34;IEntity{TKey}\u0026#34;/\u0026gt; 来定义实体，以便更好的与其他框架/结构进行集成。 /// \u0026lt;/summary\u0026gt; public interface IEntity { /// \u0026lt;summary\u0026gt; /// 返回当前实体的标识数组。 /// \u0026lt;/summary\u0026gt; object[] GetKeys(); } 2.2 自动审计 在 Entities 文件夹里面，还有一个 Auditing 文件夹。在这个文件夹里面定义了很多对象，我们最为常用的就是 FullAuditiedEntity 对象了。从字面意思来看，它是一个包含了所有审计属性的实体。\n1 2 3 4 5 6 7 8 9 10 11 12 [Serializable] public abstract class FullAuditedEntity\u0026lt;TKey\u0026gt; : AuditedEntity\u0026lt;TKey\u0026gt;, IFullAuditedObject { // 软删除标记，为 true 时说明实体已经被删除，反之亦然。 public virtual bool IsDeleted { get; set; } // 删除实体的用户 Id。 public virtual Guid? DeleterId { get; set; } // 实体被删除的时间。 public virtual DateTime? DeletionTime { get; set; } } 那么，什么是审计属性呢？在 ABP vNext 内部将以下属性定义为审计属性：创建人、创建时间、修改人、修改时间、删除人、删除时间、软删除标记。这些属性不需要开发人员手动去书写/控制，ABP vNext 框架将会自动跟踪这些属性并设置其值。\n开发人员除了可以直接继承 FullAuditedEntity 以外，也可以考虑集成其他的审计实例，例如只包含创建人与创建时间的 CreationAuditedEntity。如果你觉得你只想要创建人、软删除标记、修改时间的话，也可以直接继承相应的接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class TestEntity : Entity\u0026lt;int\u0026gt;,IMayHaveCreator,ISoftDelete,IHasModificationTime { /// \u0026lt;summary\u0026gt; /// 创建人的 Id。 /// \u0026lt;/summary\u0026gt; public Guid? CreatorId { get; set; } /// \u0026lt;summary\u0026gt; /// 软删除标记。 /// \u0026lt;/summary\u0026gt; public bool IsDeleted { get; set; } /// \u0026lt;summary\u0026gt; /// 最后的修改时间。 /// \u0026lt;/summary\u0026gt; public DateTime? LastModificationTime { get; set; } } 这里我只重点提一下关于审计实体相关的内容，对于聚合的根对象的审计实体，内容也是相似的，就不再赘述。\n2.3 值对象 (ValueObject) 2.3.1 基本概念 DDD 关于值对象某一个概念来说，每个值对象都是单一的副本，这个概念你可以类比 C# 里面关于值对象和引用对象的区别。\n值对象与实体最大的区别就在于，值对象是没有概念标识的，还有比较重要的一点就是值对象是不可变的，所谓的不可变，就是值对象产生任何变化应该直接替换掉原有副本，而不是在原有副本上进行修改。**如果值对象是可变的，那么它一定不能被共享。**值对象可以引用实体或者其他的值对象。\n这里仍然以书中的例子进行说明值对象的标识问题，例如 “地址” 这个概念。\n如果我在淘宝买了一个键盘，我的室友也从淘宝买了同款键盘。对于淘宝系统来说，我们两个是否处于同一个地址并不重要，所以这里 “地址” 就是一个值对象。因为系统不需要关心两个地址的唯一标识是否一致，在业务上来说也没有这个需要。\n另一个情况就是家里停电了，我和我的室友同时在电力服务系统提交了工单。这个时候对于电力系统来说，如果两个工单的地址是在同一个地方，那么只需要派一个人去进行维修即可。这种情况下，地址就是一个实体，因为地址涉及到比较，而比较的依据则是地址的唯一标识。\n上述情况还有的另一种实现方式，即我们将住处抽象为一个实体，电力系统与住处进行关联。住处里面包含地址，这个时候地址就是一个值对象。因为这个时候电力系统关心的是住处是否一致，而地址则作为一个普通的属性而已。\n关于值对象的另一个用法则更加通俗，例如一个 Person 类，他原来的定义是拥有一个 Id、姓名、街道、社区、城市。那么我们可以将街道、社区、城市抽象到一个值对象 Address 类里面，每个值对象内部包含的属性应该形成一个概念上的整体。\n2.3.2 如何实现 ABP vNext 对于值对象的实现是比较粗糙的，他仅参考 MSDN 定义了一个简单的 ValueObject 类型，具体的用法开发人员可以参考 MSDN 实现值对象的细节，下文仅是摘抄部分内容进行简要描述。\nMSDN 也是以地址为例，他将 Address 定义为一个值对象，如下代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Address : ValueObject { public String Street { get; private set; } public String City { get; private set; } public String State { get; private set; } public String Country { get; private set; } public String ZipCode { get; private set; } private Address() { } public Address(string street, string city, string state, string country, string zipcode) { Street = street; City = city; State = state; Country = country; ZipCode = zipcode; } protected override IEnumerable\u0026lt;object\u0026gt; GetAtomicValues() { // Using a yield return statement to return each element one at a time yield return Street; yield return City; yield return State; yield return Country; yield return ZipCode; } } 不过我们知道，如果一个值对象需要持久化到数据库，没有 Id 标识咋办？MSDN 上面也说明了在 EF Core 1.1 和 EF Core 2.0 的处理方法，这里我们只着重说明 EF Core 2.0 的处理方法。\nEF Core 2.0 可以使用 owned entity(固有实体类型) 来实现值对象，固有实体的以下特征可以帮助我们实现值对象。\n固有对象可以用作属性，并且没有自己的标识。 在查询所有实体时，固有实体将会包含进去。例如我查询订单 A，那么就会将地址这个值对象包含到订单 A 的结果当中。 但一个类型不管怎样都是会拥有它自己的标识的，这里不再详细叙述，更加详细的可以参考 MSDN 英文原版说明。(中文版翻译有问题)\nThe identity of the owner The navigation property pointing to them In the case of collections of owned types, an independent component (not yet supported in EF Core 2.0, coming up on 2.2). EF Core 不会自动发现固有实体类型，需要显示声明，这里以 MSDN 官方的 eShopOnContainers DEMO 为例。\n1 2 3 4 5 6 7 8 protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.ApplyConfiguration(new ClientRequestEntityTypeConfiguration()); modelBuilder.ApplyConfiguration(new PaymentMethodEntityTypeConfiguration()); modelBuilder.ApplyConfiguration(new OrderEntityTypeConfiguration()); modelBuilder.ApplyConfiguration(new OrderItemEntityTypeConfiguration()); //...Additional type configurations } 接着我们来到 OrderEntityTypeConfiguration 类型的 Configure() 方法中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public void Configure(EntityTypeBuilder\u0026lt;Order\u0026gt; orderConfiguration) { orderConfiguration.ToTable(\u0026#34;orders\u0026#34;, OrderingContext.DEFAULT_SCHEMA); orderConfiguration.HasKey(o =\u0026gt; o.Id); orderConfiguration.Ignore(b =\u0026gt; b.DomainEvents); orderConfiguration.Property(o =\u0026gt; o.Id) .ForSqlServerUseSequenceHiLo(\u0026#34;orderseq\u0026#34;, OrderingContext.DEFAULT_SCHEMA); // 说明 Address 属性是 Order 类型的固有实体。 orderConfiguration.OwnsOne(o =\u0026gt; o.Address); orderConfiguration.Property\u0026lt;DateTime\u0026gt;(\u0026#34;OrderDate\u0026#34;).IsRequired(); //...Additional validations, constraints and code... //... } 默认情况下，EF Core 会将固有实体的数据库列名，以 \u0026lt;实体的属性名\u0026gt;_\u0026lt;固有实体的属性\u0026gt;。以上面的 Address 类型字段为例，将会生成 Address_Street 、Address_City 这样的名称。你也可以通过流畅接口来重命名这些列，代码如下：\n1 2 3 4 5 orderConfiguration.OwnsOne(p =\u0026gt; p.Address) .Property(p=\u0026gt;p.Street).HasColumnName(\u0026#34;ShippingStreet\u0026#34;); orderConfiguration.OwnsOne(p =\u0026gt; p.Address) .Property(p=\u0026gt;p.City).HasColumnName(\u0026#34;ShippingCity\u0026#34;); 2.4 聚合 如果说实体的概念还比较好理解的话，那么聚合则是在实体之上新的抽象。聚合就是一组相关对象的集合，他会有一个根对象(root)，和它的一个边界(boundary)。对于聚合外部来说，只能够引用它的根对象，而在聚合内部的其他对象则可以相互引用。\n一个简单的例子(《领域驱动设计》)来说，汽车是一个具有全局标识的实体，每一辆汽车都拥有自己唯一的标识。在某些时候，我们可能会需要知道轮胎的磨损情况与公里数，因为汽车有四个轮胎，所以我们也需要将轮胎视为实体，为其分配唯一本地的标识，这个标识是聚合内唯一的。但是在脱离了汽车这个边界之后，我们就不需要关心这些轮胎的标识。\n所以在上述例子当中，汽车是一个聚合的根实体，而轮胎处于这个聚合的边界之内。\n那么一个聚合应该怎样进行设计呢？这里我引用汤雪华大神的 《关于领域驱动设计（DDD）中聚合设计的一些思考》 和 《聚合（根）、实体、值对象精炼思考总结》 说明一下聚合根要怎么设计才合理。\n聚合的几大设计原则：\n聚合是用来封装不变性（即固定规则），而不是将领域对象简单组合到一起。 聚合应该尽量设计成小聚合。 聚合与聚合之间的关系应该通过 Id 进行引用。 聚合内部应该是强一致性（同一事务），聚合之间只需要追求最终一致性即可。 以上内容我们还是以经典的订单系统来举例子，说明我们的实体与聚合应该怎样进行划分。我们有一个订单系统，其结构如下图：\n其中有一个固定规则，就是采购项(Line Item)的总量不能够超过 PO 总额(approved limit)的限制，这里的 Part 是具体采购的部件(产品)，它拥有一个 price 属性作为它的金额。\n从上述业务场景我们就可以得出以下问题：\n固定规则的实施，即添加新的采购项时，PO 需要检查总额，如果超出限制视为无效。 当 PO 被删除或者存档时，采购项也应该一并处理。（同生共死原则） 多用户的竞争问题，如果在采购过程中，采购项与部件都被用户修改，会产生问题。 场景 1：\n当用户编辑任何一个对象时，锁定该对象，直到编辑完成提交事务。这样就会造成 George 编辑订单 #0001 的采购项 001 时，Amanda 无法修改该采购项。但是 Amanda 可以修改其他的采购项，这样最后提交的时候就会导致 #0001 订单破坏了固定规则。\n场景 2：\n如果锁定单行对象不行，那么我们直接锁定 PO 对象，并且为了防止 Part 的价格被修改，Part 对象也需要被锁定。这样就会造成太多的数据争用，现在 3 个人都需要等待。\n从上述场景来看，我们可以得出以下结论：\nPart 在很多 PO 当中被使用。 对 Part 的修改少于对 PO 的修改。 PO 与采购项不能分开，后者独立存在没有意义。 对 Part 的价格修改不一定要实时传播给 PO，仅取决于修改价格时 PO 处于什么状态。 有以上结论可以知道，我们可以将 Part 的价格冗余到采购项，PO 和采购项的创建与删除是很自然的业务规则，而 Part 的创建与删除是独立的，所以将 PO 与采购项能划为一个聚合。\nAbp vNext 框架也为我们提供了聚合的定义与具体实现，即 AggregateRoot 类型。该类型也继承自 Entity 类型，并且内部提供了一个并发令牌防止并发冲突。\n并且在其内部也提供了领域事件的快速增删方法，其他的与常规实体基本一致。通过领域事件，我们可以完成对事务的拆分。例如上述的例子当中，我们也可以为 Part 增加一个领域事件，当价格被更新时，PO 可以订阅这个事件，实现对应的采购项更新。\n只是这里你会奇怪，增加的事件到哪儿去了呢？他们这些事件最终会被添加到 EntityChangeReport 类型的 DomainEvents 集合里面，并且在实体变更时进行触发。\n关于聚合的 示例，在 ABP vNext 官网已经有十分详细的描述，这里我贴上代码供大家理解以下，官方的例子仍然是以订单和采购项来说的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 public class Order : AggregateRoot\u0026lt;Guid\u0026gt; { public virtual string ReferenceNo { get; protected set; } public virtual int TotalItemCount { get; protected set; } public virtual DateTime CreationTime { get; protected set; } public virtual List\u0026lt;OrderLine\u0026gt; OrderLines { get; protected set; } protected Order() { } public Order(Guid id, string referenceNo) { Check.NotNull(referenceNo, nameof(referenceNo)); Id = id; ReferenceNo = referenceNo; OrderLines = new List\u0026lt;OrderLine\u0026gt;(); } public void AddProduct(Guid productId, int count) { if (count \u0026lt;= 0) { throw new ArgumentException( \u0026#34;You can not add zero or negative count of products!\u0026#34;, nameof(count) ); } var existingLine = OrderLines.FirstOrDefault(ol =\u0026gt; ol.ProductId == productId); if (existingLine == null) { OrderLines.Add(new OrderLine(this.Id, productId, count)); } else { existingLine.ChangeCount(existingLine.Count + count); } TotalItemCount += count; } } public class OrderLine : Entity { public virtual Guid OrderId { get; protected set; } public virtual Guid ProductId { get; protected set; } public virtual int Count { get; protected set; } protected OrderLine() { } internal OrderLine(Guid orderId, Guid productId, int count) { OrderId = orderId; ProductId = productId; Count = count; } internal void ChangeCount(int newCount) { Count = newCount; } } 2.5 服务 (Service) 根据 DDD 理论来说，每个实体或者值对象已经具有一些业务方法，为什么还需要服务对象来进行处理呢？\n因为在某些情况下，某些重要的领域动作都不属于任何实体或者值对象，强行将它归纳在某一个对象里面，那么就会产生概念上的混淆。\n服务都是没有自己的状态，它们除了承载领域操作以外没有其他任何意义。服务则是作为一种接口提供操作，一个良好的服务定义拥有一下几个特征。\n与领域概念相关的操作不是实体或者值对象的自然组成部分。 接口是根据领域模型的其他元素定义的。 操作是无状态的。 从上述定义来看，我们的**控制器(Controller)**就符合这几个特征，尤其是无状态的定义。那么我们哪些操作能够放到服务对象当中呢？根据 DDD 理论来说，只有领域当中某个重要的过程或者转换操作不是实体或值对象的自然职责的时候，就应该添加一个独立的服务来承载这些操作。\n那么问题来了，在层级架构来说，领域层的服务对象和应用层的服务对象最难以区分。以书中的例子举例，当客户余额小于某个阈值的时候，就会向客户发送电子邮件。在这里，应用服务负责通知的设置，而领域服务则需要确定客户是否满足阈值。这里就涉及到了银行领域的业务，说白了领域服务是会涉及到具体业务规则的。\n下面就是书中关于不同分层当中服务对象的划分：\n从上面的描述来看，领域层的应用服务就对应着 ABP vNext 框架当中的应用服务。所以我们可以将应用服务作为 API 接口暴露给前端(表现层)，因为应用服务仅仅是起一个协调领域层和基础设施层的作用。(类似脚本)\n2.5.1 领域服务 (Domain Service) 上面我们了解了什么是领域服务，ABP vNext 为我们提供了领域服务的基本抽象定义 IDomainService 与 DomainService。\n它们的内部实现比较简单，只注入了一些常用的基础组件，我们使用的时候直接继承 DomainService 类型即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public abstract class DomainService : IDomainService { public IServiceProvider ServiceProvider { get; set; } protected readonly object ServiceProviderLock = new object(); protected TService LazyGetRequiredService\u0026lt;TService\u0026gt;(ref TService reference) { // 比较简单的双重检查锁定模式。 if (reference == null) { lock (ServiceProviderLock) { if (reference == null) { reference = ServiceProvider.GetRequiredService\u0026lt;TService\u0026gt;(); } } } return reference; } public IClock Clock =\u0026gt; LazyGetRequiredService(ref _clock); private IClock _clock; // Guid 生成器。 public IGuidGenerator GuidGenerator { get; set; } // 日志工厂。 public ILoggerFactory LoggerFactory =\u0026gt; LazyGetRequiredService(ref _loggerFactory); private ILoggerFactory _loggerFactory; // 获取当前租户。 public ICurrentTenant CurrentTenant =\u0026gt; LazyGetRequiredService(ref _currentTenant); private ICurrentTenant _currentTenant; // 日志组件。 protected ILogger Logger =\u0026gt; _lazyLogger.Value; private Lazy\u0026lt;ILogger\u0026gt; _lazyLogger =\u0026gt; new Lazy\u0026lt;ILogger\u0026gt;(() =\u0026gt; LoggerFactory?.CreateLogger(GetType().FullName) ?? NullLogger.Instance, true); protected DomainService() { GuidGenerator = SimpleGuidGenerator.Instance; } } 2.5.2 应用服务 (Application Service) 应用服务的内容比较复杂繁多，会在下一篇文章《[Abp vNext 源码分析] - 6. DDD 的应用层支持 (应用服务)》里面进行详细描述，这里就暂不进行说明。\n2.6 仓储 (Repository) 仓储这个东西大家应该都不会陌生，毕竟仓储模式这玩意儿玩了这么久了，我等 Crud 码农必备利器。那么这里的仓储和 DDD 概念里面的仓储有什么异同呢？\n2.6.1 背景 我们首先要明确 DDD 里面为什么会引入仓储这个概念，虽然我们可以通过遍历对象的关联来获取相关的对象，但总是要有一个起点。传统开发人员会构造一个 SQL 查询，将其传递给基础设施层的某个查询服务，然后根据得到的表/行数据重建实体对象，ORM 框架就是这样诞生的。\n通过上述手段，开发人员就会试图绕开领域模型，转而直接获取或者操作它们所需要的数据，这样就会导致越来越多的领域规则被嵌入到查询代码当中。更为严重的是，开发人员将会直接查询数据库从中提取它们需要的数据，而不是通过聚合的根来得到这些对象。这样就会导致领域逻辑(业务规则)进入查询代码当中，而我们的实体和值对象最终只是存放数据的容器而已。最后我们的领域层只是一个空壳，最后使得模型无关紧要。\n所以我们需要一种组件，能够通过根遍历查找对象，并且禁止其他方法对聚合内部的任何对象进行访问。而持久化的值对象可以通过遍历某个实体找到，所以值对象是不需要全局搜索的。\n而仓储就能够解决上述问题，仓储可以将某种类型的所有对象表示为一个概念上的集合。开发人员只需要调用仓储对外提供的简单接口，就可以重建实体，而具体的查询、插入等技术细节完全被仓储封装。这样开发人员只需要关注领域模型。\n仓储的优点有以下几点：\n提供简单的模型，可用来获取持久化对象并管理它们的生命周期。 将应用程序与持久化技术解耦。 利于进行单元测试，例如使用内存数据库替换掉实际访问的数据库。 2.6.2 实现 ABP vNext 为我们提供了几种类型的仓储 IRepository、IBasicRepository、IReadOnlyRepository 等，其实从名字就可以看出来它们具体的职责。首先我们来看 IReadonly\u0026lt;XXX\u0026gt; 仓储，很明显这种类型的仓储只提供了查询方法，因为它们是只读的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public interface IReadOnlyBasicRepository\u0026lt;TEntity\u0026gt; : IRepository where TEntity : class, IEntity { // 获得所有实体对象。 List\u0026lt;TEntity\u0026gt; GetList(bool includeDetails = false); // 获得所有实体对象。 Task\u0026lt;List\u0026lt;TEntity\u0026gt;\u0026gt; GetListAsync(bool includeDetails = false, CancellationToken cancellationToken = default); // 获得实体对象的数据量。 long GetCount(); // 获得实体对象的数据量。 Task\u0026lt;long\u0026gt; GetCountAsync(CancellationToken cancellationToken = default); } public interface IReadOnlyBasicRepository\u0026lt;TEntity, TKey\u0026gt; : IReadOnlyBasicRepository\u0026lt;TEntity\u0026gt; where TEntity : class, IEntity\u0026lt;TKey\u0026gt; { // 根据实体的唯一标识重建对象，没有找到对象时抛出 EntityNotFoundException 异常。 [NotNull] TEntity Get(TKey id, bool includeDetails = true); [NotNull] Task\u0026lt;TEntity\u0026gt; GetAsync(TKey id, bool includeDetails = true, CancellationToken cancellationToken = default); // 根据实体的唯一标识重建对象，没有找到对象时返回 null。 [CanBeNull] TEntity Find(TKey id, bool includeDetails = true); Task\u0026lt;TEntity\u0026gt; FindAsync(TKey id, bool includeDetails = true, CancellationToken cancellationToken = default); } 除了只读仓储以外， 还拥有支持插入、更新、删除的仓储定义，它们都存放在 IBasicRepository 当中。在 Volo.Abp.Ddd.Domain 模块里面为我们提供了仓储类型的抽象实现 RepositoryBase 。\n这个抽象基类里面我们需要注意几个基础组件：\nBasicRepositoryBase 基类里面注入的 ICancellationTokenProvider 对象。 RepositoryBase 基类注入的 IDataFilter 对象。 RepositoryBase 基类注入的 ICurrentTenant 对象。 以上三个对象都不是我们讲过的组件，这里我先大概说一下它们的作用。\n2.6.2.1 ICancellationTokenProvider CancellationToken 很多人都用过，它的作用是用来取消某个耗时的异步任务。ICancellationTokenProvider 顾名思义就是 CancellationToken 的提供者，那么谁提供呢？\n可以看到它有两个定义，一个是从 Http 上下文获取，一个是默认实现，首先来看一般都很简单的默认实现。\n1 2 3 4 5 6 7 8 9 10 11 public class NullCancellationTokenProvider : ICancellationTokenProvider { public static NullCancellationTokenProvider Instance { get; } = new NullCancellationTokenProvider(); public CancellationToken Token { get; } = CancellationToken.None; private NullCancellationTokenProvider() { } } emmm，确实很简单，他直接返回的就是 CancellationToken.None 空值。那我们现在去看一下 Http 上下文的实现吧：\n1 2 3 4 5 6 7 8 9 10 11 12 [Dependency(ReplaceServices = true)] public class HttpContextCancellationTokenProvider : ICancellationTokenProvider, ITransientDependency { public CancellationToken Token =\u0026gt; _httpContextAccessor.HttpContext?.RequestAborted ?? CancellationToken.None; private readonly IHttpContextAccessor _httpContextAccessor; public HttpContextCancellationTokenProvider(IHttpContextAccessor httpContextAccessor) { _httpContextAccessor = httpContextAccessor; } } 从上面可以看到，这个提供者是从 HttpContext 里面拿的 RequestAborted ，这个属性是哪儿来的呢？看它的说明是：\nNotifies when the connection underlying this request is aborted and thus request operations should be cancelled.\nSoga，这个意思就是如果一个 Http 请求被中止的时候，就会触发的取消标记哦。\n那么它放在仓储基类里面干什么呢？肯定是要取消掉耗时的查询/持久化异步任务啊，不然一直等么\u0026hellip;\n2.6.2.2 IDataFilter 这个接口名字跟之前一样，很通俗，数据过滤器，用来过滤查询数据用的。使用过 ABP 框架的同学肯定知道这玩意儿，主要是用来过滤多租户和软删除标记的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 protected virtual TQueryable ApplyDataFilters\u0026lt;TQueryable\u0026gt;(TQueryable query) where TQueryable : IQueryable\u0026lt;TEntity\u0026gt; { // 如果实体实现了软删除标记，过滤掉已删除的数据。 if (typeof(ISoftDelete).IsAssignableFrom(typeof(TEntity))) { query = (TQueryable)query.WhereIf(DataFilter.IsEnabled\u0026lt;ISoftDelete\u0026gt;(), e =\u0026gt; ((ISoftDelete)e).IsDeleted == false); } // 如果实体实现了多租户标记，根据租户 Id 过滤数据。 if (typeof(IMultiTenant).IsAssignableFrom(typeof(TEntity))) { var tenantId = CurrentTenant.Id; query = (TQueryable)query.WhereIf(DataFilter.IsEnabled\u0026lt;IMultiTenant\u0026gt;(), e =\u0026gt; ((IMultiTenant)e).TenantId == tenantId); } return query; } 更加详细的我们放在后面说明\u0026hellip;这里你只需要知道它是用来过滤数据的就行了。\n2.6.2.3 ICurrentTenant 英语在学习编程的时候还是很重要的，这个接口的意思是当前租户，肯定这玩意儿就是提供当前登录用户的租户 Id 咯，在上面的例子里面有使用到。\n2.6.3 仓储的注册 不论是 ABP vNext 提供的默认仓储也好，还是说我们自己定义的仓储也好，都需要注入到 IoC 容器当中。ABP vNext 为我们提供了一个仓储注册基类 RepositoryRegisterarBase\u0026lt;TOptions\u0026gt; ，查看这个基类的实现就会发现仓储的具体实现模块都实现了这个基类。\n这是因为仓储肯定会有多种实现的，例如 EF Core 的仓储实现肯定有自己的一套注册机制，所以这里仅提供了一个抽象基类给开发人员。\n在基类里面，ABP vNext 首先会注册自定义的仓储类型，因为从仓储的 DDD 定义来看，我们有些业务可能会需要一些特殊的仓储接口，这个时候就需要自定义仓储了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public virtual void AddRepositories() { // 遍历自定义仓储。 foreach (var customRepository in Options.CustomRepositories) { // 调用注册方法，注册这些仓储。 Options.Services.AddDefaultRepository(customRepository.Key, customRepository.Value); } // 是否注册 ABP vNext 生成的默认仓储。 if (Options.RegisterDefaultRepositories) { RegisterDefaultRepositories(); } } CustomRepositories 里面的仓储是通过基类 CommonDbContextRegistrationOptions 所定义的 AddRepository() 方法进行添加的。例如单元测试里面就有使用范例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public override void ConfigureServices(ServiceConfigurationContext context) { var connStr = Guid.NewGuid().ToString(); Configure\u0026lt;DbConnectionOptions\u0026gt;(options =\u0026gt; { options.ConnectionStrings.Default = connStr; }); // 添加自定义仓储。 context.Services.AddMemoryDbContext\u0026lt;TestAppMemoryDbContext\u0026gt;(options =\u0026gt; { options.AddDefaultRepositories(); options.AddRepository\u0026lt;City, CityRepository\u0026gt;(); }); } 接着我们看自定义仓储是如何注册到 IoC 容器里面的呢？这里调用的 AddDefaultRepository() 方法就是在 Microsoft 文件夹里面定义的注册扩展方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public static IServiceCollection AddDefaultRepository(this IServiceCollection services, Type entityType, Type repositoryImplementationType) { // 注册复合主键实体所对应的仓储。 //IReadOnlyBasicRepository\u0026lt;TEntity\u0026gt; var readOnlyBasicRepositoryInterface = typeof(IReadOnlyBasicRepository\u0026lt;\u0026gt;).MakeGenericType(entityType); if (readOnlyBasicRepositoryInterface.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(readOnlyBasicRepositoryInterface, repositoryImplementationType); //IReadOnlyRepository\u0026lt;TEntity\u0026gt; var readOnlyRepositoryInterface = typeof(IReadOnlyRepository\u0026lt;\u0026gt;).MakeGenericType(entityType); if (readOnlyRepositoryInterface.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(readOnlyRepositoryInterface, repositoryImplementationType); } //IBasicRepository\u0026lt;TEntity\u0026gt; var basicRepositoryInterface = typeof(IBasicRepository\u0026lt;\u0026gt;).MakeGenericType(entityType); if (basicRepositoryInterface.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(basicRepositoryInterface, repositoryImplementationType); //IRepository\u0026lt;TEntity\u0026gt; var repositoryInterface = typeof(IRepository\u0026lt;\u0026gt;).MakeGenericType(entityType); if (repositoryInterface.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(repositoryInterface, repositoryImplementationType); } } } // 首先获得实体的主键类型，再进行注册。 var primaryKeyType = EntityHelper.FindPrimaryKeyType(entityType); if (primaryKeyType != null) { //IReadOnlyBasicRepository\u0026lt;TEntity, TKey\u0026gt; var readOnlyBasicRepositoryInterfaceWithPk = typeof(IReadOnlyBasicRepository\u0026lt;,\u0026gt;).MakeGenericType(entityType, primaryKeyType); if (readOnlyBasicRepositoryInterfaceWithPk.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(readOnlyBasicRepositoryInterfaceWithPk, repositoryImplementationType); //IReadOnlyRepository\u0026lt;TEntity, TKey\u0026gt; var readOnlyRepositoryInterfaceWithPk = typeof(IReadOnlyRepository\u0026lt;,\u0026gt;).MakeGenericType(entityType, primaryKeyType); if (readOnlyRepositoryInterfaceWithPk.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(readOnlyRepositoryInterfaceWithPk, repositoryImplementationType); } //IBasicRepository\u0026lt;TEntity, TKey\u0026gt; var basicRepositoryInterfaceWithPk = typeof(IBasicRepository\u0026lt;,\u0026gt;).MakeGenericType(entityType, primaryKeyType); if (basicRepositoryInterfaceWithPk.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(basicRepositoryInterfaceWithPk, repositoryImplementationType); //IRepository\u0026lt;TEntity, TKey\u0026gt; var repositoryInterfaceWithPk = typeof(IRepository\u0026lt;,\u0026gt;).MakeGenericType(entityType, primaryKeyType); if (repositoryInterfaceWithPk.IsAssignableFrom(repositoryImplementationType)) { services.TryAddTransient(repositoryInterfaceWithPk, repositoryImplementationType); } } } } return services; } 上面代码没什么好说的，只是根据不同的类型来进行不同的注册而已。\n以上是注册我们自定义的仓储类型，只要开发人员调用过 AddDefaultRepositories() 方法，那么 ABP vNext 会为每个不同的实体注册响应的默认仓库。\n1 2 3 4 5 6 7 8 public ICommonDbContextRegistrationOptionsBuilder AddDefaultRepositories(bool includeAllEntities = false) { // 可以看到将参数设置为 true 了。 RegisterDefaultRepositories = true; IncludeAllEntitiesForDefaultRepositories = includeAllEntities; return this; } 默认仓库仅包含基础仓储所定义的增删改查等方法，开发人员只需要注入相应的接口就能够直接使用。既然要为每个实体类型注入对应的默认仓储，肯定就需要知道当前项目有多少个实体，并获得它们的类型定义。\n这里我们基类仅仅是调用抽象方法 GetEntityTypes() ，然后根据具体实现返回的类型定义来注册默认仓储。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 protected virtual void RegisterDefaultRepositories() { foreach (var entityType in GetEntityTypes(Options.OriginalDbContextType)) { // 判断该实体类型是否需要注册默认仓储。 if (!ShouldRegisterDefaultRepositoryFor(entityType)) { continue; } // 为实体对象注册相应的默认仓储，这里仍然调用之前的扩展方法进行注册。 RegisterDefaultRepository(entityType); } } 找到 EF Core 定义的仓储注册器，就能够看到他是通过遍历 DbContext 里面的属性来获取所有实体类型定义的。\n1 2 3 4 5 6 7 8 9 public static IEnumerable\u0026lt;Type\u0026gt; GetEntityTypes(Type dbContextType) { return from property in dbContextType.GetTypeInfo().GetProperties(BindingFlags.Public | BindingFlags.Instance) where ReflectionHelper.IsAssignableToGenericType(property.PropertyType, typeof(DbSet\u0026lt;\u0026gt;)) \u0026amp;\u0026amp; typeof(IEntity).IsAssignableFrom(property.PropertyType.GenericTypeArguments[0]) select property.PropertyType.GenericTypeArguments[0]; } 最后的最后，这个注册器在什么时候被调用的呢？注册器一般是在项目的基础设施模块当中进行调用，这里以单元测试的代码为例，它是使用的 EF Core 作为持久层的基础设施。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [DependsOn(typeof(AbpEntityFrameworkCoreModule))] public class AbpEfCoreTestSecondContextModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { // 注意这里。 context.Services.AddAbpDbContext\u0026lt;SecondDbContext\u0026gt;(options =\u0026gt; { options.AddDefaultRepositories(); }); // 注意这里。 context.Services.AddAbpDbContext\u0026lt;ThirdDbContext.ThirdDbContext\u0026gt;(options =\u0026gt; { options.AddDefaultRepositories\u0026lt;IThirdDbContext\u0026gt;(); }); } } 跳转到 ABP vNext 提供的 EF Core模块，找到 AddAbpDbContext() 方法当中，发现了仓储注册器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public static class AbpEfCoreServiceCollectionExtensions { public static IServiceCollection AddAbpDbContext\u0026lt;TDbContext\u0026gt;( this IServiceCollection services, Action\u0026lt;IAbpDbContextRegistrationOptionsBuilder\u0026gt; optionsBuilder = null) where TDbContext : AbpDbContext\u0026lt;TDbContext\u0026gt; { services.AddMemoryCache(); var options = new AbpDbContextRegistrationOptions(typeof(TDbContext), services); optionsBuilder?.Invoke(options); services.TryAddTransient(DbContextOptionsFactory.Create\u0026lt;TDbContext\u0026gt;); foreach (var dbContextType in options.ReplacedDbContextTypes) { services.Replace(ServiceDescriptor.Transient(dbContextType, typeof(TDbContext))); } // 在这里。 new EfCoreRepositoryRegistrar(options).AddRepositories(); return services; } } 2.7 领域事件 在 ABP vNext 中，除了本地事件总线以外，还为我们提供了基于 Rabbit MQ 的分布式事件总线。关于事件总线的内容，这里就不再详细赘述，后面会有专门的文章讲解事件总线的相关知识。\n在这里，主要提一下什么是领域事件。其实领域事件与普通的事件并没什么本质上的不同，只是它们触发的地方和携带的参数有点特殊罢了。并且按照聚合的特性来说，其实聚合与聚合之间的通讯，主要是通过领域事件来实现的。\n这里的领域事件都是针对于实体产生变更时需要被触发的事件，例如我们有一个学生实体，在它被修改之后，ABP vNext 框架就会触发一个实体更新事件。\n触发领域事件这些动作都被封装在 EntityChangeEventHelper 里面，以刚才的例子来说，我们可以看到它会触发以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public virtual async Task TriggerEntityUpdatedEventOnUowCompletedAsync(object entity) { // 触发本地事件总线。 await TriggerEventWithEntity( LocalEventBus, typeof(EntityUpdatedEventData\u0026lt;\u0026gt;), entity, false ); var eto = EntityToEtoMapper.Map(entity); if (eto != null) { // 触发分布式事件总线。 await TriggerEventWithEntity( DistributedEventBus, typeof(EntityUpdatedEto\u0026lt;\u0026gt;), eto, false ); } } 关于领域事件其他的细节就不再描述，如果大家想要更加全面的了解，请直接阅读 ABP vNext 的相关源码。\n三、总结 本篇文章更多的注重 DDD 理论，关于 ABP vNext 的技术实现细节并未体现在当前模块，后续我会在其他章节注重描述关于上述 DDD 概念的技术实现。\n","date":"2019-07-20T02:05:28Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---5-domain-layer-support-for-ddd-repository-entity-value-object/","title":"ABP vNext 源码分析 - 5. DDD 的领域层支持 (仓储、实体、值对象)"},{"content":"一、简要说明 统一工作单元是一个比较重要的基础设施组件，它负责管理整个业务流程当中涉及到的数据库事务，一旦某个环节出现异常自动进行回滚处理。\n在 ABP vNext 框架当中，工作单元被独立出来作为一个单独的模块(Volo.Abp.Uow)。你可以根据自己的需要，来决定是否使用统一工作单元。\n二、源码分析 整个 Volo.Abp.Uow 项目的结构如下，从下图还是可以看到我们的老朋友 IUnitOfWorkManager 和 IUnitOfWork ，不过也多了一些新东西。看一个模块的功能，首先从它的 Module 入手，我们先看一下 AbpUnitofWorkModule 里面的实现。\n2.1 工作单元的初始模块 打开 AbpUnitOfWorkModule 里面的代码，发现还是有点失望，里面就一个服务注册完成事件。\n1 2 3 4 public override void PreConfigureServices(ServiceConfigurationContext context) { context.Services.OnRegistred(UnitOfWorkInterceptorRegistrar.RegisterIfNeeded); } 这里的结构和之前看的 审计日志 模块类似，就是注册拦截器的作用，没有其他特别的操作。\n2.1.1 拦截器注册 继续跟进代码，其实现是通过 UnitOfWorkHelper 来确定哪些类型应该集成 UnitOfWork 组件。\n1 2 3 4 5 6 7 8 public static void RegisterIfNeeded(IOnServiceRegistredContext context) { // 根据回调传入的 context 绑定的实现类型，判断是否应该为该类型注册 UnitOfWorkInterceptor 拦截器。 if (UnitOfWorkHelper.IsUnitOfWorkType(context.ImplementationType.GetTypeInfo())) { context.Interceptors.TryAdd\u0026lt;UnitOfWorkInterceptor\u0026gt;(); } } 继续分析 UnitOfWorkHelper 内部的代码，第一种情况则是实现类型 (implementationType) 或类型的任一方法标注了 UnitOfWork 特性的话，都会为其注册工作单元拦截器。\n第二种情况则是 ABP vNext 为我们提供了一个新的 IUnitOfWorkEnabled 标识接口。只要继承了该接口的实现，都会被视为需要工作单元组件，会在系统启动的时候，自动为它绑定拦截器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static bool IsUnitOfWorkType(TypeInfo implementationType) { // 第一种方式，即判断具体类型与其方法是否标注了 UnitOfWork 特性。 if (HasUnitOfWorkAttribute(implementationType) || AnyMethodHasUnitOfWorkAttribute(implementationType)) { return true; } // 第二种方式，即判断具体类型是否继承自 IUnitOfWorkEnabled 接口。 if (typeof(IUnitOfWorkEnabled).GetTypeInfo().IsAssignableFrom(implementationType)) { return true; } return false; } 2.2 新的接口与抽象 在 ABP vNext 当中，将一些 职责 从原有的工作单元进行了 分离。抽象出了 IDatabaseApi 、ISupportsRollback、ITransactionApi 这三个接口，这三个接口分别提供了不同的功能和职责。\n2.2.1 数据库统一访问接口 这里以 IDatabaseApi 为例，它是提供了一个 数据库提供者(Database Provider) 的抽象概念，在 ABP vNext 里面，是将 EFCore 作为数据库概念来进行抽象的。(因为后续 MongoDb 与 MemoryDb 与其同级)\n你可以看作是 EF Core 的 Provider ，在 EF Core 里面我们可以实现不同的 Provider ，来让 EF Core 支持访问不同的数据库。\n而 ABP vNext 这么做的意图就是提供一个统一的数据库访问 API，如何理解呢？这里以 EFCoreDatabaseApi\u0026lt;TDbContext\u0026gt; 为例，你查看它的实现会发现它继承并实现了 ISupportsSavingChanges ，也就是说 EFCoreDatabaseApi\u0026lt;TDbContext\u0026gt; 支持 SaveChanges 操作来持久化数据更新与修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class EfCoreDatabaseApi\u0026lt;TDbContext\u0026gt; : IDatabaseApi, ISupportsSavingChanges where TDbContext : IEfCoreDbContext { public TDbContext DbContext { get; } public EfCoreDatabaseApi(TDbContext dbContext) { DbContext = dbContext; } public Task SaveChangesAsync(CancellationToken cancellationToken = default) { return DbContext.SaveChangesAsync(cancellationToken); } public void SaveChanges() { DbContext.SaveChanges(); } } 也就是说 SaveChanges 这个操作，是 EFCore 这个 DatabaseApi 提供了一种特殊操作，是该类型数据库的一种特殊接口。\n如果针对于某些特殊的数据库，例如 InfluxDb 等有一些特殊的 Api 操作时，就可以通过一个 DatabaseApi 类型进行处理。\n2.2.2 数据库事务接口 通过最开始的项目结构会发现一个 ITransactionApi 接口，这个接口只定义了一个 事务提交操作(Commit)，并提供了异步方法的定义。\n1 2 3 4 5 6 public interface ITransactionApi : IDisposable { void Commit(); Task CommitAsync(); } 跳转到其典型实现 EfCoreTransactionApi 当中，可以看到该类型还实现了 ISupportsRollback 接口。通过这个接口的名字，我们大概就知道它的作用，就是提供了回滚方法的定义。如果某个数据库支持回滚操作，那么就可以为其实现该接口。\n其实这里按照语义，你也可以将它放在 EfCoreDatabaseApi\u0026lt;TDbContext\u0026gt; 进行实现，因为回滚也是数据库提供的 API 之一，只是在 ABP vNext 里面又将其归为事务接口进行处理了。\n这里就不再详细赘述该类型的具体实现，后续会在单独的 EF Core 章节进行说明。\n2.3 工作单元的原理与实现 在 ABP vNext 框架当中的工作单元实现，与原来 ABP 框架有一些不一样。\n2.3.1 内部工作单元 (子工作单元) 首先说内部工作单元的定义，现在是有一个新的 ChildUnitOfWork 类型作为 子工作单元。子工作单元本身并不会产生实际的业务逻辑操作，基本所有逻辑都是调用 UnitOfWork 的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 internal class ChildUnitOfWork : IUnitOfWork { public Guid Id =\u0026gt; _parent.Id; public IUnitOfWorkOptions Options =\u0026gt; _parent.Options; public IUnitOfWork Outer =\u0026gt; _parent.Outer; public bool IsReserved =\u0026gt; _parent.IsReserved; public bool IsDisposed =\u0026gt; _parent.IsDisposed; public bool IsCompleted =\u0026gt; _parent.IsCompleted; public string ReservationName =\u0026gt; _parent.ReservationName; public event EventHandler\u0026lt;UnitOfWorkFailedEventArgs\u0026gt; Failed; public event EventHandler\u0026lt;UnitOfWorkEventArgs\u0026gt; Disposed; public IServiceProvider ServiceProvider =\u0026gt; _parent.ServiceProvider; private readonly IUnitOfWork _parent; // 只有一个带参数的构造函数，传入的就是外部的工作单元(带事务)。 public ChildUnitOfWork([NotNull] IUnitOfWork parent) { Check.NotNull(parent, nameof(parent)); _parent = parent; _parent.Failed += (sender, args) =\u0026gt; { Failed.InvokeSafely(sender, args); }; _parent.Disposed += (sender, args) =\u0026gt; { Disposed.InvokeSafely(sender, args); }; } // 下面所有 IUnitOfWork 的接口方法，都是调用传入的 UnitOfWork 实例。 public void SetOuter(IUnitOfWork outer) { _parent.SetOuter(outer); } public void Initialize(UnitOfWorkOptions options) { _parent.Initialize(options); } public void Reserve(string reservationName) { _parent.Reserve(reservationName); } public void SaveChanges() { _parent.SaveChanges(); } public Task SaveChangesAsync(CancellationToken cancellationToken = default) { return _parent.SaveChangesAsync(cancellationToken); } public void Complete() { } public Task CompleteAsync(CancellationToken cancellationToken = default) { return Task.CompletedTask; } public void Rollback() { _parent.Rollback(); } public Task RollbackAsync(CancellationToken cancellationToken = default) { return _parent.RollbackAsync(cancellationToken); } public void OnCompleted(Func\u0026lt;Task\u0026gt; handler) { _parent.OnCompleted(handler); } public IDatabaseApi FindDatabaseApi(string key) { return _parent.FindDatabaseApi(key); } public void AddDatabaseApi(string key, IDatabaseApi api) { _parent.AddDatabaseApi(key, api); } public IDatabaseApi GetOrAddDatabaseApi(string key, Func\u0026lt;IDatabaseApi\u0026gt; factory) { return _parent.GetOrAddDatabaseApi(key, factory); } public ITransactionApi FindTransactionApi(string key) { return _parent.FindTransactionApi(key); } public void AddTransactionApi(string key, ITransactionApi api) { _parent.AddTransactionApi(key, api); } public ITransactionApi GetOrAddTransactionApi(string key, Func\u0026lt;ITransactionApi\u0026gt; factory) { return _parent.GetOrAddTransactionApi(key, factory); } public void Dispose() { } public override string ToString() { return $\u0026#34;[UnitOfWork {Id}]\u0026#34;; } } 虽然基本上所有方法的实现，都是调用的实际工作单元实例。但是有两个方法 ChildUnitOfWork 是空实现的，那就是 Complete() 和 Dispose() 方法。\n这两个方法一旦在内部工作单元调用了，就会导致 事务被提前提交，所以这里是两个空实现。\n下面就是上述逻辑的伪代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 using(var transactioinUow = uowMgr.Begin()) { // 业务逻辑 1 。 using(var childUow1 = uowMgr.Begin()) { // 业务逻辑 2。 using(var childUow2 = uowMgr.Begin()) { // 业务逻辑 3。 childUow2.Complete(); } childUow1.Complete(); } transactioinUow.Complete(); } 以上结构一旦某个内部工作单元抛出了异常，到会导致最外层带事务的工作单元无法调用 Complete() 方法，也就能够保证我们的 数据一致性。\n2.3.2 外部工作单元 首先我们查看 UnitOfWork 类型和 IUnitOfWork 的定义和属性，可以获得以下信息。\n每个工作单元是瞬时对象，因为它继承了 ITransientDependency 接口。\n每个工作单元都会有一个 Guid 作为其唯一标识信息。\n每个工作单元拥有一个 IUnitOfWorkOptions 来说明它的配置信息。\n这里的配置信息主要指一个工作单元在执行时的 超时时间，是否包含一个事务，以及它的 事务隔离级别（如果是事务性的工作单元的话）。\n每个工作单元存储了 IDatabaseApi 与 ITransactionApi 的集合，并提供了访问/存储接口。\n提供了两个操作事件 Failed 与 Disposed。\n这两个事件分别在工作单元执行失败以及被释放时(调用 Dispose() 方法)触发，开发人员可以挂载这两个事件提供自己的处理逻辑。\n工作单元还提供了一个工作单元完成事件组。\n用于开发人员在工作单元完成时(调用Complete() 方法)挂载自己的处理事件，因为是 List\u0026lt;Func\u0026lt;Task\u0026gt;\u0026gt; 所以你可以指定多个，它们都会在调用 Complete() 方法之后执行，例如如下代码：\n1 2 3 4 5 6 7 using (var uow = _unitOfWorkManager.Begin()) { uow.OnCompleted(async () =\u0026gt; completed = true); uow.OnCompleted(async()=\u0026gt;Console.WriteLine(\u0026#34;Hello ABP vNext\u0026#34;)); uow.Complete(); } 以上信息是我们查看了 UnitOfWork 的属性与接口能够直接得出的结论，接下来我会根据一个工作单元的生命周期来说明一遍工作单元的实现。\n一个工作单元的的构造是通过工作单元管理器实现的(IUnitOfWorkManager)，通过它的 Begin() 方法我们会获得一个工作单元，至于这个工作单元是外部工作单元还是内部工作单元，取决于开发人员传入的参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public IUnitOfWork Begin(UnitOfWorkOptions options, bool requiresNew = false) { Check.NotNull(options, nameof(options)); // 获得当前的工作单元。 var currentUow = Current; // 如果当前工作单元不为空，并且开发人员明确说明不需要构建新的工作单元时，创建内部工作单元。 if (currentUow != null \u0026amp;\u0026amp; !requiresNew) { return new ChildUnitOfWork(currentUow); } // 调用 CreateNewUnitOfWork() 方法创建新的外部工作单元。 var unitOfWork = CreateNewUnitOfWork(); // 使用工作单元配置初始化外部工作单元。 unitOfWork.Initialize(options); return unitOfWork; } 这里需要注意的就是创建新的外部工作单元方法，它这里就使用了 IoC 容器提供的 Scope 生命周期，并且在创建之后会将最外部的工作单元设置为最新创建的工作单元实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private IUnitOfWork CreateNewUnitOfWork() { var scope = _serviceProvider.CreateScope(); try { var outerUow = _ambientUnitOfWork.UnitOfWork; var unitOfWork = scope.ServiceProvider.GetRequiredService\u0026lt;IUnitOfWork\u0026gt;(); // 设置当前工作单元的外部工作单元。 unitOfWork.SetOuter(outerUow); // 设置最外层的工作单元。 _ambientUnitOfWork.SetUnitOfWork(unitOfWork); unitOfWork.Disposed += (sender, args) =\u0026gt; { _ambientUnitOfWork.SetUnitOfWork(outerUow); scope.Dispose(); }; return unitOfWork; } catch { scope.Dispose(); throw; } } 上述描述可能会有些抽象，结合下面这两幅图可能会帮助你的理解。\n我们可以在任何地方注入 IAmbientUnitOfWork 来获取当前活动的工作单元，关于 IAmbientUnitOfWork 与 IUnitOfWorkAccessor 的默认实现，都是使用的 AmbientUnitOfWork。\n在该类型的内部，通过 AsyncLocal\u0026lt;IUnitOfWork\u0026gt; 来确保在不同的 异步上下文切换 过程中，其值是正确且统一的。\n构造了一个外部工作单元之后，我们在仓储等地方进行数据库操作。操作完成之后，我们需要调用 Complete() 方法来说明我们的操作已经完成了。如果你没有调用 Complete() 方法，那么工作单元在被释放的时候，就会产生异常，并触发 Failed 事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public virtual void Dispose() { if (IsDisposed) { return; } IsDisposed = true; DisposeTransactions(); // 只有调用了 Complete()/CompleteAsync() 方法之后，IsCompleted 的值才为 True。 if (!IsCompleted || _exception != null) { OnFailed(); } OnDisposed(); } 所以，我们在手动使用工作单元管理器构造工作单元的时候，一定要注意调用 Complete() 方法。\n既然 Complete() 方法这么重要，它内部究竟做了什么事情呢？下面我们就来看一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public virtual void Complete() { // 是否已经进行了回滚操作，如果进行了回滚操作，则不提交工作单元。 if (_isRolledback) { return; } // 防止多次调用 Complete 方法，原理就是看 _isCompleting 或者 IsCompleted 是不是已经为 True 了。 PreventMultipleComplete(); try { _isCompleting = true; SaveChanges(); CommitTransactions(); IsCompleted = true; // 数据储存了，事务提交了，则说明工作单元已经完成了，遍历完成事件集合，依次调用这些方法。 OnCompleted(); } catch (Exception ex) { // 一旦在持久化或者是提交事务时出现了异常，则往上层抛出。 _exception = ex; throw; } } public virtual void SaveChanges() { // 遍历集合，如果对象实现了 ISupportsSavingChanges 则调用相应的方法进行数据持久化。 foreach (var databaseApi in _databaseApis.Values) { (databaseApi as ISupportsSavingChanges)?.SaveChanges(); } } protected virtual void CommitTransactions() { // 遍历事务 API 提供者，调用提交事务方法。 foreach (var transaction in _transactionApis.Values) { transaction.Commit(); } } protected virtual void RollbackAll() { // 回滚操作，还是从集合里面判断是否实现了 ISupportsRollback 接口，来调用具体的实现进行回滚。 foreach (var databaseApi in _databaseApis.Values) { try { (databaseApi as ISupportsRollback)?.Rollback(); } catch { } } foreach (var transactionApi in _transactionApis.Values) { try { (transactionApi as ISupportsRollback)?.Rollback(); } catch { } } } 这里可以看到，ABP vNext 完全剥离了具体事务或者回滚的实现方法，都是移动到具体的模块进行实现的，也就是说在调用了 Complete() 方法之后，我们的事务就会被提交了。\n本小节从创建、提交、释放这三个生命周期讲解了工作单元的原理和实现，关于具体的事务和回滚实现，我会放在下一篇文章进行说明，这里就不再赘述了。\n为什么工作单元常常配合 using 语句块 使用，就是因为在提交工作单元之后，就可以自动调用 Dispose() 方法，对工作单元的状态进行校验，而不需要我们手动处理。\n1 2 3 4 using(var uowA = _uowMgr.Begion()) { uowA.Complete(); } 2.3.3 保留工作单元 在 ABP vNext 里面，工作单元有了一个新的动作/属性，叫做 是否保留(Is Reserved)。它的实现也比较简单，指定了一个 ReservationName，然后设置 IsReserved 为 true 就完成了整个动作。\n那么它的作用是什么呢？这块内容我会在工作单元管理器小节进行解释。\n2.4 工作单元管理器 工作单元管理器在工作单元的原理/实现里面已经有过了解，工作单元管理器主要负责工作单元的创建。\n这里我再挑选一个工作单元模块的单元测试，来说明什么叫做 保留工作单元。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 [Fact] public async Task UnitOfWorkManager_Reservation_Test() { _unitOfWorkManager.Current.ShouldBeNull(); using (var uow1 = _unitOfWorkManager.Reserve(\u0026#34;Reservation1\u0026#34;)) { _unitOfWorkManager.Current.ShouldBeNull(); using (var uow2 = _unitOfWorkManager.Begin()) { // 此时 Current 值是 Uow2 的值。 _unitOfWorkManager.Current.ShouldNotBeNull(); _unitOfWorkManager.Current.Id.ShouldNotBe(uow1.Id); await uow2.CompleteAsync(); } // 这个时候，因为 uow1 是保留工作单元，所以不会被获取到，应该为 null。 _unitOfWorkManager.Current.ShouldBeNull(); // 调用了该方法，设置 uow1 的 IsReserved 属性为 false。 _unitOfWorkManager.BeginReserved(\u0026#34;Reservation1\u0026#34;); // 获得到了值，并且诶它的 Id 是 uow1 的值。 _unitOfWorkManager.Current.ShouldNotBeNull(); _unitOfWorkManager.Current.Id.ShouldBe(uow1.Id); await uow1.CompleteAsync(); } _unitOfWorkManager.Current.ShouldBeNull(); } 通过对代码的注释和断点调试的结果，我们知道了通过 Reserved 创建的工作单元它的 IsReserved 属性是 true，所以我们调用 IUnitOfWorkManager.Current 访问的时候，会忽略掉保留工作单元，所以得到的值就是 null。\n但是通过调用 BeginReserved(string name) 方法，我们就可以将指定的工作单元置为 当前工作单元，这是因为调用了该方法之后，会重新调用工作单元的 Initialize() 方法，在该方法内部，又会将 IsReserved 设置为 false 。\n1 2 3 4 5 6 public virtual void Initialize(UnitOfWorkOptions options) { // ... 其他代码。 // 注意这里。 IsReserved = false; } 保留工作单元的用途主要是在某些特殊场合，在某些特定条件下不想暴露给 **IUnitOfWorkManager.Current ** 时使用。\n2.5 工作单元拦截器 如果我们每个地方都通过工作单元管理器来手动创建工作单元，那还是比较麻烦的。ABP vNext 通过拦截器，来为特定的类型（符合规则）自动创建工作单元。\n关于拦截器的注册已经在文章最开始说明了，这里就不再赘述，我们直接来看拦截器的内部实现。其实在拦截器的内部，一样是使用工作单元拦截器我来为我们创建工作单元的。只不过通过拦截器的方式，就能够无感知/无侵入地为我们构造健壮的数据持久化机制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public override void Intercept(IAbpMethodInvocation invocation) { // 如果类型没有标注 UnitOfWork 特性，或者没有继承 IUnitOfWorkEnabled 接口，则不创建工作单元。 if (!UnitOfWorkHelper.IsUnitOfWorkMethod(invocation.Method, out var unitOfWorkAttribute)) { invocation.Proceed(); return; } // 通过工作单元管理器构造工作单元。 using (var uow = _unitOfWorkManager.Begin(CreateOptions(invocation, unitOfWorkAttribute))) { invocation.Proceed(); uow.Complete(); } } 关于在 ASP.NET Core MVC 的工作单元过滤器，在实现上与拦截器大同小异，后续讲解 ASP.NET Core Mvc 时再着重说明。\n三、总结 ABP vNext 框架通过统一工作单元为我们提供了健壮的数据库访问与持久化机制，使得开发人员在进行软件开发时，只需要关注业务逻辑即可。不需要过多关注与数据库等基础设施的交互，这一切交由框架完成即可。\n这里多说一句，ABP vNext 本身就是面向 DDD 所设计的一套快速开发框架，包括值对象（ValueObject）这些领域驱动开发的特殊概念也被加入到框架实现当中。\n微服务作为 DDD 的一个典型实现，DDD 为微服务的划分提供理论支持。这里为大家推荐**《领域驱动设计：软件核心复杂性应对之道》**这本书，该书籍由领域驱动设计的提出者编写。\n看了之后发现在大型系统当中（博主之前做 ERP 的，吃过这个亏）很多时候都是凭感觉来写，没有一个具体的理论来支持软件开发。最近拜读了上述书籍之后，发现领域驱动设计（DDD）就是一套完整的方法论（当然 不是银弹）。大家在学习并理解了领域驱动设计之后，使用 ABP vNext 框架进行大型系统开发就会更加得心应手。\n四、后记 关于本系列文章的更新，因为最近自己在做 物联网(Rust 语言学习、数字电路设计)相关的开发工作，所以 5 月到 6 月这段时间都没怎么去研究 ABP vNext。\n最近在学习领域驱动设计的过程中，发现 ABP vNext 就是为 DDD 而生的，所以趁热打铁想将后续的 ABP vNext 文章一并更新，预计在 7 月内会把剩余的文章补完（核心模块）。\n","date":"2019-07-01T01:47:50Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---4-unit-of-work/","title":"Abp vNext 源码分析 - 4. 工作单元"},{"content":"问题 在一个 Timer 时钟的周期方法内，有一个 foreach 循环，当执行到某些特定的语句时，会从头开始执行，而不会执行后续的语句。\n分析 该问题我在初步分析之后，发现可能是由于程序出现了异常，但是被吞噬掉造成的。在我某一个 item 元素当中，其值为 null 应该会抛出空异常。但是没有异常抛出，后续我不知道哪个地方吞噬了异常，就在循环体内增加了一个 if 语句过滤掉了 null 元素。\n不过之后仍然会出现最开始所说的问题，看来还有其他的地方在抛出异常，最后排查到是执行 DevExpress 图表控件的 BeginDataUpdate() 和 EndDataUpdate() 之后就会出现上述症状。\n查阅了我的 Timer 是参照 ABP 实现的一个 Timer，找到调用回调方法的地方，发现是我自己将异常捕获并将其忽略掉了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 private void TimerCallBack(object state) { lock (_taskTimer) { if (!_running || _performingTasks) { return; } _taskTimer.Change(Timeout.Infinite, Timeout.Infinite); _performingTasks = true; } try { Elapsed?.Invoke(this, new EventArgs()); } catch { // ignored } finally { lock (_taskTimer) { _performingTasks = false; if (_running) { _taskTimer.Change(Period, Timeout.Infinite); } Monitor.Pulse(_taskTimer); } } } 根据上图来看，确实是我回调方法中的代码抛出了异常，导致后台任务重新执行。\n解决 将跨线程访问语句修复之后，程序运行正常，后面我也在 catch 语句块里面增加了异常日志写入，成功解决问题。\n","date":"2019-06-23T13:30:26Z","permalink":"https://real-zony.github.io/p/a-problem-of-abnormal-swallowing/","title":"异常吞噬问题一则"},{"content":"一、背景 第一次接触 Polly 还是在做某个微服务系统的时候，那时只会使用单一的超时策略与重试策略，更加高级的特性就没有再进行学习了。最近开为某个客户开发 PC 端的上位机的时候，客户有个需求，在发起请求之后如果 5 秒钟没有响应则进行重试，总共可以重试 3 次，如果 3 次请求都未返回数据，就视为请求失败。\n关于 Polly 的高级用法可以参考官方的 Wiki 文档 即可，国内也有很多优秀的介绍文章，例如 这篇 和 这篇。\n二、思路 查阅了 Polly 的官方文档之后，发现 Polly 提供了策略组合功能，每个 Policy 实例都可以调用其 Wrap() 方法与另外一个策略进行组合。\n或者是通过 Policy 静态类提供的 Warp() 静态方法来指定需要组合的两个策略。\n根据需求描述来看，我们需要用到超时策略和重试策略，只要将其组合即可。不过这里需要注意一个坑，即他们的组合顺序。\n正确的组合顺序应该是 **重试策略.Warp(超时策略) **，而不是 超时策略.Warp(重试策略) 。这是因为在超时之后 Polly 会抛出 TimeoutRejectedException 异常，在重试策略捕获到该异常之后，就会开始重试操作，即后面组合策略的 ExecuteAsync() 方法接收的委托。\n三、实现 首先我们定义一个方法，该方法用于组合策略(超时+重试)，因为我这里是传入的异步委托操作，所以返回的是 AsyncPolicy 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 private AsyncPolicyWrap BuildTimeoutRetryPolicy(string msg) { // 超时策略，执行目标委托超过 5 秒则视为超时，抛出异常。 var timeoutPolicy = Policy.TimeoutAsync(5); // 重试策略，重试 2 次，每次打印信息。 var retryPolicy = Policy.Handle\u0026lt;TimeoutRejectedException\u0026gt;().RetryAsync(2, (exception, i) =\u0026gt; { Console.WriteLine(\u0026#34;开始第 i 次重试...\u0026#34;); }); return retryPolicy.WrapAsync(timeoutPolicy); } 定义好策略之后，就是我们的实际应用了。这里说明一下执行逻辑，当第一次请求的时候如果发生了超时的情况，则进入重试策略，重试两次，当最后一次仍然抛出 TimeoutRejectedException 异常，则重试策略不再捕获，直接将异常抛出给调用者。\n1 2 3 4 5 6 7 8 9 10 11 private async Task\u0026lt;string\u0026gt; GetResult(AsyncPolicyWrap policy) { try { return await policy.ExecuteAsync(() =\u0026gt; SendDataAsync(sendProtocol)); } catch (TimeoutRejectedException) { return \u0026#34;超时\u0026#34;; } } ","date":"2019-06-11T10:36:32Z","permalink":"https://real-zony.github.io/p/implement-complex-policies-with-polly-timeout-retry/","title":"使用 Polly 实现复杂策略(超时重试)"},{"content":"一、背景 DotNetty 本身是一个优秀的网络通讯框架，不过它是基于异步事件驱动来处理另一端的响应，需要在单独的 Handler 去处理相应的返回结果。而在我们的实际使用当中，尤其是 客户端程序 基本都是 请求-响应 模型，在发送了数据时候需要等待服务器的响应才能进行下一步操作，如果服务器返回的是错误信息，则需要进行特殊的处理。\n类似于下面这种方式：\n1 2 3 4 5 6 7 8 9 10 11 public async void Button1_Click() { var result = await DotNettyClient.SendData(\u0026#34;Hello\u0026#34;); if(result == \u0026#34;Error\u0026#34;) { throw new Exception(\u0026#34;服务器返回错误!\u0026#34;); } Console.WriteLine($\u0026#34;Hello {result}\u0026#34;); } 二、解决思路 参阅了大部分资料之后，发现在 Java 的 Netty 当中可以使用 Future / Promise 来实现，那么 C# 是否有类似的组件呢？答案是有的，他们对应的就是 Task 和 TaskCompletionSource，前者是给调用者的任务，而后者则是用于设置响应任务的结果。\n那么我们就可以这么来处理，当客户端发送请求时，附带唯一的一个请求 ID，并将 TaskCompletionSource 放在一个请求字典当中，请求 ID 作为字典的 Key，值是 TaskCompletionSource，之后返回一个 Task。当客户端接收到服务器响应的时候，通过 TaskCompletionSource 设置之前那个 Task 的结果，这样我们接收到响应之后，就会从之前 await 的地方继续执行。\n这里我自己的需求仅仅是类似于 同步阻塞式 的操作，所以我直接使用一个队列来做简单处理，并没有用唯一的请求 ID 来表示不同的请求，也没有使用字典，因为我可以 保证在同一时间内有且仅有一个客户端请求被发起，而且也做了响应的超时处理机制。\n三、代码实现 实现起来超级简单，只需要在发起请求的时候，创建一个 TaskCompletionSource\u0026lt;TResponse\u0026gt; 对象。这个泛型参数指的是你想要的返回值类型，这里我以 TResponse 代替，下面的 DEMO 我会用 string 类型进行演示。\n创建好一个 TaskCompletionSource\u0026lt;TResponse\u0026gt; 之后，在发送方法里面，我们可以将其对象放在一个先进先出的队列当中，然后将其 Task 属性作为发送方法的返回值。\n我们再来到处理服务器响应的 Handler 当中，从队列里面拿去之前存放的 TaskCompletionSource\u0026lt;TResponse\u0026gt; 对象，调用其 SetResult() 方法，将具体响应进行设置。\n通过以上的操作，我们在发送数据的时候，就可以使用 await 关键字等待服务端的响应，但不会阻塞线程，当客户端接收到服务端响应时，就会恢复到之前 await 的位置继续执行。\n数据发送方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static class DotNettyClient { static DotNettyClient() { RequestQueue = new Queue\u0026lt;TaskCompletionSource\u0026lt;string\u0026gt;\u0026gt;(); } public static Queue\u0026lt;TaskCompletionSource\u0026lt;string\u0026gt;\u0026gt; RequestQueue { get; set; } public static async Task\u0026lt;string\u0026gt; SendData(string data) { var resultTask = new TaskCompletionSource\u0026lt;string\u0026gt;(); var buffer = new Unpooled.Buffer(); buffer.WriteBytes(Encoding.UTF8.GetBytes(data)); await _clientChannel.WriteAndFlushAsync(buffer); RequestQueue.Enqueue(resultTask); return await resultTask.Task; } } 服务端响应处理：\n1 2 3 4 5 6 7 8 9 10 11 public class ProtocolHandler : ChannelHandlerAdapter { public override void ChannelRead(IChannelHandlerContext context, object message) { if(message is string response) { if(!DotNettyClient.RequestQueue.TryDequeue(out TaskCompletionSource\u0026lt;string\u0026gt; result)) return; result.SetResult(response); } } } 这里我就不再编写解析器，主要说明一下代码的思路，下面在使用的时候就如同第一节说的一样，直接使用 await 关键字等待响应结果即可。\n四、缺陷 在这里我并没有展示多个异步请求的情况，如果是用户同时发起多个请求的时候，你可以通过数据的唯一 ID 来标识每一个请求，读取时根据唯一 ID 从字典获取数据，这样在接收服务端响应的时候就能处理这种情况了。\n五、参考资料 DotNetty Github Issues [dotBlogs - 《C#] 將事件驅動 (event-driven) 的模式改為可等候的方法 (awaitable method)》 [dotBlogs -《C#.NET][TPL] 利用 TaskCompletionSource 將 EAP 轉換成 TAP》 HK-Zhang -《TaskCompletionSource的使用场景》 ","date":"2019-05-22T01:52:19Z","permalink":"https://real-zony.github.io/p/implementing-synchronous-requests-in-dotnetty/","title":"在 DotNetty 中实现同步请求"},{"content":"一、协议的定义 要对某种协议进行编解码操作，就必须知道协议的基本定义，首先我们来看一下 CJ/T188 的数据帧定义(协议定义)，了解请求数据与响应数据的基本结构。\n1.1 CJ/T188 水表通讯协议 请求帧：\n字节 值 描述 0 0x68 数据帧开始标识。 1 T 表计类型代码，详细信息请参考 表计类型表 。 2-8 A0-A6 表计地址，水表设备的具体地址，这里是 BCD 形式。 9 CTR_01 协议控制码，例如 0x1 就是读表数据。 10 0x3 数据域长度。 11-12 0x1F,0x90 数据标识 DI0-DI1。 13 0x00 序列号，一般为 0x00，序列号也被作为整个数据域的长度。 14 CS 表示校验和数据，即 0-13 位置的所有字节的累加和。 15 0x16 数据帧的结束标识。 例如有以下请求帧数据(读取水表数据)：\n1 68 10 01 00 00 05 08 00 00 01 03 1F 90 00 39 16 对应的解释如下。\n顺序 0 1 2-8 9 10 11-12 13 14 15 说明 帧头 类型 地址 CTR_0 长度 数据标识 序列号 校验和 帧尾 实例 68 10 01 00 00 05 08 00 00 01 03 1F 90 00 39 16 表计类型表：\n值 含义 10 冷水水表 11 生活热水水表 12 直饮水水表 13 中水水表 20 热量表 (记热量) 21 热量表 (记冷量) 30 燃气表 40 电度表 响应帧(读表操作)：\n字节 值 描述 0 0x68 数据帧开始标识。 1 T 表计类型代码，详细信息请参考 表计类型表 。 2-8 A0-A6 表计地址，水表设备的具体地址，这里是 BCD 形式。 9 CTR_1 协议控制码，在返回帧含义即是请求帧的控制码加上 0x80。 10 L 数据域长度。 11-12 0x1F,0x90 数据标识 DI0-DI1。 13 0x00 序列号，一般为 0x00。 14-17 ALL DATA 累计用量，以 BCD 形式进行存储。 18 单位 计量单位，具体含义可以参考 计量单位表 。 19-22 MONTH DATA 本月用量，以 BCD 形式进行存储。 23 单位 计量单位，具体含义可以参考 计量单位表 。 24-30 时间 表示实际时间，以 BCD 形式存储，格式为 ss mm HH dd MM yy yy。 31 状态 1 状态字段。 32 状态 2 保留字节，一般置为 0xFF。 33 CS 表示校验和数据，即 0-32 位置的所有字节的累加和。 34 0x16 数据帧的结束标识。 例如有以下响应帧数据：\n1 68 10 44 33 22 11 00 33 78 81 16 1F 90 00 00 77 66 55 2C 00 77 66 55 2C 31 01 22 11 05 15 20 21 84 6D 16 对应的解释如下：\n顺序 0 1 2-8 9 10 11-12 13 说明 帧头 类型 地址 控制码 长度 标识 序列号 实例 68 10 44 33 22 11 00 33 78 81 16 1F 90 00 顺序 14-17 18 19-22 23 24-30 说明 累计用量 单位 本月用量 单位 时间 实例 00 77 66 55 2C 00 77 66 55 2C 31 01 22 11 05 15 20 顺序 31 32 33 34 说明 状态 1 状态 2 校验和 帧尾 实例 00 FF 6D 16 计量单位表：\n单位 值 Wh 0x2 KWh 0x5 MWh 0x8 MWh * 100 0xA J 0x1 KJ 0xB MJ 0xE GJ 0x11 GJ * 100 0x13 W 0x14 KW 0x17 MW 0x1A L 0x29 $$m^3$$ 0x2C $$ L/h $$ 0x32 $$m^3/h$$ 0x35 2.2 DL/T645 多功能电能表通信协议 请求帧：\n字节 值 描述 0 0x68 数据帧开始标识。 1-6 A0-A5 电表设备地址，以 BCD 码形式存储。 7 0x68 帧起始符。 8 C 控制码。 9 L 数据域长度。 10 DATA 数据域。 11 CS 校验码，从 0-10 字节的累加和。 12 0x16 数据帧结束标识。 读取电表的当前正向有功总电量，表号为 12345678。\n1 68 78 56 34 12 00 00 68 11 04 33 33 34 33 C6 16 顺序 0 1-6 7 8 9 10-13 说明 帧头 地址 帧头 控制码 长度 数据域 实例 68 78 56 34 12 00 00 68 11 04 顺序 14 15 说明 累加和 帧尾 实例 C6 16 这里需要注意的是，33 33 34 33 是 00 01 00 00 加上 0x33 之后的值，因为传输的时候是低位在前，高位在后，所以就是 00 00 01 00 每字节加上 0x33，00 01 00 00 即代表要读取当前正向有功总电能，也有其他的标识，这里不再叙述。\n响应帧(读表操作)：\n1 68 78 56 34 12 00 00 68 91 08 33 33 34 33 A4 56 79 38 F5 16 顺序 0 1-6 7 8 9 说明 帧头 地址 帧头 控制码，这里即 0x11 + 0x80 长度 实例 68 78 56 34 12 00 00 68 91 08 顺序 10-17 18 19 说明 数据域 累加和 帧尾 实例 33 33 34 33 A4 56 79 38 F5 16 这里只说明一下数据域，在这里 33 33 34 33 可以理解成寄存器地址，而 A4 56 79 38 则是具体的电量数据，在这里就是分别减去 0x33，即 71 23 46 5，因为其精度是两位，且是 BCD 码的形式，最后的结果就是 54623.71 度。\n2.3 前导字节 前导字节并非水/电表协议强制规定的协议组，所谓前导字节是在数据帧的头部增加 1-4 组 0xFE，例如以下数据帧就是增加了前导字节。\n1 FE FE FE FE 68 10 44 33 22 11 00 33 78 01 03 1F 90 00 80 16 所以在处理的协议的时候，某些厂家可能会加入前导字节，在处理的时候一定要注意。\n2.4 小结 水/电表协议的请求帧与响应帧其实结构一致，区别仅在于不同的响应，其具体的数据域值也不同，所以在处理的时候可以用一个字典/列表来存储数据域。\n二、代码的实现 2.1 工具类的编码 为了方便我们对协议的解析与组装，我们需要编写一个工具类实现对字节组的某些特殊操作，例如校验和、BCD 转换、十六进制数据的校验等。\n2.1.1 累加和计算功能 首先我们来实现累加和的计算，累加和就是一堆字节相加的结果，不过这个结果可能超过一个字节的大小，我们需要对 256 取模，使其结果刚好能被 1 个字节存储。\n1 2 3 4 5 6 7 8 9 10 11 /// \u0026lt;summary\u0026gt; /// 计算一组二进制数据的累加和。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;waitCalcBytes\u0026#34;\u0026gt;等待计算的二进制数据。\u0026lt;/param\u0026gt; public static byte CalculateAccumulateSum(byte[] waitCalcBytes) { int ck = 0; foreach (var @byte in waitCalcBytes) ck = (ck + @byte); // 对 256 取余，获得 1 个字节的数据。 return (byte)(ck % 0x100); } 2.1.2 十六进制字符串转字节数组 首先我们需要校验一个字符串是否是一个规范合法的十六进制字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 /// \u0026lt;summary\u0026gt; /// 判断输入的字符串是否是有效的十六进制数据。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;hexStr\u0026#34;\u0026gt;等待判断的十六进制数据。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;符合规范则返回 True，不符合则返回 False。\u0026lt;/returns\u0026gt; public static bool IsIllegalHexadecimal(string hexStr) { var validStr = hexStr.Replace(\u0026#34;-\u0026#34;, string.Empty).Replace(\u0026#34; \u0026#34;, string.Empty); if (validStr.Length % 2 != 0) return false; if (string.IsNullOrEmpty(hexStr) || string.IsNullOrWhiteSpace(hexStr)) return false; return new Regex(@\u0026#34;[A-Fa-f0-9]+$\u0026#34;).IsMatch(hexStr); } 校验之后我们才能够将这个字符串用于转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// \u0026lt;summary\u0026gt; /// 将 16 进制的字符串转换为字节数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;hexStr\u0026#34;\u0026gt;等待转换的 16 进制字符串。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;转换成功的字节数组。\u0026lt;/returns\u0026gt; public static byte[] HexStringToBytes(string hexStr) { // 处理干扰，例如空格和 \u0026#39;-\u0026#39; 符号。 var str = hexStr.Replace(\u0026#34;-\u0026#34;, string.Empty).Replace(\u0026#34; \u0026#34;, string.Empty); return Enumerable.Range(0, str.Length) .Where(x =\u0026gt; x % 2 == 0) .Select(x =\u0026gt; Convert.ToByte(str.Substring(x, 2), 16)) .ToArray(); } 2.1.3 BCD 数据的转换 关于 BCD 码的介绍，网上有诸多解释，这里不再赘述，这里只讲一下编码实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /// \u0026lt;summary\u0026gt; /// BCD 码转换成 \u0026lt;see cref=\u0026#34;double\u0026#34;/\u0026gt; 类型。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sourceBytes\u0026#34;\u0026gt;等待转换的 BCD 码数据。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;precisionIndex\u0026#34;\u0026gt;精度位置，用于指示小数点所在的索引。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;转换成功的值。\u0026lt;/returns\u0026gt; public static double BCDToDouble(byte[] sourceBytes, int precisionIndex) { var sb = new StringBuilder(); var reverseBytes = sourceBytes.Reverse().ToArray(); for (int index = 0; index \u0026lt; reverseBytes.Length; index++) { sb.Append(reverseBytes[index] \u0026gt;\u0026gt; 4 \u0026amp; 0xF); sb.Append(reverseBytes[index] \u0026amp; 0xF); if (index == precisionIndex - 1) sb.Append(\u0026#39;.\u0026#39;); } return Convert.ToDouble(sb.ToString()); } /// \u0026lt;summary\u0026gt; /// BCD 码转换成 \u0026lt;see cref=\u0026#34;string\u0026#34;/\u0026gt; 类型。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sourceBytes\u0026#34;\u0026gt;等待转换的 BCD 码数据。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;转换成功的值。\u0026lt;/returns\u0026gt; public static string BCDToString(byte[] sourceBytes) { var sb = new StringBuilder(); var reverseBytes = sourceBytes.Reverse().ToArray(); for (int index = 0; index \u0026lt; reverseBytes.Length; index++) { sb.Append(reverseBytes[index] \u0026gt;\u0026gt; 4 \u0026amp; 0xF); sb.Append(reverseBytes[index] \u0026amp; 0xF); } return sb.ToString(); } 2.2 协议的实现 协议分为发送帧与响应帧，发送帧是通过传入一系列参数构建一个 byte 数组，而响应帧则需要我们从一个 byte 数组转换为方便读写的对象。\n根据以上特点，我们编写一个 IProtocol 接口，该接口拥有两个方法，即编码 (Encode) 和解码 (Decode) 方法。\n1 2 3 4 5 6 7 8 public interface IProtocol { byte[] Encode(); IProtocol Decode(byte[] sourceBytes); List\u0026lt;DataDefine\u0026gt; DataDefines { get;} } 接着我们可以使用一个类型来表示每个数据域的数据，这里我定义了一个 DataDefine 类型。\n1 2 3 4 5 6 7 8 public class DataDefine { public string Name { get; set; } public byte[] Data { get; set; } public int Length { get; set; } } 这里我以水表的读表操作为例，定义了一个抽象基类，在抽象基类里面定义了数据帧的基本接口，并且实现了编码/解码方法。在这里 DataDefines 的作用就体现了，他主要是用于\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 public abstract class CJT188Protocol : IProtocol { protected const byte FrameHead = 0x68; public byte DeviceType { get; protected set; } public byte[] Address { get; protected set; } public byte ControlCode { get; protected set; } public int DataLength { get; protected set; } public byte[] DataArea { get; private set; } public List\u0026lt;DataDefine\u0026gt; DataDefines { get;} public byte AccumulateSum { get; protected set; } protected const byte FrameEnd = 0x16; public CJT188Protocol() { DataDefines = new List\u0026lt;DataDefine\u0026gt;(); } public DataDefine this[string key] { get { return DataDefines.FirstOrDefault(x =\u0026gt; x.Name == key); } } public virtual byte[] Encode() { // 校验协议数据。 if(Address.Length != 7) throw new ArgumentException($\u0026#34;水表地址 {BitConverter.ToString(Address)} 的长度不正确，长度不等于 7 个字节。\u0026#34;); BuildDataArea(); using (var mem = new MemoryStream()) { mem.WriteByte(FrameHead); mem.WriteByte(DeviceType); mem.Write(Address); mem.WriteByte(ControlCode); mem.WriteByte((byte)DataLength); mem.Write(DataArea); AccumulateSum = ByteUtils.CalculateAccumulateSum(mem.ToArray()); mem.WriteByte(AccumulateSum); mem.WriteByte(FrameEnd); return mem.ToArray(); } } public virtual IProtocol Decode(byte[] sourceBytes) { using (var mem = new MemoryStream(sourceBytes)) { using (var reader = new BinaryReader(mem)) { reader.ReadByte(); DeviceType = reader.ReadByte(); Address = reader.ReadBytes(7); ControlCode = reader.ReadByte(); DataLength = reader.ReadByte(); foreach (var dataDefine in DataDefines) { dataDefine.Data = reader.ReadBytes(dataDefine.Length); } AccumulateSum = reader.ReadByte(); } } return this; } protected virtual void BuildDataArea() { // 构建数据域。 using (var dataMemory = new MemoryStream()) { foreach (var data in DataDefines) { if(data==null) continue; dataMemory.Write(data.Data); } DataArea = dataMemory.ToArray(); DataLength = DataArea.Length; } } } 最后我们定义了两个具体的协议类，分别是读表的请求帧和读表的响应帧，在其构造方法分别定义了具体的数据域。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class CJT188_Read_Request : CJT188Protocol { public CJT188_Read_Request(string address,byte type) { Address = ByteUtils.HexStringToBytes(address).Reverse().ToArray(); ControlCode = 0x1; DeviceType = type; DataDefines.Add(new DataDefine{Name = \u0026#34;Default\u0026#34;,Length = 2}); DataDefines.Add(new DataDefine{Name = \u0026#34;Seq\u0026#34;,Length = 1}); } } public class CJT188_Read_Response : CJT188Protocol { public CJT188_Read_Response() { DataDefines.Add(new DataDefine{Name = \u0026#34;Default\u0026#34;,Length = 2}); DataDefines.Add(new DataDefine{Name = \u0026#34;Seq\u0026#34;,Length = 1}); DataDefines.Add(new DataDefine{Name = \u0026#34;AllData\u0026#34;,Length = 4}); DataDefines.Add(new DataDefine{Name = \u0026#34;AllDataUnit\u0026#34;,Length = 1}); DataDefines.Add(new DataDefine{Name = \u0026#34;MonthData\u0026#34;,Length = 4}); DataDefines.Add(new DataDefine{Name = \u0026#34;MonthDataUnit\u0026#34;,Length = 1}); DataDefines.Add(new DataDefine{Name = \u0026#34;DateTime\u0026#34;,Length = 7}); DataDefines.Add(new DataDefine{Name = \u0026#34;Status1\u0026#34;,Length = 1}); DataDefines.Add(new DataDefine{Name = \u0026#34;Status2\u0026#34;,Length = 1}); } } 测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Program { static void Main(string[] args) { // 发送水表读表数据。 var sendProtocol = new CJT188_Read_Request(\u0026#34;00000805000001\u0026#34;,0x10); sendProtocol[\u0026#34;Default\u0026#34;].Data = new byte[] {0x1F, 0x90}; sendProtocol[\u0026#34;Seq\u0026#34;].Data = new byte[] {0x00}; Console.WriteLine(BitConverter.ToString(sendProtocol.Encode())); // 解析水表响应数据。 var receiveProtocol = new CJT188_Read_Response().Decode(ByteUtils.HexStringToBytes(\u0026#34;68 10 78 06 12 18 20 00 00 81 16 90 1F 00 00 01 00 00 2C 00 01 00 00 2C 00 00 00 00 00 00 00 01 FF E0 16\u0026#34;)); Console.ReadLine(); } } 2.3 代码打包下载 上述代码实现均已打包为压缩文件，点击我 即可直接下载。\n","date":"2019-05-21T01:27:21Z","permalink":"https://real-zony.github.io/p/use-csharp-to-implement-the-analysis-and-coding-of-cj-t188-water-meter-protocol-and-dl-t645-electricity-meter-protocol/","title":"使用 C# 实现 CJ-T188 水表协议和 DL-T645 电表协议的解析与编码"},{"content":"背景 在使用 DevExpress 的 GridControl 为其实现 Checkbox 列，发现如果勾选了三行的数据，在遍历 GridControl 绑定的数据源时 Checkbox 列的数据仅有 2 行被更新。\n原因 使用 Google 搜索了半天，在 DevExpress 的 Support 上找到了答案，似乎是需要手动调用 GridControl 关联 View 的 PostEditor() 方法。\n解决 在这里我使用的是 GridControl 的 BandedGridView 视图，所以在获取数据源的时候，手动调用一下视图的 PostEditor() 即可。\n1 2 3 4 5 6 7 8 9 private void ButtonA_Click(object sender,EventArgs e) { bandedGridView1.PostEditor(); if(gricControl1.DataSource is BindingList\u0026lt;ItemDto\u0026gt; items) { var checkedItems = item.Where(x=\u0026gt;x.IsUpdate); } } 关于 PostEditor() 方法的解释：\nposts the value to the associated data source but doesn\u0026rsquo;t close the active in-place editor.\n","date":"2019-05-20T08:07:14Z","permalink":"https://real-zony.github.io/p/when-devexpress-uses-gridcontrol-the-data-source-cannot-be-updated-immediately/","title":"DevExpress 使用 GridControl 时，数据源无法立即更新的问题"},{"content":"问题 最近在进行硬件上位机开发的时候，经常会遇到将 16 进制字符串转换为 byte[] 的情况，除了这种需求以外，还需要判定一个字符串是否是有效的 16 进制数据。\n解决 字符串转 byte[] 的情况可以使用 Convert.ToByte(string) 来解决，16 进制数据的判定则可以结合正则和长度来进行处理。\n在这里我是只接受以下两种形式的 16 进制字符串，并对其进行验证和转换。\n1 2 AA 12 34 56 78 06 AA-12-34-56-78-06 下面就是代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static byte[] HexStringToBytes(string hexStr) { // 处理干扰，例如空格和 \u0026#39;-\u0026#39; 符号。 var str = hexStr.Replace(\u0026#34;-\u0026#34;,string.Empty).Replace(\u0026#34; \u0026#34;, string.Empty); if (validStr.Length % 2 != 0) throw new ArgumentException(\u0026#34;传入的 16 进制字符串长度不对。\u0026#34;); if (!new Regex(@\u0026#34;[A-Fa-f0-9]+$\u0026#34;).IsMatch(hexStr)) throw new ArgumentException(\u0026#34;传入的 16 进制字符串数据不符合规范。\u0026#34;); // 构建一个字符串长度的序列，每隔 2 个字符长度，即使用 Convert 构成一个字节。 return Enumerable.Range(0, str.Length) .Where(x =\u0026gt; x % 2 == 0) .Select(x =\u0026gt; Convert.ToByte(str.Substring(x, 2), 16)) .ToArray(); } 参考：StackOverFlow\n后记 最近在忙自己的事情，vNext 系列的文章可能会在 10 号之后才能更新了。\n","date":"2019-05-04T15:38:08Z","permalink":"https://real-zony.github.io/p/csharp-checksum-converts-hexadecimal-string-to-byte-array/","title":"C# 校验并转换 16 进制字符串到字节数组"},{"content":"一、简要说明 ABP vNext 框架在使用依赖注入服务的时候，是直接使用的微软提供的 Microsoft.Extensions.DependencyInjection 包。这里与原来的 ABP 框架就不一样了，原来的 ABP 框架还需要抽象出来一个 IIocManager 用来管理整个 IoC 容器，现在则直接操作 IServiceCollection 与 IServiceProvider 进行组件的注册/解析。\n这里需要注意的是，虽然现在的依赖注入服务是使用微软官方那一套库进行操作，但是 ABP vNext 还是为我们提供了组件自动注册、拦截器这些基础功能。\n二、源码分析 2.1 组件自动注册 ABP vNext 仍然在其 Core 库为我们提供了三种接口，即 ISingletonDependency 和 ITransientDependency 、IScopedDependency 接口，方便我们的类型/组件自动注册，这三种接口分别对应了对象的 单例、瞬时、范围 生命周期。只要任何类型/接口实现了以上任意接口，ABP vNext 就会在系统启动时候，将这些对象注册到 IoC 容器当中。\n那么究竟是在什么时候呢？回顾上一章的模块系统的文章，在模块系统调用模块的 ConfigureService() 的时候，就会有一个 services.AddAssembly(module.Type.Assembly) ，他会将模块的所属的程序集传入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class ModuleLoader : IModuleLoader { // ... 其他代码 protected virtual void ConfigureServices(List\u0026lt;IAbpModuleDescriptor\u0026gt; modules, IServiceCollection services) { // ... 其他代码 //ConfigureServices foreach (var module in modules) { if (module.Instance is AbpModule abpModule) { // 是否跳过服务的自动注册，默认为 false。 if (!abpModule.SkipAutoServiceRegistration) { services.AddAssembly(module.Type.Assembly); } } module.Instance.ConfigureServices(context); } // ... 其他代码 } // ... 其他代码 } 看来核心就在于这个 AddAssembly() 扩展方法了，跳转到方法的内部，发现真正干事的是 IConventionalRegistrar 对象，暂且称之为规约注册器，而且我们可以拥有多个规约注册器，你可以自己实现自动注册规则。\n1 2 3 4 5 6 7 8 9 10 public static IServiceCollection AddAssembly(this IServiceCollection services, Assembly assembly) { // 获得所有规约注册器，然后调用规约注册器的 AddAssmbly 方法注册类型。 foreach (var registrar in services.GetConventionalRegistrars()) { registrar.AddAssembly(services, assembly); } return services; } 该接口定义了三个方法，支持传入程序集、类型数组、具体类型，他们的默认实现都在抽象类 ConventionalRegistrarBase 当中。\n1 2 3 4 5 6 7 8 public interface IConventionalRegistrar { void AddAssembly(IServiceCollection services, Assembly assembly); void AddTypes(IServiceCollection services, params Type[] types); void AddType(IServiceCollection services, Type type); } 抽象类当中的实现也非常简单，他们最终都是调用的 AddType() 方法来将类型注册到 IServiceCollection 当中的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public abstract class ConventionalRegistrarBase : IConventionalRegistrar { public virtual void AddAssembly(IServiceCollection services, Assembly assembly) { // 获得程序集内的所有类型，过滤掉抽象类和泛型类型。 var types = AssemblyHelper .GetAllTypes(assembly) .Where( type =\u0026gt; type != null \u0026amp;\u0026amp; type.IsClass \u0026amp;\u0026amp; !type.IsAbstract \u0026amp;\u0026amp; !type.IsGenericType ).ToArray(); AddTypes(services, types); } public virtual void AddTypes(IServiceCollection services, params Type[] types) { foreach (var type in types) { AddType(services, type); } } public abstract void AddType(IServiceCollection services, Type type); } 所以我们的重点就在于 AddType() 方法，ABP vNext 框架默认的规约注册器叫做 DefaultConventionalRegistrar，跳转到其定义可以发现在其内部，除了对三种生命周期接口处理之外，如果类型使用了 DependencyAttribute 特性，也会根据该特性的参数配置进行不同的注册逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public override void AddType(IServiceCollection services, Type type) { // 判断类型是否标注了 DisableConventionalRegistration 特性，如果有标注，则跳过。 if (IsConventionalRegistrationDisabled(type)) { return; } // 获得 Dependency 特性，如果没有则返回 null。 var dependencyAttribute = GetDependencyAttributeOrNull(type); // 优先使用 Dependency 特性所指定的生命周期，如果不存在则根据 type 实现的接口确定生命周期。 var lifeTime = GetLifeTimeOrNull(type, dependencyAttribute); if (lifeTime == null) { return; } // 获得等待注册的类型定义，类型的定义优先使用 ExposeServices 特性指定的类型，如果没有则使用 // 类型当中接口以 I 开始，后面为实现类型名称的接口。 foreach (var serviceType in AutoRegistrationHelper.GetExposedServices(services, type)) { var serviceDescriptor = ServiceDescriptor.Describe(serviceType, type, lifeTime.Value); if (dependencyAttribute?.ReplaceServices == true) { // 替换服务。 services.Replace(serviceDescriptor); } else if (dependencyAttribute?.TryRegister == true) { // 注册服务。 services.TryAdd(serviceDescriptor); } else { // 注册服务。 services.Add(serviceDescriptor); } } } 这里就是在 GetLifeTimeOrNull() 内部的 GetServiceLifetimeFromClassHierarcy() 方法确定了每个接口对应的生命周期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protected virtual ServiceLifetime? GetServiceLifetimeFromClassHierarcy(Type type) { if (typeof(ITransientDependency).GetTypeInfo().IsAssignableFrom(type)) { return ServiceLifetime.Transient; } if (typeof(ISingletonDependency).GetTypeInfo().IsAssignableFrom(type)) { return ServiceLifetime.Singleton; } if (typeof(IScopedDependency).GetTypeInfo().IsAssignableFrom(type)) { return ServiceLifetime.Scoped; } return null; } 如果读者有用过 AutoFac 或者 Castle Windsor 这些依赖注入框架的话，就知道我们要注册一个类型，需要知道该类型的定义和实现。这里的 AutoRegistrationHelper 工具类就会为我们确定注册类型的类型定义，与其默认实现。\n例如我有两个接口 IDemoTest、IDemoTestTwo，和他们的默认实现 DemoTest ，我可以有以下几种方法来确定我的注册类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 指定了两个接口类型的实现都是 DemoTest，在注册的时候就会执行两次注册。 // 分别是 services.AddTransient\u0026lt;IDemoTest,DemoTest\u0026gt;(); // services.AddTransient\u0026lt;IDemoTestTwo,DemoTest\u0026gt;(); [ExposeServices(typeof(IDemoTest),typeof(IDemoTestTwo))] public class DemoTest : IDemoTest,ITransientDependency { } // 或者不显式指定，只需要接口定义符合约定即可。 // services.AddTransient\u0026lt;IDemoTest,DemoTest\u0026gt;(); public class DemoTest : IDemoTest,ITransientDependency { } // 如果连注册接口都没有指定，那么就直接注入当前的实现类型。 // services.AddTransient\u0026lt;DemoTest\u0026gt;(); public class DemoTest : ITransientDependency { } 2.2 方法拦截器 2.2.1 ABP vNext 新的抽象层 在 ABP vNext 框架当中，将方法拦截器抽象了一层 IAbpInterceptor，但实际实现还是使用的 Castle.Core 所提供的动态代理功能，其定义在 Volo.Abp.Dependency.DynamicProxy 文件夹当中，如下图。\nABP vNext 将拦截器和方法调用模型都进行了定义，其中 AbpInterceptor 则是 IAbpInterceptor 的默认抽象实现。在ProxyHelper 工具类当中，提供了从代理对象获取真实类型的方法。(PS: 通过 Castle.Core 代理后的对象与原有类型定义是不一致的。)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ABP vNext 当中的拦截器定义 public interface IAbpInterceptor { // 同步方法拦截。 void Intercept(IAbpMethodInvocation invocation); // 异步方法拦截。 Task InterceptAsync(IAbpMethodInvocation invocation); } // ABP vNext 当中拦截器的默认抽象实现。 public abstract class AbpInterceptor : IAbpInterceptor { public abstract void Intercept(IAbpMethodInvocation invocation); // 异步方法本质上还是调用同步方法，并返回一个已完成的 Task。 public virtual Task InterceptAsync(IAbpMethodInvocation invocation) { Intercept(invocation); return Task.CompletedTask; } } 至于 IAbpMethodInvocation 接口，则是封装了一个被拦截方法调用时的各种参数，例如被拦截方法的在调用时所传递的参数，返回值类型，方法定义等。而 ABP vNext 也为它建立了一个 CastleAbpMethodInvocationAdapter 适配器，实现了上述接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public interface IAbpMethodInvocation { object[] Arguments { get; } IReadOnlyDictionary\u0026lt;string, object\u0026gt; ArgumentsDictionary { get; } Type[] GenericArguments { get; } object TargetObject { get; } MethodInfo Method { get; } object ReturnValue { get; set; } void Proceed(); Task ProceedAsync(); } 2.2.2 Castle.Core 动态代理的集成 ABP vNext 在实际使用的时候，还是通过 Castle.Core 提供的动态代理功能来实现拦截器，相关的代码存放在 Volo.Abp.Castle.Core 库和 Volo.Abp.Autofac 库当中。\n首先我们来看 Castle.Core 库对接口 IAbpMethodInvocation 和 IAbpInterceptor 的实现，在 CastleAbpInterceptorAdapter 中通过适配器来定义了一个标准的 Castle 拦截器，这个拦截器可以传入 ABP vNext 定义的 IAbpInterceptor 作为其泛型参数。\n1 2 3 4 5 public class CastleAbpInterceptorAdapter\u0026lt;TInterceptor\u0026gt; : IInterceptor where TInterceptor : IAbpInterceptor { } Castle 的拦截器也会有一个 Intercept() 方法，该方法将在被拦截方法执行的时候触发。在触发之后，会根据当前方法的定义进行不同的操作，这里异步方法和同步方法处理逻辑是不一样的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public void Intercept(IInvocation invocation) { var proceedInfo = invocation.CaptureProceedInfo(); var method = invocation.MethodInvocationTarget ?? invocation.Method; // 判断执行的方法是否是异步方法。 if (method.IsAsync()) { InterceptAsyncMethod(invocation, proceedInfo); } else { InterceptSyncMethod(invocation, proceedInfo); } } 这里我们以异步方法为例，其内部又会根据方法的返回值是否是 Task 进行不同的操作，因为如果是泛型的 Task，说明该异步方法是有返回值的，所以处理逻辑也不一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void InterceptAsyncMethod(IInvocation invocation, IInvocationProceedInfo proceedInfo) { if (invocation.Method.ReturnType == typeof(Task)) { invocation.ReturnValue = MethodExecuteWithoutReturnValueAsync .Invoke(this, new object[] { invocation, proceedInfo }); } else { invocation.ReturnValue = MethodExecuteWithReturnValueAsync .MakeGenericMethod(invocation.Method.ReturnType.GenericTypeArguments[0]) .Invoke(this, new object[] {invocation, proceedInfo}); } } 进一步解析在返回类型为 Task 时，它所调用的方法。\n1 2 3 4 5 6 7 8 9 10 private async Task ExecuteWithoutReturnValueAsync(IInvocation invocation, IInvocationProceedInfo proceedInfo) { // 注意这里，该用法在之前的 C# 多线程学习笔记文章有说过，作用是出让当前核心给其他线程。 await Task.Yield(); // 调用真实的拦截器，根据传入的方法调用模型去拦截真实的方法。 await _abpInterceptor.InterceptAsync( new CastleAbpMethodInvocationAdapter(invocation, proceedInfo) ); } 从上述代码可以得知，ABP vNext 的拦截器动作现在被包裹在一个 Castle 拦截器内部进行的。\n那么，我们的 Castle.Core 拦截器在什么时候与类型进行绑定的呢，每个拦截器又是如何与特性的类型进行注册的呢？这里我以审计日志拦截器为例，看一下它在系统当中是如何注册，并被使用的。\n审计日志相关的代码存放在 Volo.Abp.Auditing 库中，我们找到 AuditingInterceptor 类型，查看其定义可以看到它也是继承自 AbpInterceptor 抽象基类。\n1 2 3 4 public class AuditingInterceptor : AbpInterceptor, ITransientDependency { } 接着我们根据名字找到了拦截器的注册工具类 AuditingInterceptorRegistrar，在类型的定义当中 ShouldIntercept() 与 ShouldAuditTypeByDefault() 根据传入的 Type 类型，根据特定的逻辑决定是否为该类型关联审计日志拦截器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 private static bool ShouldIntercept(Type type) { if (ShouldAuditTypeByDefault(type)) { return true; } // 如果类型的任意方法启用了 Auditied 特性，则应用拦截器。 if (type.GetMethods().Any(m =\u0026gt; m.IsDefined(typeof(AuditedAttribute), true))) { return true; } return false; } public static bool ShouldAuditTypeByDefault(Type type) { // 判断类型是否使用了 Audited 特性，使用了则应用审计日志拦截器。 if (type.IsDefined(typeof(AuditedAttribute), true)) { return true; } // 判断类型是否使用了 DisableAuditing 特性，使用了则不关联拦截器。 if (type.IsDefined(typeof(DisableAuditingAttribute), true)) { return false; } // 如果类型实现了 IAuditingEnabled 接口，则启用拦截器。 if (typeof(IAuditingEnabled).IsAssignableFrom(type)) { return true; } return false; } 我们这里需要关注的是 RegisterIfNeeded() 方法，它在审计日志模块的预加载方法就被添加到了一个 ServiceRegistrationActionList 集合当中，这个集合会在后面 AutoFac 进行类型注册的时候被使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static void RegisterIfNeeded(IOnServiceRegistredContext context) { // 如果类型允许被审计日志拦截器所拦截，则在类型关联的拦截器上下文当中添加审计日志拦截器。 if (ShouldIntercept(context.ImplementationType)) { context.Interceptors.TryAdd\u0026lt;AuditingInterceptor\u0026gt;(); } } public override void PreConfigureServices(ServiceConfigurationContext context) { // 将这个 Action 加入 List。 context.Services.OnRegistred(AuditingInterceptorRegistrar.RegisterIfNeeded); } 继续查看 OnRegistred() 的代码，得到如下的定义，可以看到最后的 Action 会被添加到一个 ServiceRegistrationActionList 访问器中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static void OnRegistred(this IServiceCollection services, Action\u0026lt;IOnServiceRegistredContext\u0026gt; registrationAction) { GetOrCreateRegistrationActionList(services).Add(registrationAction); } public static ServiceRegistrationActionList GetRegistrationActionList(this IServiceCollection services) { return GetOrCreateRegistrationActionList(services); } private static ServiceRegistrationActionList GetOrCreateRegistrationActionList(IServiceCollection services) { var actionList = services.GetSingletonInstanceOrNull\u0026lt;IObjectAccessor\u0026lt;ServiceRegistrationActionList\u0026gt;\u0026gt;()?.Value; if (actionList == null) { actionList = new ServiceRegistrationActionList(); services.AddObjectAccessor(actionList); } return actionList; } AutoFac 在执行注册操作的时候，会调用 AutofacRegistration 静态类的 Register 方法，该方法会遍历整个 IServiceCollection 集合。在将类型注册到 AutoFac 的 IoC 容器中的时候，在它的内部会调用 AbpRegistrationBuilderExtensions 提供的扩展方法为具体的类型添加过滤器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private static void Register( ContainerBuilder builder, IServiceCollection services) { var moduleContainer = services.GetSingletonInstance\u0026lt;IModuleContainer\u0026gt;(); // 获取之前添加的上下文集合，即审计日志拦截器在预加载方法添加的 Action 集合。 var registrationActionList = services.GetRegistrationActionList(); foreach (var service in services) { if (service.ImplementationType != null) { var serviceTypeInfo = service.ServiceType.GetTypeInfo(); if (serviceTypeInfo.IsGenericTypeDefinition) { builder .RegisterGeneric(service.ImplementationType) .As(service.ServiceType) .ConfigureLifecycle(service.Lifetime) // 这里是重点，传入了 Action 集合，调用了扩展方法。 .ConfigureAbpConventions(moduleContainer, registrationActionList); } // ... 注释了其他代码。 } // ... 注释了其他代码。 } } 下面是扩展方法所定义的相关代码，注意阅读注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public static IRegistrationBuilder\u0026lt;TLimit, TActivatorData, TRegistrationStyle\u0026gt; ConfigureAbpConventions\u0026lt;TLimit, TActivatorData, TRegistrationStyle\u0026gt;( this IRegistrationBuilder\u0026lt;TLimit, TActivatorData, TRegistrationStyle\u0026gt; registrationBuilder, IModuleContainer moduleContainer, ServiceRegistrationActionList registrationActionList) where TActivatorData : ReflectionActivatorData { // ... 注释了其他代码。 registrationBuilder = registrationBuilder.InvokeRegistrationActions(registrationActionList, serviceType, implementationType); // ... 注释了其他代码。 } private static IRegistrationBuilder\u0026lt;TLimit, TActivatorData, TRegistrationStyle\u0026gt; InvokeRegistrationActions\u0026lt;TLimit, TActivatorData, TRegistrationStyle\u0026gt;(this IRegistrationBuilder\u0026lt;TLimit, TActivatorData, TRegistrationStyle\u0026gt; registrationBuilder, ServiceRegistrationActionList registrationActionList, Type serviceType, Type implementationType) where TActivatorData : ReflectionActivatorData { // 构造上下文，以便去调用之前传入的 Action。 var serviceRegistredArgs = new OnServiceRegistredContext(serviceType, implementationType); foreach (var registrationAction in registrationActionList) { // 以审计日志拦截器为例，这里会调用在预加载方法传入的 AuditingInterceptorRegistrar.RegisterIfNeeded 方法。 registrationAction.Invoke(serviceRegistredArgs); } // 这里的 Interceptors 实际上就是 AuditingInterceptorRegistrar.RegisterIfNeeded 内部添加的拦截器哦。 if (serviceRegistredArgs.Interceptors.Any()) { registrationBuilder = registrationBuilder.AddInterceptors( serviceType, serviceRegistredArgs.Interceptors ); } return registrationBuilder; } private static IRegistrationBuilder\u0026lt;TLimit, TActivatorData, TRegistrationStyle\u0026gt; AddInterceptors\u0026lt;TLimit, TActivatorData, TRegistrationStyle\u0026gt;( this IRegistrationBuilder\u0026lt;TLimit, TActivatorData, TRegistrationStyle\u0026gt; registrationBuilder, Type serviceType, IEnumerable\u0026lt;Type\u0026gt; interceptors) where TActivatorData : ReflectionActivatorData { // ... 注释了其他代码。 foreach (var interceptor in interceptors) { // 构造真实的拦截器，并与类型集成。 registrationBuilder.InterceptedBy( typeof(CastleAbpInterceptorAdapter\u0026lt;\u0026gt;).MakeGenericType(interceptor) ); } return registrationBuilder; } 2.3 对象访问器 在第一章节的时候，我们就遇到过 IObjectAccessor\u0026lt;T\u0026gt; 接口，基本上是针对该接口所提供的 Value 属性进行操作，下面就是该接口的定义和它的默认实现 ObjectAccessor\u0026lt;T\u0026gt;，十分简单，就一个泛型的 Value。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface IObjectAccessor\u0026lt;out T\u0026gt; { [CanBeNull] T Value { get; } } public class ObjectAccessor\u0026lt;T\u0026gt; : IObjectAccessor\u0026lt;T\u0026gt; { public T Value { get; set; } public ObjectAccessor() { } public ObjectAccessor([CanBeNull] T obj) { Value = obj; } } 仅仅看上述的代码，是看不出什么名堂的，接着我们来到它的扩展方法定义 ServiceCollectionObjectAccessorExtensions 。\n可以看到其核心的代码在于 ObjectAccessor\u0026lt;T\u0026gt; AddObjectAccessor\u0026lt;T\u0026gt;(this IServiceCollection services, ObjectAccessor\u0026lt;T\u0026gt; accessor) 这个重载方法。它首先判断某个特定泛型的对象访问器是否被注册，如果被注册直接抛出异常，没有则继续。\n最后呢通过一个小技巧，将某个特定类型的对象访问器作为单例注册到 IoC 容器的头部，方便快速检索。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static ObjectAccessor\u0026lt;T\u0026gt; AddObjectAccessor\u0026lt;T\u0026gt;(this IServiceCollection services, ObjectAccessor\u0026lt;T\u0026gt; accessor) { if (services.Any(s =\u0026gt; s.ServiceType == typeof(ObjectAccessor\u0026lt;T\u0026gt;))) { throw new Exception(\u0026#34;An object accessor is registered before for type: \u0026#34; + typeof(T).AssemblyQualifiedName); } //Add to the beginning for fast retrieve services.Insert(0, ServiceDescriptor.Singleton(typeof(ObjectAccessor\u0026lt;T\u0026gt;), accessor)); services.Insert(0, ServiceDescriptor.Singleton(typeof(IObjectAccessor\u0026lt;T\u0026gt;), accessor)); return accessor; } 使用的时候，从第一章就有见到，这里的对象访问器可以传入一个类型。这个时候其 Value 就是空的，但并不影响该类型的解析，只需要在真正使用之前将其 Value 值赋值为实例对象即可。\n只是目前来看，该类型的作用并不是十分明显，更多的时候是一个占位类型而已，你可以在任意时间替换某个类型的对象访问器内部的 Value 值。\n2.4 服务的范围工厂 我们知道在依赖注入框架当中，有一种特别的生命周期叫做 Scoped 周期，这个周期在我之前的相关文章有讲过，它是一个比较特别的生命周期。\n简单来说，Scoped 对象的生命周期只有在某个范围内是单例存在的，例如以下伪代码，用户会请求 ScopedTest() 接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class HomeController() { public Task ScopedTest() { using(var scope = ScopedFactory.CreateScope\u0026lt;TestApp\u0026gt;()) { scope.ChildContainer.Resolve\u0026lt;TestApp\u0026gt;.Name = \u0026#34;111\u0026#34;; scope.ChildContainer.Resolve\u0026lt;TestController\u0026gt;(); } } } public class TestController() { public TestController(TestApp app) { Console.WritleLine(app.Name); } } 最后在 TestController 中，控制台会输出 111 作为结果，在 HomeController 中 ScopedTest() 语句块结束的时候，obj 对象会被释放，在后续的请求当中，TestApp 都是作为一个 Scoped 对象生存的。\n所以流程可以分为以下几步：\n通过 ScopeFactory 创建一个 Scope 范围。 通过 Scope 范围内的子容器，解析对象。 子容器在解析时，如果解析出来的类型是 Scope 生命周期，则在整个 Scope 存活期间，它都是单例的。 Scope 范围释放，会调用销毁内部的子容器，并销毁掉所有解析出来的对象。 在 Volo.Abp.Autofac 库当中，定义了使用 AutoFac 封装的范围工厂与服务范围类型的定义，他们将会作为默认的 IServiceScopeFactory 实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 internal class AutofacServiceScopeFactory : IServiceScopeFactory { private readonly ILifetimeScope _lifetimeScope; public AutofacServiceScopeFactory(ILifetimeScope lifetimeScope) { this._lifetimeScope = lifetimeScope; } public IServiceScope CreateScope() { return new AutofacServiceScope(this._lifetimeScope.BeginLifetimeScope()); } } 这里可以看到，在构建这个工厂的时候，会注入一个 ILifetimScope，这个东西就是 AutoFac 提供的 子容器。在 CreateScope() 方法内部，我们通过构造一个 Scope 作为具体的范围解析对象，并将子容器传入到它的内部。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 internal class AutofacServiceScope : IServiceScope { private readonly ILifetimeScope _lifetimeScope; public AutofacServiceScope(ILifetimeScope lifetimeScope) { // 构造子容器。 this._lifetimeScope = lifetimeScope; this.ServiceProvider = this._lifetimeScope.Resolve\u0026lt;IServiceProvider\u0026gt;(); } public IServiceProvider ServiceProvider { get; } public void Dispose() { // 范围释放的时候，释放子容器。 this._lifetimeScope.Dispose(); } } 那么是在什么时候，我们的范围工厂会被调用来构造一个 IServiceScope 对象呢？就是在 ASP.NET Core 每次请求的时候，它在获得其内部的 RequestServices 时，就会通过 IServiceProvidersFeature 来创建一个 Scope 范围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public IServiceProvider RequestServices { get { if (!_requestServicesSet) { _context.Response.RegisterForDispose(this); // 通过工厂，创建一个范围解析对象，这里就是 AutofacServiceScopeFactory。 _scope = _scopeFactory.CreateScope(); _requestServices = _scope.ServiceProvider; _requestServicesSet = true; } return _requestServices; } set { _requestServices = value; _requestServicesSet = true; } } 所以，我们在每次请求的时候，针对于 Scope 声明周期的对象，默认的话都是在整个请求处理期间，都是单例的，除非显式使用 using 语句块声明作用域。\n而在 ABP vNext 中给我们提供了两个 Scoped Factory，分别是 HttpContextServiceScopeFactory 和 DefaultServiceScopeFactory ，它们都继承自 IHybridServiceScopeFactory 接口。\n这个 IHybridServiceScopeFactory 接口只是一个空的接口，并继承自 Microsoft Dependency Inject 提供的 IServiceScopeFactory 工厂接口。\n但在实际注入的时候，并不会替换掉默认的 IServiceScopeFactory 实现。因为在 IHybridServiceScopeFactory 的默认两个实现的定义上，他们都显式得通过 ExposeServices 特性说明了自己是哪些类型的默认实现，且一般使用的时候，都是通过注入 IHybridServiceScopeFactory 并结合 using 语句块来操作。\n例如在 Volo.Abp.Data 库的 DataSeeder 类型中，有如下用法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public async Task SeedAsync(DataSeedContext context) { using (var scope = ServiceScopeFactory.CreateScope()) { foreach (var contributorType in Options.Contributors) { var contributor = (IDataSeedContributor) scope .ServiceProvider .GetRequiredService(contributorType); await contributor.SeedAsync(context); } } } 只是这两个实现有什么不同呢？通过两个类型的名字就可以看出来，一个是给 ASP.NET Core MVC 程序使用的，另一个则是默认的范围工厂，下面我们从代码层面上来比较一下两者之间的差别。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [ExposeServices( typeof(IHybridServiceScopeFactory), typeof(DefaultServiceScopeFactory) )] public class DefaultServiceScopeFactory : IHybridServiceScopeFactory, ITransientDependency { // 直接注入封装的 AutofacServiceScopeFactory。 protected IServiceScopeFactory Factory { get; } public DefaultServiceScopeFactory(IServiceScopeFactory factory) { Factory = factory; } public IServiceScope CreateScope() { // 通过 AutofacServiceScopeFactory 创建一个 scope。 return Factory.CreateScope(); } } HttpContextServiceScopeFactory 是放在 AspNetCore 模块下的，从他的 Dependency 特性可以看出来，他会替换掉默认的 DefaultServiceScopeFactory 实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 [ExposeServices( typeof(IHybridServiceScopeFactory), typeof(HttpContextServiceScopeFactory) )] [Dependency(ReplaceServices = true)] public class HttpContextServiceScopeFactory : IHybridServiceScopeFactory, ITransientDependency { protected IHttpContextAccessor HttpContextAccessor { get; } // AutoFacServiceScopeFactory protected IServiceScopeFactory ServiceScopeFactory { get; } public HttpContextServiceScopeFactory( IHttpContextAccessor httpContextAccessor, IServiceScopeFactory serviceScopeFactory) { HttpContextAccessor = httpContextAccessor; ServiceScopeFactory = serviceScopeFactory; } public virtual IServiceScope CreateScope() { // 假如 HTTP 上下文为空，直接使用 AutoFacScopeFactory 创建一个范围。 var httpContext = HttpContextAccessor.HttpContext; if (httpContext == null) { return ServiceScopeFactory.CreateScope(); } // 使用 HttpContext 的 RequestServices 构建一个 Scope。 return new NonDisposedHttpContextServiceScope(httpContext.RequestServices); } protected class NonDisposedHttpContextServiceScope : IServiceScope { public IServiceProvider ServiceProvider { get; } public NonDisposedHttpContextServiceScope(IServiceProvider serviceProvider) { ServiceProvider = serviceProvider; } public void Dispose() { } } } 可以看到，后者如果在 HttpContext 不为 null 的时候，是使用的 HttpContext.RequestServices 作为这个 Scope 的解析器。\nRequestServices, on the other hand, is a scoped container created from the root on each request.\n翻译成中文的意思就是，它是在每个请求的的时候创建的独立范围容器，其实就是开头所说的子容器。\n2.5 类型注册完成的动作 其实这个玩意儿应该放在 2.2 节之前讲，只是在写完之后我才看到相关类型是放在依赖注入相关的文件夹当中，这里还请各位读者理解一下。\n早期在 Castle Windsor 当中，类型在注册完成的时候会有一个注册完成的事件，用户可以挂载该事件来进行一些特殊的处理，比如说为类型添加动态代理。在 ABP vNext 当中因为支持多种不同的依赖注入框架，所以就没有类似的事件来做处理。\nABP vNext 则封装了一个 ServiceRegistrationActionList 类型，该类型用于存储在类型注册完成之后，用户可以执行的操作，可以看到它就是一个 Action 集合，用于存放一系列回调方法。\n1 2 3 4 public class ServiceRegistrationActionList : List\u0026lt;Action\u0026lt;IOnServiceRegistredContext\u0026gt;\u0026gt; { } 由 2.2 节得知，这个玩意儿是在每一个类型注册完成之后，都会被遍历调用其中的 Action 动作。在调用的时候，会将当前注册完成的类型封装成一个 IOnServiceRegistredContext 对象，传递给具体的委托，这样委托就能够知道当前调用的类型，也就能够将拦截器放在其 Interceptors 属性当中了。\n1 2 3 4 5 6 public interface IOnServiceRegistredContext { ITypeList\u0026lt;IAbpInterceptor\u0026gt; Interceptors { get; } Type ImplementationType { get; } } 三、总结 ABP vNext 框架针对于依赖注入这块的工作也进行了大量的精简，就代码量来说，比原有 ABP 框架减少了差不多一半左右，而且整个逻辑也比原来更加简洁易懂。\n开发人员在使用的时候，其实最多的是关注如何注入自己想要的类型。通过了解 ABP vNext 底层的代码， 方便我们清楚拦截器和依赖注入框架的具体过程，这样在后面扩展功能的时候才能够做到心中有数。\n","date":"2019-04-23T02:45:42Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---3-dependency-injection-and-interceptor/","title":"Abp vNext 源码分析 - 3. 依赖注入与拦截器"},{"content":"一、简要说明 本篇文章主要分析 Abp vNext 当中的模块系统，从类型构造层面上来看，Abp vNext 当中不再只是单纯的通过 AbpModuleManager 来管理其他的模块，它现在则是 IModuleManager 和 IModuleLoader 来协同工作，其他的代码逻辑并无太大变化。\nAbp vNext 规定每个模块必须继承自 IAbpModule 接口，这样 vNext 系统在启动的时候才会扫描到相应的模块。与原来 Abp 框架一样，每个模块可以通过 DependsOnAttribute 特性来确定依赖关系，算法还是使用拓扑排序算法，来根据依赖性确定模块的加载顺序。(从最顶层的模块，依次加载，直到启动模块。)\n以我们的 Demo 项目为例，这里通过拓扑排序之后的依赖关系如上图，这样最开始执行的即 AbpDataModule 模块，然后再是 AbpAuditingModule 以此类推，直到我们的启动模块 DemoAppModule。\n在 Abp vNext 当中，所有的组件库/第三方库都是以模块的形式呈现的，模块负责管理整个库的生命周期，包括注册组件，配置组件，销毁组件等。\n在最开始的 Abp 框架当中，一个模块有 4 个生命周期，它们都是在抽象基类 AbpModule 当中定义的，分别是 预加载、初始化、初始化完成、销毁。前三个生命周期是依次执行的 预加载-\u0026gt;初始化-\u0026gt;初始化完成，而最后一个销毁动作则是在程序终止的时候，通过 AbpModuleManager 遍历模块，调用其 ShutDown() 方法进行销毁动作。\n新的 Abp vNext 框架除了原有的四个生命周期以外，还抽象出了 IOnPreApplicationInitialization、IOnApplicationInitialization、IOnPostApplicationInitialization、IOnApplicationShutdown。从名字就可以看出来，新的四个生命周期是基于应用程序级别的，而不是模块级别。\n这是什么意思呢？在 Abp vNext 框架当中，模块按照功能用途划分为两种类型的模块。第一种是 框架模块，它是框架的核心模块，比如缓存、EF Core 等基础设施就属于框架模块，其模块的逻辑与处理基本都在传统的三个生命周期进行处理。\n在我们的 services.AddApplication（） 阶段就已经完成所有初始化，可以给 应用程序模块 提供服务。\n第二种则是 应用程序模块，这种模块则是实现了特定的业务/功能，例如身份管理、租户管理等，而新增加的四个生命周期基本是为这种类型的模块服务的。\n在代码和结构上来说，两者并没有区别，在这里仅仅是按用途进行了一次分类。单就模块系统来说，其基本的作用就类似于一个配置类，配置某种组件的各种参数和一些默认逻辑。\n二、源码分析 2.1 模块系统的基础设施 模块的初始化动作是在 AbpApplicationBase 基类开始的，在该基类当中除了注入模块相关的基础设施以外。还定义了模块的初始化方法，即 LoadModules() 方法，在该方法内部是调用的 IModuleLoader 去执行具体的加载操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 internal AbpApplicationBase( [NotNull] Type startupModuleType, [NotNull] IServiceCollection services, [CanBeNull] Action\u0026lt;AbpApplicationCreationOptions\u0026gt; optionsAction) { Check.NotNull(startupModuleType, nameof(startupModuleType)); Check.NotNull(services, nameof(services)); // 配置当前系统的启动模块，以便按照依赖关系进行查找。 StartupModuleType = startupModuleType; Services = services; services.TryAddObjectAccessor\u0026lt;IServiceProvider\u0026gt;(); var options = new AbpApplicationCreationOptions(services); optionsAction?.Invoke(options); // 当前的 Application 就是一个模块容器。 services.AddSingleton\u0026lt;IAbpApplication\u0026gt;(this); services.AddSingleton\u0026lt;IModuleContainer\u0026gt;(this); services.AddCoreServices(); // 注入模块加载类，以及模块的四个应用程序生命周期。 services.AddCoreAbpServices(this, options); // 遍历所有模块，并按照预加载、初始化、初始化完成的顺序执行其生命周期方法。 Modules = LoadModules(services, options); } private IReadOnlyList\u0026lt;IAbpModuleDescriptor\u0026gt; LoadModules(IServiceCollection services, AbpApplicationCreationOptions options) { // 从 IoC 容器当中得到模块加载器。 return services .GetSingletonInstance\u0026lt;IModuleLoader\u0026gt;() .LoadModules( services, StartupModuleType, options.PlugInSources ); } 2.2 模块的初始化 进入 IModuleLoader 的默认实现 ModuleLoader，在它的 LoadModules() 方法中，基本逻辑如下：\n扫描当前应用程序的所有模块类，并构建模块描述对象。 基于模块描述对象，使用拓扑排序算法来按照模块的依赖性进行排序。 排序完成之后，遍历排序完成的模块描述对象，依次执行它们的三个生命周期方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public IAbpModuleDescriptor[] LoadModules( IServiceCollection services, Type startupModuleType, PlugInSourceList plugInSources) { // 验证参数的有效性。 Check.NotNull(services, nameof(services)); Check.NotNull(startupModuleType, nameof(startupModuleType)); Check.NotNull(plugInSources, nameof(plugInSources)); // 扫描模块类型，并构建模块描述对象集合。 var modules = GetDescriptors(services, startupModuleType, plugInSources); // 按照模块的依赖性重新排序。 modules = SortByDependency(modules, startupModuleType); // 调用模块的三个生命周期方法。 ConfigureServices(modules, services); return modules.ToArray(); } 在搜索模块类型的时候，是使用的 AbpModuleHelper 工具类提供的 .FindAllModuleTypes() 方法。该方法会将我们的启动模块传入，根据模块上面的 DependsOn() 标签递归构建 模块描述对象 的集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private List\u0026lt;IAbpModuleDescriptor\u0026gt; GetDescriptors( IServiceCollection services, Type startupModuleType, PlugInSourceList plugInSources) { // 创建一个空的模块描述对象集合。 var modules = new List\u0026lt;AbpModuleDescriptor\u0026gt;(); // 按照启动模块，递归构建模块描述对象集合。 FillModules(modules, services, startupModuleType, plugInSources); // 设置每个模块的依赖项。 SetDependencies(modules); // 返回结果。 return modules.Cast\u0026lt;IAbpModuleDescriptor\u0026gt;().ToList(); } protected virtual void FillModules( List\u0026lt;AbpModuleDescriptor\u0026gt; modules, IServiceCollection services, Type startupModuleType, PlugInSourceList plugInSources) { // 调用 AbpModuleHelper 提供的搜索方法。 foreach (var moduleType in AbpModuleHelper.FindAllModuleTypes(startupModuleType)) { modules.Add(CreateModuleDescriptor(services, moduleType)); } // ... 其他代码。 } 走进 AbpModuleHelper 静态类，其代码与结构与原有的 Abp 框架类似，首先看下它的 FindAllModuleTypes() 方法，根据启动模块的类型递归查找所有的模块类型，并添加到一个集合当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public static List\u0026lt;Type\u0026gt; FindAllModuleTypes(Type startupModuleType) { var moduleTypes = new List\u0026lt;Type\u0026gt;(); // 递归构建模块类型集合。 AddModuleAndDependenciesResursively(moduleTypes, startupModuleType); return moduleTypes; } private static void AddModuleAndDependenciesResursively(List\u0026lt;Type\u0026gt; moduleTypes, Type moduleType) { // 检测传入的类型是否是模块类。 AbpModule.CheckAbpModuleType(moduleType); // 集合已经包含了类型定义，则返回。 if (moduleTypes.Contains(moduleType)) { return; } moduleTypes.Add(moduleType); // 遍历其 DependsOn 特性定义的类型，递归将其类型添加到集合当中。 foreach (var dependedModuleType in FindDependedModuleTypes(moduleType)) { AddModuleAndDependenciesResursively(moduleTypes, dependedModuleType); } } public static List\u0026lt;Type\u0026gt; FindDependedModuleTypes(Type moduleType) { AbpModule.CheckAbpModuleType(moduleType); var dependencies = new List\u0026lt;Type\u0026gt;(); // 从传入的类型当中，获得 DependsOn 特性。 var dependencyDescriptors = moduleType .GetCustomAttributes() .OfType\u0026lt;IDependedTypesProvider\u0026gt;(); // 可能有多个特性标签，遍历。 foreach (var descriptor in dependencyDescriptors) { // 根据特性存储的类型，将其添加到返回结果当中。 foreach (var dependedModuleType in descriptor.GetDependedTypes()) { dependencies.AddIfNotContains(dependedModuleType); } } return dependencies; } 以上操作完成之后，我们就能获得一个平级的模块描述对象集合，我们如果要使用拓扑排序来重新针对这个集合进行排序，就需要知道每个模块的依赖项，根据 IAbpModuleDescriptor 的定义，我们可以看到它有一个 Dependencies 集合来存储它的依赖项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public interface IAbpModuleDescriptor { // 模块的具体类型。 Type Type { get; } // 模块所在的程序集。 Assembly Assembly { get; } // 模块的单例实例。 IAbpModule Instance { get; } // 是否是一个插件。 bool IsLoadedAsPlugIn { get; } // 依赖的其他模块。 IReadOnlyList\u0026lt;IAbpModuleDescriptor\u0026gt; Dependencies { get; } } 而 SetDependencies(List\u0026lt;AbpModuleDescriptor\u0026gt; modules) 方法就是来设置每个模块的依赖项的，代码逻辑很简单。遍历之前的平级模块描述对象集合，根据当前模块的类型定义，找到其依赖项的类型定义。根据这个类型定义去平级的模块描述对象集合搜索，将搜索到的结果存储到当前的模块描述对象中的 Dependencies 属性当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 protected virtual void SetDependencies(List\u0026lt;AbpModuleDescriptor\u0026gt; modules) { // 遍历整个模块描述对象集合。 foreach (var module in modules) { SetDependencies(modules, module); } } protected virtual void SetDependencies(List\u0026lt;AbpModuleDescriptor\u0026gt; modules, AbpModuleDescriptor module) { // 根据当前模块描述对象存储的 Type 类型，获得 DependsOn 标签依赖的类型。 foreach (var dependedModuleType in AbpModuleHelper.FindDependedModuleTypes(module.Type)) { // 在模块描述对象中，按照 Type 类型搜索。 var dependedModule = modules.FirstOrDefault(m =\u0026gt; m.Type == dependedModuleType); if (dependedModule == null) { throw new AbpException(\u0026#34;Could not find a depended module \u0026#34; + dependedModuleType.AssemblyQualifiedName + \u0026#34; for \u0026#34; + module.Type.AssemblyQualifiedName); } // 搜索到结果，则添加到当前模块描述对象的 Dependencies 属性。 module.AddDependency(dependedModule); } } 最后的拓扑排序就不在赘述，关于拓扑排序的算法，可以在我的 这篇 博文当中找到。\n关于模块的最后操作，就是执行模块的三个生命周期方法了，这块代码在 ConfigureServices() 方法当中，没什么特别的的处理，遍历整个模块描述对象集合，依次执行几个方法就完了。\n只是在这里的生命周期方法与之前的不一样了，这里会为每个方法传入一个服务上下文对象，主要是可以通过 IServiceCollection 来配置各个模块的参数，而不是原来的 Configuration 属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 protected virtual void ConfigureServices(List\u0026lt;IAbpModuleDescriptor\u0026gt; modules, IServiceCollection services) { // 构造一个服务上下文，并将其添加到 IoC 容器当中。 var context = new ServiceConfigurationContext(services); services.AddSingleton(context); foreach (var module in modules) { if (module.Instance is AbpModule abpModule) { abpModule.ServiceConfigurationContext = context; } } // 执行预加载方法 PreConfigureServices。 foreach (var module in modules.Where(m =\u0026gt; m.Instance is IPreConfigureServices)) { ((IPreConfigureServices)module.Instance).PreConfigureServices(context); } // 执行初始化方法 ConfigureServices。 foreach (var module in modules) { if (module.Instance is AbpModule abpModule) { if (!abpModule.SkipAutoServiceRegistration) { services.AddAssembly(module.Type.Assembly); } } module.Instance.ConfigureServices(context); } // 执行初始化完成方法 PostConfigureServices。 foreach (var module in modules.Where(m =\u0026gt; m.Instance is IPostConfigureServices)) { ((IPostConfigureServices)module.Instance).PostConfigureServices(context); } // 将服务上下文置为 NULL。 foreach (var module in modules) { if (module.Instance is AbpModule abpModule) { abpModule.ServiceConfigurationContext = null; } } } 以上动作都是在 Startup 类当中的 ConfigureService() 方法中执行，你可能会奇怪，剩下的四个应用程序生命周期的方法在哪儿执行的呢？\n这几个方法是被抽象成了 IModuleLifecycleContributor 类型，在前面的 AddCoreAbpService() 方法的内部就被添加到了配置项里面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 internal static void AddCoreAbpServices(this IServiceCollection services, IAbpApplication abpApplication, AbpApplicationCreationOptions applicationCreationOptions) { // ... 其他代码 services.Configure\u0026lt;ModuleLifecycleOptions\u0026gt;(options =\u0026gt; { options.Contributors.Add\u0026lt;OnPreApplicationInitializationModuleLifecycleContributor\u0026gt;(); options.Contributors.Add\u0026lt;OnApplicationInitializationModuleLifecycleContributor\u0026gt;(); options.Contributors.Add\u0026lt;OnPostApplicationInitializationModuleLifecycleContributor\u0026gt;(); options.Contributors.Add\u0026lt;OnApplicationShutdownModuleLifecycleContributor\u0026gt;(); }); } 执行的话，则是在 Startup 类的 Configure() 方法当中，它会调用 AbpApplicationBase 基类的 InitializeModules() 方法，在该方法内部也是遍历所有的 Contributor (生命周期)，再将所有的模块对应的方法调用一次而已。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public void InitializeModules(ApplicationInitializationContext context) { LogListOfModules(); // 遍历应用程序的几个生命周期。 foreach (var Contributor in _lifecycleContributors) { // 遍历所有的模块，将模块实例传入具体的 Contributor，方便在其内部调用具体的生命周期方法。 foreach (var module in _moduleContainer.Modules) { Contributor.Initialize(context, module.Instance); } } _logger.LogInformation(\u0026#34;Initialized all modules.\u0026#34;); } 这里操作可能有点看不懂，不是说调用模块的生命周期方法么，为啥还将实例传递给 Contributor 呢？我们找到一个 Contributor 的定义就知道了。\n1 2 3 4 5 6 7 8 public class OnApplicationInitializationModuleLifecycleContributor : ModuleLifecycleContributorBase { public override void Initialize(ApplicationInitializationContext context, IAbpModule module) { // 使用模块实例转换为 IOnApplicationInitialization 对象，调用其生命周期方法。 (module as IOnApplicationInitialization)?.OnApplicationInitialization(context); } } 这里我认为 Abp vNext 把 Contributor 抽象出来可能是为了后面方便扩展吧，如果你也有自己的看法不妨在评论区留言。\n三、总结 至此，整个模块系统的解析就结束了，如果看过 Abp 框架源码解析的朋友就可以很明显的感觉到，新框架的模块系统除了生命周期多了几个以外，其他的变化很少，基本没太大的变化。\n在 Abp vNext 框架里面，模块系统是整个框架的基石，了解了模块系统以后，对于剩下的设计就很好理解了。\n","date":"2019-04-19T02:33:15Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---2-changes-in-the-module-system/","title":"Abp vNext 源码分析 - 2. 模块系统的变化"},{"content":"一、简要说明 本片文章主要剖析与讲解 Abp vNext 在 Web API 项目下的启动流程，让大家了解整个 Abp vNext 框架是如何运作的。总的来说 ，Abp vNext 比起 ABP 框架更加精简。因为在 vNext 版本当中，原来归属于 Abp 库的许多内置的基本组件 (组织单元、拦截器等) 被拆分成了单独的模块，这样我们来看它整个启动流程就更加地直观清晰。\n二、源码分析 要分析其源码，我这里是从他官方的 Demo 模板入手的，你可以在 https://abp.io 上构建你自己的模板项目。工具上我使用的是 Jetbrains 家的 Rider，配置好符号服务器(External Symbols Server)，我们就能够直接调试其底层源码。(因为 Abp vNext 项目使用了 Source Link)\n2.1 Startup 文件的入口点 这里我选择的项目是 Web API，直接来到其 Startup.cs 文件，我们就可以看到在 Startup 类当中的 Configure() 与 ConfigureService() 方法内部我们注入并启用了 Abp vNext 框架。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Startup { public IServiceProvider ConfigureServices(IServiceCollection services) { // 注入 Abp 相关的服务。 services.AddApplication\u0026lt;DemoAppModule\u0026gt;(options =\u0026gt; { options.UseAutofac(); }); // 接管自带的 IoC Container。 return services.BuildServiceProviderFromFactory(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { // 配置 ASP.NET Core Mvc 相关参数。 app.InitializeApplication(); } } 在上面我们可以看到，ABP vNext 在注入服务的时候支持传入一个 Action\u0026lt;AbpApplicationCreationOptions\u0026gt; 委托。上述代码中，这个委托内部使用了 UseAutoFac() 将 AutoFac 的容器注入到了 MS IoC 当中，关于这块代码下文会着重讲解。\n2.2 Abp 服务注册 在上一节看到的服务注册代码，是通过扩展 IServiceCollection 接口编写的一个扩展方法实现的，在方法内部是通过 AbpApplicationFactory 静态工厂来创建一个 AbpApplicationBase 实例。\n1 2 3 4 5 6 7 8 9 10 11 12 public static class ServiceCollectionApplicationExtensions { public static IAbpApplicationWithExternalServiceProvider AddApplication\u0026lt;TStartupModule\u0026gt;( [NotNull] this IServiceCollection services, [CanBeNull] Action\u0026lt;AbpApplicationCreationOptions\u0026gt; optionsAction = null) where TStartupModule : IAbpModule { return AbpApplicationFactory.Create\u0026lt;TStartupModule\u0026gt;(services, optionsAction); } // ... 其他代码 } 在这个方法当中，通过名字 WithExternalServiceProvider 我们就知道，这个 Applictaion 是依赖于外部的 IServiceProvider 实例。\n提示：\n它继承的 AbpApplicationBase 基类还拥有另外一个实现，即 AbpApplicationWithInternalServiceProvider 类型，该类型一般 用于控制台程序，它会在 Abp vNext 框架内自行构建一个 IServiceProvider 对象。\n我们回到之前的代码，在这个 AbpApplicationWithExternalServiceProvider 类型内部的构造方法很简单，只是通过 IServiceCollection 对象把自己注入到了服务集合当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 internal class AbpApplicationWithExternalServiceProvider : AbpApplicationBase, IAbpApplicationWithExternalServiceProvider { public AbpApplicationWithExternalServiceProvider( [NotNull] Type startupModuleType, [NotNull] IServiceCollection services, [CanBeNull] Action\u0026lt;AbpApplicationCreationOptions\u0026gt; optionsAction ) : base( startupModuleType, services, optionsAction) { // 注入自己到 IoC 当中。 services.AddSingleton\u0026lt;IAbpApplicationWithExternalServiceProvider\u0026gt;(this); } // 执行框架初始化操作，主要工作是加载模块并执行其初始化方法。 public void Initialize(IServiceProvider serviceProvider) { Check.NotNull(serviceProvider, nameof(serviceProvider)); SetServiceProvider(serviceProvider); InitializeModules(); } } 重点代码在于它的基类构造函数，在基类构造函数当中 Abp vNext 注入了诸多 ASP.NET Core 需要的日志服务、本地化服务等。并且它也抽象出了一个 IModuleLoader，用于辅助我们加载模块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 internal AbpApplicationBase( [NotNull] Type startupModuleType, [NotNull] IServiceCollection services, [CanBeNull] Action\u0026lt;AbpApplicationCreationOptions\u0026gt; optionsAction) { Check.NotNull(startupModuleType, nameof(startupModuleType)); Check.NotNull(services, nameof(services)); // 设置启动模块。 StartupModuleType = startupModuleType; Services = services; // 添加一个空的对象访问器，该访问器的值会在初始化的时候被赋值。 services.TryAddObjectAccessor\u0026lt;IServiceProvider\u0026gt;(); // 调用用户传入的配置委托。 var options = new AbpApplicationCreationOptions(services); optionsAction?.Invoke(options); // 注册自己。 services.AddSingleton\u0026lt;IAbpApplication\u0026gt;(this); services.AddSingleton\u0026lt;IModuleContainer\u0026gt;(this); // 添加日志等基础设施组件。 services.AddCoreServices(); // 添加核心的 Abp 服务，主要是模块系统相关组件。 services.AddCoreAbpServices(this, options); // 加载模块，并按照依赖关系排序，依次执行他们的生命周期方法。 Modules = LoadModules(services, options); } 提示：\n这里的对象访问器其实就是一个占位的类型对象，这样方面后面替换其具体实现。例如在上文当中的 IServiceProvider 通过 ObjectAccessor\u0026lt;T\u0026gt; 对象包裹起来，其值是 NULL，但是在后面我们可以根据自己的需要替换其具体的 Value 。\n2.3 替换 IoC 容器 再回到之前调用 AddApplication\u0026lt;T\u0026gt;() 传递的委托方法，在其内部我们调用了 UseAutofac() 方法。这个方法很简单，内部就只有三行代码。\n这三行代码主要是初始化了一个 AutoFac 的容器构建对象，其次注入 IServiceProviderFactory 和 Abp 的默认实现 AbpAutofacServiceProviderFactory 。\n1 2 3 4 5 6 7 public static void UseAutofac(this AbpApplicationCreationOptions options) { var builder = new ContainerBuilder(); options.Services.AddObjectAccessor(builder); // 这里是实例注册。 options.Services.AddSingleton((IServiceProviderFactory\u0026lt;ContainerBuilder\u0026gt;) new AbpAutofacServiceProviderFactory(builder)); } 这个工厂类的就是在构建 IServiceProvider 的时候使用，即 BuildServiceProviderFromFactory() 方法。该方法内部逻辑很简单，就是从已经注册的服务集合(IServiceCollection)当中获得之前注册的工厂类，通过调用工厂类的 CreateServiceProvider() 方法构建 IServiceProvider，并作为返回值替换掉默认的 IoC 容器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public static IServiceProvider BuildServiceProviderFromFactory([NotNull] this IServiceCollection services) { Check.NotNull(services, nameof(services)); // 遍历已经注册的类型，找到之前注入的工厂类。 foreach (var service in services) { var factoryInterface = service.ImplementationInstance?.GetType() .GetTypeInfo() .GetInterfaces() .FirstOrDefault(i =\u0026gt; i.GetTypeInfo().IsGenericType \u0026amp;\u0026amp; i.GetGenericTypeDefinition() == typeof(IServiceProviderFactory\u0026lt;\u0026gt;)); if (factoryInterface == null) { continue; } // 通过反射调用 IServiceProvider 的构建方法。 var containerBuilderType = factoryInterface.GenericTypeArguments[0]; return (IServiceProvider)typeof(ServiceCollectionCommonExtensions) .GetTypeInfo() .GetMethods() .Single(m =\u0026gt; m.Name == nameof(BuildServiceProviderFromFactory) \u0026amp;\u0026amp; m.IsGenericMethod) .MakeGenericMethod(containerBuilderType) .Invoke(null, new object[] { services, null }); } return services.BuildServiceProvider(); } // 这里是另外一个重载方法的定义。 public static IServiceProvider BuildServiceProviderFromFactory\u0026lt;TContainerBuilder\u0026gt;([NotNull] this IServiceCollection services, Action\u0026lt;TContainerBuilder\u0026gt; builderAction = null) { Check.NotNull(services, nameof(services)); var serviceProviderFactory = services.GetSingletonInstanceOrNull\u0026lt;IServiceProviderFactory\u0026lt;TContainerBuilder\u0026gt;\u0026gt;(); if (serviceProviderFactory == null) { throw new AbpException($\u0026#34;Could not find {typeof(IServiceProviderFactory\u0026lt;TContainerBuilder\u0026gt;).FullName} in {services}.\u0026#34;); } var builder = serviceProviderFactory.CreateBuilder(services); builderAction?.Invoke(builder); return serviceProviderFactory.CreateServiceProvider(builder); } 2.3 初始化 Abp 框架 这里针对 IApplicationBuilder 的扩展是在模块包 Volo.Abp.AspNetCore 当中的，这里仅讲解 ASP.NET Core Mvc 项目是如何处理的。\n1 2 3 4 5 6 7 8 9 10 public static void InitializeApplication([NotNull] this IApplicationBuilder app) { Check.NotNull(app, nameof(app)); // 获取 IApplicationBuilde 的对象访问器，并将其值设置为 app。 app.ApplicationServices.GetRequiredService\u0026lt;ObjectAccessor\u0026lt;IApplicationBuilder\u0026gt;\u0026gt;().Value = app; // 获得之前在 ConfigureService 注册的 Provider 类型，并调用其初始化方法。 app.ApplicationServices.GetRequiredService\u0026lt;IAbpApplicationWithExternalServiceProvider\u0026gt;().Initialize(app.ApplicationServices); } 这里可能会疑惑 ObjectAccessor\u0026lt;IApplicationBuilder\u0026gt; 是在什么时候注入的，其实该类型是在 AbpAspNetCoreModule 模块注册的。\n1 2 3 4 5 6 7 8 9 10 public class AbpAspNetCoreModule : AbpModule { // ... 其他代码 public override void ConfigureServices(ServiceConfigurationContext context) { // ... 其他代码 context.Services.AddObjectAccessor\u0026lt;IApplicationBuilder\u0026gt;(); } // ... 其他代码 } 接着看初始化方法内部的操作，初始化方法定义是在基类当中，方法名是 InitializeModules() ，在方法内部，通过 IModuleManager 来执行模块的初始化方法。\n1 2 3 4 5 6 7 8 9 protected virtual void InitializeModules() { using (var scope = ServiceProvider.CreateScope()) { scope.ServiceProvider .GetRequiredService\u0026lt;IModuleManager\u0026gt;() .InitializeModules(new ApplicationInitializationContext(scope.ServiceProvider)); } } 除了模块的初始化，模块的销毁动作 Abp vNext 好像是没有作处理，你可以挂载 IApplicationLifetime.ApplicationStopping 事件来手动执行模块的销毁方法。\n三、总结 总体来说 Abp vNext 的启动流程与之前精简了许多，这是因为在新的框架当中将许多基础组件从核心层移除了，用户可以自由选择自己需要加载的组件。IoC 相关的代码则是通过的 Microsoft Dependency 提供的 IServiceProvider/IServiceCollection 进行操作，没有了之前的 IocManager。\n","date":"2019-04-17T03:52:13Z","permalink":"https://real-zony.github.io/p/abp-vnext-source-code-analysis---1-framework-startup-process-analysis/","title":"Abp vNext 源码分析 - 1. 框架启动流程分析"},{"content":"问题 在使用 Abp 框架的后台作业时，当后台作业抛出异常，会导致整个程序崩溃。在 Abp 框架的底层执行后台作业的时候，有 try/catch 语句块用来捕获后台任务执行时的异常，但是在这里没有生效。\n原始代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class TestAppService : ITestAppService { private readonly IBackgroundJobManager _backgroundJobManager; public TestAppService(IBackgroundJobManager backgroundJobManager) { _backgroundJobManager = backgroundJobManager; } public Task GetInvalidOperationException() { throw new InvalidOperationException(\u0026#34;模拟无效操作异常。\u0026#34;); } public async Task\u0026lt;string\u0026gt; EnqueueJob() { await _backgroundJobManager.EnqueueAsync\u0026lt;BG, string\u0026gt;(\u0026#34;测试文本。\u0026#34;); return \u0026#34;执行完成。\u0026#34;; } } public class BG : BackgroundJob\u0026lt;string\u0026gt;, ITransientDependency { private readonly TestAppService _testAppService; public BG(TestAppService testAppService) { _testAppService = testAppService; } public override async void Execute(string args) { await _testAppService.GetInvalidOperationException(); } } 调用接口时的效果：\n原因 出现这种情况是因为任何异步方法返回 void 时，抛出的异常都会在 async void 方法启动时，处于激活状态的同步上下文 (SynchronizationContext) 触发，我们的所有 Task 都是放在线程池执行的。\n所以在上述样例当中，此时 AsyncVoidMethodBuilder.Create() 使用的同步上下文为 null ，这个时候 ThreadPool 就不会捕获异常给原有线程处理，而是直接抛出。\n线程池在底层使用 AsyncVoidMethodBuilder.Craete() 所拿到的同步上下文，所捕获异常的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext) { var edi = ExceptionDispatchInfo.Capture(exception); // 同步上下文是空的，则不会做处理。 if (targetContext != null) { try { targetContext.Post(state =\u0026gt; ((ExceptionDispatchInfo)state).Throw(), edi); return; } catch (Exception postException) { edi = ExceptionDispatchInfo.Capture(new AggregateException(exception, postException)); } } } 虽然你可以通过挂载 AppDoamin.Current.UnhandledException 来监听异常，不过你是没办法从异常状态恢复的。\n参考文章：\nStephen Cleary： https://msdn.microsoft.com/en-us/magazine/jj991977.aspx\nJerome Laban\u0026rsquo;s：https://jaylee.org/archive/2012/07/08/c-sharp-async-tips-and-tricks-part-2-async-void.html\n布鲁克石：https://www.cnblogs.com/brookshi/p/5240510.html\n解决 可以使用 AsyncBackgroundJob\u0026lt;TArgs\u0026gt; 替换掉之前的 BackgroundJob\u0026lt;TArgs\u0026gt; ，只需要实现它的 Task ExecuteAsync(TArgs args) 方法即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class BGAsync : AsyncBackgroundJob\u0026lt;string\u0026gt;,ITransientDependency { private readonly TestAppService _testAppService; public BGAsync(TestAppService testAppService) { _testAppService = testAppService; } protected override async Task ExecuteAsync(string args) { await _testAppService.GetInvalidOperationException(); } } ","date":"2019-04-03T05:24:00Z","permalink":"https://real-zony.github.io/p/why-not-use-async-void/","title":"为什么不要使用 async void ？"},{"content":"用途 一致性哈希算法是为了解决普通哈希算法的热点问题，当使用普通哈希算法来切割数据到不同的缓存服务器时。 一旦缓存服务器的数量产生变化，客户端向缓存服务器请求相应的数据就不会命中，转而请求具体的数据库服务器，从而造成 缓存击穿。\n下面我们来看一下使用普通哈希算法时所带来的问题，假如我们拥有 10 台缓存服务器，那么我们在存放数据的时候可以对缓存数据项的 Key 进行哈希操作，取得其散列值，并将其与服务器数量进行取模运算，就可以得到一个服务器下标的数字。\n服务器信息 = Hash(Key) % 10\n例如我针对字符串 \u0026ldquo;140\u0026rdquo; 进行 SHA256 散列操作，得到 762818267，对 10 取模运算结果是 7 号服务器。但如果增加了一台服务器，那么就会变成对 11 取模,，其结果就是 2 号服务器，得到的位置完全不正确，造成取缓存的时候肯定不会命中。\n原理 注意：\n由于画图的时候粗心将服务器 C 的 IP 地址写成了 192.168.100.102，其真实 IP 应该是 192.168.100.103，阅读文章的时候请注意这个区别。\n1.创建一个环，这个哈希环有 2^32 个节点。\n2.求出服务器的哈希值，并将其与哈希环节点的数量取模，得到的值即是服务器节点在哈希环上的位置。\n3.根据要存储的数据项键值，求出其哈希值，与哈希环节点数量取模，得到在哈希环的位置。\n4.根据数据项在哈希环的位置，顺时针查找遇到的第一个服务器节点，将数据项存放到该服务器。\n5.如果增加了一台服务器 D，只会影响 D 之前区间的数据。\n上述情况仅适用于服务节点在哈希环上分布均匀的情况，如果哈希环上服务器节点的 分布位置不均匀，则会导致某个区间内的数据项的大量数据存放在一个服务器节点中。如下图，A 缓存服务器就会接收大量请求，当该服务器崩溃掉之后，B 服务器，C 服务器会依次崩溃，这样就会造成 服务器雪崩效应，整个缓存服务器集群都会瘫痪。\n这种时候，我们可以引入虚拟节点来解决该问题。例如我们拥有 A、B、C 三台服务器，我们在哈希环上创建哈希服务器的时候，可以为其创建 N 个虚拟节点，这些虚拟节点都是指向真实服务器的 IP，这样我们在哈希环上的服务器节点分布就会很均匀。\n实现 在这里我们基于 C# 与 .NET Core 编写一个 DEMO 代码，用来演示上述情况，这里的代码仅作演示使用，如果要应用到生产环境，请注意线程同步问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 using System; using System.Collections.Generic; using System.Security.Cryptography; using System.Text; /* * 一致性哈希算法的 DEMO，主要用于演示一致性哈希算法的实现与实际应用。 */ namespace ConsistentHashing.Startup { public class NodeInfo { public string IPAddress { get; set; } } public class VirtualNodeInfo { public string NodeName { get; set; } public NodeInfo RealNodeInfo { get; set; } } public class ConsistentHashing { // 哈希环的大小 private readonly int _ringCount; // 每个物理节点对应的虚拟节点数量 private readonly int _virtualNodeCount; // 哈希环 public readonly VirtualNodeInfo[] HashRing; public ConsistentHashing(int ringCount = int.MaxValue, int virtualNodeCount = 3) { _ringCount = ringCount; _virtualNodeCount = virtualNodeCount; HashRing = new VirtualNodeInfo[_ringCount]; } public NodeInfo GetNode(string key) { var pos = Math.Abs(GetStandardHashCode(key) % _ringCount); // 顺时针查找最近的节点 return GetFirstNodeInfo(pos).RealNodeInfo; } /// \u0026lt;summary\u0026gt; /// 向哈希环上添加虚拟节点。 /// \u0026lt;/summary\u0026gt; public void AddNode(NodeInfo info) { for (int index = 0; index \u0026lt; _virtualNodeCount; index++) { // 哈希环上没有物理节点，只有虚拟节点 var virtualNodeName = $\u0026#34;{info.IPAddress}#{index}\u0026#34;; var hashIndex = Math.Abs(GetStandardHashCode(virtualNodeName) % _ringCount); // 搜索空的哈希环位置 var emptyIndex = GetEmptyNodeIndex(hashIndex); if (emptyIndex == -1) { break; } HashRing[emptyIndex] = new VirtualNodeInfo{NodeName = virtualNodeName,RealNodeInfo = info}; } } public void RemoveNode(NodeInfo info) { // 构建虚拟节点的 KEY var virtualNames = new List\u0026lt;string\u0026gt;(); for (int i = 0; i \u0026lt; _virtualNodeCount; i++) { virtualNames.Add($\u0026#34;{info.IPAddress}#{i}\u0026#34;); } for (int i = 0; i \u0026lt; HashRing.Length; i++) { if(HashRing[i] == null) continue; if (virtualNames.Contains(HashRing[i].NodeName)) HashRing[i] = null; } } /// \u0026lt;summary\u0026gt; /// 计算指定 KEY 的 HASH 值 /// \u0026lt;/summary\u0026gt; private int GetStandardHashCode(string key) { var sha1 = SHA256.Create(); var hashValue = sha1.ComputeHash(Encoding.UTF8.GetBytes(key)); return BitConverter.ToInt32(hashValue); } /// \u0026lt;summary\u0026gt; /// 循环遍历哈希环，寻找空节点的索引，防止覆盖存在的节点信息。 /// \u0026lt;/summary\u0026gt; private int GetEmptyNodeIndex(int startFindIndex) { while (true) { if (HashRing[startFindIndex] == null) { return startFindIndex; } var nextIndex = GetNextNodeIndex(startFindIndex); // 说明已经遍历了整个哈希环，说明没有空的节点了。 if (startFindIndex == nextIndex) { return -1; } startFindIndex = nextIndex; } } /// \u0026lt;summary\u0026gt; /// 根据指定的索引，获得哈希环的下一个索引。这里需要注意的是，因为哈希环是一个环形，当 /// 当前位置为环的末尾时，应该从 0 开始查找。 /// \u0026lt;/summary\u0026gt; private int GetNextNodeIndex(int preIndex) { if (preIndex == HashRing.Length - 1) return 0; return ++preIndex; } private VirtualNodeInfo GetFirstNodeInfo(int currentIndex) { VirtualNodeInfo nodeInfo = null; int nextIndex = currentIndex; while (nodeInfo == null) { nodeInfo = HashRing[GetNextNodeIndex(nextIndex)]; nextIndex += 1; } return nodeInfo; } } internal class Program { private static void Main(string[] args) { var consistentHashing = new ConsistentHashing(400,10); consistentHashing.AddNode(new NodeInfo {IPAddress = \u0026#34;192.168.1.101\u0026#34;}); consistentHashing.AddNode(new NodeInfo {IPAddress = \u0026#34;192.168.1.102\u0026#34;}); consistentHashing.AddNode(new NodeInfo {IPAddress = \u0026#34;192.168.1.103\u0026#34;}); consistentHashing.AddNode(new NodeInfo {IPAddress = \u0026#34;192.168.1.104\u0026#34;}); foreach (var node in consistentHashing.HashRing) { Console.WriteLine(node?.NodeName ?? \u0026#34;NULL\u0026#34;); } // 存放 Id 为 15 的缓存服务器 var nodeInfo = consistentHashing.GetNode(\u0026#34;15\u0026#34;); // 删除节点测试 consistentHashing.RemoveNode(new NodeInfo {IPAddress = \u0026#34;192.168.1.103\u0026#34;}); } } } ","date":"2019-03-26T09:37:36Z","permalink":"https://real-zony.github.io/p/understanding-consistent-hash-algorithms/","title":"了解一致性哈希算法"},{"content":"问题 有时更新了一些内网的程序库/包，但仅仅是一些小的更改，不想增加版本号再推送到内网服务器。手动删除了 .nuget 文件夹下的相关包文件，但是使用 Visual Studio 重新构建的时候，其使用的包版本仍然不正确。\n原因 原因未知，可能是由于缓存未清理彻底造成的。\n解决 NuGet 包相关的文件夹，除了 .nuget 文件夹以外，还有其他两个缓存/临时文件夹，将这两个文件夹清空之后，程序可以正常构建。\n文件夹路径：\nC:\\Users\\\u0026lt;用户名\u0026gt;\\.nuget\\packages C:\\Users\\\u0026lt;用户名\u0026gt;\\AppData\\Local\\NuGet\\v3-cache C:\\Users\\\u0026lt;用户名\u0026gt;\\AppData\\Local\\Temp\\NuGetScratch ","date":"2019-03-25T00:57:58Z","permalink":"https://real-zony.github.io/p/nuget-clearing-cache-manually-doesnt-work/","title":"NuGet 手动清除缓存不起作用"},{"content":"问题 将 SignalR 集成到 ASP.NET Core MVC 程序的时候，按照官方 DEMO 配置完成，但使用 DEMO 页面建立连接一直提示如下信息。\n1 Access to XMLHttpRequest at \u0026#39;http://localhost:8090/signalr-myChatHub/negotiate\u0026#39; from origin \u0026#39;null\u0026#39; has been blocked by CORS policy: Response to preflight request doesn\u0026#39;t pass access control check: The value of the \u0026#39;Access-Control-Allow-Origin\u0026#39; header in the response must not be the wildcard \u0026#39;*\u0026#39; when the request\u0026#39;s credentials mode is \u0026#39;include\u0026#39;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute. 原始代码：\n1 2 3 4 5 6 7 8 9 10 services.AddCors(op =\u0026gt; { op.AddPolicy(MonitorStartupConsts.DefaultCorsPolicyName, set =\u0026gt; { set.AllowAnyOrigin() .AllowAnyHeader() .AllowAnyMethod() .AllowCredentials(); }); }); 原因 出现该问题的原因是由于 CORS 策略设置不正确造成的，原始设置我是允许所有 Origin 来源。但是由于 dotnetCore 2.2 的限制，无法使用 AllowAnyOrigin() + AllowCredentials() 的组合，只能显式指定 Origin 来源，或者通过下述方式来间接实现。\n解决 更改 Cors 相关配置，在 CorsPolicyBuilder 提供了一个方法用于配置验证逻辑。该方法名字叫做 SetIsOriginAllowed(Func\u0026lt;string, bool\u0026gt; isOriginAllowed)，这个委托会验证传入的 Origin 源，如果验证通过则返回 true。\n在这里我们只需要将其设置为一直返回 true 即可。 最终代码如下：\n1 2 3 4 5 6 7 8 9 10 services.AddCors(op =\u0026gt; { op.AddPolicy(MonitorStartupConsts.DefaultCorsPolicyName, set =\u0026gt; { set.SetIsOriginAllowed(origin =\u0026gt; true) .AllowAnyHeader() .AllowAnyMethod() .AllowCredentials(); }); }); ","date":"2019-03-11T08:35:59Z","permalink":"https://real-zony.github.io/p/cors-issues-with-aspnet-core-using-signalr/","title":"ASP.NET Core 使用 SignalR 遇到的 CORS 问题"},{"content":"一、什么是 BT Tracker ？ 在 BT 下载过程当中，我们如果拿到一个种子文件，在其内部会包含一组 BT Tracker 服务器信息。在开始进行下载的时候，BT 下载工具会根据种子内的唯一 HASH 码请求 Tracker 服务器，之后 Tracker 服务器会返回给正在 下载/做种 的 Peer 信息，下载工具获得了其他的 Peer 信息之后就会与其他的 Peer 建立通讯下载数据。\n整个过程的时序图如下：\n在这里 BT Tracker 充当的角色就是一个通讯员的角色，它的构造很简单，最简构造的情况下只需要一个 HTTP API 接口即可。其作用就是在 BT 下载工具请求 Peer 信息的时候，返回相应的信息即可。\n二、BT 协议与 BEncode 编码 在 BT 协议通讯的过程当中，所有的数据都是通过 B Encode 进行编码的。这种编码方式类似于 JSON 的数据组织形式，它可以表示字符串与整形这两种基本类型，也可以表示列表与字典这两种数据结构，其语法规则很简单。\n字符串 \u0026ldquo;hello\u0026rdquo; 的编码形式：\n1 2 [字符串长度]:[字符串数据] 5:hello 整数 10 的编码形式：\n1 2 i[整数]e i10e 列表这种数据结构，可以包含任意 B 编码的类型，包括 字符串、整形、字典(dictionary)、列表(list) 。\n包含两个字符串元素 \u0026ldquo;hello\u0026rdquo;、\u0026ldquo;world\u0026rdquo; 的 列表 编码形式：\n1 2 I[内容]e I5:hello5:world 字典的概念与我们 C# 当中 BCL 所定义的 Dictionary\u0026lt;string,T\u0026gt; 一样，它是由一个键值对组成，其键的类型必须为 B 编码的字符串，而其值可以为任意的 B 编码类型，包括 字符串、整形、字典(dictionary)、列表(list) 。\n1 2 d[内容]e d4:Name4:Lisa3:Agei15ee 上述内容以 JSON 为例，则表示为：\n1 2 3 4 { \u0026#34;Name\u0026#34;:\u0026#34;Lisa\u0026#34;, \u0026#34;Age\u0026#34;:15 } 在本篇文章的示例当中，没有自行编写 B Encode 的编码与解码工具类，而是使用的第三方库 BencodeNET 来进行操作。\n当然，针对于 B Encode 的编解码工具类的编写并不复杂，有了上述的解析，你也可以尝试自己编写一个 B Encode 编解码工具类。\n三、整体编写思路 BT Tracker 服务器本质上就是一个 Web Api 项目，BT 客户端携带种子的唯一 HASH 值，去请求某个接口，从而获得正在工作的 Peer 列表。剩下的事情就与 Tracker 服务器无关了，Tacker 服务器的职责就是为 BT 下载工具提供正在工作的其他 BT 客户端。\n因此我们第一步就需要建立一个基于 .NET Core 的 Web Api 项目，并编写一个控制器接口用于响应 BT 下载工具的请求。除此之外，我们还需要一个字典用来存储种子与对应的 Peer 集合信息，在 BT 下载工具请求 Tracker 服务器的时候，能够返回相应的 Peer 集合信息。\n除了返回给 BT 下载工具 Peer 信息之外，Tracker 还可以根据 Client 请求时携带的附加数据来更新 Peer 的统计信息。(这些信息常用于 PT 站进行积分统计)\nTracker 服务器针对于返回的 Peer 集合有两种处理方式，第一种则是 紧凑模式 ，这个时候 Tracker 服务器需要将 Peer 的 IP 与 Port 按照 [IP 地址(4 byte)][端口号(2 byte)] 的形式进行编码，返回二进制流。另一种则是直接将 Peer 集合的信息，通过 BDictionary 进行编码，其组织形式如下。\n1 2 3 {PeerIdKey,PeerId 值}, {IpKey,IP 值}， {PortKey,Port 值} 最后总结来说，如果要实现最简的 Tracker 服务器，只需要管理好 Peer (BT 客户端) 的状态，并且响应 Peer 的请求即可。如果需要实现积分制，那么就需要针对 Peer 的信息进行持久化处理。\n四、BT Tacker 服务器接口的定义 BT 下载工具向 Tracker 接口请求的参数与返回的参数已经在 BT 协议规范 当中有说明，下面我们就来介绍一下请求参数与返回参数的含义。\n4.1 请求参数 参数名称 具体含义 类型 必填 info_hash 种子的唯一 HASH 标识。 string 是 peer_id BT 下载端的唯一标识，由客户端生成。 string 是 ip 客户端的 IP 地址。 string 否 port 客户端监听的端口。 int 是 uploaded 客户端已经上传的数据大小，以 byte 为单位。 long 是 downloaded 客户端已经下载的数据大小，以 byte 为单位。 long 是 left 客户端待下载的数据大小，以 bytes 为单位。 long 是 event 当前事件，一般有三个值代表客户端现在的状态，已开始 、已停止、已完成。 string 是 compact 是否启用紧凑模式，如果为 1 则启动，为 0 则正常编码。 int 否 numWant 客户端想要获得的 Peer 数量。 int 否 Tracker 的接口返回参数其 Content-Type 的值必须为 text/plain ，并且其结果是通过 B Encode 进行编码的。最外层是一个 BDictionary 字典，内部的数据除了一个 Peer 集合之外，还包含了以下的固定键值对。\n4.2 返回参数 字典键 字典值类型 含义 必填 peers BList/BString Peer 列表，根据 compact 参数不同，其值类型不一样。 是 interval BNumber 客户端发送规则请求到 Tracker 服务器之后的强制等待 时间，以秒为单位。 是 min interval BNumer 最小的发布时间间隔，客户端的重发间隔不能小于此值，也 是以秒为单位。 是 tracker id BString Tracker 服务器的 Id，用于标识服务器。 是 complete BNumber 当前请求的种子，已经完成的 Peer 数量(做种数)。 是 incomplete BNumber 当前请求的种子，非做种状态的用户。 是 failure reason BString Tracker 处理失败的原因，为可选参数。 否 五、编码实现 BT Tracker 服务器 5.1 基本架构 首先新建立一个标准的 Web API 模板项目，删除掉其默认的 ValuesController ，建立一个新的控制器，其名字为 AnnounceController ，最后我们的项目结构如下。\n添加一个 GetPeersInfo 接口，其 HTTP Method 为 GET 类型，建立一个输入 DTO 其代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class GetPeersInfoInput { /// \u0026lt;summary\u0026gt; /// 种子的唯一 Hash 标识。 /// \u0026lt;/summary\u0026gt; public string Info_Hash { get; set; } /// \u0026lt;summary\u0026gt; /// 客户端的随机 Id，由 BT 客户端生成。 /// \u0026lt;/summary\u0026gt; public string Peer_Id { get; set; } /// \u0026lt;summary\u0026gt; /// 客户端的 IP 地址。 /// \u0026lt;/summary\u0026gt; public string Ip { get; set; } /// \u0026lt;summary\u0026gt; /// 客户端监听的端口。 /// \u0026lt;/summary\u0026gt; public int Port { get; set; } /// \u0026lt;summary\u0026gt; /// 已经上传的数据大小。 /// \u0026lt;/summary\u0026gt; public long Uploaded { get; set; } /// \u0026lt;summary\u0026gt; /// 已经下载的数据大小。 /// \u0026lt;/summary\u0026gt; public long Downloaded { get; set; } /// \u0026lt;summary\u0026gt; /// 事件表示，具体可以转换为 \u0026lt;see cref=\u0026#34;TorrentEvent\u0026#34;/\u0026gt; 枚举的具体值。 /// \u0026lt;/summary\u0026gt; public string Event { get; set; } /// \u0026lt;summary\u0026gt; /// 该客户端剩余待下载的数据。 /// \u0026lt;/summary\u0026gt; public long Left { get; set; } /// \u0026lt;summary\u0026gt; /// 是否启用压缩，当该值为 1 的时候，表示当前客户端接受压缩格式的 Peer 列表，即使用 /// 6 字节表示一个 Peer (前 4 字节表示 IP 地址，后 2 字节表示端口号)。当该值为 0 /// 的时候则表示客户端不接受。 /// \u0026lt;/summary\u0026gt; public int Compact { get; set; } /// \u0026lt;summary\u0026gt; /// 表示客户端想要获得的 Peer 数量。 /// \u0026lt;/summary\u0026gt; public int? NumWant { get; set; } } 上面仅仅是 PT 客户端传递给 Tracker 服务器的参数信息，为了在后面我们方便使用，我们还需要将其转换为方便操作的充血模型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 public class AnnounceInputParameters { /// \u0026lt;summary\u0026gt; /// 客户端 IP 端点信息。 /// \u0026lt;/summary\u0026gt; public IPEndPoint ClientAddress { get; } /// \u0026lt;summary\u0026gt; /// 种子的唯一 Hash 标识。 /// \u0026lt;/summary\u0026gt; public string InfoHash { get; } /// \u0026lt;summary\u0026gt; /// 客户端的随机 Id，由 BT 客户端生成。 /// \u0026lt;/summary\u0026gt; public string PeerId { get; } /// \u0026lt;summary\u0026gt; /// 已经上传的数据大小。 /// \u0026lt;/summary\u0026gt; public long Uploaded { get; } /// \u0026lt;summary\u0026gt; /// 已经下载的数据大小。 /// \u0026lt;/summary\u0026gt; public long Downloaded { get; } /// \u0026lt;summary\u0026gt; /// 事件表示，具体可以转换为 \u0026lt;see cref=\u0026#34;TorrentEvent\u0026#34;/\u0026gt; 枚举的具体值。 /// \u0026lt;/summary\u0026gt; public TorrentEvent Event { get; } /// \u0026lt;summary\u0026gt; /// 该客户端剩余待下载的数据。 /// \u0026lt;/summary\u0026gt; public long Left { get; } /// \u0026lt;summary\u0026gt; /// Peer 是否允许启用压缩。 /// \u0026lt;/summary\u0026gt; public bool IsEnableCompact { get; } /// \u0026lt;summary\u0026gt; /// Peer 想要获得的可用的 Peer 数量。 /// \u0026lt;/summary\u0026gt; public int PeerWantCount { get; } /// \u0026lt;summary\u0026gt; /// 如果在请求过程当中出现了异常，则本字典包含了异常信息。 /// \u0026lt;/summary\u0026gt; public BDictionary Error { get; } public AnnounceInputParameters(GetPeersInfoInput apiInput) { Error = new BDictionary(); ClientAddress = ConvertClientAddress(apiInput); InfoHash = ConvertInfoHash(apiInput); Event = ConvertTorrentEvent(apiInput); PeerId = apiInput.Peer_Id; Uploaded = apiInput.Uploaded; Downloaded = apiInput.Downloaded; Left = apiInput.Left; IsEnableCompact = apiInput.Compact == 1; PeerWantCount = apiInput.NumWant ?? 30; } /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;GetPeersInfoInput\u0026#34;/\u0026gt; 到当前类型的隐式转换定义。 /// \u0026lt;/summary\u0026gt; public static implicit operator AnnounceInputParameters(GetPeersInfoInput input) { return new AnnounceInputParameters(input); } /// \u0026lt;summary\u0026gt; /// 将客户端传递的 IP 地址与端口转换为 \u0026lt;see cref=\u0026#34;IPEndPoint\u0026#34;/\u0026gt; 类型。 /// \u0026lt;/summary\u0026gt; private IPEndPoint ConvertClientAddress(GetPeersInfoInput apiInput) { if (IPAddress.TryParse(apiInput.Ip, out IPAddress ipAddress)) { return new IPEndPoint(ipAddress,apiInput.Port); } return null; } /// \u0026lt;summary\u0026gt; /// 将客户端传递的字符串 Event 转换为 \u0026lt;see cref=\u0026#34;TorrentEvent\u0026#34;/\u0026gt; 枚举。 /// \u0026lt;/summary\u0026gt; private TorrentEvent ConvertTorrentEvent(GetPeersInfoInput apiInput) { switch (apiInput.Event) { case \u0026#34;started\u0026#34;: return TorrentEvent.Started; case \u0026#34;stopped\u0026#34;: return TorrentEvent.Stopped; case \u0026#34;completed\u0026#34;: return TorrentEvent.Completed; default: return TorrentEvent.None; } } /// \u0026lt;summary\u0026gt; /// 将 info_hash 参数从 URL 编码转换为标准的字符串。 /// \u0026lt;/summary\u0026gt; private string ConvertInfoHash(GetPeersInfoInput apiInput) { var infoHashBytes = HttpUtility.UrlDecodeToBytes(apiInput.Info_Hash); if (infoHashBytes == null) { Error.Add(TrackerServerConsts.FailureKey,new BString(\u0026#34;info_hash 参数不能为空.\u0026#34;)); return null; } if (infoHashBytes.Length != 20) { Error.Add(TrackerServerConsts.FailureKey,new BString($\u0026#34;info_hash 参数的长度 {{{infoHashBytes.Length}}} 不符合 BT 协议规范.\u0026#34;)); } return BitConverter.ToString(infoHashBytes); } } 上述代码我们构建了一个新的类型 AnnounceInputParameters ，该类型会将部分参数转换为我们便于操作的类型。这里需要注意的是，我们在 TrackerServerConsts 当中定义了所用到了大部分 BDictionary 关键字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public enum TorrentEvent { /// \u0026lt;summary\u0026gt; /// 未知状态。 /// \u0026lt;/summary\u0026gt; None, /// \u0026lt;summary\u0026gt; /// 已开始。 /// \u0026lt;/summary\u0026gt; Started, /// \u0026lt;summary\u0026gt; /// 已停止。 /// \u0026lt;/summary\u0026gt; Stopped, /// \u0026lt;summary\u0026gt; /// 已完成。 /// \u0026lt;/summary\u0026gt; Completed } /// \u0026lt;summary\u0026gt; /// 常用的字典 KEY。 /// \u0026lt;/summary\u0026gt; public static class TrackerServerConsts { public static readonly BString PeerIdKey = new BString(\u0026#34;peer id\u0026#34;); public static readonly BString PeersKey = new BString(\u0026#34;peers\u0026#34;); public static readonly BString IntervalKey = new BString(\u0026#34;interval\u0026#34;); public static readonly BString MinIntervalKey = new BString(\u0026#34;min interval\u0026#34;); public static readonly BString TrackerIdKey = new BString(\u0026#34;tracker id\u0026#34;); public static readonly BString CompleteKey = new BString(\u0026#34;complete\u0026#34;); public static readonly BString IncompleteKey = new BString(\u0026#34;incomplete\u0026#34;); public static readonly BString Port = new BString(\u0026#34;port\u0026#34;); public static readonly BString Ip = new BString(\u0026#34;ip\u0026#34;); public static readonly string FailureKey = \u0026#34;failure reason\u0026#34;; } 5.2 Peer 的定义 每一个 Peer 我们定义一个 Peer 类型进行表示，我们可以通过 BT 客户端传递的请求参数来实时更新每个 Peer 对象的信息。\n除此之外，根据 BT 协议的规定，在返回 Peer 列表的时候可以返回紧凑型的结果和正常 B 编码结果的 Peer 信息。所以我们也会在 Peer 对象中，增加两个方法用于将 Peer 信息进行特定的编码处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 /// \u0026lt;summary\u0026gt; /// 每个 BT 下载客户端的定义。 /// \u0026lt;/summary\u0026gt; public class Peer { /// \u0026lt;summary\u0026gt; /// 客户端 IP 端点信息。 /// \u0026lt;/summary\u0026gt; public IPEndPoint ClientAddress { get; private set; } /// \u0026lt;summary\u0026gt; /// 客户端的随机 Id，由 BT 客户端生成。 /// \u0026lt;/summary\u0026gt; public string PeerId { get; private set; } /// \u0026lt;summary\u0026gt; /// 客户端唯一标识。 /// \u0026lt;/summary\u0026gt; public string UniqueId { get; private set; } /// \u0026lt;summary\u0026gt; /// 客户端在本次会话过程中下载的数据量。(以 Byte 为单位) /// \u0026lt;/summary\u0026gt; public long DownLoaded { get; private set; } /// \u0026lt;summary\u0026gt; /// 客户端在本次会话过程当中上传的数据量。(以 Byte 为单位) /// \u0026lt;/summary\u0026gt; public long Uploaded { get; private set; } /// \u0026lt;summary\u0026gt; /// 客户端的下载速度。(以 Byte/秒 为单位) /// \u0026lt;/summary\u0026gt; public long DownloadSpeed { get; private set; } /// \u0026lt;summary\u0026gt; /// 客户端的上传速度。(以 Byte/秒 为单位) /// \u0026lt;/summary\u0026gt; public long UploadSpeed { get; private set; } /// \u0026lt;summary\u0026gt; /// 客户端是否完成了当前种子，True 为已经完成，False 为还未完成。 /// \u0026lt;/summary\u0026gt; public bool IsCompleted { get; private set; } /// \u0026lt;summary\u0026gt; /// 最后一次请求 Tracker 服务器的时间。 /// \u0026lt;/summary\u0026gt; public DateTime LastRequestTrackerTime { get; private set; } /// \u0026lt;summary\u0026gt; /// Peer 还需要下载的数量。 /// \u0026lt;/summary\u0026gt; public long Left { get; private set; } public Peer() { } public Peer(AnnounceInputParameters inputParameters) { UniqueId = inputParameters.ClientAddress.ToString(); // 根据输入参数更新 Peer 的状态。 UpdateStatus(inputParameters); } /// \u0026lt;summary\u0026gt; /// 根据输入参数更新 Peer 的状态。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;inputParameters\u0026#34;\u0026gt;BT 客户端请求 Tracker 服务器时传递的参数。\u0026lt;/param\u0026gt; public void UpdateStatus(AnnounceInputParameters inputParameters) { var now = DateTime.Now; var elapsedTime = (now - LastRequestTrackerTime).TotalSeconds; if (elapsedTime \u0026lt; 1) elapsedTime = 1; ClientAddress = inputParameters.ClientAddress; // 通过差值除以消耗的时间，得到每秒的大概下载速度。 DownloadSpeed = (int) ((inputParameters.Downloaded - DownLoaded) / elapsedTime); DownLoaded = inputParameters.Downloaded; UploadSpeed = (int) ((inputParameters.Uploaded) / elapsedTime); Uploaded = inputParameters.Uploaded; Left = inputParameters.Left; PeerId = inputParameters.PeerId; LastRequestTrackerTime = now; // 如果没有剩余数据，则表示 Peer 已经完成下载。 if (Left == 0) IsCompleted = true; } /// \u0026lt;summary\u0026gt; /// 将 Peer 信息进行 B 编码，按照协议处理为字典。 /// \u0026lt;/summary\u0026gt; public BDictionary ToEncodedDictionary() { return new BDictionary { {TrackerServerConsts.PeerIdKey,new BString(PeerId)}, {TrackerServerConsts.Ip,new BString(ClientAddress.Address.ToString())}, {TrackerServerConsts.Port,new BNumber(ClientAddress.Port)} }; } /// \u0026lt;summary\u0026gt; /// 将 Peer 信息进行紧凑编码成字节组。 /// \u0026lt;/summary\u0026gt; public byte[] ToBytes() { var portBytes = BitConverter.GetBytes(IPAddress.HostToNetworkOrder((short) ClientAddress.Port)); var addressBytes = ClientAddress.Address.GetAddressBytes(); var resultBytes = new byte[portBytes.Length + addressBytes.Length]; // 根据协议规定，首部的 4 字节为 IP 地址，尾部的 2 自己为端口信息 Array.Copy(addressBytes,resultBytes,addressBytes.Length); Array.Copy(portBytes,0,resultBytes,addressBytes.Length,portBytes.Length); return resultBytes; } } 5.3 管理种子与其 Peer 集合 BT 客户端请求 Tracker 服务器的目的只有一个，就是获取正在 下载同一个种子的 Peer 列表 ，明白了这一点之后就知道我们需要一个字典来管理种子与可用 Peer 集合的关系。\n在上一节我们知道，客户端在请求 Tracker 服务器的时候会带上正在下载的种子唯一 Hash 值，而我们则可以根据这个 Hash 值来索引我们 Peer 列表。\nPT 站的原理也是类似，会有一个种子表，这个表以种子的唯一 Hash 值作为主键，并添加某些扩展字段。(IMDB 评分、描述、视频信息等\u0026hellip;)\n这里我们定义一个 IBitTorrentManager 管理器对象，通过该对象来管理种子的状态，以及种子与 Peer 集合的状态。该接口的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /// \u0026lt;summary\u0026gt; /// 用于管理 BT 种子与其关联的 Peer 集合。 /// \u0026lt;/summary\u0026gt; public interface IBitTorrentManager { /// \u0026lt;summary\u0026gt; /// 添加一个新的 Peer 到指定种子关联的集合当中。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;infoHash\u0026#34;\u0026gt;种子的唯一标识。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;inputParameters\u0026#34;\u0026gt;BT 客户端传入的参数信息。\u0026lt;/param\u0026gt; Peer AddPeer(string infoHash,AnnounceInputParameters inputParameters); /// \u0026lt;summary\u0026gt; /// 根据参数删除指定种子的 Peer 信息。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;infoHash\u0026#34;\u0026gt;种子的唯一标识。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;inputParameters\u0026#34;\u0026gt;BT 客户端传入的参数信息。\u0026lt;/param\u0026gt; void DeletePeer(string infoHash,AnnounceInputParameters inputParameters); /// \u0026lt;summary\u0026gt; /// 更新指定种子的某个 Peer 状态。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;infoHash\u0026#34;\u0026gt;种子的唯一标识。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;inputParameters\u0026#34;\u0026gt;BT 客户端传入的参数信息。\u0026lt;/param\u0026gt; void UpdatePeer(string infoHash, AnnounceInputParameters inputParameters); /// \u0026lt;summary\u0026gt; /// 获得指定种子的可用 Peer 集合。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;infoHash\u0026#34;\u0026gt;种子的唯一标识。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;当前种子关联的 Peer 列表。\u0026lt;/returns\u0026gt; IReadOnlyList\u0026lt;Peer\u0026gt; GetPeers(string infoHash); /// \u0026lt;summary\u0026gt; /// 清理指定种子内部不活跃的 Peer 。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;infoHash\u0026#34;\u0026gt;种子的唯一标识。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;expiry\u0026#34;\u0026gt;超时周期，超过这个时间的 Peer 将会被清理掉。\u0026lt;/param\u0026gt; void ClearZombiePeers(string infoHash,TimeSpan expiry); /// \u0026lt;summary\u0026gt; /// 获得指定种子已经完成下载的 Peer 数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;infoHash\u0026#34;\u0026gt;种子的唯一标识。\u0026lt;/param\u0026gt; int GetComplete(string infoHash); /// \u0026lt;summary\u0026gt; /// 获得指定种子正在下载的 Peer 数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;infoHash\u0026#34;\u0026gt;种子的唯一标识。\u0026lt;/param\u0026gt; int GetInComplete(string infoHash); } 前四个方法都是用于管理种子关联的 Peer 数据的，就是一些 CRUD 操作。由于某些用户可能不再做种，这个时候他的 Peer 信息就是无用的，就需要进行清理，所以我们也提供了一个 ClearZombiePeers() 方法来清理这些无效的 Peer 。\n最后两个方法是用于更新种子的最新状态，每一个种子除了它关联的 Peer 信息，同时也有一些统计信息，例如已经完成的 Peer 数，正在下载的 Peer 数，下载完成等统计信息，这里我们可以建立一个类存放这些统计信息以跟种子相关联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /// \u0026lt;summary\u0026gt; /// 用于表示某个种子的状态与统计信息。 /// \u0026lt;/summary\u0026gt; public class BitTorrentStatus { /// \u0026lt;summary\u0026gt; /// 下载完成的 Peer 数量。 /// \u0026lt;/summary\u0026gt; public BNumber Downloaded { get; set; } /// \u0026lt;summary\u0026gt; /// 已经完成种子下载的 Peer 数量。 /// \u0026lt;/summary\u0026gt; public BNumber Completed { get; set; } /// \u0026lt;summary\u0026gt; /// 正在下载种子的 Peer 数量。 /// \u0026lt;/summary\u0026gt; public BNumber InCompleted { get; set; } public BitTorrentStatus() { Downloaded = new BNumber(0); Completed = new BNumber(0); InCompleted = new BNumber(0); } } 接下来我们就来实现 IBitTorrentManager 接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 public class BitTorrentManager : IBitTorrentManager { private readonly ConcurrentDictionary\u0026lt;string, List\u0026lt;Peer\u0026gt;\u0026gt; _peers; private readonly ConcurrentDictionary\u0026lt;string, BitTorrentStatus\u0026gt; _bitTorrentStatus; public BitTorrentManager() { _peers = new ConcurrentDictionary\u0026lt;string, List\u0026lt;Peer\u0026gt;\u0026gt;(); _bitTorrentStatus = new ConcurrentDictionary\u0026lt;string, BitTorrentStatus\u0026gt;(); } public Peer AddPeer(string infoHash, AnnounceInputParameters inputParameters) { CheckParameters(infoHash, inputParameters); var newPeer = new Peer(inputParameters); if (!_peers.ContainsKey(infoHash)) { _peers.TryAdd(infoHash, new List\u0026lt;Peer\u0026gt; {newPeer}); } _peers[infoHash].Add(newPeer); UpdateBitTorrentStatus(infoHash); return newPeer; } public void DeletePeer(string infoHash, AnnounceInputParameters inputParameters) { CheckParameters(infoHash, inputParameters); if (!_peers.ContainsKey(infoHash)) return; _peers[infoHash].RemoveAll(p =\u0026gt; p.UniqueId == inputParameters.ClientAddress.ToString()); UpdateBitTorrentStatus(infoHash); } public void UpdatePeer(string infoHash, AnnounceInputParameters inputParameters) { CheckParameters(infoHash, inputParameters); if (!_peers.ContainsKey(inputParameters.InfoHash)) _peers.TryAdd(infoHash, new List\u0026lt;Peer\u0026gt;()); if (!_bitTorrentStatus.ContainsKey(inputParameters.InfoHash)) _bitTorrentStatus.TryAdd(infoHash, new BitTorrentStatus()); // 如果 Peer 不存在则添加，否则更新其状态。 var peers = _peers[infoHash]; var peer = peers.FirstOrDefault(p =\u0026gt; p.UniqueId == inputParameters.ClientAddress.ToString()); if (peer == null) { AddPeer(infoHash, inputParameters); } else { peer.UpdateStatus(inputParameters); } // 根据事件更新种子状态与 Peer 信息。 if (inputParameters.Event == TorrentEvent.Stopped) DeletePeer(infoHash,inputParameters); if (inputParameters.Event == TorrentEvent.Completed) _bitTorrentStatus[infoHash].Downloaded++; UpdateBitTorrentStatus(infoHash); } public IReadOnlyList\u0026lt;Peer\u0026gt; GetPeers(string infoHash) { if (!_peers.ContainsKey(infoHash)) return null; return _peers[infoHash]; } public void ClearZombiePeers(string infoHash, TimeSpan expiry) { if (!_peers.ContainsKey(infoHash)) return; var now = DateTime.Now; _peers[infoHash].RemoveAll(p =\u0026gt; now - p.LastRequestTrackerTime \u0026gt; expiry); } public int GetComplete(string infoHash) { if (_bitTorrentStatus.TryGetValue(infoHash, out BitTorrentStatus status)) { return status.Completed; } return 0; } public int GetInComplete(string infoHash) { if (_bitTorrentStatus.TryGetValue(infoHash, out BitTorrentStatus status)) { return status.InCompleted; } return 0; } /// \u0026lt;summary\u0026gt; /// 更新种子的统计信息。 /// \u0026lt;/summary\u0026gt; private void UpdateBitTorrentStatus(string infoHash) { if (!_peers.ContainsKey(infoHash)) return; if (!_bitTorrentStatus.ContainsKey(infoHash)) return; // 遍历种子所有的 Peer 状态，对种子统计信息进行处理。 int complete = 0, incomplete = 0; var peers = _peers[infoHash]; foreach (var peer in peers) { if (peer.IsCompleted) complete++; else incomplete++; } _bitTorrentStatus[infoHash].Completed = complete; _bitTorrentStatus[infoHash].InCompleted = incomplete; } /// \u0026lt;summary\u0026gt; /// 检测参数与种子唯一标识的状态。 /// \u0026lt;/summary\u0026gt; private void CheckParameters(string infoHash,AnnounceInputParameters inputParameters) { if (string.IsNullOrEmpty(infoHash)) throw new Exception(\u0026#34;种子的唯一标识不能为空。\u0026#34;); if (inputParameters == null) throw new Exception(\u0026#34;BT 客户端传入的参数不能为空。\u0026#34;); } } 5.4 响应客户端请求 上述工作完成之后，我们就需要来构建我们的响应结果了。根据 BT 协议的规定，返回的结果是一个字典类型(BDictionary) ，并且还要支持紧凑模式与非紧凑模式。\n现在我们可以通过 IBitTorrentManager 来获得所需要的 Peer 信息，这个时候只需要将这些信息按照 BT 协议来组装即可。\n来到 GetPeersInfo() 接口开始编码，首先我们编写一个方法用于构建 Peer 集合的结果，这个方法可以处理紧凑/非紧凑两种模式的 Peer 信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /// \u0026lt;summary\u0026gt; /// 将 Peer 集合的数据转换为 BT 协议规定的格式 /// \u0026lt;/summary\u0026gt; private void HandlePeersData(BDictionary resultDict, IReadOnlyList\u0026lt;Peer\u0026gt; peers, AnnounceInputParameters inputParameters) { var total = Math.Min(peers.Count, inputParameters.PeerWantCount); //var startIndex = new Random().Next(total); // 判断当前 BT 客户端是否需要紧凑模式的数据。 if (inputParameters.IsEnableCompact) { var compactResponse = new byte[total * 6]; for (int index =0; index\u0026lt;total; index++) { var peer = peers[index]; Buffer.BlockCopy(peer.ToBytes(),0,compactResponse,(total -1) *6,6); } resultDict.Add(TrackerServerConsts.PeersKey,new BString(compactResponse)); } else { var nonCompactResponse = new BList(); for (int index =0; index\u0026lt;total; index++) { var peer = peers[index]; nonCompactResponse.Add(peer.ToEncodedDictionary()); } resultDict.Add(TrackerServerConsts.PeersKey,nonCompactResponse); } } 处理完成之后，在 GetPeersInfo() 方法内部针对返回结果的字典结合 Peer 列表进行构建，构建完成之后写入到响应体当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 [HttpGet] [Route(\u0026#34;/Announce/GetPeersInfo\u0026#34;)] public async Task GetPeersInfo(GetPeersInfoInput input) { // 如果 BT 客户端没有传递 IP，则通过 Context 获得。 if (string.IsNullOrEmpty(input.Ip)) input.Ip = _httpContextAccessor.HttpContext.Connection.RemoteIpAddress.MapToIPv4().ToString(); // 本机测试用。 input.Ip = \u0026#34;127.0.0.1\u0026#34;; AnnounceInputParameters inputPara = input; var resultDict = new BDictionary(); // 如果产生了错误，则不执行其他操作，直接返回结果。 if (inputPara.Error.Count == 0) { _bitTorrentManager.UpdatePeer(input.Info_Hash,inputPara); _bitTorrentManager.ClearZombiePeers(input.Info_Hash,TimeSpan.FromMinutes(10)); var peers = _bitTorrentManager.GetPeers(input.Info_Hash); HandlePeersData(resultDict,peers,inputPara); // 构建剩余字段信息 // 客户端等待时间 resultDict.Add(TrackerServerConsts.IntervalKey,new BNumber((int)TimeSpan.FromSeconds(30).TotalSeconds)); // 最小等待间隔 resultDict.Add(TrackerServerConsts.MinIntervalKey,new BNumber((int)TimeSpan.FromSeconds(30).TotalSeconds)); // Tracker 服务器的 Id resultDict.Add(TrackerServerConsts.TrackerIdKey,new BString(\u0026#34;Tracker-DEMO\u0026#34;)); // 已完成的 Peer 数量 resultDict.Add(TrackerServerConsts.CompleteKey,new BNumber(_bitTorrentManager.GetComplete(input.Info_Hash))); // 非做种状态的 Peer 数量 resultDict.Add(TrackerServerConsts.IncompleteKey,new BNumber(_bitTorrentManager.GetInComplete(input.Info_Hash))); } else { resultDict = inputPara.Error; } // 写入响应结果。 var resultDictBytes = resultDict.EncodeAsBytes(); var response = _httpContextAccessor.HttpContext.Response; response.ContentType = \u0026#34;text/plain;\u0026#34;; response.StatusCode = 200; response.ContentLength = resultDictBytes.Length; await response.Body.WriteAsync(resultDictBytes); } 5.5 测试效果 六、源码下载 本 DEMO 已经托管到 Github 上，有需要的朋友可以自行前往以下地址进行 clone 。\nGitHub 仓库地址: https://github.com/GameBelial/BTTrackerDemo\n","date":"2019-03-08T00:39:28Z","permalink":"https://real-zony.github.io/p/develop-bt-tracker-server-with-net-core/","title":"使用 .NET Core 开发 BT Tracker 服务器"},{"content":"问题 在实际开发过程当中我们可能会针对某些类型使用动态代理技术(AOP)，注入了一些拦截器进行处理，但是一旦某个类型被动态代理了，那么就会生成一个代理类。这个时候在该类内部使用 GetType() 方法获取到的 Type 类型并不是实际类型的 Type，而是代理类的 Type。\n解决 那么我们如何在代理类当中获取到具体类型的 Type 呢？其实 Castle 给我们提供了一个工具类，叫做 ProxyUtil ，可以使用该工具类来获取到代理类所拦截的具体类型，下面的代码就是具体的使用方法。\nDEMO 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /// \u0026lt;summary\u0026gt; /// 获得实例对象的真实类型 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;待获取类型的实例对象\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;实例对象的真实类型\u0026lt;/returns\u0026gt; public static Type GetProxyClassRealType(this object instance) { Type realType; if (ProxyUtil.IsProxy(instance)) { realType = ProxyUtil.GetUnproxiedType(instance); } else { realType = instance.GetType(); } return realType; } ","date":"2019-03-07T01:12:48Z","permalink":"https://real-zony.github.io/p/how-castle-windsors-dynamic-proxy-class-gets-the-actual-type/","title":"Castle Windsor 的动态代理类如何获取实际类型"},{"content":"问题 使用 HTTP Client 请求 HTTPS 的 API 时出现 The certificate cannot be verified up to a trusted certification authority 异常，并且证书已经传入。\n下面就是问题代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Program { public static void Main(string[] args) { var url = @\u0026#34;https://xxx.xxx.xxx.xxx:xxxx/xxx-web/services/xxxx?wsdl\u0026#34;; var handler = new HttpClientHandler { ClientCertificateOptions = ClientCertificateOption.Manual, ClientCertificates = { new X509Certificate2(@\u0026#34;E:\\cert\\rootTrust.cer\u0026#34;,\u0026#34;11111111\u0026#34;), new X509Certificate2(@\u0026#34;E:\\cert\\middleTrust.cer\u0026#34;,\u0026#34;11111111\u0026#34;), new X509Certificate2(@\u0026#34;E:\\cert\\wskey.pfx\u0026#34;,\u0026#34;ws654321\u0026#34;) } }; var webRequest = new HttpClient(handler); var result = webRequest.GetStringAsync(url).GetAwaiter().GetResult(); Console.WriteLine(result); } } 原因 因为在发出 HTTPS 请求的时候，HttpClient 都会检查 SSL 证书是否合法。如果不合法的话，就会导致抛出异常信息，而对方给出的证书是自签发的测试接口的证书，所以不是一个合法的 SSL 证书。\n解决 在 HttpClientHandler 当中会有一个 ServerCertificateCustomValidationCallback 事件，该事件用于判定证书验证是否通过。我们可以挂接该事件，然后逻辑编写为直接返回 true 结果，这样就会忽略掉证书异常的情况。\n最新的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Program { public static void Main(string[] args) { var url = @\u0026#34;https://xxx.xxx.xxx.xxx:xxxx/xxx-web/services/xxxx?wsdl\u0026#34;; var handler = new HttpClientHandler { ServerCertificateCustomValidationCallback = (message, certificate2, arg3, arg4) =\u0026gt; true, ClientCertificateOptions = ClientCertificateOption.Manual, ClientCertificates = { new X509Certificate2(@\u0026#34;E:\\cert\\rootTrust.cer\u0026#34;,\u0026#34;11111111\u0026#34;), new X509Certificate2(@\u0026#34;E:\\cert\\middleTrust.cer\u0026#34;,\u0026#34;11111111\u0026#34;), new X509Certificate2(@\u0026#34;E:\\cert\\wskey.pfx\u0026#34;,\u0026#34;ws654321\u0026#34;) } }; var webRequest = new HttpClient(handler); var result = webRequest.GetStringAsync(url).GetAwaiter().GetResult(); Console.WriteLine(\u0026#34;xx\u0026#34;); } } ","date":"2019-03-06T03:21:58Z","permalink":"https://real-zony.github.io/p/dotnet-core-using-httpclient-ssl-request-error-solution/","title":".NET Core 使用 HttpClient SSL 请求出错的解决办法"},{"content":"问题： 在使用 WRK 对应用服务进行压测的时候，提示 \u0026ldquo;too many open files\u0026rdquo; 信息，导致无法启动测试。\n原因： CentOS 7.x 默认的打开文件数目限制为 1024，如果在使用其他软件出现 \u0026ldquo;too many open files\u0026rdquo; 的错误。\n解决： 只需要更改 /etc/security/limits.conf 文件里面的内容，增加如下信息即可。\n1 2 3 4 * soft nproc 80000 * hard nproc 80000 * soft nofile 80000 * hard nofile 80000 其中 * 代表所有用户，你可以指定特定的用户。\n上面的 nproc 是允许创建的子进程数目，不能过大，防止 accidental fork bombs，一般 4096 比较合适 高级一点的做法： 将配置写到 /etc/security/limits.d/nofile.conf 这种不直接写到系统 limits 文件中，当 limits 需要升级时，不会丢失配置 另外一种做法： 在系统启动过程中，执行一次 ulimit -SHn 65533, 比如可以写到 /etc/rc.local 中，或者 /etc/profile 中。\n","date":"2019-03-03T13:23:38Z","permalink":"https://real-zony.github.io/p/centos-too-many-open-files-solution/","title":"CentOS Too Many Open Files 解决"},{"content":"问题： 在自行构造 HttpClient 请求 SOAP 接口之后，返回 500 错误，并且提示 NoSOAPAction 信息。\n原因： 造成这个问题的主要原因是因为缺少了 SOAPAction 标头，所以提示该信息。\n解决： 解决问题很简单，只需要在请求的时候，为其 Header 增加一个 SOAPAction 标头，并且将其值设置为你需要调用的 SOAP 接口。\n例如：\n1 2 3 4 5 var webRequest = new HttpRequestMessage(HttpMethod.Post,@\u0026#34;https://58.247.0.18:20443/uis-web/services/TransactionOntimeService?wsdl\u0026#34;); webRequset.Headers.Add(\u0026#34;SOAPAction\u0026#34;,\u0026#34;TransactionOntimeService\u0026#34;); var webClient = new HttpClient(); var result = webClient.SendAsync(webRequest).GetAwaiter().GetResult(); ","date":"2019-03-02T09:06:22Z","permalink":"https://real-zony.github.io/p/csharp-uses-httpclient-to-call-webservice-prompts-nosoapaction/","title":"C# 使用 HttpClient 调用 WebService 提示 NoSOAPAction"},{"content":"一、背景 目前我们项目是采用的 Ocelot 作为 API 网关，并且在其基础上结合 IdentityServer4 开发了一套 API 开放平台。由于部分项目是基于 ABP 框架进行开发的，接口的平均 QPS 基本是在 2K~3K /S 左右 (E3 1231 16G)。采用 Ocelot 进行请求转发之后，前端反馈接口调用速度变慢了，也没有太过在意，以为是项目接口的问题，一直在接口上面尝试进行优化。\n极限优化接口后仍然没有显著改善，故针对 Ocelot 的性能进行压力测试，得到的结果也是让我比较惊讶。\n二、准备工作 2.1 测试项目准备 首先新建了一个解决方案，其名字为 OcelotStudy ，其下面有三个项目，分别是两个 API 项目和一个网关项目。\n网关项目编写：\n为 OcelotStudy 项目引入 Ocelot 的 NuGet 包。\n在 OcelotStudy 项目的 Program.cs 文件当中显式指定我们网关的监听端口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.Hosting; namespace OcelotStudy { public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { // 指定监听端口为 5000 webBuilder.UseStartup\u0026lt;Startup\u0026gt;() .UseKestrel(x=\u0026gt;x.ListenAnyIP(5000)); }); } } 在 OcelotStudy 项目的 Program.cs 文件当中显式指定我们网关的监听端口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.Hosting; namespace OcelotStudy { public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { // 指定监听端口为 5000 webBuilder.UseStartup\u0026lt;Startup\u0026gt;() .UseKestrel(x=\u0026gt;x.ListenAnyIP(5000)); }); } } 在 Startup.cs 类当中注入 Ocelot 的服务，并应用 Ocelot 的中间件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; using Ocelot.DependencyInjection; using Ocelot.Middleware; namespace OcelotStudy { public class Startup { public void ConfigureServices(IServiceCollection services) { // 禁用日志的控制台输出，防止由于线程同步造成的性能损失 services.AddLogging(op =\u0026gt; op.ClearProviders()); services.AddMvc(); services.AddOcelot(new ConfigurationBuilder().AddJsonFile(\u0026#34;Ocelot.json\u0026#34;).Build()); } public async void Configure(IApplicationBuilder app, IHostingEnvironment env) { await app.UseOcelot(); app.UseMvc(); } } } 在 OcelotStudy 项目下建立 Ocelot.json 文件，内容如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \u0026#34;ReRoutes\u0026#34;: [ { \u0026#34;DownstreamPathTemplate\u0026#34;: \u0026#34;/api/{everything}\u0026#34;, \u0026#34;DownstreamScheme\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;DownstreamHostAndPorts\u0026#34;: [ { \u0026#34;Host\u0026#34;: \u0026#34;API 1 服务器IP\u0026#34;, \u0026#34;Port\u0026#34;: 6000 }, { \u0026#34;Host\u0026#34;: \u0026#34;API 2 服务器IP\u0026#34;, \u0026#34;Port\u0026#34;: 7000 } ], \u0026#34;UpstreamPathTemplate\u0026#34;: \u0026#34;/{everything}\u0026#34;, \u0026#34;UpstreamHttpMethod\u0026#34;: [ \u0026#34;Get\u0026#34;, \u0026#34;Post\u0026#34; ], \u0026#34;LoadBalancerOptions\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;RoundRobin\u0026#34; } } ], \u0026#34;GlobalConfiguration\u0026#34;: { } } 测试项目的编写：\n两个测试项目的监听端口分别为 6000 与 7000 ，都建立一个 ValuesController 控制器，返回一个字符串用于输出当前请求的 API 服务器信息。\nApiService01 的文件信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 using Microsoft.AspNetCore.Mvc; namespace ApiService01.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class ValuesController : ControllerBase { // GET api/values [HttpGet] public ActionResult\u0026lt;string\u0026gt; Get() { return \u0026#34;当前请求的 API 接口是 1 号服务器。\u0026#34;; } // GET api/values/5 [HttpGet(\u0026#34;{id}\u0026#34;)] public ActionResult\u0026lt;string\u0026gt; Get(int id) { return \u0026#34;value\u0026#34;; } // POST api/values [HttpPost] public void Post([FromBody] string value) { } // PUT api/values/5 [HttpPut(\u0026#34;{id}\u0026#34;)] public void Put(int id, [FromBody] string value) { } // DELETE api/values/5 [HttpDelete(\u0026#34;{id}\u0026#34;)] public void Delete(int id) { } } } ApiService02 的文件信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 using Microsoft.AspNetCore.Mvc; namespace ApiService02.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class ValuesController : ControllerBase { // GET api/values [HttpGet] public ActionResult\u0026lt;string\u0026gt; Get() { return \u0026#34;当前请求的 API 接口是 2 号服务器。\u0026#34;; } // GET api/values/5 [HttpGet(\u0026#34;{id}\u0026#34;)] public ActionResult\u0026lt;string\u0026gt; Get(int id) { return \u0026#34;value\u0026#34;; } // POST api/values [HttpPost] public void Post([FromBody] string value) { } // PUT api/values/5 [HttpPut(\u0026#34;{id}\u0026#34;)] public void Put(int id, [FromBody] string value) { } // DELETE api/values/5 [HttpDelete(\u0026#34;{id}\u0026#34;)] public void Delete(int id) { } } } 他们两个的 Startup.cs 与 Program.cs 文件内容基本一致，区别只是监听的端口分别是 6000 和 7000 而已。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.Hosting; namespace ApiService02 { public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); webBuilder.UseKestrel(x =\u0026gt; x.ListenAnyIP(6000)); // 或者 7000 }); } } using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; namespace ApiService02 { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } // This method gets called by the runtime. Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { // 禁用日志的控制台输出，防止由于线程同步造成的性能损失 services.AddLogging(op =\u0026gt; op.ClearProviders()); services.AddMvc(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseRouting(routes =\u0026gt; { routes.MapApplication(); }); } } } 以上三个项目都采用 Release 版本进行发布。\n1 dotnet publish -c Release ApiService01 部署在单独的 E3 1231 v3 16G DDR3 服务器。\nApiService02 部署在单独的 i3-7100 16G DDR4 服务器。\nOcelotStudy 部署在单独的 E3 1231 v3 16G DDR3 服务器。\n三、开始测试 这里我使用的是 WRK 来进行压力测试，OcelotStudy 网关项目的 IP 地址为 172.31.61.41:5000 ，故使用以下命令进行测试。\n1 ./wrk -t 10 -c 10000 -d 20s --latency --timeout 3s \u0026#34;http://172.31.61.41:5000/values\u0026#34; 测试结果：\n我将 ApiService01 项目放在网关的服务器，直接调用 ApiService01 的接口，其压力测试情况。\n四、结语 最后 Ocelot 的 QPS 结果为：3461.53\n直接请求 API 接口的 QPS 结果为：38874.50\n这样的结果让我感到很意外，不知道是由于 Ocelot 实现机制的原因，还是我的使用方法不对。这样的性能测试结果数据对于 API 网关来说确实不太好看，但也希望今后 Ocelot 能够继续努力。\n如果大家对于我的测试方式有疑问的话，可以在评论区指出，我将按照你所提供的方法再次进行测试。(PS: 我也不想换啊，多希望是我测错了)\n五、原生 API、Ocelot、Kong API 性能比较 针对于评论区各位朋友所提出的建议，以及我最近针对 Ocelot 的再次测试，整理出来一份测试结果的表格。以下结果均是单节点进行部署，如果使用 LB + API 集群的话是可以有效提升吞吐量。\n使用的网关 测试时间 并发数 总请求 QPS 超时数量 平均响应 没有使用网关 1 分钟 15000 2495541 41518.07 1592 115.98 ms Kong API 1 分钟 15000 690141 11478.06 43997 860.31 ms Ocelot 1 分钟 15000 277627 4618.98 1795 1.7 s 没有使用网关 1 分钟 5000 2530107 42111.44 0 115.48 ms Kong API 1 分钟 5000 866449 14418.25 3090 383.75 ms Ocelot 1 分钟 5000 307226 5113.09 78 932.19 ms 没有使用网关 10 分钟 8000 13080964 21797.98 103 364.97 ms Kong API 10 分钟 8000 4809613 8014.7 305503 636.41 ms Ocelot 10 分钟 8000 2558431 4263.34 2137 1.84 s Ocelot 与 Kong 均部署在一台 32G 12C 3.0Ghz 的 CentOS 服务器上，API 1 与 API 2 部署在 8C 16G 3.0 Ghz 的服务器上，所有环境都是基于 Docker CE 进行部署。\n另外针对于 Kong API 不知道是我使用方式不对还是什么情况，其网络吞吐量经常波动，如下图，还请不吝赐教。\n网关服务器： API 1 与 API 2 服务器： ","date":"2019-02-19T07:27:28Z","permalink":"https://real-zony.github.io/p/performance-tests-for-ocelot-gateways/","title":"针对 Ocelot 网关的性能测试"},{"content":"1. IEnuemrable.Select() Select 方法比较简单，就是在原有序列的基础上，为每个元素建立一个新的输出形式(类型)。\n标准用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class TestClass { public string Name { get; set; } public int Age { get; set; } } void Main() { var testList = new List\u0026lt;TestClass\u0026gt; { new TestClass{Name = \u0026#34;张三\u0026#34;,Age = 18}, new TestClass{Name=\u0026#34;李四\u0026#34;,Age = 32}, new TestClass{Name=\u0026#34;王二\u0026#34;,Age = 24} }; var selectResult = testList.Select(student =\u0026gt; new { Name = student.Name, NewAge = student.Age + 20 }); foreach (var student in selectResult) { Console.WriteLine($\u0026#34;姓名：{student.Name},新的年龄：{student.NewAge}\u0026#34;); } } 输出结果：\n1 2 3 姓名：张三,新的年龄：38 姓名：李四,新的年龄：52 姓名：王二,新的年龄：44 这样 newResult 的结果就是我们所投射出来新序列，同时 IEnumerbale\u0026lt;T\u0026gt;.Select() 也拥有 延迟执行 的特性，只会在我们需要用到的时候才会进行计算。\n2. IEnumerable.SelectMany() SelectMany() 方法的作用则与 Select() 方法不同，SelectMany() 是用于将每个元素的子集合合并为一个新的集合。\n标准用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void Main() { var demoList = new List\u0026lt;Demo\u0026gt;() { new Demo(){Names = new List\u0026lt;string\u0026gt;{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;}}, new Demo(){Names = new List\u0026lt;string\u0026gt;{\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;,\u0026#34;g\u0026#34;,\u0026#34;h\u0026#34;}}, new Demo(){Names = new List\u0026lt;string\u0026gt;{\u0026#34;i\u0026#34;,\u0026#34;j\u0026#34;,\u0026#34;k\u0026#34;,\u0026#34;l\u0026#34;}}, new Demo(){Names = new List\u0026lt;string\u0026gt;{\u0026#34;m\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;p\u0026#34;}}, }; var selectResult = demoList.Select(item=\u0026gt;item.Names); Console.WriteLine(\u0026#34;Select 操作的结果...\u0026#34;); foreach(var selectItem in selectResult) { foreach(var value in selectItem) { Console.WriteLine($\u0026#34;Value：{value}\u0026#34;); } } Console.WriteLine(\u0026#34;================================\u0026#34;); Console.WriteLine(\u0026#34;SelectMany 操作的结果...\u0026#34;); var selectManyResult = demoList.SelectMany(item=\u0026gt;item.Names); foreach(var selectManyItem in selectManyResult) { Console.WriteLine($\u0026#34;Value：{selectManyItem}\u0026#34;); } } public class Demo { public List\u0026lt;string\u0026gt; Names { get; set; } } 在本例当中这两个方法分别输出的是 IEnumerable\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; 和 IEnumerable\u0026lt;string\u0026gt; ，这里就可以看出来 SelectionMany() 方法将子集合扁平化输出成一个结果集。\n输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Select 操作的结果... Value：a Value：b Value：c Value：d Value：e Value：f Value：g Value：h Value：i Value：j Value：k Value：l Value：m Value：n Value：o Value：p ================================ SelectMany 操作的结果... Value：a Value：b Value：c Value：d Value：e Value：f Value：g Value：h Value：i Value：j Value：k Value：l Value：m Value：n Value：o Value：p IEnumerable\u0026lt;T\u0026gt;.SelectMany() 还拥有另外一个重载方法，这个新的重载方法多了一个 resultSelector 参数。在这个委托当中，可以传入 TSource 和 TCollection 让我们将主表的数据与从表进行合并。\n标准用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void Main() { Store[] stores = new Store[] { new Store() { Name = \u0026#34;App Store\u0026#34;, Products = new string[] {\u0026#34;iPhone 8\u0026#34;, \u0026#34;iPhone 8s\u0026#34;, \u0026#34;iPhone X\u0026#34;} }, new Store() { Name = \u0026#34;Google Store\u0026#34;, Products = new string[] {\u0026#34;Pixel\u0026#34;, \u0026#34;Pixel 2\u0026#34;} } }; var result = stores.SelectMany(store =\u0026gt; store.Products, (store, product) =\u0026gt; new { StoreName = store.Name, ProductName = product }); foreach(var item in result) { Console.WriteLine($\u0026#34;商店名称：{item.StoreName}，产品名称：{item.ProductName}\u0026#34;); } } class Store { public string Name { get; set; } public string[] Products { get; set; } } 输出结果：\n1 2 3 4 5 商店名称：App Store，产品名称：iPhone 8 商店名称：App Store，产品名称：iPhone 8s 商店名称：App Store，产品名称：iPhone X 商店名称：Google Store，产品名称：Pixel 商店名称：Google Store，产品名称：Pixel 2 3. IEnuemrable.Where() IEnumerable\u0026lt;T\u0026gt;.Where(Func\u0026lt;T,bool\u0026gt;) 主要用于过滤序列当中需要的元素，与 Select() 一样也是拥有 延迟执行 的特性。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 void Main() { var integers = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; var result = integers.Where(x =\u0026gt; x \u0026gt;= 5); foreach (var @int in result) { Console.WriteLine($\u0026#34;整形数据：{@int}\u0026#34;); } } 输出结果：\n1 2 3 4 5 整形数据：5 整形数据：6 整形数据：7 整形数据：8 整形数据：9 4. IEnuemrable.OrderBy() 与 IEnuemrable.OrderByDescending() 上述两个方法主要用于针对序列进行排序操作，OrderBy() 方法是升序排列，而 OrderByDescending() 则是降序排列。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void Main() { var integers = new[] { 3, 1, 2, 8, 5, 6, 7, 4, 9 }; var orderByResult = integers.OrderBy(i=\u0026gt;i); Console.WriteLine(\u0026#34;升序排列结果.\u0026#34;); foreach (var @int in orderByResult) { Console.WriteLine($\u0026#34;整形数据：{@int}\u0026#34;); } Console.WriteLine(\u0026#34;降序排列结果.\u0026#34;); var orderByDescResult = integers.OrderByDescending(i =\u0026gt; i); foreach (var @int in orderByDescResult) { Console.WriteLine($\u0026#34;整形数据：{@int}\u0026#34;); } } 输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 升序排列结果. 整形数据：1 整形数据：2 整形数据：3 整形数据：4 整形数据：5 整形数据：6 整形数据：7 整形数据：8 整形数据：9 降序排列结果. 整形数据：9 整形数据：8 整形数据：7 整形数据：6 整形数据：5 整形数据：4 整形数据：3 整形数据：2 整形数据：1 除了上述的基本排序以外，有的时候我们可能会有几个条件一起进行排序操作，例如先按照年龄排序，之后再按照成绩排序。这个时候就可以使用到 IEnumerable\u0026lt;T\u0026gt;.ThenBy() 和 IEnumerable\u0026lt;T\u0026gt;.ThenByDescending() 来继续进行排序。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Student { public string Name { get; set; } public int Age { get; set; } public int Score { get; set; } } void Main() { // 初始化数据 var students = new List\u0026lt;Student\u0026gt; { new Student{Name=\u0026#34;张三\u0026#34;,Age=14,Score=120}, new Student{Name=\u0026#34;李四\u0026#34;,Age=17,Score=80}, new Student{Name=\u0026#34;王二\u0026#34;,Age=11,Score=170}, new Student{Name =\u0026#34;孙五\u0026#34;,Age=21,Score=145} }; // 首先按照成绩降序排序，然后按照年龄升序排序 Console.WriteLine(\u0026#34;使用 Then XX 方法进行排序。\u0026#34;); var result = students.OrderByDescending(student=\u0026gt;student.Score).ThenBy(student=\u0026gt;student.Age); // 输出排序结果 Output(result); // 如果不使用 ThenXX 进行排序，而直接使用 OrderXX 进行多个排序条件排序结果 Console.WriteLine(\u0026#34;没有使用 Then XX 方法进行排序。\u0026#34;); var newResult = students.OrderByDescending(student =\u0026gt; student.Score).OrderBy(student =\u0026gt; student.Age); Output(newResult); void Output(IEnumerable\u0026lt;Student\u0026gt; outputStudents) { foreach (var student in outputStudents) { Console.WriteLine($\u0026#34;学生名称：{student.Name},学生年龄：{student.Age},学生成绩：{student.Score}\u0026#34;); } } } 输出结果：\n1 2 3 4 5 6 7 8 9 10 使用 Then XX 方法进行排序。 学生名称：王二,学生年龄：11,学生成绩：170 学生名称：孙五,学生年龄：21,学生成绩：145 学生名称：张三,学生年龄：14,学生成绩：120 学生名称：李四,学生年龄：17,学生成绩：80 没有使用 Then XX 方法进行排序。 学生名称：王二,学生年龄：11,学生成绩：170 学生名称：张三,学生年龄：14,学生成绩：120 学生名称：李四,学生年龄：17,学生成绩：80 学生名称：孙五,学生年龄：21,学生成绩：145 可以看到如果没有使用 ThenBy() 方法排序的结果，第一个条件根本没有起作用。所以在使用 LINQ 对序列进行排序的时候应该注意这一点，否则得到的结果可能与预期的不一样。\n5. IEnuemrable.GroupBy() IEnumerable\u0026lt;T\u0026gt;.GroupBy() 方法主要用于将序列按照指定的列进行分组，这样我们就可以很方便对这些结果进行处理。\nIEnumerable\u0026lt;T\u0026gt;.GroupBy() 方法一样是拥有八种不同参数的重载，但按照工作方式来说只有四类，只是每一类都会有一个支持 comparer 比较器的重载。\nGroupBy() 方法拥有 延迟执行 特性。\n下面的例子列举了不同重载的使用方法：\n方法 1\n1 2 3 public static IEnumerable\u0026lt;IGrouping\u0026lt;TKey, TSource\u0026gt;\u0026gt; GroupBy\u0026lt;TSource, TKey\u0026gt;( this IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, TKey\u0026gt; keySelector); keySelector 指定的是分组所需要的的列/属性，最后的结果会是一个分组结果的序列。这个序列的值是使用 TKey 和 TSource 组成的分组结果，TKey 指代的是用作分组的列/属性，而 TSource 也是一个序列，存储的是这个分组下的结果。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Student { public string Name { get; set; } public bool Graduation { get; set; } public int Age { get; set; } public int Score { get; set; } public string City { get; set; } public override string ToString() { return $\u0026#34;姓名：{Name},年龄：{Age},分数：{Score},是否毕业：{Graduation},城市：{City}\u0026#34;; } } class Program { static void Main(string[] args) { var students = new List\u0026lt;Student\u0026gt; { new Student{Name = \u0026#34;张三\u0026#34;,Age = 15,Score = 94,Graduation = true,City = \u0026#34;北京\u0026#34;}, new Student{Name = \u0026#34;李四\u0026#34;,Age = 17,Score = 47,Graduation = false,City = \u0026#34;北京\u0026#34;}, new Student{Name = \u0026#34;王二\u0026#34;,Age = 19,Score = 77,Graduation = false,City = \u0026#34;广州\u0026#34;}, new Student{Name = \u0026#34;孙五\u0026#34;,Age = 14,Score = 14,Graduation = false,City = \u0026#34;上海\u0026#34;} }; var groupByResult = students.GroupBy(x =\u0026gt; x.City); foreach (var item in groupByResult) { Console.WriteLine($\u0026#34;分组城市：{item.Key}\u0026#34;); foreach (var student in item) { Console.WriteLine(student.ToString()); } } } } 输出结果：\n1 2 3 4 5 6 7 分组城市：北京 姓名：张三,年龄：15,分数：94,是否毕业：True,城市：北京 姓名：李四,年龄：17,分数：47,是否毕业：False,城市：北京 分组城市：广州 姓名：王二,年龄：19,分数：77,是否毕业：False,城市：广州 分组城市：上海 姓名：孙五,年龄：14,分数：14,是否毕业：False,城市：上海 方法 2\n1 2 3 4 public static IEnumerable\u0026lt;IGrouping\u0026lt;TKey, TElement\u0026gt;\u0026gt; GroupBy\u0026lt;TSource, TKey, TElement\u0026gt;( this IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, TKey\u0026gt; keySelector, Func\u0026lt;TSource, TElement\u0026gt; elementSelector); 其第一个参数的意思与之前一样，用于指定分组条件。第二个 elementSelector 参数则是与 Select() 方法类似，可以指定输出的分组结果类型。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Student { public string Name { get; set; } public bool Graduation { get; set; } public int Age { get; set; } public int Score { get; set; } public string City { get; set; } public override string ToString() { return $\u0026#34;姓名：{Name},年龄：{Age},分数：{Score},是否毕业：{Graduation},城市：{City}\u0026#34;; } } class Program { static void Main(string[] args) { var students = new List\u0026lt;Student\u0026gt; { new Student{Name = \u0026#34;张三\u0026#34;,Age = 15,Score = 94,Graduation = true,City = \u0026#34;北京\u0026#34;}, new Student{Name = \u0026#34;李四\u0026#34;,Age = 17,Score = 47,Graduation = false,City = \u0026#34;北京\u0026#34;}, new Student{Name = \u0026#34;王二\u0026#34;,Age = 19,Score = 77,Graduation = false,City = \u0026#34;广州\u0026#34;}, new Student{Name = \u0026#34;孙五\u0026#34;,Age = 14,Score = 14,Graduation = false,City = \u0026#34;上海\u0026#34;} }; var groupByResult = students.GroupBy(x =\u0026gt; x.City,student=\u0026gt;new{student.Name,student.City}); foreach (var item in groupByResult) { Console.WriteLine($\u0026#34;分组城市：{item.Key}\u0026#34;); foreach (var student in item) { Console.WriteLine($\u0026#34;姓名：{student.Name},城市：{student.City}\u0026#34;); } } } } 输出结果：\n标准用法：\n1 2 3 4 5 6 7 分组城市：北京 姓名：张三,城市：北京 姓名：李四,城市：北京 分组城市：广州 姓名：王二,城市：广州 分组城市：上海 姓名：孙五,城市：上海 方法 3\n1 2 3 4 public static IEnumerable\u0026lt;TResult\u0026gt; GroupBy\u0026lt;TSource, TKey, TResult\u0026gt;( this IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, TKey\u0026gt; keySelector, Func\u0026lt;TKey, IEnumerable\u0026lt;TSource\u0026gt;, TResult\u0026gt; resultSelector); 本方法重载与之前的方法不一样，没有了 elementSelector 参数，变成了 resultSelector 参数，并且其返回值也由 IEnumerable\u0026lt;IGrouping\u0026lt;TKey, TSource\u0026gt;\u0026gt; 变成了 IEnumerable\u0026lt;YResult\u0026gt; 。\n在这个方法当中，我们只需要通过 resultSelector 委托即可指定需要输出的数据类型，这里该委托的 TKey 参数是分组的列/属性，而 IEnumerable\u0026lt;TSource\u0026gt; 则是每个分组结果的关联序列。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Student { public string Name { get; set; } public bool Graduation { get; set; } public int Age { get; set; } public int Score { get; set; } public string City { get; set; } public override string ToString() { return $\u0026#34;姓名：{Name},年龄：{Age},分数：{Score},是否毕业：{Graduation},城市：{City}\u0026#34;; } } class Program { static void Main(string[] args) { var students = new List\u0026lt;Student\u0026gt; { new Student{Name = \u0026#34;张三\u0026#34;,Age = 15,Score = 94,Graduation = true,City = \u0026#34;北京\u0026#34;}, new Student{Name = \u0026#34;李四\u0026#34;,Age = 17,Score = 47,Graduation = false,City = \u0026#34;北京\u0026#34;}, new Student{Name = \u0026#34;王二\u0026#34;,Age = 19,Score = 77,Graduation = false,City = \u0026#34;广州\u0026#34;}, new Student{Name = \u0026#34;孙五\u0026#34;,Age = 14,Score = 14,Graduation = false,City = \u0026#34;上海\u0026#34;} }; var groupByResult = students.GroupBy(x =\u0026gt; x.City, (key, enumerable) =\u0026gt; { return new { City = key, Avg = enumerable.Average(x =\u0026gt; x.Score), Max = enumerable.Max(x =\u0026gt; x.Score) }; }); foreach (var student in groupByResult) { Console.WriteLine($\u0026#34;城市：{student.City},平均分：{student.Avg},最高分：{student.Max}\u0026#34;); } } } 输出结果：\n1 2 3 城市：北京,平均分：70.5,最高分：94 城市：广州,平均分：77,最高分：77 城市：上海,平均分：14,最高分：14 方法 4\n1 2 3 4 5 public static IEnumerable\u0026lt;TResult\u0026gt; GroupBy\u0026lt;TSource, TKey, TElement, TResult\u0026gt;( this IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, TKey\u0026gt; keySelector, Func\u0026lt;TSource, TElement\u0026gt; elementSelector, Func\u0026lt;TKey, IEnumerable\u0026lt;TElement\u0026gt;, TResult\u0026gt; resultSelector); 最后一个方法与之前的方法一样，不过多了 elementSelector，与第二个方法一样，用于指定要选择的属性字段，排除其他字段。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class Student { public string Name { get; set; } public bool Graduation { get; set; } public int Age { get; set; } public int Score { get; set; } public string City { get; set; } public override string ToString() { return $\u0026#34;姓名：{Name},年龄：{Age},分数：{Score},是否毕业：{Graduation},城市：{City}\u0026#34;; } } class Program { static void Main(string[] args) { var students = new List\u0026lt;Student\u0026gt; { new Student{Name = \u0026#34;张三\u0026#34;,Age = 15,Score = 94,Graduation = true,City = \u0026#34;北京\u0026#34;}, new Student{Name = \u0026#34;李四\u0026#34;,Age = 17,Score = 47,Graduation = false,City = \u0026#34;北京\u0026#34;}, new Student{Name = \u0026#34;王二\u0026#34;,Age = 19,Score = 77,Graduation = false,City = \u0026#34;广州\u0026#34;}, new Student{Name = \u0026#34;孙五\u0026#34;,Age = 14,Score = 14,Graduation = false,City = \u0026#34;上海\u0026#34;} }; var groupByResult = students.GroupBy(x =\u0026gt; x.City, x=\u0026gt;new{x.Name,x.City,x.Age,x.Score},(key, enumerable) =\u0026gt; { return new { City = key, Avg = enumerable.Average(x =\u0026gt; x.Score), Max = enumerable.Max(x =\u0026gt; x.Score), AvgAge = enumerable.Average(x=\u0026gt;x.Age) }; }); foreach (var student in groupByResult) { Console.WriteLine($\u0026#34;城市：{student.City},平均分：{student.Avg},最高分：{student.Max},平均年龄：{student.AvgAge}\u0026#34;); } } } 输出结果：\n1 2 3 城市：北京,平均分：70.5,最高分：94,平均年龄：16 城市：广州,平均分：77,最高分：77,平均年龄：19 城市：上海,平均分：14,最高分：14,平均年龄：14 6. IEnuemrable.Join() IEnumerable\u0026lt;T\u0026gt;.Join() 方法一般用来连接两个不同的表进行关联查询，其方法定义大概如下。\n1 2 3 4 5 6 public static IEnumerable\u0026lt;TResult\u0026gt; Join\u0026lt;TOuter, TInner, TKey, TResult\u0026gt;( this IEnumerable\u0026lt;TOuter\u0026gt; outer, IEnumerable\u0026lt;TInner\u0026gt; inner, Func\u0026lt;TOuter, TKey\u0026gt; outerKeySelector, Func\u0026lt;TInner, TKey\u0026gt; innerKeySelector, Func\u0026lt;TOuter, TInner, TResult\u0026gt; resultSelector); 假设我们拥有两张表，分别是员工表与联系方式表，都是通过一个 Id 相互关联。如果我们需要找到某个员工的联系方式，那么员工是主表则为 inner，而联系方式是从表，则为 outer 。另外两个 Selector 分别用于指定各自的关联属性。\nIEnumerable\u0026lt;T\u0026gt;.Join() 拥有 延迟执行 的特性，并且是内连查询。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Person { public int Id { get; set; } public string Name { get; set; } } public class ContactInformation { public int PersonId { get; set; } public string PhoneNumber { get; set; } public string Address { get; set; } } class Program { static void Main(string[] args) { // 初始化员工信息 var persons = new[] {new Person {Id = 1, Name = \u0026#34;张三\u0026#34;}, new Person {Id = 2, Name = \u0026#34;李四\u0026#34;}, new Person {Id = 3, Name = \u0026#34;王二\u0026#34;}}; // 初始化员工的联系方式 var contactInfos = new[] { new ContactInformation {PersonId = 1, Address = \u0026#34;上海\u0026#34;, PhoneNumber = \u0026#34;001-00001\u0026#34;}, new ContactInformation {PersonId = 2, Address = \u0026#34;北京\u0026#34;, PhoneNumber = \u0026#34;002-00002\u0026#34;}, new ContactInformation {PersonId = 3, Address = \u0026#34;广州\u0026#34;, PhoneNumber = \u0026#34;003-00003\u0026#34;}, new ContactInformation {PersonId = 1, Address = \u0026#34;深圳\u0026#34;, PhoneNumber = \u0026#34;004-00004\u0026#34;} }; var joinResult = contactInfos.Join(persons, contactInfo =\u0026gt; contactInfo.PersonId, person =\u0026gt; person.Id, (information, person) =\u0026gt; new { Name = person.Name, PhoneNumber = information.PhoneNumber, Address = information.Address }); foreach (var item in joinResult) { Console.WriteLine($\u0026#34;姓名：{item.Name},电话：{item.PhoneNumber},地址：{item.Address}\u0026#34;); } } } 输出结果：\n1 2 3 4 姓名：张三,电话：001-00001,地址：上海 姓名：李四,电话：002-00002,地址：北京 姓名：王二,电话：003-00003,地址：广州 姓名：张三,电话：004-00004,地址：深圳 7. IEnuemrable.GroupJoin() 以上一个 IEnumerable\u0026lt;T\u0026gt;.Join() 的方法结果为例，可以看到某个员工的联系方式数据有两笔甚至以上的时候就会拥有重复数据，这个时候就需要使用到 GroupJoin() 来进行处理。\n1 2 3 4 5 6 public static IEnumerable\u0026lt;TResult\u0026gt; GroupJoin\u0026lt;TOuter, TInner, TKey, TResult\u0026gt;( this IEnumerable\u0026lt;TOuter\u0026gt; outer, IEnumerable\u0026lt;TInner\u0026gt; inner, Func\u0026lt;TOuter, TKey\u0026gt; outerKeySelector, Func\u0026lt;TInner, TKey\u0026gt; innerKeySelector, Func\u0026lt;TOuter, IEnumerable\u0026lt;TInner\u0026gt;, TResult\u0026gt; resultSelector); GroupJoin() 方法与 Join() 类似，都是根据 outer 的关联字段与 inner 的关联字段相等的数据进行查询，并支持进行汇总操作。\nGroupJoin() 方法也具有 延迟执行 的特性，并且通过 SelectMany() 方法与 DefaultIfEmpty() 方法可以实现 Left Join 的查询效果。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Person { public int Id { get; set; } public string Name { get; set; } } public class ContactInformation { public int PersonId { get; set; } public string PhoneNumber { get; set; } public string Address { get; set; } } class Program { static void Main(string[] args) { // 初始化员工信息 var persons = new[] {new Person {Id = 1, Name = \u0026#34;张三\u0026#34;}, new Person {Id = 2, Name = \u0026#34;李四\u0026#34;}, new Person {Id = 3, Name = \u0026#34;王二\u0026#34;}}; // 初始化员工的联系方式 var contactInfos = new[] { new ContactInformation {PersonId = 1, Address = \u0026#34;上海\u0026#34;, PhoneNumber = \u0026#34;001-00001\u0026#34;}, new ContactInformation {PersonId = 2, Address = \u0026#34;北京\u0026#34;, PhoneNumber = \u0026#34;002-00002\u0026#34;}, new ContactInformation {PersonId = 3, Address = \u0026#34;广州\u0026#34;, PhoneNumber = \u0026#34;003-00003\u0026#34;}, new ContactInformation {PersonId = 1, Address = \u0026#34;深圳\u0026#34;, PhoneNumber = \u0026#34;004-00004\u0026#34;} }; var groupJoinResult = persons.GroupJoin(contactInfos, person =\u0026gt; person.Id, contactInfo =\u0026gt; contactInfo.PersonId, (person, infos) =\u0026gt; new { Name = person.Name, Phones = string.Join(\u0026#39;,\u0026#39;,infos.Select(x=\u0026gt;x.PhoneNumber)) }); foreach (var item in groupJoinResult) { Console.WriteLine($\u0026#34;姓名：{item.Name},电话：{item.Phones}\u0026#34;); } } } 输出结果：\n1 2 3 姓名：张三,电话：001-00001,004-00004 姓名：李四,电话：002-00002 姓名：王二,电话：003-00003 扩展写法，使用 SelectMany() 与 DefaultIfEmpty() 实现左连接查询。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class Person { public int Id { get; set; } public string Name { get; set; } } public class ContactInformation { public int PersonId { get; set; } public string PhoneNumber { get; set; } public string Address { get; set; } } class Program { static void Main(string[] args) { // 初始化员工信息 var persons = new[] {new Person {Id = 1, Name = \u0026#34;张三\u0026#34;}, new Person {Id = 2, Name = \u0026#34;李四\u0026#34;}, new Person {Id = 3, Name = \u0026#34;王二\u0026#34;}}; // 初始化员工的联系方式 var contactInfos = new[] { new ContactInformation {PersonId = 1, Address = \u0026#34;上海\u0026#34;, PhoneNumber = \u0026#34;001-00001\u0026#34;}, new ContactInformation {PersonId = 2, Address = \u0026#34;北京\u0026#34;, PhoneNumber = \u0026#34;002-00002\u0026#34;}, // ContactInformation {PersonId = 3, Address = \u0026#34;广州\u0026#34;, PhoneNumber = \u0026#34;003-00003\u0026#34;}, new ContactInformation {PersonId = 1, Address = \u0026#34;深圳\u0026#34;, PhoneNumber = \u0026#34;004-00004\u0026#34;} }; var groupJoinResult = persons.GroupJoin(contactInfos, person =\u0026gt; person.Id, contactInfo =\u0026gt; contactInfo.PersonId, (person, infos) =\u0026gt; new { Name = person.Name, ContactInfos = infos }).SelectMany(x=\u0026gt;x.ContactInfos.DefaultIfEmpty(), (_, __) =\u0026gt; new { PersonName = _.Name, PhoneNumber = __?.PhoneNumber ?? null }); foreach (var item in groupJoinResult) { Console.WriteLine($\u0026#34;姓名：{item.PersonName},电话：{item.PhoneNumber}\u0026#34;); } } } 输出结果：\n1 2 3 4 姓名：张三,电话：001-00001 姓名：张三,电话：004-00004 姓名：李四,电话：002-00002 姓名：王二,电话： 8. IEnuemrable.Skip() IEnumerable\u0026lt;T\u0026gt;.Skip(int N) 方法的主要作用就是从序列首部跳过序列中 N 个元素，然后返回其结果，这个方法还有两个衍生的方法。\n第一个是 IEnumerable\u0026lt;T\u0026gt;.SkipLast(int N) 方法，与 Skip(int N) 方法相反，它会从序列的尾部跳过 N 个元素再返回结果。\n第二个则是 IEnumerbale\u0026lt;T\u0026gt;.SkipWhile(Func\u0026lt;T,bool\u0026gt; predicate) ，它可以传入一个过滤条件，当序列当中遇到第一个不满足条件的元素时，就会返回该元素及其后续的所有元素，而略过之前符合条件的元素。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Program { static void Main() { void OutputResult(IEnumerable\u0026lt;int\u0026gt; ienumerable) { foreach (var item in ienumerable) { Console.WriteLine($\u0026#34;{item}\u0026#34;); } } var integers = new List\u0026lt;int\u0026gt; {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // Skip() 方法演示。 Console.WriteLine(\u0026#34;Skip() 方法演示：\u0026#34;); var skipResult = integers.Skip(5); OutputResult(skipResult); // SkipLast() 方法演示。 Console.WriteLine(\u0026#34;SkipLast() 方法演示：\u0026#34;); var skipLastResult = integers.SkipLast(5); OutputResult(skipLastResult); // SkipWhile() 方法演示。 Console.WriteLine(\u0026#34;SkipWhile() 方法演示：\u0026#34;); var skipWhileResult = integers.SkipWhile(@int =\u0026gt; @int != 3); OutputResult(skipWhileResult); } } 输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Skip() 方法演示： 6 7 8 9 10 SkipLast() 方法演示： 1 2 3 4 5 SkipWhile() 方法演示： 3 4 5 6 7 8 9 10 9. IEnuemrable.Take() IEnumerable\u0026lt;T\u0026gt;.Take(int N) 方法的作用是从序列首部选取 N 个元素返回结果。\n它也拥有两个衍生的方法，第一个是 IEnumerable\u0026lt;T\u0026gt;.TakeLast(int N) 方法，与 Skip(int N) 方法相同。这个方法主要是从序列的尾部选取 N 个元素组成一个新的序列并返回其结果。\n第二个方法也是相似，叫做 IEnumerable\u0026lt;T\u0026gt;.TakeWhile(Func\u0026lt;T,bool\u0026gt;) ，与 IEnumerable\u0026lt;T\u0026gt;.Skip(Func\u0026lt;T,bool\u0026gt;) 方法相反，本方法是会从序列首部开始获取元素，直到条件满足时就会停止获取，然后将这些结果返回成为一个新的序列。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Program { static void Main() { void OutputResult(IEnumerable\u0026lt;int\u0026gt; ienumerable) { foreach (var item in ienumerable) { Console.WriteLine($\u0026#34;{item}\u0026#34;); } } var integers = new List\u0026lt;int\u0026gt; {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // Take() 方法演示。 Console.WriteLine(\u0026#34;Take() 方法演示：\u0026#34;); var skipResult = integers.Take(5); OutputResult(skipResult); // TakeLast() 方法演示。 Console.WriteLine(\u0026#34;TakeLast() 方法演示：\u0026#34;); var skipLastResult = integers.Take(3); OutputResult(skipLastResult); // TakeWhile() 方法演示。 Console.WriteLine(\u0026#34;TakeWhile() 方法演示：\u0026#34;); var skipWhileResult = integers.TakeWhile(@int =\u0026gt; @int != 3); OutputResult(skipWhileResult); } } 输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 Take() 方法演示： 1 2 3 4 5 TakeLast() 方法演示： 1 2 3 TakeWhile() 方法演示： 1 2 10. IEnuemrable.Aggregate() IEnumerable\u0026lt;T\u0026gt;.Aggregate() 方法的主要作用是帮助开发人员对一个序列的资料进行汇总处理，即会执行 N 次，每次会将之前的汇总结果与当前元素的值传入到一个 Func\u0026lt;TSource, TSource, TSource\u0026gt; 委托当中，其返回值就会作为新的汇总结果传递给下一个元素。\nIEnumerable\u0026lt;T\u0026gt;.Aggregate() 共有 3 个重载方法，其运行机制与上述说明一致，只是在于初始化操作和返回值的时候不太一致。\n1 2 3 public static TSource Aggregate\u0026lt;TSource\u0026gt;( this IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, TSource, TSource\u0026gt; func); 其中 func 参数是每次执行汇总操作时的逻辑方法，第一个参数则是之前的汇总结果，第二个参数即是当前元素的值，最后一个返回值则是汇总完成的结果，将会作为下一次汇总操作时的传入参数。(即第一个参数的值)\n1 2 3 4 public static TAccumulate Aggregate\u0026lt;TSource, TAccumulate\u0026gt;( this IEnumerable\u0026lt;TSource\u0026gt; source, TAccumulate seed, Func\u0026lt;TAccumulate, TSource, TAccumulate\u0026gt; func); 其中 seed 是汇总结果的初始值，这个值将会在第一次计算汇总结果的时候用到。\n1 2 3 4 5 public static TResult Aggregate\u0026lt;TSource, TAccumulate, TResult\u0026gt;( this IEnumerable\u0026lt;TSource\u0026gt; source, TAccumulate seed, Func\u0026lt;TAccumulate, TSource, TAccumulate\u0026gt; func, Func\u0026lt;TAccumulate, TResult\u0026gt; resultSelector); 本方法与上一个方法类似，不同的是有一个 resultSelector 委托可以方便我们将数据重新投射到不同的类型当中去。\n标准用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Program { void OutputResult(IEnumerable\u0026lt;int\u0026gt; ienumerable) { foreach (var item in ienumerable) { Console.WriteLine($\u0026#34;{item}\u0026#34;); } } static void Main(string[] args) { var integers = new[] {3, 2, 1, 7, 10, 6, 4, 8, 9, 5}; // IEnumerable\u0026lt;T\u0026gt;.Sum(x=\u0026gt;x) 效果，计算整个序列元素之和。 var sumResult = integers.Aggregate((totalCount, nextItem) =\u0026gt; totalCount + nextItem); Console.WriteLine($\u0026#34;序列求和结果：{sumResult}\u0026#34;); // IEnumerable\u0026lt;T\u0026gt;.Min(x=\u0026gt;x) 效果，计算整个序列当中的最小元素。 var minResult = integers.Aggregate((min, next) =\u0026gt; min \u0026gt; next ? next : min); Console.WriteLine($\u0026#34;序列当中的最小值：{minResult}\u0026#34;); // IEnumerable\u0026lt;T\u0026gt;.Max(x=\u0026gt;x) 效果，计算整个序列当中最大的元素。 var maxResult = integers.Aggregate((max, next) =\u0026gt; max \u0026lt; next ? next : max); Console.WriteLine($\u0026#34;序列当中的最大值：{maxResult}\u0026#34;); // IEnumerable\u0026lt;T\u0026gt;.Count() 效果，计算整个序列当中的元素数量。 var countResult = integers.Aggregate(0,(count, next) =\u0026gt; ++count); Console.WriteLine($\u0026#34;序列当中的元素数量：{countResult}\u0026#34;); // IEnumerable\u0026lt;T\u0026gt;.Average(x=\u0026gt;) 效果，计算整个序列当中的平均数。 int enumerableCount = 0; var averageResult = integers.Aggregate(0, (total, next) =\u0026gt; { total += next; enumerableCount++; return total; },total=\u0026gt;new { averageValue = total / enumerableCount }); Console.WriteLine($\u0026#34;序列的平均值：{averageResult.averageValue}\u0026#34;); } } 输出结果：\n1 2 3 4 5 序列求和结果：55 序列当中的最小值：1 序列当中的最大值：10 序列当中的元素数量：10 序列的平均值：5 ","date":"2019-02-18T08:58:29Z","permalink":"https://real-zony.github.io/p/general-usage-of-linq-in-csharp-lambda-method/","title":"C# 当中 LINQ 的常规用法 (Lambda 方式)"},{"content":"一、基于事件的异步模式 基于事件的异步模式 (event-based asynchronous pattern) 提供了简单的方式，让类型提供多线程的能力而不需要显式启动线程。\n协作取消模型。 工作线程完成时安全更新 UI 的能力。 转发异常到完成事件。 EAP 仅是一个模式，需要开发人员自己实现。\nEAP 一般会提供一组成员，在其内部管理工作线程，例如 WebClient 类型就使用的 EAP 模式进行设计。\n1 2 3 4 5 6 7 8 9 10 11 // 下载数据的同步版本。 public byte[] DownloadData (Uri address); // 下载数据的异步版本。 public void DownloadDataAsync (Uri address); // 下载数据的异步版本，支持传入 token 标识任务。 public void DownloadDataAsync (Uri address, object userToken); // 完成时候的事件，当任务取消，出现异常或者更新 UI 操作都可以才该事件内部进行操作。 public event DownloadDataCompletedEventHandler DownloadDataCompleted; public void CancelAsync (object userState); // 取消一个操作 public bool IsBusy { get; } // 指示是否仍在运行 通过 Task 可以很方便的实现 EAP 模式类似的功能。\n二、BackgroundWorker 1 BackgroundWorker 是一个通用的 EAP 实现，提供了下列功能。\n协作取消模型。 工作线程完成时安全更新 UI 的能力。 转发异常到完成事件。 报告工作进度的协议。 BackgroundWorker 使用线程池来创建线程，所以不应该在 BackgroundWorker 的线程上调用 Abort() 方法。\n2.1 使用方法 实例化 BackgroundWorker 对象，并且挂接 DoWork 事件。\n调用 RunWorkerAsync() 可以传递一个 object 参数，以上则是 BackgroundWorker 的最简使用方法。\n可以为 BackgroundWorker 对象挂接 RunWorkerCompleted 事件，在该事件内部可以对工作线程执行后的异常与结果进行检查，并且可以直接在该事件内部安全地更新 UI 组件。\n如果需要支持取消功能，则需要将 WorkerSupportsCancellation 属性置为 true。这样在 DoWork() 事件当中就可通过检查对象的 CancellationPending 属性来确定是否被取消，如果是则将 Cancel 置为 true 并结束工作事件。\n调用 CancelAsync 来请求取消。\n开发人员不一定需要在 CancellationPending 为 true 时才取消任务，随时可以通过将 Cancel 置为 true 来终止任务。\n如果需要添加工作进度报告，则需要将 WorkerReportsProgress 属性置为 true，并在 DoWork 事件中周期性地调用 ReportProcess() 方法来报告工作进度。同时挂接 ProgressChanged 事件，在其内部可以安全地更新 UI 组件，例如设置进度条 Value 值。\n下列代码即是上述功能的完整实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Program { static void Main() { var backgroundTest = new BackgroundWorkTest(); backgroundTest.Run(); Console.ReadLine(); } } public class BackgroundWorkTest { private readonly BackgroundWorker _bw = new BackgroundWorker(); public BackgroundWorkTest() { // 绑定工作事件 _bw.DoWork += BwOnDoWork; // 绑定工作完成事件 _bw.WorkerSupportsCancellation = true; _bw.RunWorkerCompleted += BwOnRunWorkerCompleted; // 绑定工作进度更新事件 _bw.WorkerReportsProgress = true; _bw.ProgressChanged += BwOnProgressChanged; } private void BwOnProgressChanged(object sender, ProgressChangedEventArgs e) { Console.WriteLine($\u0026#34;当前进度：{e.ProgressPercentage}%\u0026#34;); } private void BwOnRunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { if (e.Cancelled) { Console.WriteLine(\u0026#34;任务已经被取消。\u0026#34;); } if (e.Error != null) { Console.WriteLine(\u0026#34;执行任务的过程中出现了异常。\u0026#34;); } // 在当前线程可以直接更新 UI 组件的数据 Console.WriteLine($\u0026#34;执行完成的结果：{e.Result}\u0026#34;); } public void Run() { _bw.RunWorkerAsync(10); } private void BwOnDoWork(object sender, DoWorkEventArgs e) { // 这里是工作线程进行执行的 Console.WriteLine($\u0026#34;需要计算的数据值为：{e.Argument}\u0026#34;); for (int i = 0; i \u0026lt;= 100; i += 20) { if (_bw.CancellationPending) { e.Cancel = true; return; } _bw.ReportProgress(i); } // 传递完成的数据给完成事件 e.Result = 1510; } } BackgroundWorker 不是密闭类，用户可以继承自 BackgroundWorker 类型，并重写其 DoWork() 方法以达到自己的需要。\n三、线程的中断与中止 所有 阻塞 方法在解除阻塞的条件没有满足，并且其没有指定超时时间的情况下，会永久阻塞。\n开发人员可以通过 Thread.Interrupt() 与 Thread.Abort() 方法来解除阻塞。\n在使用线程中断与中止方法的时候，应该十分谨慎，这可能会导致一些意想不到的情况发生。\n为了演示上面所说的概念，可以编写如下代码进行测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Program { static void Main() { var test = new ThreadInterrupt(); test.Run(); Console.ReadLine(); } } public class ThreadInterrupt { public void Run() { var testThread = new Thread(WorkThread); testThread.Start(); // 中断指定的线程 testThread.Interrupt(); } private void WorkThread() { try { // 永远阻塞 Thread.Sleep(Timeout.Infinite); } catch (ThreadInterruptedException e) { Console.WriteLine(\u0026#34;产生了中断异常.\u0026#34;); } Console.WriteLine(\u0026#34;线程执行完成.\u0026#34;); } } 3.1 中断 在一个阻塞线程上调用 Thread.Interrupt() 方法，会导致该线程抛出 ThreadInterruptedException 异常，并且强制释放线程。 中断线程时，除非没有对 ThreadInterruptedException 进行处理，否则是不会导致阻塞线程结束的。 随意中断一个线程是十分危险的，我们可以通过信号构造或者取消构造。哪怕是使用 Thread.Abort() 来中止线程，都比中断线程更加安全。 因为随意中断线程会导致调用栈上面的任何框架，或者第三方的方法意外接收到中断。 3.2 中止 Thread.Abort() 方法在 .NET Core 当中无法使用，调用该方法会抛出 Thread abort is not supported on this platform. 错误。\n在一个阻塞线程上调用 Thread.Abort() 方法，效果与中断相似，但会抛出一个 ThreadAbortException 异常。 该异常在 catch 块结束之后会被重新抛出。 未经处理的 ThreadAbortException 是仅有的两个不会导致应用程序关闭的异常之一。 中止与中断最大的不同是，中止操作会立即在执行的地方抛出异常。例如中止发生在 FileStream 的构造期间，可能会导致一个非托管文件句柄保持打开状态导致内存泄漏。 四、安全取消 与实现了 EAP 模式的 BackgroundWorker 类型一样，我们可以通过协作模式，使用一个标识来优雅地中止线程。\n其核心思路就是封装一个取消标记，将其传入到线程当中，在线程执行时可以通过这个取消标记来优雅中止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class Program { static void Main() { var test = new CancelTest(); test.Run(); Console.ReadLine(); } } public class CancelToken { private readonly object _selfLocker = new object(); private bool _cancelRequest = false; /// \u0026lt;summary\u0026gt; /// 当前操作是否已经被取消。 /// \u0026lt;/summary\u0026gt; public bool IsCancellationRequested { get { lock (_selfLocker) { return _cancelRequest; } } } /// \u0026lt;summary\u0026gt; /// 取消操作。 /// \u0026lt;/summary\u0026gt; public void Cancel() { lock (_selfLocker) { _cancelRequest = true; } } /// \u0026lt;summary\u0026gt; /// 如果操作已经被取消，则抛出异常。 /// \u0026lt;/summary\u0026gt; public void ThrowIfCancellationRequested() { lock (_selfLocker) { if (_cancelRequest) { throw new OperationCanceledException(\u0026#34;操作被取消.\u0026#34;); } } } } public class CancelTest { public void Run() { var cancelToken = new CancelToken(); var workThread = new Thread(() =\u0026gt; { try { Work(cancelToken); } catch (OperationCanceledException e) { Console.WriteLine(\u0026#34;任务已经被取消。\u0026#34;); } }); workThread.Start(); Thread.Sleep(1000); cancelToken.Cancel(); } private void Work(CancelToken token) { // 模拟耗时操作 while (true) { token.ThrowIfCancellationRequested(); try { RealWork(token); } finally { // 清理资源 } } } private void RealWork(CancelToken token) { token.ThrowIfCancellationRequested(); Console.WriteLine(\u0026#34;我是真的在工作...\u0026#34;); } } 4.1 取消标记 在 .NET 提供了 CancellationTokenSource 和 CancellationToken 来简化取消操作。\n如果需要使用这两个类，则只需要实例化一个 CancellationTokenSource 对象，并将其 Token 属性传递给支持取消的方法，在需要取消的使用调用 Source 的 Cancel() 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 伪代码 var cancelSource = new CancellationTokenSource(); // 启动线程 new Thread(() =\u0026gt; work(cancelSource.Token)).Start(); // Work 方法的定义 void Work(CancellationToken cancelToken) { cancelToken.ThrowIfCancellationRequested(); } // 需要取消的时候，调用 Cancel 方法。 cancelSource.Cancel(); 五、延迟初始化 延迟初始化的作用是缓解类型构造的开销，尤其是某个类型的构造开销很大的时候可以按需进行构造。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 原始代码 public class Foo { public readonly Expensive Expensive = new Expensive(); } public class Expensive { public Expensive() { // ... 构造开销极大 } } // 按需构造 public class LazyFoo { private Expensive _expensive; public Expensive Expensive { get { if(_expensive == null) _expensive = new Expensive(); } } } // 按需构造的线程安全版本 public class SafeLazyFoo { private Expensive _expensive; private readonly object _lazyLocker = new object(); public Expensive Expensive { get { lock(_lazyLocker) { if(_expensive == null) { _expensive = new Expensive(); } } } } } 在 .NET 4.0 之后提供了一个 Lazy\u0026lt;T\u0026gt; 类型，可以免去上面复杂的代码编写，并且也实现了双重锁定模式。\n通过在创建 Lazy\u0026lt;T\u0026gt; 实例时传递不同的 bool 参数来决定是否创建线程安全的初始化模式，传递了 true 则是线程安全的，传递了 false 则不是线程安全的。\n1 2 3 4 5 6 7 8 9 10 11 12 public class LazyExpensive { } public class LazyTest { // 线程安全版本的延迟初始化对象。 private Lazy\u0026lt;LazyExpensive\u0026gt; _lazyExpensive = new Lazy\u0026lt;LazyExpensive\u0026gt;(()=\u0026gt;new LazyExpensive(),true); public LazyExpensive LazyExpensive =\u0026gt; _lazyExpensive.Value; } 5.1 LazyInitializer LazyInitializer 是一个静态类，基本与 Lazy\u0026lt;T\u0026gt; 相似，但是提供了一系列的静态方法，在某些极端情况下可以改善性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class LazyFactoryTest { private LazyExpensive _lazyExpensive; // 双重锁定模式。 public LazyExpensive LazyExpensive { get { LazyInitializer.EnsureInitialized(ref _lazyExpensive, () =\u0026gt; new LazyExpensive()); return _lazyExpensive; } } } LazyInitializer 提供了一个竞争初始化的版本，这种在多核处理器(线程数与核心数相等)的情况下速度比双重锁定技术要快。\n1 2 3 4 5 6 7 8 9 10 11 12 13 volatile Expensive _expensive; public Expensive Expensive { get { if (_expensive == null) { var instance = new Expensive(); Interlocked.CompareExchange (ref _expensive, instance, null); } return _expensive; } } 六、线程局部存储 某些数据不适合作为全局遍历和局部变量，但是在整个调用栈当中又需要进行共享，是与执行路径紧密相关的。所以这里来说，应该是在代码的执行路径当中是全局的，这里就可以通过线程来达到数据隔离的效果。例如线程 A 调用链是这样的 A() -\u0026gt; B() -\u0026gt; C()。\n对静态字段增加 [ThreadStatic] ，这样每个线程就会拥有独立的副本，但仅适用于静态字段。\n1 [ThreadStatic] static int _x; .NET 提供了一个 ThreadLocal\u0026lt;T\u0026gt; 类型可以用于静态字段和实例字段的线程局部存储。\n1 2 3 4 5 // 静态字段存储 static ThreadLocal\u0026lt;int\u0026gt; _x = new ThreadLocal\u0026lt;int\u0026gt;(() =\u0026gt; 3); // 实例字段存储 var localRandom = new ThreadLocal\u0026lt;Random\u0026gt;(() =\u0026gt; new Random()); ThreadLocal\u0026lt;T\u0026gt; 的值是 延迟初始化 的，第一次被使用的时候 才通过工厂进行初始化。\n我们可以使用 Thread 提供的 Thread.GetData() 与 Thread.SetData() 方法来将数据存储在线程数据槽当中。\n同一个数据槽可以跨线程使用，而且它在不同的线程当中数据仍然是独立的。\n通过 LocalDataStoreSolt 可以构建一个数据槽，通过 Thread.GetNamedDataSlot(\u0026quot;securityLevel\u0026quot;) 来获得一个命名槽，可以通过 Thread.FreeNameDataSlot(\u0026quot;securityLevel\u0026quot;) 来释放。\n如果不需要命名槽，也可以通过 Thread.AllocateDataSlot() 来获得一个匿名槽。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Program { static void Main() { var test = new ThreadSlotTest(); test.Run(); Console.ReadLine(); } } public class ThreadSlotTest { // 创建一个命名槽。 private LocalDataStoreSlot _localDataStoreSlot = Thread.GetNamedDataSlot(\u0026#34;命名槽\u0026#34;); // 创建一个匿名槽。 private LocalDataStoreSlot _anonymousDataStoreSlot = Thread.AllocateDataSlot(); public void Run() { new Thread(NamedThreadWork).Start(); new Thread(NamedThreadWork).Start(); new Thread(AnonymousThreadWork).Start(); new Thread(AnonymousThreadWork).Start(); // 释放命名槽。 Thread.FreeNamedDataSlot(\u0026#34;命名槽\u0026#34;); } // 命名槽测试。 private void NamedThreadWork() { // 设置命名槽数据 Thread.SetData(_localDataStoreSlot,DateTime.UtcNow.Ticks); var data = Thread.GetData(_localDataStoreSlot); Console.WriteLine($\u0026#34;命名槽数据：{data}\u0026#34;); ContinueNamedThreadWork(); } private void ContinueNamedThreadWork() { Console.WriteLine($\u0026#34;延续方法中命名槽的数据：{Thread.GetData(_localDataStoreSlot)}\u0026#34;); } // 匿名槽测试。 private void AnonymousThreadWork() { // 设置匿名槽数据 Thread.SetData(_anonymousDataStoreSlot,DateTime.UtcNow.Ticks); var data = Thread.GetData(_anonymousDataStoreSlot); Console.WriteLine($\u0026#34;匿名槽数据：{data}\u0026#34;); ContinueAnonymousThreadWork(); } private void ContinueAnonymousThreadWork() { Console.WriteLine($\u0026#34;延续方法中匿名槽的数据：{Thread.GetData(_anonymousDataStoreSlot)}\u0026#34;); } } 七、定时器 7.1 多线程定时器 多线程定时器使用线程池触发时间，也就意味着 Elapsed 事件可能会在不同线程当中触发。 System.Threading.Timer 是最简单的多线程定时器，而 System.Timers.Timer 则是对于该计时器的封装。 多线程定时器的精度大概在 10 ~ 20 ms。 7.2 单线程定时器 单线程定时器依赖于 UI 模型的底层消息循环机制，所以其 Tick 事件总是在创建该定时器的线程触发。 单线程定时器关联的事件可以安全地操作 UI 组件。 精度比多线程定时器更低，而且更容易使 UI 失去响应。 ","date":"2019-02-15T00:38:03Z","permalink":"https://real-zony.github.io/p/csharp-multi-threaded-study-notes---3/","title":"C# 多线程学习笔记 - 3"},{"content":"在 C# 当中的 foreach 语句实际上就是遍历迭代器的语法糖。例如我们拥有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 public class TestClass { public void TestMethod() { var integers = new int[] {1,2,3,4,5,6,7,8,9}; foreach(var @int in integers) { Console.WriteLine(@int); } } } 上述代码结构十分简单，作用就是遍历 integers 数组，并将其结果输出到控制台当中。 由于 int[] 是一个 Array 类型，它继承并实现了 IEnumerbale\u0026lt;T\u0026gt; 接口，所以 foreach 语句实际上是翻译成下面伪代码进行遍历输出的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class TestClass { public void TestMethod() { var integers = new int[] {1,2,3,4,5,6,7,8,9}; var tmpEnumerator = integers.GetEnumerator(); try { while(tmpEnumerator.MoveNext()) { var itemValue = tempEnumerator.Current; // 需要执行的代码段 Console.WriteLine(itemValue); } } finally { tmpEnumerator.Dispose(); } } } ","date":"2019-02-14T02:18:59Z","permalink":"https://real-zony.github.io/p/the-principle-of-foreach-in-csharp/","title":"C# 当中 foreach 的原理"},{"content":"例如我拥有以下代码。\n1 2 3 4 5 6 public class NewObject { public int? TestValue { get; set; } public int? Age { get; set; } } 当我为 TestValue 属性传入一个非法数据的时候，在使用 JSON.NET 进行反序列化时会抛出异常。例如我通过以下代码对一个字符串进行反序列化，如果不出意外的话会提示无效参数值的异常。\n1 var newValue = JsonConvert.DeserializeObject\u0026lt;NewObject\u0026gt;(@\u0026#34;{\u0026#34;\u0026#34;TestValue\u0026#34;\u0026#34;:\u0026#34;\u0026#34;FFFF\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:15}\u0026#34;,settings); 通过 Stackoverflow 查询得知，可以通过在反序列化时指定 JsonSerializerSettings 对象进行忽略。\n1 2 3 4 5 6 7 8 9 var settings = new JsonSerializerSettings { Error = (obj, args2) =\u0026gt; { args2.ErrorContext.Handled = true; } }; var newValue = JsonConvert.DeserializeObject\u0026lt;NewObject\u0026gt;(@\u0026#34;{\u0026#34;\u0026#34;TestValue\u0026#34;\u0026#34;:\u0026#34;\u0026#34;FFFF\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:15}\u0026#34;,settings); 这样，在进行反序列化的时候就可以忽略 TestValue 的无效值，为其属性设置为 null，并且成功解析 Age 的值。\n如果你是 ASP.NET Core 的程序，可以通过 IServiceCollection 的 Configure\u0026lt;T\u0026gt;() 方法来配置 Error 的处理器。\n1 2 3 4 5 services.Configure\u0026lt;MvcJsonOptions\u0026gt;(jsonOptions =\u0026gt; { // 忽略转换过程中的异常信息 jsonOptions.SerializerSettings.Error += (sender, args) =\u0026gt; { args.ErrorContext.Handled = true; }; }); ","date":"2019-02-02T01:52:06Z","permalink":"https://real-zony.github.io/p/ignore-invalid-property-values-during-json-serialization/","title":"JSON 序列化的时候忽略无效的属性值"},{"content":" 本文主要针对 GKarch 相关文章留作笔记，仅在原文基础上记录了自己的理解与摘抄部分片段。 遵循原作者的 CC 3.0 协议。 如果想要了解更加详细的文章信息内容，请访问下列地址进行学习。\n原文章地址：https://blog.gkarch.com/threading/part2.html\n一、同步概要 同步构造基本分为四种，简单的阻塞方法、锁构造、信号构造、非阻塞同步构造。\n1.1 阻塞方法 阻塞方法一般是会暂停某些线程的执行，例如 Sleep() 与 Join() 方法。当一个线程被阻塞的时候，会立即出让(yields) CPU 时间片，不再消耗处理器时间。 通过检查线程的 ThreadState 属性来确认某个线程是否被阻塞。 当某个线程被阻塞或者解除阻塞的时候，会进行上下文切换。 阻塞方法在满足以下几个条件的时候会进行解除。 阻塞条件满足。 操作超时。 通过 Thread.Interrupt() 中断。 通过 Thread.Abort() 中止。 1.2 阻塞与自旋 信号构造与锁构造可以在某些条件被满足前阻塞线程。另外一种方法就是通过自旋来等待条件被满足。\n自旋即通过一个循环不断检测条件，来伪造一个空忙状态。\n虽然自旋会造成大量的处理器时间浪费，但是它可以避免上下文切换带来的额外开销。\n一个标准的自旋结构如下列代码。\n1 2 3 4 // 单纯的自旋 while(!proceed); // 阻塞 + 自旋 while(!proceed) Thread.Sleep(10); 二、锁 2.1 排它锁 排它锁的作用是为了保证线程安全，如下列代码。如果 Go() 方法被两个线程同时执行，则可能某个线程在执行完 if 后，另一个线程已经将 V2 置为0，原先线程就可能造成除数不能为 0 的异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Code1 { static int V1 = 1,V2 = 1; static void Go() { if(V2 != 0) Console.WriteLine(V1 / V2); V2 = 0; } } // 使用了排它锁的代码 class Code2 { static int V1 = 1,V2 = 1; static readonly object locker = new object(); static void Go() { lock(locker) { if(V2 != 0) Console.WriteLine(V1 / V2); V2 = 0; } } } 如果使用了 lock 语句快，则可以锁定一个同步对象，其他竞争锁的线程会被阻塞，直到锁被释放。\n如果有多个线程竞争锁，则按照先到先得的队列进行排队，通过排它锁可以强制线程对锁保护的内容进行顺序访问。\n在竞争锁时被阻塞的线程，其状态为 WaitSleepJoin 。\n不同的同步结构技术的性能开销。\n构造 用途 开销 lock （ Monitor.Enter / Monitor.Exit ） 确保同一时间只有一个线程可以访问资源或代码 20 ns Mutex 确保同一时间只有一个线程可以访问资源或代码 1000 ns SemaphoreSlim 确保只有不超过指定数量的线程可以并发访问资源或代码 200 ns Semaphore 确保只有不超过指定数量的线程可以并发访问资源或代码 1000 ns ReaderWriterLockSlim 允许多个读线程和一个写线程共存 40 ns ReaderWriterLock (已过时) 允许多个读线程和一个写线程共存 100 ns 2.2 Monitor.Enter 与 Monitor.Exit lock 语句块实质上就是一个语法糖，其核心代码就是结合 try/finally 来调用 Monitor.Enter() 与 Monitor.Exit() 方法，并且如果在一个方法内直接调用 Monitor.Exit() 会直接抛出异常。\n1 2 3 4 5 6 7 8 9 10 Monitor.Enter(locker); try { if(V2 != 0) Console.Writeline(V1 / V2); V2 = 0; } finally { Monitor.Exit(locker); } 上述情况可能发生锁泄漏，因为在 Monitor.Enter() 与 try/finally 语句块之间如果发生了异常，会导致后续的 try/finally 语句块不被执行。造成无法获得锁，或者得到锁之后，无法释放造成锁泄漏。\n解决锁泄漏的方式是，CLR 4.0 当中，对于 lock 语句的翻译则是通过一个 bool 类型的 lockTaken 进行解决。\n1 2 3 4 5 6 7 8 9 10 11 12 13 bool lockTaken = false; try { Monitor.Enter (locker, ref lockTaken); // 用户代码 ... } finally { if(lockTaken) { Monitor.Exit(locker); } } Monitor 还提供了 TryEnter() 方法，用于执行超时时间，如果超过时间没有获得到锁，则返回 false 。\n2.3 什么时候加锁 需要访问任意可写的共享字段，下面代码展示了线程安全与非线程安全的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class ThreadUnsafe { static int _x; static void Increment() { _x++; } static void Assign() { _x = 123; } } // 线程安全 class ThreadSafe { static readonly object _locker = new object(); static int _x; static void Increment() { lock(_locker) _X++; } static void Assign() { lock(_locker) _x++; } } 2.4 锁与原子性 如果一组变量总是在一个锁内进行读且，即可被成为原子的读写。 例如 lock(locker) { if(x != 0) y /= x; } 就可以说 x 与 y 是被原子访问的，因为这段代码无法被其他线程分割或者抢占。 如果在 lock 锁内抛出异常，将会影响锁的原子性，这个时候就需要结合回滚机制来进行实现。 2.5 锁嵌套 排他锁是可以被嵌套的，并且只有当最外层的锁被释放的时候，对象才会被解锁。 线程只会在最外层的 lock 语句处被阻塞。 2.6 死锁 死锁是当两个甚至多个线程所等待的资源都被对方占用的时候，它们都无法执行，就会产生了死锁。\n一个标准的死锁代码如下，我们在 A 线程内部锁定了 locker1 与 locker2 ，在主线程同同时也锁定了 locker2 与 locker1 。这个时候由于排他锁的特性，主线程与新开启的线程都会等待对方的锁被释放，造成死锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 object locker1 = new object(); object locker2 = new object(); new Thread(() =\u0026gt; { lock(locker1) { Thread.Sleep(1000); lock(loekcer2); } }).Start(); lock(locker2) { Thread.Sleep(); lock(locker1); } 应该尽量较少对锁的使用，更多的依靠其他的同步构造进行处理。\n2.7 互斥体 互斥体使用 WaitOne() 方法进行加锁，使用 ReleaseMutex() 来解锁。 关闭或者销毁 Mutex 对象会自动释放锁，所以可以结合 using 语句块进行使用。 互斥体是机器范围的，其性能比 lock 慢约 50 倍。 2.8 信号量 信号量具有一定容量，当容量满了之后和就会拒绝其他线程占用，当有一个线程释放资源之后，其他线程按先后顺序进入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Program { static void Main(string[] args) { var sem = new Semaphore(); for (int i = 1; i \u0026lt;= 5; i++) new Thread(sem.Enter).Start(i); } } public class Semaphore { private readonly SemaphoreSlim _semaphoreSlim = new SemaphoreSlim(3); public void Enter(object id) { Console.WriteLine($\u0026#34;Id 为 {id} 的线程想调用本方法。\u0026#34;); _semaphoreSlim.Wait(); Console.WriteLine($\u0026#34;Id 为 {id} 的线程已经进入方法。\u0026#34;); Thread.Sleep(1000 * (int)id); Console.WriteLine($\u0026#34;Id 为 {id} 的线程正在离开方法。\u0026#34;); _semaphoreSlim.Release(); } } 容量为 1 的信号量与 Mutex 和 lock 类似。\n信号量是线程无关的，任何线程都可以调用 Release() 方法释放信号量。而 Mutex 与 lock 只有获得锁的线程才可以释放。\n在 .NET 4.0 当中有一个轻量级的信号量 SemaphoreSlim ，但是不是跨进程的，开销只有 Semaphore 的四分之一。\n一般在某些需要限流或者是要执行比较密集的磁盘 I/O 操作，这个时候可以使用信号量进行并发限制，这样可以改善程序整体的性能。\n三、线程安全 如果某个程序或者方法是一个线程安全的，那么它在任意的多线程场景中都不会存在不确定性。 线程安全是通过锁，或者减少线程交互来实现的。 多线程当中的线程安全一般是在需要的时候才会进行实现，但是可以以牺牲粒度，将整段代码甚至是整个对象封装在一个排它锁的内部。这种解决方案十分简单有效，这种方案适用于使用了线程不安全的第三方库代码，并且仅适用于能够快速执行的场景，否则会产生大量阻塞。 除了 CLR 定义的基本类型以外，很少有能够在高并发需求下保证其实例是线程安全的，除了 Concurrent 下的并行集合以外。 可以最小化共享数据来减少线程交互，例如 Web 服务器不需要持久化并发请求的数据，是无状态的，线程交互的时候仅需要考虑静态字段等共享资源。 除了以上两种方法之外，也可以使用自动锁机制，集成 ContextBoundObject 类并且使用 Synchronization 特性。但是这种方法很容易造成死锁的情况，并且降低并发度。 3.1 线程安全与 BCL 类型 通过锁可以将不安全的代码转换为线程安全的代码，例如 BCL 提供的 List\u0026lt;T\u0026gt; 集合本身不是线程安全的，但是通过对一个集合实例的锁定，我们就可以进行线程安全的操作。下面的代码当中，我们直接使用 List\u0026lt;int\u0026gt; 集合自身来加锁，这里对集合进行遍历的操作也不是线程安全的，也需要加锁进行处理，另一种方式就是通过读写锁来实现避免长时间锁定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Program { static void Main(string[] args) { var bcl = new BCLThreadSafe(); for (int i = 0; i \u0026lt; 10; i++) { new Thread(bcl.AddItem).Start(); } } } public class BCLThreadSafe { private readonly List\u0026lt;int\u0026gt; _innerList = new List\u0026lt;int\u0026gt;(); public void AddItem() { lock (_innerList) { _innerList.Add(_innerList.Count); } var sb = new StringBuilder(); lock (_innerList) { foreach (var item in _innerList) { sb.Append(item).Append(\u0026#39;,\u0026#39;); } } Console.WriteLine(sb.ToString().TrimEnd(\u0026#39;,\u0026#39;)); } } 即便 List\u0026lt;T\u0026gt; 集合是线程安全的，如果我们需要使用以下代码增加一个新的数据到集合当中。也会由于在执行 if 之后，其他线程抢占修改了 _list 集合，增加了一个相同的类目。在这个时候，对 _list 集合的添加操作就是存在问题的。\n1 if(!_list.Contains(newItem)) _list.Add(newItem); 在高并发的环境下，对集合的访问加锁可能产生大量阻塞，所以进行类似操作的时候建议使用线程安全的队列、栈、字典。\n针对于静态成员，BCL 的所有类型的静态成员都实现了线程安全，所以开发人员在开发基础类型或者框架的时候，应该保证静态成员的线程安全。\n大部分 BCL 类型的只读访问都是线程安全的，开发人员在设计类基础类型或者框架的时候也应该遵循这个规则。\n3.2 应用服务器其与线程安全 服务端经常需要使用到多线程处理客户请求，也就意味着必须考虑线程安全。但一般来说服务端类都是无状态的，或者为每个请求创建新的对象实例，很少存在有交互的点。\n以缓存为例，假设对一个用户表使用了静态的字典实例进行缓存，那么就存在线程安全的问题。下列代码在读取与更新锁的时候，使用了排它锁进行加锁处理。但是会存在两个线程同时访问 GetUser() 方法的时候，都传递了未缓存过得数据的 id ，这个时候就会去查询两次数据库。虽然可以通过对整个 GetUser() 加锁，但是这样设计的话，都会在 QueryUser() 进行查询的时候，整个获得用户信息的方法都被阻塞。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static class UserCache { static Dictionary\u0026lt;int,User\u0026gt; _users = new Dictionary\u0026lt;int,User\u0026gt;(); internal static User GetUser(int id) { User u = null; lock(_users) { if(_users.TryGetValue(id,out u)) { return u; } } // 从数据库查询用户数据 u = QueryUser(id); lock(_users)_users[id] = u; return u; } } 3.3 WPF 与 WinForm 程序的线程安全 富客户端程序一般都是基于 DependencyObject (WPF) 与 Control (Windows Forms)，它们都具备线程亲和性，即只有创建他们的线程才能够访问其成员。\n作用就是访问 UI 对象并不需要加锁，坏处则是如果要跨线程调用 UI 控件则需要一些比较繁琐的步骤。\nWPF：其 Dispatcher 调用 Invoke() 或 BeginInvoke() 。 Windows Forms：调用 Control() 对象的 Invoke() 或 BeginInvoke() 。 Invoke() 与 BeginInvoke() 都接收一个委托以便代替工作线程需要在 UI 线程执行的操作。前者是同步方法，在委托执行完成之前，都处于阻塞状态。后者是异步方法，调用方立刻返回。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // WPF DEMO public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); new Thread(Work).Start(); } private void Work() { Thread.Sleep(5000); // 阻塞当前线程 5s 模拟耗时任务 UpdateMessage(\u0026#34;new msg\u0026#34;); } private void UpdateMessage(string msg) { var action = () =\u0026gt; txtMessage.Text = msg; Dispatcher.Invoke(action); } } // Windows Forms DEMO public partial class FormClass : Form { // ... 其他代码 private void UpdateMessage(string msg) { var action = () =\u0026gt; txtMessage.Text = msg; this.Invoke(action); } // ... 其他代码 } 3.4 不可变对象 不可变对象拥有的不变性可以在多线程环境中最小化共享可写状态的问题。 四、事件等待句柄与信号同步 事件等待句柄的作用是用于进行信号同步。\n信号同步即一个线程进行等待，直到其接受到其他线程通知的过程。\n信号构造的开销比较。\n构造 用途 开销 AutoResetEvent 使线程在接收到其他线程信号时解除阻塞一次。 1000 ns ManualResetEvent 使线程在接收到其他线程信号时解除阻塞，并不继续 阻塞，直到其复位。 1000 ns ManualResetEventSlim 使线程在接收到其他线程信号时解除阻塞，并不继续 阻塞，直到其复位。 40 ns CountdownEvent 使线程在收到预订数量的信号时，解除阻塞。 40 ns Barrier 实现线程执行屏障。 80 ns Wait 和 Pulse 使线程阻塞，直到自定义条件被满足。 Pulse/120 ns 4.1 AutoResetEvent AutoResetEvent 的原理类似于验票闸机，在闸机处调用 WaitOne() 方法，线程就会被阻塞。插入票的动作就类似于调用 Set() 方法打开闸机。任何能够访问这个 AutoResetEvent 的非阻塞线程都可以调用 Set() 方法来放行一个被阻塞的线程。\nAutoResetEvent 是基于 EventWaitHandle 进行构造的，有两种方法可以创建 AutoResetEvent 对象。第一种即通过其构造方法 var auto = new AutoResetEvent (false); ，第二种则是通过 EventWaitHandle 传递事件类型，var auto = new EventWaitHandle (false, EventResetMode.AutoReset); 。这里如果传递的是 false 则会在创建后立即调用 Set() 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Program { public static readonly EventWaitHandle WaitHandle = new AutoResetEvent(false); static void Main(string[] args) { var testClass = new AutoResetEventTest(); new Thread(testClass.Waiter).Start(); // 主线程等待 1 秒再发送信号唤醒 Thread.Sleep(1000); WaitHandle.Set(); } } public class AutoResetEventTest { public void Waiter() { Console.WriteLine(\u0026#34;线程开始等待...\u0026#34;); // 如果传入了超时时间，超时则返回 false。 Program.WaitHandle.WaitOne(); Console.WriteLine(\u0026#34;接受到了通知，进入闸机。\u0026#34;); } } 如果没有线程等待的时候调用 Set() 方法，则等待句柄会保持初始状态，直到有线程调用了 WaitOne() 方法。\n为等待句柄调用 Reset() 方法可以关闭闸机，这个方法不会被阻塞。\n可以调用 Dispose() 方法来销毁等待句柄，或者直接丢弃，等待 GC 进行回收。\n如果主线程需要向工作线程连续发送 3 个信号并结束线程，则可以通过双向信号进行实现，其步骤大体如下。\n启动工作线程。 主线程通过事件等待句柄 A 等待工作线程就绪。 工作线程通过 A 句柄通知主线程就绪，工作线程通过事件等待句柄 B 等待主线程通知。 主线程更改某个共享数据，通过句柄 B 通知工作线程进行处理。 工作线程收到信号唤醒之后，输出共享数据，并判断是否应该结束线程。 循环往复三次之后，工作线程收到的共享数据为 null，工作线程进行退出。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 static void Main(string[] args) { var testObj = new MultiAutoResetEventTest(); new Thread(testObj.WorkThread).Start(); MultiAutoResetEventTest.WaitHandle_MainThread.WaitOne(); lock (MultiAutoResetEventTest.Locker) MultiAutoResetEventTest.Message = DateTime.Now.ToFileTimeUtc().ToString(); MultiAutoResetEventTest.WaitHandle_WorkThread.Set(); MultiAutoResetEventTest.WaitHandle_MainThread.WaitOne(); lock (MultiAutoResetEventTest.Locker) MultiAutoResetEventTest.Message = DateTime.Now.ToFileTimeUtc().ToString(); MultiAutoResetEventTest.WaitHandle_WorkThread.Set(); MultiAutoResetEventTest.WaitHandle_MainThread.WaitOne(); lock (MultiAutoResetEventTest.Locker) MultiAutoResetEventTest.Message = DateTime.Now.ToFileTimeUtc().ToString(); MultiAutoResetEventTest.WaitHandle_WorkThread.Set(); MultiAutoResetEventTest.WaitHandle_MainThread.WaitOne(); lock (MultiAutoResetEventTest.Locker) MultiAutoResetEventTest.Message = null; MultiAutoResetEventTest.WaitHandle_WorkThread.Set(); } } public class MultiAutoResetEventTest { public static readonly EventWaitHandle WaitHandle_MainThread = new AutoResetEvent(false); public static readonly EventWaitHandle WaitHandle_WorkThread = new AutoResetEvent(false); public static string Message = string.Empty; public static readonly object Locker = new object(); public void WorkThread() { while (true) { WaitHandle_MainThread.Set(); WaitHandle_WorkThread.WaitOne(); lock (Locker) { if (Message == null) return; Console.WriteLine($\u0026#34;收到主线程的消息，内容为: {Message}\u0026#34;); } } } } 生产消费者队列的构成如下所描述的一致。\n构建一个队列，用于存放需要执行的工作项。 如果有新的任务需要执行，将其放在队列当中。 一个或多个工作线程在后台执行，从队列中拿取工作项执行，将其消费。 生产/消费者队列可以精确控制工作线程的数量，CLR 的线程池就是一种生产/消费者队列。\n结合 AutoResetEvent 事件等待句柄，我们可以很方便地实现一个生产/消费者队列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Program { static void Main(string[] args) { using (var queue = new ProducerConsumerQueue()) { queue.EnqueueTask(\u0026#34;Hello\u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { queue.EnqueueTask($\u0026#34;{i}\u0026#34;); } queue.EnqueueTask(\u0026#34;End\u0026#34;); } } } public class ProducerConsumerQueue : IDisposable { private readonly EventWaitHandle _waitHandle = new AutoResetEvent(false); private readonly object _locker = new object(); private readonly Queue\u0026lt;string\u0026gt; _taskQueue = new Queue\u0026lt;string\u0026gt;(); private readonly Thread _workThread; public ProducerConsumerQueue() { _workThread = new Thread(Work); _workThread.Start(); } public void EnqueueTask(string task) { // 向队列当中插入任务，加锁保证线程安全 lock (_locker) { _taskQueue.Enqueue(task); } // 通知工作线程开始干活 _waitHandle.Set(); } private void Work() { while (true) { string task = null; lock (_locker) { if (_taskQueue.Count \u0026gt; 0) { task = _taskQueue.Dequeue(); if (task == null) return; } } if (task != null) { Thread.Sleep(100); Console.WriteLine($\u0026#34;正在处理任务 {task}\u0026#34;); } else { // 如果任务等于空则阻塞线程，等待心的工作项 _waitHandle.WaitOne(); } } } public void Dispose() { // 优雅退出 EnqueueTask(null); _workThread.Join(); _waitHandle.Close(); } } .NET 4.0 以后提供了一个 BlockingCollection\u0026lt;T\u0026gt; 类型实现了生产/消费者队列。\n4.2 ManualResetEvent 与 AutoResetEvent 类似，但在调用 Set() 方法的时候打开门，是可以允许任意数量的线程在调用 WaitOne() 后通过。(与 AutoResetEvent 每次只能通过 1 个不一样)\n如果是在关闭状态下调用 WaitOne() 方法，线程会被阻塞，其余功能都与 AutoResetEvent 一致。\nManualResetEvent 的基类也是 EventWaitHandle ，通过以下两种方式均可构造。\n1 2 var manual1 = new ManualResetEvent(false); var manual2 = new EventWaitHandle(false, EventResetModel.ManualReset); .NET 4.0 提供了性能更高的 ManualResetEventSliam ，但是不能够跨线程使用。\n4.3 CountdownEvent 使用 CountdownEvent 可以指定一个计数器的值，用于表明需要等待的线程数量。\n调用 Signal() 方法会将计数器自减 1 ，如果调用其 Wait() 则会阻塞计数到 0 ，通过 AddCount() 可以增加计数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Program { static void Main() { var test = new CountdownEventTest(); new Thread(test.Say).Start(\u0026#34;Hello 1\u0026#34;); new Thread(test.Say).Start(\u0026#34;Hello 2\u0026#34;); new Thread(test.Say).Start(\u0026#34;Hello 3\u0026#34;); test.CountdownEvent.Wait(); Console.WriteLine(\u0026#34;所有线程执行完成...\u0026#34;); } } public class CountdownEventTest { public readonly CountdownEvent CountdownEvent = new CountdownEvent(3); public void Say(object info) { Thread.Sleep(1000); Console.WriteLine(info); CountdownEvent.Signal(); } } 当计数为 0 的时候，无法通过 AddCount() 增加计数，只能调用 Reset() 进行复位。\n4.4 等待句柄与线程池 除了手动开启线程之外，事件等待句柄也支持通过线程池来运行工作任务。\n通过 ThreadPool.RegisterWaitForSingleObject() 方法可以减少资源消耗，当需要执行的委托处于等待状态的时候，不会浪费线程资源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Program { static void Main() { var test = new ThreadPoolTest(); test.Test(); } } public class ThreadPoolTest { private readonly EventWaitHandle _waitHandle = new ManualResetEvent(false); public void Test() { RegisteredWaitHandle regHandle = ThreadPool.RegisterWaitForSingleObject(_waitHandle, Work, \u0026#34;OJBK\u0026#34;, -1, true); Thread.Sleep(1000); _waitHandle.Set(); Console.ReadLine(); regHandle.Unregister(_waitHandle); } public void Work(object data,bool timeout) { Console.WriteLine($\u0026#34;正在执行任务 {data} .....\u0026#34;); } } 上述代码如果通过传统的方式进行阻塞与信号发送， 那么有 1000 个请求 Work() 方法，就会造成大量服务线程阻塞，而 RegisterWaitForSingleObject 可以立即返回，不会浪费线程资源。\n4.5 跨进程的 EventWaitHandle 可以通过对 EventWaitHandle 类型构造函数的第三个参数传入标识，来获得跨进程的事件的等待句柄。\n1 EventWaitHandle wh = new EventWaitHandle(false,EventResetMode.AutoReset,\u0026#34;AppName.Identity\u0026#34;); 五、同步上下文 5.1 使用同步上下文 这里的同步上下文不是 SynchronizationContext 类，而是 CLR 的自动锁机制。 通过继承 ContextBoundObject 基类并添加 Synchronization 特性即可让 CLR 自动加锁。 同步上下文是一种比较重型的加锁方法，很容易引起死锁的情况发生。 5.2 重入 线程安全方法也被称之为可重入的，因为其可以在运行途中被其他线程抢占。 使用了自动锁会有一个严重问题，如果将 Synchronization 特性的 reentrant 参数设置为 true 。则允许同步类是可被重入的，这就导致同步上下文被临时释放，会导致过度期间任何线程都可以自由调用原对象的任何方法。 这是因为 Synchronization 特性是直接作用于类，所以其所有方法都会带来可重入的问题。 所以因尽量减少粗粒度的自动锁。 ","date":"2019-01-31T11:15:54Z","permalink":"https://real-zony.github.io/p/csharp-multi-threaded-study-notes---2/","title":"C# 多线程学习笔记 - 2"},{"content":"基础知识 静态字段是在所有线程当中共享状态的。 一个线程被阻塞时，不会消耗 CPU 资源。 Join 可以等待另一个线程结束，Sleep 可以将线程阻塞指定的时间，两者使用时线程都是阻塞状态。 Join 可以设置超时时间，当线程执行超过指定时间返回 False。 Thread.Sleep(0) 会释放当前时间片，将 CPU 资源让出给其他线程。 Thread.Sleep(0) 作用与 Thread.Yield() 作用一样，后者只会让出给当前核心的其他线程。 Thread.Yield() 执行时会影响到程序的话，基本可以确定代码存在 Bug。 在使用 Lambda 表达式启动线程并传入变量的时候，不要在启动线程之后更改被捕获变量的值。 线程分为前台线程与后台线程，当所有前台线程中止时，程序自动退出。 可以显式地提高线程优先级，但可能会导致线程饥饿。 线程池 由于线程创建成本高昂(私有局部变量栈，每个线程默认占用 1 MB内存)，所以一般都会使用线程池来进行线程的创建与回收。\n线程池线程可以临时更改其优先级，在回收后会恢复默认状态。\n开发人员可以通过 Thread.CurrentThread.IsThreadPoolThread 属性查询线程是否运行在线程池中。\n通过查询 Task.Result 会导致当前线程阻塞，直到任务执行完成，如果发生错误，则会将异常包装到 AggregateException 异常内进行抛出。\n通过异步委托可以快速创建一个工作线程。\n创建目标方法委托。 在委托上调用 BeginInvoke() 方法，保存其 IActionResult 返回值。 需要返回结果时，调用 EndInvoke() 方法，传递保存的 IActionResult 对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Program { static void Main(string[] args) { Func\u0026lt;string, int\u0026gt; work = Work; var result = work.(\u0026#34;测试\u0026#34;,null,null); Console.WriteLine(\u0026#34;获得结果\u0026#34;); work.EndInvoke(result); } public static int Work(string inputStr) { Console.Write(Thread.CurrentThread); return inputStr.Length; } } 注意：\n上述代码在 .NET Core 平台上是无法运行的。\n异步委托在调用 BeginInvoke() 的时候可以传入回调方法。\n线程池可以通过 ThreadPool.SetMaxThreads 与 ThreadPool.SetMinThreads 进行优化。\n","date":"2019-01-31T11:13:30Z","permalink":"https://real-zony.github.io/p/csharp-multi-threaded-study-notes---1/","title":"C# 多线程学习笔记 - 1"},{"content":"一、简介 阅读 Abp 源码的过程中，自己也学习到了一些之前没有接触过的知识。在这里，我在这儿针对研究学习 Abp 框架中，遇到的一些值得分享的知识写几篇文章。如果有什么疑问或者问题，欢迎大家评论指正。\n在本篇主要是 Scoped 范围与 using 语句块的使用。using 语句块大家一定都不陌生，都是与非托管对象一起存在的，它有一个特性就是在 using 语句块结束的时候会调用对象的 IDispose.Dispose() 方法。一般我们会在非托管类型的 Dispose() 方法内部进行资源的释放，类似于 C 语言的 free() 操作。\n例如下面的代码：\n1 2 3 4 5 6 7 8 9 public void TestMethod() { using(var waitDisposeObj = new TestClass()) { // 执行其他操作 xxx } // 出了语句块之后就，自动调用 waitDisposeObj 的 Dispose() 方法。 } 可以看到上面的例子，using 语句块包裹的就是一个范围 (Scoped)。其实这里可以延伸到依赖注入的概念，在依赖注入的生命周期当中有一个 Scoped 的生命周期。(PS: 需要了解的可以去阅读我的 这篇文章)\n一个 Scoped 其实就可以看作是一个 using 语句块包裹的范围，所有解析出来的对象在离开 using 语句块的时候都应该被释放。\n例如下面的代码：\n1 2 3 4 5 6 7 8 9 10 public void TestMethod() { using(var scopedResolver = new ScopedResolver()) { var a = scopedResolver.Resolve\u0026lt;A\u0026gt;(); var b = scopedResolver.Reslove\u0026lt;B\u0026gt;(); } // 出了语句块之后 a b 对象自动释放 } 其实这里也是利用了 using 语句块的特性，在 ScopedResolver 类型的定义当中，也实现了 IDisopse 接口。所以在 using 语句块结束的时候，会自动调用 ScopedResovler 的 Dispose() 方法，在这个方法内部则对已经解析出来的对象调用其 Dispose() 进行释放。\n二、分析 2.0 释放委托 也是不知道叫什么标题了，这玩意儿是 Abp 封装的一个类型，它的作用就是在 using 语句块结束的时候，执行你传入的委托。\n使用方法如下：\n1 2 3 4 5 6 var completedTask = new DisposeAction(()=\u0026gt;Console.WriteLine(\u0026#34;using 语句块结束了。\u0026#34;)); using(completedTask) { // 其他操作 } // 执行完成之后会调用 completedTask 传入的委托。 根据上述用法，你也应该猜出来这个 DisposeAction 类型的定义了。该类型继承了 IDispose 接口，并且在内部有一个 Action 字段，用于存储构造函数传入的委托。在执行 Dispose() 方法的时候，执行传入的委托。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class DisposeAction : IDisposable { public static readonly DisposeAction Empty = new DisposeAction(null); private Action _action; public DisposeAction([CanBeNull] Action action) { _action = action; } public void Dispose() { // 防止在多线程环境下，多次调用 action var action = Interlocked.Exchange(ref _action, null); action?.Invoke(); } } 2.1 统一对象释放 统一对象释放是 Abp 当中的另一种用法，其实按照 Abp 框架的定义，叫做 ScopedResolver(范围解析器)。顾名思义，通过 ScopedResolver 解析出来的对象，都会在 using 语句块结束之后统一进行销毁。\nIScopedIocResolver 接口继承自 IIocResolver 和 IDisposable 接口，它的本质就是作为 Ioc 解析器的一种特殊实现，所以它拥有所有 Ioc 解析器的方法，这里就不再赘述。\n它的实现也比较简单，在其内部有一个集合维护每一次通过 IIocResolver 解析出来的对象。在 Dispose() 方法执行的时候，遍历这个集合，调用 Ioc 解析器的 Release() 方法释放对象并从集合中删除对象。下面就是实现的简化版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class ScopedIocResolver : IScopedIocResolver { private readonly IIocResolver _iocResolver; private readonly List\u0026lt;object\u0026gt; _resolvedObjects; public ScopedIocResolver(IIocResolver iocResolver) { _iocResolver = iocResolver; _resolvedObjects = new List\u0026lt;object\u0026gt;(); } // 解析对象 public object Resolve(Type type) { var resolvedObject = _iocResolver.Resolve(type); // 添加到集合，方便后续释放 _resolvedObjects.Add(resolvedObject); return resolvedObject; } public void Release(object obj) { // 从集合当中移除 _resolvedObjects.Remove(obj); // 通过 Ioc 管理器释放对象 _iocResolver.Release(obj); } public void Dispose() { // 遍历集合，释放对象 _resolvedObjects.ForEach(_iocResolver.Release); } } 通过 IScopedResolver 解析出来的对象，在 using 语句块结束的时候都会被释放，免去了我们每次手动释放的操作。\n2.2 临时值变更 暂时想不到一个好一点的标题，暂时用这个标题代替吧。这里以 Abp 的一段实例代码为例，在有的时候我们可能当前的用户没有登录，所以在 IAbpSession 里面的 UserId 等属性肯定是为 NULL 的。而 IAbpSession 在设计的时候，这些属性是不允许更改的。\n那么我们有时候可能会临时更改 IAbpSession 里面关于 UserId 的值怎么办呢？\n这个时候可以通过 IAbpSession 提供的一个 IDisposable Use(int tenantId, long? userId, string userCode) 进行临时更改。他拥有一个 Use() 方法，并且返回一个实现了 IDispose 接口的对象，用法一般是这样：\n1 2 3 4 5 6 7 8 9 public void TestMethod() { using(AbpSession.Use(1,2,\u0026#34;3\u0026#34;)) { // 内部临时更改了 AbpSession 的值 } // using 语句块结束的时候，调用 Use 返回对象的 Dispose 方法。 } 转到其抽象类 AbpSessionBase 实现，可以看到他的实现是这个样子的：\n1 2 3 4 5 6 protected IAmbientScopeProvider\u0026lt;SessionOverride\u0026gt; SessionOverrideScopeProvider { get; } public IDisposable Use(int tenantId, long? userId, string userCode) { return SessionOverrideScopeProvider.BeginScope(SessionOverrideContextKey, new SessionOverride(null, tenantId, userId, userCode)); } 所以在这里，它是通过 SessionOverrideScopeProvider 的 BegionScope() 方法创建了可以被 Dispose() 的对象。\n接着继续跳转，来到 IAmbientScopeProvider 接口定义，这个接口接受一个泛型参数，可以看到之前在 AbpSessionBase 传入了一个 SessionOverride。这个 SessionOverride 就是封装了 UserId 等信息的存储类，也就是说 SessionOverride 就是允许进行临时值更改的类型定义。\n在开始执行 BegionScope() 方法的时候，就针对传入的 value 进行存储，获取 Session 值的时候优先读取存储的值，不存在才执行真正的读取，调用 Dispose() 方法的时候就进行释放。\n所以接口提供了两个方法，第一个我们先看 BegionScope() 方法，接收一个 contextKey 用来区分不同的临时值，第二个参数则是要存储的临时值。\n第二个方法为 GetValue，从一个上下文(后面讲)当中根据 contextKey 获得存储的临时值。\n1 2 3 4 5 6 public interface IAmbientScopeProvider\u0026lt;T\u0026gt; { T GetValue(string contextKey); IDisposable BeginScope(string contextKey, T value); } 针对于该接口，其默认实现是 DataContextAmbientScopeProvider ，它的内部可能略微复杂，牵扯到了另一个接口 IAmbientDataContext 和 ScopeItem 类型。\n这两个类型一个是上下文，一个是包裹具体临时值对象的类型。我们先从 BeginScope() 方法开始看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // ScopeItem 的 Id 与其值关联的字典，其键为 Guid，值为具体的 ScopeItem 对象，这里并未与 ContextKey 进行关联。 private static readonly ConcurrentDictionary\u0026lt;string, ScopeItem\u0026gt; ScopeDictionary = new ConcurrentDictionary\u0026lt;string, ScopeItem\u0026gt;(); // 数据的上下文对象，管理 ContextKey 与其 Id。 private readonly IAmbientDataContext _dataContext; public IDisposable BeginScope(string contextKey, T value) { // 将需要临时存储的对象，用 ScopeItem 包装起来，它的外部对象是当前对象 (如果存在的话)。 var item = new ScopeItem(value, GetCurrentItem(contextKey)); // 将包装好的对象以 Id-对象，的形式存储在字典当中。 if (!ScopeDictionary.TryAdd(item.Id, item)) { throw new AbpException(\u0026#34;Can not add item! ScopeDictionary.TryAdd returns false!\u0026#34;); } // 在上下文当中设置当前的 ContextKey 关联的 Id。 _dataContext.SetData(contextKey, item.Id); // 集合释放委托，using 语句块结束时，做释放操作。 return new DisposeAction(() =\u0026gt; { // 从字典中移除指定 Id 的对象。 ScopeDictionary.TryRemove(item.Id, out item); // 如果包装对象没有外部对象，直接设置上下文关联的 Id 为 NULL。 if (item.Outer == null) { _dataContext.SetData(contextKey, null); return; } // 如果还有外部对象，则设置上下文关联的 Id 为外部对象的 I的。 _dataContext.SetData(contextKey, item.Outer.Id); }); } 从上面的逻辑可以看出来，每次我们加入的临时值都是通过 ScopeItem 包裹起来的。而这个 ScopeItem 与我们的工作单元相似，它会有一个外部连接的对象。这个外部连接对象的作用就是解决 using 语句嵌套问题的，例如我们有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public void TestMethod() { using(AbpSession.Use(1,2,\u0026#34;3\u0026#34;)) { // 一些业务逻辑 // ScopeItem.Outer = null; using(AbpSession.Use(4,5,\u0026#34;6\u0026#34;)) { // 一些业务逻辑 // ScopeItem.Outer = 外部对象; } } } 那么我们在这里会有同一个 ContextKey，都是提供给 AbpSession 使用的。第一次我在 Use() 内部通过 BeginScope() 方法创建了一个 ScopeItem 对象，包装了临时值，这个 ScopeItem 的外部对象为 NULL。第二次我又在内部创建了一个 ScopeItem 对象，包装了第二个临时值，这个时候 ScopeItem 的外部对象就是第一次包装的对象了。\n执行释放操作的时候，首先判断外部对象是否为空。如果为空则直接在上下文当中将绑定的 ScopeItem 的 Id 值设为 NULL，如果不为空，则设置为它的外部对象的 Id。\n还是以上面的代码为例，在 Dispose() 被执行之后，由内而外，到最外层的时候在上下文与 ContextKey 关联的 Id 已经被置为 NULL 了。\n1 2 3 4 5 6 7 private ScopeItem GetCurrentItem(string contextKey) { // 从数据上下文获取指定 ContextKey 当前关联的 Id 值。 var objKey = _dataContext.GetData(contextKey) as string; // 不存在则返回 NULL，存在则尝试以 Id 从字典中拿取对象外部，并返回。 return objKey != null ? ScopeDictionary.GetOrDefault(objKey) : null; } 分析了一下 IAmbientDataContext 的实现，感觉与 ICurrentUnitOfWorkProvider 类似，内部都是通过 AsyncLocal 来进行处理的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class AsyncLocalAmbientDataContext : IAmbientDataContext, ISingletonDependency { // 这里的字典是以 ContextKey 与 ScopeItem 的 Id 构成的。 private static readonly ConcurrentDictionary\u0026lt;string, AsyncLocal\u0026lt;object\u0026gt;\u0026gt; AsyncLocalDictionary = new ConcurrentDictionary\u0026lt;string, AsyncLocal\u0026lt;object\u0026gt;\u0026gt;(); public void SetData(string key, object value) { // 设置指定 ContextKey 对应的 Id 值。 var asyncLocal = AsyncLocalDictionary.GetOrAdd(key, (k) =\u0026gt; new AsyncLocal\u0026lt;object\u0026gt;()); asyncLocal.Value = value; } public object GetData(string key) { // 获取指定 ContextKey 对应的 Id 值。 var asyncLocal = AsyncLocalDictionary.GetOrAdd(key, (k) =\u0026gt; new AsyncLocal\u0026lt;object\u0026gt;()); return asyncLocal.Value; } } 从开始到这里使用并行字典的情况来看，这里这么做的原因很简单，是为了处理异步上下文切换的情况，确保 ContextKey 对应的 Id 是一致的，防止在 Get/Set Data 的时候出现 意外的情况。\n最后呢在具体的 Session 实现类 ClaimsAbpSession 当中要获取 UserId 会经过下面的步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public override long? UserId { get { // 尝试从临时对象中获取数据。 if (OverridedValue != null) { return OverridedValue.UserId; } // 从 JWT Token 当中获取 UserId 信息。 return userId; } } 最后我再贴上 ScopeItem 的定义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private class ScopeItem { public string Id { get; } public ScopeItem Outer { get; } public T Value { get; } public ScopeItem(T value, ScopeItem outer = null) { Id = Guid.NewGuid().ToString(); Value = value; Outer = outer; } } 这个临时值变更可能是 Abp 用法当中最为复杂的一个，牵扯到了异步上下文和 using 语句嵌套的问题。但仔细阅读源码之后，其实有一种豁然开朗的感觉，也加强了对于 C# 程序设计的理解。\n三、结语 通过学习 Abp 框架，也了解了自己在基础方面的诸多不足。其次也是能够看到一些比较实用新奇的写法，你也可以在自己项目中进行应用，本文主要是起一个抛砖引玉的作用。最近年底了，事情也比较多，博客也是疏于更新。后面会陆续恢复博文更新，尽量 2 天 1 更，新年新气象。\n","date":"2019-01-16T01:27:56Z","permalink":"https://real-zony.github.io/p/three-practical-ways-to-combine-using-block-in-csharp/","title":"C# 结合 using 语句块的三种实用方法"},{"content":"一、背景 在实际项目的开发当中，使用 Abp Zero 自带的审计日志功能写入效率比较低。其次审计日志数据量中后期十分庞大，不适合与业务数据存放在一起。所以我们可以重新实现 Abp 的 IAuditingStore 接口，来让我们的审计日志数据存储在 MongoDb 当中。\n二、实现 2.0 引入相关包 这里我们需要在模块项目引入 Abp 与 mongocsharpdriver 包，引入之后项目如下图。\n2.1 实体封装 基于 Abp 框架的设计，它许多组件都可以随时被我们所替换。这里我们先定义存储到 MongoDb 数据库的实体，取名叫做 MongoDbAuditEntity。下面就是它的基本定义，它是我从 Zero 里面单独扒出来的，是基于 Abp 的审计信息定义重新进行封装的一个实体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 using System; using System.Linq; using Abp.Extensions; using Abp.Runtime.Validation; using Abp.UI; namespace Abp.Auditing.MongoDb { /// \u0026lt;summary\u0026gt; /// 审计日志记录实体，仅用于 MongoDb 存储使用。 /// \u0026lt;/summary\u0026gt; public class MongoDbAuditEntity { /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;ServiceName\u0026#34;/\u0026gt; 属性的最大长度。 /// \u0026lt;/summary\u0026gt; public static int MaxServiceNameLength = 256; /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;MethodName\u0026#34;/\u0026gt; 属性的最大长度。 /// \u0026lt;/summary\u0026gt; public static int MaxMethodNameLength = 256; /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;Parameters\u0026#34;/\u0026gt; 属性的最大长度。 /// \u0026lt;/summary\u0026gt; public static int MaxParametersLength = 1024; /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;ClientIpAddress\u0026#34;/\u0026gt; 属性的最大长度。 /// \u0026lt;/summary\u0026gt; public static int MaxClientIpAddressLength = 64; /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;ClientName\u0026#34;/\u0026gt; 属性的最大长度。 /// \u0026lt;/summary\u0026gt; public static int MaxClientNameLength = 128; /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;BrowserInfo\u0026#34;/\u0026gt; 属性的最大长度。 /// \u0026lt;/summary\u0026gt; public static int MaxBrowserInfoLength = 512; /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;Exception\u0026#34;/\u0026gt; 属性的最大长度。 /// \u0026lt;/summary\u0026gt; public static int MaxExceptionLength = 2000; /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;CustomData\u0026#34;/\u0026gt; 属性的最大长度。 /// \u0026lt;/summary\u0026gt; public static int MaxCustomDataLength = 2000; /// \u0026lt;summary\u0026gt; /// 调用接口时用户的编码，如果是匿名访问，则可能为 null。 /// \u0026lt;/summary\u0026gt; public string UserCode { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口时用户的集团 Id，如果是匿名访问，则可能为 null。 /// \u0026lt;/summary\u0026gt; public int? GroupId { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口时，请求的应用服务/控制器名称。 /// \u0026lt;/summary\u0026gt; public string ServiceName { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口时，请求的的具体方法/接口名称。 /// \u0026lt;/summary\u0026gt; public string MethodName { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口时，传递的具体参数。 /// \u0026lt;/summary\u0026gt; public string Parameters { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口的时间，以服务器的时间进行记录。 /// \u0026lt;/summary\u0026gt; public DateTime ExecutionTime { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口执行方法时所消耗的时间，以毫秒为单位。 /// \u0026lt;/summary\u0026gt; public int ExecutionDuration { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口时客户端的 IP 地址。 /// \u0026lt;/summary\u0026gt; public string ClientIpAddress { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口时客户端的名称(通常为计算机名)。 /// \u0026lt;/summary\u0026gt; public string ClientName { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口的浏览器信息。 /// \u0026lt;/summary\u0026gt; public string BrowserInfo { get; set; } /// \u0026lt;summary\u0026gt; /// 调用接口时如果产生了异常，则记录在本字段，如果没有异常则可能 null。 /// \u0026lt;/summary\u0026gt; public string Exception { get; set; } /// \u0026lt;summary\u0026gt; /// 自定义数据 /// \u0026lt;/summary\u0026gt; public string CustomData { get; set; } /// \u0026lt;summary\u0026gt; /// 从给定的 \u0026lt;see cref=\u0026#34;auditInfo\u0026#34;/\u0026gt; 审计信息创建一个新的 MongoDb 审计日志实体 /// (\u0026lt;see cref=\u0026#34;MongoDbAuditEntity\u0026#34;/\u0026gt;)。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;auditInfo\u0026#34;\u0026gt;原始审计日志信息。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;创建完成的 \u0026lt;see cref=\u0026#34;MongoDbAuditEntity\u0026#34;/\u0026gt; 实体对象。\u0026lt;/returns\u0026gt; public static MongoDbAuditEntity CreateFromAuditInfo(AuditInfo auditInfo) { var expMsg = GetAbpClearException(auditInfo.Exception); return new MongoDbAuditEntity { UserCode = auditInfo.UserId?.ToString(), GroupId = null, ServiceName = auditInfo.ServiceName.TruncateWithPostfix(MaxServiceNameLength), MethodName = auditInfo.MethodName.TruncateWithPostfix(MaxMethodNameLength), Parameters = auditInfo.Parameters.TruncateWithPostfix(MaxParametersLength), ExecutionTime = auditInfo.ExecutionTime, ExecutionDuration = auditInfo.ExecutionDuration, ClientIpAddress = auditInfo.ClientIpAddress.TruncateWithPostfix(MaxClientIpAddressLength), ClientName = auditInfo.ClientName.TruncateWithPostfix(MaxClientNameLength), BrowserInfo = auditInfo.BrowserInfo.TruncateWithPostfix(MaxBrowserInfoLength), Exception = expMsg.TruncateWithPostfix(MaxExceptionLength), CustomData = auditInfo.CustomData.TruncateWithPostfix(MaxCustomDataLength) }; } public override string ToString() { return string.Format( \u0026#34;审计日志: {0}.{1} 由用户 {2} 执行，花费了 {3} 毫秒，请求的源 IP 地址为: {4} 。\u0026#34;, ServiceName, MethodName, UserCode, ExecutionDuration, ClientIpAddress ); } /// \u0026lt;summary\u0026gt; /// 创建更加清楚明确的异常信息。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;exception\u0026#34;\u0026gt;要处理的异常数据。\u0026lt;/param\u0026gt; private static string GetAbpClearException(Exception exception) { var clearMessage = \u0026#34;\u0026#34;; switch (exception) { case null: return null; case AbpValidationException abpValidationException: clearMessage = \u0026#34;异常为参数验证错误，一共有 \u0026#34; + abpValidationException.ValidationErrors.Count + \u0026#34;个错误:\u0026#34;; foreach (var validationResult in abpValidationException.ValidationErrors) { var memberNames = \u0026#34;\u0026#34;; if (validationResult.MemberNames != null \u0026amp;\u0026amp; validationResult.MemberNames.Any()) { memberNames = \u0026#34; (\u0026#34; + string.Join(\u0026#34;, \u0026#34;, validationResult.MemberNames) + \u0026#34;)\u0026#34;; } clearMessage += \u0026#34;\\r\\n\u0026#34; + validationResult.ErrorMessage + memberNames; } break; case UserFriendlyException userFriendlyException: clearMessage = $\u0026#34;业务相关错误，错误代码: {userFriendlyException.Code} \\r\\n 异常详细信息: {userFriendlyException.Details}\u0026#34;; break; } return exception + (string.IsNullOrEmpty(clearMessage) ? \u0026#34;\u0026#34; : \u0026#34;\\r\\n\\r\\n\u0026#34; + clearMessage); } } } 2.2 编写 MongoDb 配置类 一般来说，我们编写一个 Abp 模块肯定是需要构建一个配置类的，以便其他开发人员在使用我们的模块可以进行一些自定义配置。这里我们的 MongoDb 审计日志模块无非就是需要配置两个信息，第一个就是 MongoDb 数据库的连接字符串，第二个就是要存储的库名称。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// \u0026lt;summary\u0026gt; /// 审计日志的 MongoDb 存储模块。 /// \u0026lt;/summary\u0026gt; public interface IAuditingMongoDbConfiguration { /// \u0026lt;summary\u0026gt; /// MongoDb 连接字符串。 /// \u0026lt;/summary\u0026gt; string ConnectionString { get; set; } /// \u0026lt;summary\u0026gt; /// 要连接的 MongoDb 数据库名称 /// \u0026lt;/summary\u0026gt; string DataBaseName { get; set; } } 同理，再编写一个实现。\n1 2 3 4 5 6 public class AuditingMongoDbConfiguration : IAuditingMongoDbConfiguration { public string ConnectionString { get; set; } public string DataBaseName { get; set; } } 2.3 编写 IMongoClient 的工厂类 其实你直接 new 也可以，这里编写一个工厂类是省去一些构建流程而已，首先为工厂类定义一个接口，该接口只有一个方法，就是创建 IMongoClient 的实例对象。\n1 2 3 4 public interface IMongoClientFactory { IMongoClient Create(); } 这个工厂的实现也很简单，只不过我们在工厂当中注入了 IAuditingMongoDbConfiguration ，方便我们创建实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MongoClientFactory : IMongoClientFactory { private readonly IAuditingMongoDbConfiguration _mongoDbConfiguration; public MongoClientFactory(IAuditingMongoDbConfiguration mongoDbConfiguration) { _mongoDbConfiguration = mongoDbConfiguration; } public IMongoClient Create() { return new MongoClient(_mongoDbConfiguration.ConnectionString); } } 2.4 审计日志的具体存储动作 上面几点都是做一些准备工作，下面我们需要实现 IAuditingStore 接口，以便将我们的审计日志存储在 MongoDb 数据库当中。IAuditingStore 接口只定义了一个方法，就是 SaveAsync(AuditInfo auditInfo) 方法。该方法是在每次接口请求的时候，通过过滤器/拦截器的时候会被调用。当然整个审计日志的构成不是这么简单的，如果大家有兴趣可以查看我的另一篇博客 [《Abp 源码分析] 十五、自动审计记录》 ，在这篇博客有详细讲述审计日志的相关知识。\n我们接着继续，因为 SaveAsync(AuditInfo auditInfo) 方法传入了一个 AuditInfo 对象，我们就可以基于这个对象来构造我们的数据实体。构造完成之后，将其通过 IMongoClient 对象存储到 MongoDb 数据库当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /// \u0026lt;summary\u0026gt; /// \u0026lt;see cref=\u0026#34;IAuditingStore\u0026#34;/\u0026gt; 的特殊实现，使用的是 MongoDb 作为持久化存储。 /// \u0026lt;/summary\u0026gt; public class MongoDbAuditingStore : IAuditingStore { private readonly IMongoClientFactory _clientFactory; private readonly IAuditingMongoDbConfiguration _mongoDbConfiguration; public MongoDbAuditingStore(IMongoClientFactory clientFactory, IAuditingMongoDbConfiguration mongoDbConfiguration) { _clientFactory = clientFactory; _mongoDbConfiguration = mongoDbConfiguration; } public async Task SaveAsync(AuditInfo auditInfo) { var entity = MongoDbAuditEntity.CreateFromAuditInfo(auditInfo); await _clientFactory.Create() .GetDatabase(_mongoDbConfiguration.DataBaseName) .GetCollection\u0026lt;MongoDbAuditEntity\u0026gt;(typeof(MongoDbAuditEntity).Name) .InsertOneAsync(entity); } } 可以看到整体代码还是十分简单的，直接通过 auditInfo 对象构造好数据实体之后，插入到 MongoDb 数据库当中。\n2.5 编写模块类 每一个基于 Abp 的第三方模块都会有一个模块类，模块类的主要作用就是针对于第三方模块进行一些基本配置，以及对一些组件的替换动作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using Abp.Auditing.MongoDb.Configuration; using Abp.Auditing.MongoDb.Infrastructure; using Abp.Dependency; using Abp.Modules; namespace Abp.Auditing.MongoDb { [DependsOn(typeof(AbpKernelModule))] public class AbpAuditingMongoDbModule : AbpModule { public override void PreInitialize() { IocManager.Register\u0026lt;IAuditingMongoDbConfiguration,AuditingMongoDbConfiguration\u0026gt;(); IocManager.Register\u0026lt;IMongoClientFactory,MongoClientFactory\u0026gt;(); // 替换自带的审计日志存储实现 Configuration.ReplaceService(typeof(IAuditingStore),() =\u0026gt; { IocManager.Register\u0026lt;IAuditingStore, MongoDbAuditingStore\u0026gt;(DependencyLifeStyle.Transient); }); } public override void Initialize() { IocManager.RegisterAssemblyByConvention(typeof(AbpAuditingMongoDbModule).Assembly); } } } 2.6 编写集成的扩展方法 Abp 模块都会基于 IModuleConfigurations 接口编写一个扩展方法，这样其他基于 Abp 框架的项目开发人员就可以很方便地在其启动模块的 PreInitialzie() 方法当中通过 Configuration.Modules 来进行配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /// \u0026lt;summary\u0026gt; /// MongoDb 审计日志存储提供器的配置类的扩展方法。 /// \u0026lt;/summary\u0026gt; public static class AuditingMongoDbConfigurationExtensions { /// \u0026lt;summary\u0026gt; /// 配置审计日志的 MongoDb 实现的相关参数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;modules\u0026#34;\u0026gt;模块配置类\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;connectString\u0026#34;\u0026gt;MongoDb 连接字符串。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;dataBaseName\u0026#34;\u0026gt;要操作的 MongoDb 数据库。\u0026lt;/param\u0026gt; public static void ConfigureMongoDbAuditingStore(this IModuleConfigurations modules,string connectString,string dataBaseName) { var configuration = modules.AbpConfiguration.Get\u0026lt;IAuditingMongoDbConfiguration\u0026gt;(); configuration.ConnectionString = connectString; configuration.DataBaseName = dataBaseName; } } 三、测试 新建一个项目，并添加对我们库的引用，在其启动模块当中添加对 AbpAuditingMongoDbModule 模块的依赖，在其 PreInitialize() 方法当中加入以下代码，以配置审计日志相关功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [DependsOn(typeof(AbpAuditingMongoDbModule))] public class StartupModule : AbpModule { public override void PreInitialize() { // 其他代码... // 开启审计日志记录 Configuration.Auditing.IsEnabled = true; // 允许记录匿名用户请求 Configuration.Auditing.IsEnabledForAnonymousUsers = true; // 配置 MonggoDb 数据库地址与名称 Configuration.Modules.ConfigureMongoDbAuditingStore(\u0026#34;mongodb://username:Zpassword@ip:port\u0026#34;,\u0026#34;TestDataBase\u0026#34;); // 其他代码... } } 启动项目之后，我们尝试访问测试方法，之后来到 MongoDb 数据库当中，查看具体的审计日志信息。\n可以看到，所有对接口的请求都被记录到了 MongoDb 当中，这样后续可以基于这些数据进行二次分析。\n四、结语 Abp.Auditing.MongoDb 包下载地址\nAbp.Auditing.MongoDb 包 GitHub 地址\n","date":"2019-01-14T02:08:31Z","permalink":"https://real-zony.github.io/p/abp-mongodb-retrofits-the-default-audit-log-storage-location/","title":"Abp + MongoDb 改造默认的审计日志存储位置"},{"content":"一、.NET 开发 1. 必装 软件名称 说明 下载地址 JetBrains Toolbox JetBrins 全家桶管理工具。 下载地址 JetBrains Rider 跨平台 .NET 开发 IDE，支持 .NET Core 程序开发。 Toolbox 安装 JetBrains GoLand 跨平台 Golang 的 IDE。 Toolbox 安装 JetBrains DataGrip 类 SQL 数据库管理工具，支持 MySQL 与 SQL Server。 Toolbox 安装 .NET Core SDK .NET Core 跨平台的 SDK。 下载地址 Git for Windows Git 的 Windows 客户端。 下载地址 dotMemory .NET 内存泄漏分析工具。 Toolbox 安装 dotTrace .NET 性能分析工具。 Toolbox 安装 dotPeek .NET 反编译工具。 Toolbox 安装 Navicat Premium 12 Windows 下最好的数据库管理工具之一，支持 数据库之间的结构/数据同步。最新版本支持 MongoDb 数据库的管理。 下载地址 Redis Desktop Manager Redis 数据库的 GUI 管理工具。 下载地址 2. 备选 软件名称 说明 下载地址 Visual Studio 2017 企业版 宇宙第一 IDE，支持 C# 与 C++ 开 发，但资源占用过高。 下载地址 dotFX .NET 平台下生成自己库的 XML 描述文件 来生成 API 文档站点。 下载地址 二、服务器管理软件 软件名称 说明 下载地址 XShell Windows 下最好用的 SSH 连接管理工具。 下载地址 WinSCP 通过 SCP 协议在 Linux 服务器与 Windows 之 间传输文件。 下载地址 三、网络相关工具 软件名称 说明 下载地址 Fiddler 4 接口抓包工具，比较适合 HTTP API 接口 抓包。 下载地址 Wireshark TCP/UDP 层级的抓包工具，功能强大。 下载地址 Tcping 可以通过 IP + 端口检测服务器某个端口的 Ping 值。 下载地址 Best Trace 可视化的路由追踪工具。 下载地址 WakeMeOnLan 远程开机的小工具，发送魔术包到指定 IP，远程唤醒 机器。 下载地址 四、文本编辑器 软件名称 说明 下载地址 Typora Windows 下最好的 Markdown 编辑器。 下载地址 Notepad++ 轻量级文件编辑器，支持多种格式的文件，打开 文件快速。 下载地址 Visual Studio Code 轻量级的文件格式化编辑器，支持 XML 与 JSON 等多种文件。 下载地址 Boostnote 程序员专用的笔记工具，跨平台软件，支持 Markdown 并 且也是一个开源软件。 下载地址 五、群晖软件 软件名称 说明 下载地址 Synology Note Station 群晖云笔记同步工具。 下载地址 Synology Drive 群晖文件同步工具。 下载地址 六、即时通讯 必装： 软件名称 说明 下载地址 TIM 清爽简洁的 QQ 聊天工具。 下载地址 微信 PC 支持微信在电脑端登录。 下载地址 可选： 软件名称 说明 下载地址 YY 语音 组队开黑吹逼必备，推荐使用绿色版。 下载地址 七、压缩工具 软件名称 说明 下载地址 7z 开源且强大的压缩/解压软件。 下载地址 WinRAR Windows 平台下最强大的压缩/解压软件。 下载地址 八、办公工具 软件名称 说明 下载地址 Microsoft Office Word Office 三件套必备。 通过工具安装 Microsoft Office Excel Office 三件套必备。 通过工具安装 Microsoft Office PPT Office 三件套必备。 通过工具安装 Microsoft Outlook 支持多个邮箱账户的客户端。 通过工具安装 Office 2013-2019 C2R Install 可以快速安装想要的 Office 组件，支持 VOL 与 零售版本的选择。 下载地址 Microsoft To-Do 简洁好用的 GTD 工具，方便管理日程，并且 支持多端同步。 下载地址 九、PDF 阅读工具 软件名称 说明 下载地址 SumatraPDF 轻量级的 PDF 阅读软件，拥有绿色版，打开 文件快速，功能齐全。 下载地址 十、输入法 软件名称 说明 下载地址 小狼毫 不需要联网的输入法，结合群晖 NAS 同步词库。 高度可自定义，并且界面美观。 下载地址 十一、音视频播放器 软件名称 说明 下载地址 foobar 2000 绿色的音乐播放器。 下载地址 PotPlayer 视频播放器，支持硬解码与 SMB 和 WebDAV 协议。 下载地址 十二、虚拟机 (可选) 软件名称 说明 下载地址 VMware WorkStation 15 Windows 下最好用的虚拟机工具之一。 下载地址 Docker for Windows Docker 容器软件的 Windows 版本。 下载地址 十三、效率软件 软件名称 说明 下载地址 Everything 能够以毫秒级的速度搜索到所有硬盘的文件/目录。 下载地址 Wox 结合 Everything 可以快速定位磁盘当中 的文件路径。 下载地址 Seer 支持随时按空格键快速预览文件信息。 下载地址 DropIt 能够快速预览文件的内容，不需要打开文件。 下载地址 十四、截图工具 软件名称 说明 下载地址 ScreenToGif 支持 GIF 录屏的小工具。 下载地址 Snipaste 很好用的截图工具。 下载地址 十五、梯子 软件名称 说明 下载地址 SSR 小飞机客户端。 下载地址 十六、接口测试工具 软件名称 说明 下载地址 Postman 比较好用的 HTTP API 接口测试工具。 下载地址 十七、密码管理工具 软件名称 说明 下载地址 KeePass Windows 下最好用的免费开源的密码管理工具。 下载地址 十八、图片浏览器 软件名称 说明 下载地址 蜂蜜浏览器(Honeyview) 免费好用的图片浏览器，无广告，界面简洁。 下载地址 十九、系统扫描与清理 软件名称 说明 下载地址 SpaceSniffer 能够扫描指定磁盘下的文件，并以图形的 方式直观展示各个文件/文件夹的占用空间。 下载地址 Dism++ 轻量且免费的垃圾清理工具，有免安装版本。综合 来说，其功能与效果还可以。 下载地址 备选 软件名称 说明 下载地址 CCleaner 备受好评的系统清理工具，有免费版，但 免费版的功能限制较多。 下载地址 二十、网页浏览器 软件名称 说明 下载地址 Google Chrome 谷歌浏览器。 下载地址 二十一、系统监控 软件名称 说明 下载地址 TrafficMonitor 网络流量与 CPU 和内存使用率监控。 下载地址 二十二、其他组件 软件名称 说明 下载地址 Windows LSTC 版本的 Microsoft 商店恢复 因为 Microsoft Windows LSTC 企业版 是不包含商店的，所以要使用商店 的话就需要这个工具进行恢复。 下载地 ","date":"2019-01-13T11:35:19Z","image":"https://real-zony.github.io/cover.jpg","permalink":"https://real-zony.github.io/p/personally-organized-software-for-net-development-under-windows/","title":"个人整理的 Windows 下 .NET 开发必装的软件"},{"content":"一、背景 在平时开发过程当中需要针对 MySQL 数据库进行监控，这里我们可以使用 Grafana 和 Prometheus 来实现监控功能。Grafana 是一款功能强大的仪表盘面板，支持多种数据源，可以自定义图表进行监控。而 Prometheus 就是 Grafana 支持的数据源之一，Prometheus 负责采集需要监控的数据，然后通过 Grafana 展示出来。\nPrometheus 拥有多种 Exporter 进行监控数据的导出，这里我们使用的是 Mysql Exporter 来进行数据库状态的监控。\n很久没写博客了，最近实在太忙，工作之余在研究 Abp vNext。\n二、动手实践 首先参考博文《Linux 下的 Docker 安装与使用》安装好 Docker，之后再参考博文 《CentOS 7.x 安装 Docker-Compose》安装好 Docker-Compose 之后，就可以开始我们的工作了。\n2.1 编写 Docker-Compose.Yaml 文件 首先我们确定会启动起来三个服务，分别是 MySQL-Exporter (监控 MySQL 指标)、Prometheus (收集 Exporter 的数据)、Grafana (从 Prometheus 读取指标数据，并展示出来)。\n所以 yaml 文件的内容大体如下，这里也增加了响应的注释方便大家学习。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 version: \u0026#39;2\u0026#39; services: exporter: container_name: mysql-exporter-dev image: prom/mysqld-exporter environment: # 这里指定的是要监控的 MySQL 数据库，这里我们以启动的 test-mysql 容器为示范。 # 实际应用当中，应该配置为具体的数据库实例。 - DATA_SOURCE_NAME=root:root@(test-mysql:3306)/ prometheus: container_name: prometheus image: prom/prometheus ports: - \u0026#34;20001:9090\u0026#34; # 映射普罗米修斯的配置文件，用于配置 Exporter，这里的文件应该在后面创建好，具体 # 路径以实际为准。 volumes: - /root/Docker/Volumes/Prometheus/prometheus.yml:/etc/prometheus/prometheus.yml grafana: container_name: grafana image: grafana/grafana environment: # 配置 Grafana 的默认根 URL。 - GF_SERVER_ROOT_URL=http://192.168.100.107:20002 # 配置 Grafana 的默认 admin 密码。 - GF_SECURITY_ADMIN_PASSWORD=admin ports: - \u0026#34;20002:3000\u0026#34; # 映射 Grafana 的数据文件，方便后面进行更改。 volumes: - /root/Docker/Volumes/Grafana:/var/lib/grafana # 本服务只是用于演示，实际使用请注释掉本服务。 mysql: container_name: test-mysql image: mysql environment: - MYSQL_ROOT_PASSWORD=root # 这里如果需要连接外部 MySQL 就需要处在同一个网络。 networks: default: external: name: mysql-monitor 2.2 配置 prometheus.yml 文件 在 prometheus.yaml 文件当中存储了所有 Exporter 的信息，所以我们需要创建一个自己的 prometheus.yml 文件，映射到容器当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 global: scrape_interval: 15s evaluation_interval: 15s alerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093 scrape_configs: # Prometheus 监控配置 - job_name: \u0026#39;prometheus\u0026#39; static_configs: - targets: [\u0026#39;prometheus:9090\u0026#39;] # MySQL 监控配置 - job_name: \u0026#39;mysql\u0026#39; # 抓取间隔 scrape_interval: 5s static_configs: # 这里配置的是具体的 MySQL Exporter 的地址，在之前的 docker compose 文件 # 定义当中，mysql exporter 的容器名为 mysql-exporter-dev。 - targets: [\u0026#39;mysql-exporter-dev:9104\u0026#39;] 2.3 启动 首先我们要建立一个监控用的 Docker 网络，与 Docker Compose 文件对应：\n1 docker network create mysql-monitor 假设 yaml 文件名称为 docker-compose.yaml ，执行以下命令来创建我们的容器。\n1 docker-compose -f ./docker-compose.yaml -p MySQL-Monitor up -d 但是呢，有时候可能会提示以下信息，说没有对应的权限，这个时候你使用 chmod 命令改变以下 Grafana 文件夹的权限即可。\n1 chmod -R 777 /root/Docker/Volumes/Grafana 之后，再次运行 docker-compose -f ./docker-compose.yaml -p MySQL-Monitor up -d 命令，启动服务。第一次启动可能会有点慢，Grafana 需要迁移相关的数据，等待一会儿之后访问 机器IP:20002 就可以看到 Grafana 了。\n2.4 配置 首先我们需要在 Grafana 配置 Prometheus 数据源，登录 Grafana 之后，选择数据源。\n选择 Prometheus。\n之后在 URL 填入 Prometheus 的容器名字 + 端口，点击 Save \u0026amp; Test，这里一定要注意数据源的名字叫做 Prometheus，不然等会儿导入我的面板是无法使用的。\n导入我们的 Dashboard 文件。\n2.5 文件下载地址 DashBoard 文件点击我下载\n三、效果图 ","date":"2019-01-11T03:15:13Z","permalink":"https://real-zony.github.io/p/deploy-grafana-prometheus-with-docker-to-monitor-mysql-database/","title":"使用 Docker 部署 Grafana + Prometheus 监控 MySQL 数据库"},{"content":"一、安装步骤 添加企业版附加包。\n1 yum -y install epel-release 安装 PIP。\n1 yum -y install python-pip 更新 PIP。\n1 pip install --upgrade pip 安装 Docker Compose\n1 pip install docker-compose 二、可能遇到的问题 在执行 pip install docker-compose 命令的时候可能会提示以下内容：\n1 Cannot uninstall \u0026#39;requests\u0026#39;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall. 这个时候，你需要执行以下命令强制重新安装 request。\n1 pip install -I requests==2.9 安装完成之后，Docker-Compose 安装成功。\n三、二进制安装 下载最新版的 docker-compose 二进制执行文件。\n1 sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 配置可执行权限。\n1 sudo chmod +x /usr/local/bin/docker-compose 测试是否安装成功。\n1 docker-compose --version ","date":"2019-01-11T01:44:42Z","permalink":"https://real-zony.github.io/p/install-docker-compose-on-centos-7x/","title":"CentOS 7.x 安装 Docker-Compose"},{"content":"一、安装基本环境 1. 调整 SWAP 分区大小 (可选) 如果你的服务器配置内存过低，低于 4 G 的话都建议添加 SWAP 交换区。按照顺序依次执行以下代码：\n1 2 3 4 /bin/dd if=/dev/zero of=/var/swap.1 bs=1M count=8000 mkswap /var/swap.1 swapon /var/swap.1 sed -i \u0026#39;$a /var/swap.1 swap swap default 0 0\u0026#39; /etc/fstab 这里 count=8000 是你需要指定的 Swap 文件大小，你可以执行成你自己想要的交换文件大小，当然越大越好。\n2. 安装运行库 首先进行基本的系统更新，这里直接使用阿里云的 Yum 源进行更新，依次执行以下代码：\n1 2 3 4 5 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo yum clean all yum makecache yum -y update yum -y upgrade 下面就开始安装数据库与执行 GeoIP 编译所需要的必要文件，依然按次序执行下列代码：\n1 2 3 4 yum -y install gcc gcc-c++ make zlib-devel libc.so.6 libstdc++ glibc.i686 xulrunner.i686 libXtst.i686 unzip screen mysql-server chkconfig mysqld on service mysqld start service mysqld enable 二、上传服务端与数据库相关文件 找到附带的 服务端相关文件.zip 文件，如果你的操作系统是 macOS/Linux 的话，可以直接通过 scp 命令传输文件到你的服务端。\n1 scp ./服务端相关文件.zip root@[你服务器 IP]:/home 如果你是 Windows 操作系统，直接使用 WinSCP 将该文件上传到 /home 目录下。\n三、解压与编译相关文件 跳转到 /home 目录下，可以看到刚才上传的 ZIP 文件，执行以下命令进行解压：\n1 2 cd /home unzip ./服务端相关文件.zip 解压完成之后，你可以看到下图的文件结构。\n1. 解压 GeoIP 并编译相关文件 依次执行以下命令：\n1 2 3 4 5 6 7 cd /home unzip ./GeoIP-1.4.8.zip cd ./GeoIP-1.4.8 ./configure make \u0026amp;\u0026amp; make check \u0026amp;\u0026amp; make install cd /home rm -rf ./GeoIP-1.4.8.zip 2. 解压 lib.zip ，并移动到相应文件夹 依次执行以下命令：\n1 2 3 4 5 6 7 8 9 cd /home unzip ./lib.zip cd ./lib cp ./libGeoIP.so.1 /lib cp ./libGeoIP.so.1 /lib/libGeoIP.so cp ./libGeoIP.so.1 /lib/libGeoIP.so.1.4.8 cp ./libnxencryption.so /lib cd /home rm -rf ./lib.zip 3. 解压 neople.zip 依次执行以下命令：\n1 2 3 4 cd /home unzip ./neople.zip chmod -R 777 ./neople rm -rf ./neople.zip 4. 解压 MySQL 相关文件，并移动到相应文件夹 依次执行以下命令：\n1 2 3 service mysqld stop cd /home unzip ./mysql.zip -d /var/lib/ 执行之后会提示是否覆盖，输入大写 A ，然后按回车解压完成。\n更改目录权限为 777，防止无法访问数据库文件。\n1 2 3 chmod -R 777 /var/lib/mysql/ cd /home rm -rf mysql.zip 重启 MySQL 服务器：\n1 service mysqld restart 五、关闭防火墙 关闭 CentOS 6.x 自带的 iptables 防火墙。\n1 2 service iptables stop chkconfig iptables off 六、更改服务端相应的 IP 地址 执行以下命令，将 192.168.200.131 的 IP 更换成你自己的服务器 IP 地址。\n1 2 3 cd /home/neople/ sed -i \u0026#34;s/192.168.200.131/你服务器IP/g\u0026#34; `find . -type f -name \u0026#34;*.tbl\u0026#34;` sed -i \u0026#34;s/192.168.200.131/你服务器IP/g\u0026#34; `find . -type f -name \u0026#34;*.cfg\u0026#34;` 七、更改数据库表内的 IP 地址 使用 Navicat Premium 或者 DataGrip 之类的工具，连接上你服务器的 MySQL，端口是 3306，帐号为 root，密码为 uu5!^%jg。\n找到下表所对应的表，将内部所有字段的192.168.200.131 改成你自己的服务器 IP 地址。\n数据库名称 数据库表 数据库字段 d_taiwan db_connect db_ip d_taiwan dbab_db_connect_130516 db_ip taiwan_cain game.channel gc_ip 七、运行服务端 运行服务端的时候，请使用以下命令开启一个新的后台终端，这样在断开连接的时候也不会中断服务器运行。\n1 screen -S DNF 之后执行以下命令，跳转到 /home/neople 目录下，执行以下脚本。\n1 2 cd /home/neople ./run 等待服务端提示五国的时候，你就可以开始连接服务端了。\n服务端下载地址: 链接: https://pan.baidu.com/s/1j6bqACJuxKNASfz-LNO1tg 密码: ded0\n","date":"2019-01-05T06:33:11Z","permalink":"https://real-zony.github.io/p/dnf-server-installation-steps-based-on-centos-6x/","title":"DNF 服务端基于 CENTOS 6.x 进行安装步骤"},{"content":"在之前有些过一篇文章 《使用 DryIoc 替换 Abp 的 DI 框架》 ，在该文章里面我尝试通过以替换 IocManager 内部的 IContainer 来实现使用我们自己的 DI 框架。替换了之后我们基本上是可以正常使用了，不过仍然还存在有以下两个比较显著的问题。\n拦截器功能无法正常使用，需要重复递归查找真实类型，消耗性能。 针对于通过 IServiceCollection.AddScoped() 方法添加的 Scoped 类型的解析存在问题。 下面我们就来针对于上述问题进行问题的分析与解决。\n1. 问题 1 1.1 现象与原因 首先，来看一下问题 1 ，针对于问题 1 我在 Github 上面向作者请教了一下，造成嵌套注册的原因很简单。因为之所以我们解析的时候，原来的注册类型会解析出来代理类。\n关于上述原因可以参考 DryIoc 的 Github 问题 #50 。\n这是因为 DryIoc 是通过替换了原有注册类型的实现，而如果按照之前我们那篇文章的方法，每次注册事件被触发的时候就会针对注册类型嵌套一层代理类。这样如果某个类型有多个拦截器，这样就会造成一个类型嵌套的问题，在外层的拦截器被拦截到的时候无法获取到当前代理的真实类型。\n1.2 思路与解决方法 解决思路也比较简单，就是我们在注册某个类型的时候，触发了拦截器注入事件。在这个时候，我们并不真正的执行代理类的一个操作。而是将需要代理的类型与它的拦截器类型通过字典存储起来，然后在类型完全注册完成之后，通过遍历这个字典，我们来一次性地为每一个注册类型进行拦截器代理。\n思路清晰了，那么我们就可以编写代码来进行实现了，首先我们先为 IocManager 增加一个内部的字典，用于存储注册类-拦截器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class IocManager : IIocManager { // ... 其他代码 private readonly List\u0026lt;IConventionalDependencyRegistrar\u0026gt; _conventionalRegistrars; private readonly ConcurrentDictionary\u0026lt;Type, List\u0026lt;Type\u0026gt;\u0026gt; _waitRegisterInterceptor; // ... 其他代码 public IocManager() { _conventionalRegistrars = new List\u0026lt;IConventionalDependencyRegistrar\u0026gt;(); _waitRegisterInterceptor = new ConcurrentDictionary\u0026lt;Type, List\u0026lt;Type\u0026gt;\u0026gt;(); } // ... 其他代码 } 之后我们需要开放两个方法用于为指定的注册类型添加对应的拦截器，而不是在类型注册事件被触发的时候直接生成代理类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public interface IIocRegistrar { // ... 其他代码 /// \u0026lt;summary\u0026gt; /// 为指定的类型添加拦截器 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TService\u0026#34;\u0026gt;注册类型\u0026lt;/typeparam\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TInterceptor\u0026#34;\u0026gt;拦截器类型\u0026lt;/typeparam\u0026gt; void AddInterceptor\u0026lt;TService, TInterceptor\u0026gt;() where TInterceptor : IInterceptor; /// \u0026lt;summary\u0026gt; /// 为指定的类型添加拦截器 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;serviceType\u0026#34;\u0026gt;注册类型\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;interceptor\u0026#34;\u0026gt;拦截器类型\u0026lt;/param\u0026gt; void AddInterceptor(Type serviceType,Type interceptor); // ... 其他代码 } public class IocManager : IIocManager { // ... 其他代码 /// \u0026lt;inheritdoc /\u0026gt; public void AddInterceptor\u0026lt;TService, TInterceptor\u0026gt;() where TInterceptor : IInterceptor { AddInterceptor(typeof(TService),typeof(TInterceptor)); } /// \u0026lt;inheritdoc /\u0026gt; public void AddInterceptor(Type serviceType, Type interceptorType) { if (_waitRegisterInterceptor.ContainsKey(serviceType)) { var interceptors = _waitRegisterInterceptor[serviceType]; if (interceptors.Contains(interceptorType)) return; _waitRegisterInterceptor[serviceType].Add(interceptorType); } else { _waitRegisterInterceptor.TryAdd(serviceType, new List\u0026lt;Type\u0026gt; {interceptorType}); } } // ... 其他代码 } 然后针对所有拦截器的监听事件进行替换，例如工作单元拦截器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 internal static class UnitOfWorkRegistrar { /// \u0026lt;summary\u0026gt; /// 注册器初始化方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;iocManager\u0026#34;\u0026gt;IOC 管理器\u0026lt;/param\u0026gt; public static void Initialize(IIocManager iocManager) { // 事件监听处理 iocManager.RegisterTypeEventHandler += (manager, type, implementationType) =\u0026gt; { HandleTypesWithUnitOfWorkAttribute(iocManager,type,implementationType.GetTypeInfo()); HandleConventionalUnitOfWorkTypes(iocManager,type, implementationType.GetTypeInfo()); }; // 校验当前注册类型是否带有 UnitOfWork 特性，如果有则注入拦截器 private static void HandleTypesWithUnitOfWorkAttribute(IIocManager iocManager,Type serviceType,TypeInfo implementationType) { if (IsUnitOfWorkType(implementationType) || AnyMethodHasUnitOfWork(implementationType)) { // 添加拦截器 iocManager.AddInterceptor(serviceType,typeof(UnitOfWorkInterceptor)); } } // 处理特定类型的工作单元拦截器 private static void HandleConventionalUnitOfWorkTypes(IIocManager iocManager,Type serviceType,TypeInfo implementationType) { // ... 其他代码 if (uowOptions.IsConventionalUowClass(implementationType.AsType())) { // 添加拦截器 iocManager.AddInterceptor(serviceType,typeof(UnitOfWorkInterceptor)); } } // ... 其他代码 } } 处理完成之后，我们需要在 RegisterAssemblyByConvention() 方法的内部真正地执行拦截器与代理类的生成工作，逻辑很简单，遍历之前的 _waitRegisterInterceptor 字典，依次使用 ProxyUtils 与 DryIoc 进行代理类的生成与绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class IocManager : IIocManager { // ... 其他代码 /// \u0026lt;summary\u0026gt; /// 使用已经存在的规约注册器来注册整个程序集内的所有类型。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;assembly\u0026#34;\u0026gt;等待注册的程序集\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;config\u0026#34;\u0026gt;附加的配置项参数\u0026lt;/param\u0026gt; public void RegisterAssemblyByConvention(Assembly assembly, ConventionalRegistrationConfig config) { var context = new ConventionalRegistrationContext(assembly, this, config); foreach (var registerer in _conventionalRegistrars) { registerer.RegisterAssembly(context); } if (config.InstallInstallers) { this.Install(assembly); } // 这里使用 TPL 并行库的原因是因为存在大量仓储类型与应用服务需要注册，应最大限度利用 CPU 来进行操作 Parallel.ForEach(_waitRegisterInterceptor, keyValue =\u0026gt; { var proxyBuilder = new DefaultProxyBuilder(); Type proxyType; if (keyValue.Key.IsInterface) proxyType = proxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(keyValue.Key, ArrayTools.Empty\u0026lt;Type\u0026gt;(), ProxyGenerationOptions.Default); else if (keyValue.Key.IsClass()) proxyType = proxyBuilder.CreateClassProxyTypeWithTarget(keyValue.Key,ArrayTools.Empty\u0026lt;Type\u0026gt;(),ProxyGenerationOptions.Default); else throw new ArgumentException($\u0026#34;类型 {keyValue.Value} 不支持进行拦截器服务集成。\u0026#34;); var decoratorSetup = Setup.DecoratorWith(useDecorateeReuse: true); // 使用 ProxyBuilder 创建好的代理类替换原有类型的实现 IocContainer.Register(keyValue.Key,proxyType, made: Made.Of(type=\u0026gt;type.GetConstructors().SingleOrDefault(c=\u0026gt;c.GetParameters().Length != 0), Parameters.Of.Type\u0026lt;IInterceptor[]\u0026gt;(request =\u0026gt; { var objects = new List\u0026lt;object\u0026gt;(); foreach (var interceptor in keyValue.Value) { objects.Add(request.Container.Resolve(interceptor)); } return objects.Cast\u0026lt;IInterceptor\u0026gt;().ToArray(); }), PropertiesAndFields.Auto), setup: decoratorSetup); }); _waitRegisterInterceptor.Clear(); } // ... 其他代码 } 这样的话，在调用控制器或者应用服务方法的时候能够正确的获取到真实的代理类型。\n图：\n可以看到拦截器不像原来那样是多个层级的情况，而是直接注入到代理类当中。\n通过 invocation 参数，我们也可以直接获取到被代理对象的真实类型。\n2. 问题 2 2.1 现象与原因 问题 2 则是由于 DryIoc 的 Adapter 针对于 Scoped 生命周期对象的处理不同而引起的，比较典型的情况就是在 Startup 类当中使用 IServiceCollection.AddDbContxt\u0026lt;TDbContext\u0026gt;() 方法注入了一个 DbContext 类型，因为其方法内部默认是使用 ServiceLifeTime.Scoped 周期来进行注入的。\n1 2 3 4 5 6 7 8 9 10 11 public static IServiceCollection AddDbContext\u0026lt;TContextService, TContextImplementation\u0026gt;( [NotNull] this IServiceCollection serviceCollection, [CanBeNull] Action\u0026lt;DbContextOptionsBuilder\u0026gt; optionsAction = null, ServiceLifetime contextLifetime = ServiceLifetime.Scoped, ServiceLifetime optionsLifetime = ServiceLifetime.Scoped) where TContextImplementation : DbContext, TContextService =\u0026gt; AddDbContext\u0026lt;TContextService, TContextImplementation\u0026gt;( serviceCollection, optionsAction == null ? (Action\u0026lt;IServiceProvider, DbContextOptionsBuilder\u0026gt;)null : (p, b) =\u0026gt; optionsAction.Invoke(b), contextLifetime, optionsLifetime); 按照正常的逻辑，一个 Scoped 对象的生命周期应该是与一个请求一致的，当请求结束之后该对象被释放，而且在该请求的生命周期范围内，通过 Ioc 容器解析出来的 Scoped 对象应该是同一个。如果有新的请求，则会创建一个新的 Scoped 对象。\n但是使用 DryIoc 替换了原有 Abp 容器之后，现在如果在一个控制器方法当中解析一个 Scoped 周期的对象，不论是几次请求获得的都是同一个对象。因为这种现象的存在，在 Abp 的 UnitOfWorkBase 当中完成一次数据库查询操作之后，会调用 DbContext 的 Dispose() 方法释放掉 DbContext。这样的话，在第二次请求因为获取的是同一个 DbContext，这样的话就会抛出对象已经被关闭的异常信息。\n除了开发人员自己注入的 Scoped 对象，在 Abp 的 Zero 模块内部重写了 Microsoft.Identity 相关组件，而这些组件也是通过 IServiceCollection.AddScoped() 方法与 IServiceCollection.TryAddScoped() 进行注入的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public static AbpIdentityBuilder AddAbpIdentity\u0026lt;TTenant, TUser, TRole\u0026gt;(this IServiceCollection services, Action\u0026lt;IdentityOptions\u0026gt; setupAction) where TTenant : AbpTenant\u0026lt;TUser\u0026gt; where TRole : AbpRole\u0026lt;TUser\u0026gt;, new() where TUser : AbpUser\u0026lt;TUser\u0026gt; { services.AddSingleton\u0026lt;IAbpZeroEntityTypes\u0026gt;(new AbpZeroEntityTypes { Tenant = typeof(TTenant), Role = typeof(TRole), User = typeof(TUser) }); //AbpTenantManager services.TryAddScoped\u0026lt;AbpTenantManager\u0026lt;TTenant, TUser\u0026gt;\u0026gt;(); //AbpEditionManager services.TryAddScoped\u0026lt;AbpEditionManager\u0026gt;(); //AbpRoleManager services.TryAddScoped\u0026lt;AbpRoleManager\u0026lt;TRole, TUser\u0026gt;\u0026gt;(); services.TryAddScoped(typeof(RoleManager\u0026lt;TRole\u0026gt;), provider =\u0026gt; provider.GetService(typeof(AbpRoleManager\u0026lt;TRole, TUser\u0026gt;))); //AbpUserManager services.TryAddScoped\u0026lt;AbpUserManager\u0026lt;TRole, TUser\u0026gt;\u0026gt;(); services.TryAddScoped(typeof(UserManager\u0026lt;TUser\u0026gt;), provider =\u0026gt; provider.GetService(typeof(AbpUserManager\u0026lt;TRole, TUser\u0026gt;))); //SignInManager services.TryAddScoped\u0026lt;AbpSignInManager\u0026lt;TTenant, TRole, TUser\u0026gt;\u0026gt;(); services.TryAddScoped(typeof(SignInManager\u0026lt;TUser\u0026gt;), provider =\u0026gt; provider.GetService(typeof(AbpSignInManager\u0026lt;TTenant, TRole, TUser\u0026gt;))); // ... 其他注入代码 return new AbpIdentityBuilder(services.AddIdentity\u0026lt;TUser, TRole\u0026gt;(setupAction), typeof(TTenant)); } 以上代码与 DbContext 产生的异常现象一致，都会导致每次请求获取的都是同一个对象，而 Abp 在底层会在每次请求结束后进行释放，这样也会造成后续请求访问到已经被释放的对象。\n上面这些仅仅是替换 DryIoc 框架后产生的异常现象，具体的原因在于 DryIoc 官方编写的 DryIoc.Microsoft.DependencyInjection 扩展。这是针对于 ASP.NET Core 自带的 DI 框架进行替换的 Adapter 适配器，大体原理就是通过实现 IServiceScopeFactory 接口与 IServiceScope 接口替换掉原有 DI 框架的实现。以实现接管容器注册与生命周期的管理。\n这里的重点就是 IServiceScopeFactory 接口，通过名字我们可以得知这是一个工厂，他拥有一个 CreateScope() 方法以创建一个 Scoped 范围。在 MVC 处理请求的时候，通过 CreateScope() 方法获得一个子容器，请求结束之后调用子容器的 Dispose() 方法进行释放。\n伪代码大概如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public void Request() { var factory = serviceProvider.GetService\u0026lt;IServiceScopeFactory\u0026gt;(); using(var scoped = factory.CreateScope()) { scoped.Resove\u0026lt;HomeController\u0026gt;().Index(); scoped.Resove\u0026lt;TestDbContext\u0026gt;(); } } public class HomeController : Controller { public HomeController(TestDbContext t1) { // 这里的 t1 在 scoped 子容器释放之后会被释放 } public IActionResult Index() { var t2 = IocManager.Instance.Resove\u0026lt;TestDbContext\u0026gt;(); } } 可以看到它通过 using 语句块包裹了 CreateScope() 方法，在 HomeController 解析的时候，其内部的 t1 对象是通过子容器进行解析创建出来的，那么它的生命周期跟随子容器的销毁而被销毁。子容器销毁的时间则是在一次 Http 请求结束之后，那么我们每次请求的时候 t1 的值都会不一样。\n而 t2 则有点特殊，因为我们重写 IocManager 类的时候就已经知道这个 Instance 是一个静态实例，而我们在这里通过 Instance 进行解析出来的对象是从这个静态实例的容器当中解析的。这个静态容器是不会随着请求的结束而被释放，因此每次请求得到的 t2 值都是一样的。\n2.1 思路与解决方法 思路比较简单，只需要在 IocManager 的 Resolve() 方法进行解析的时候，通过静态容器 IContainer 同样创建一个子容器即可。\n更改原来的解析方法 Resolve() ，在解析的时候通过 IocContainer 的 OpenScope() 创建一个新的子容器，然后通过这个子容器进行实例解析。下面是针对 TestApplicationService 的 GetScopedObject() 方法进行测试的结果。\n1 2 3 4 5 6 7 8 9 子容器： 351e8576-6f70-4c9b-8cda-02d46a22455d a4af414b-103e-4972-b7e2-8b8b067c1ce1 04bd79d5-33a2-4e2c-87ae-e72f345c4232 Ioc 静态容器： 2e5dfd1f-36d9-4d62-94cd-c6cc66e316ef 2e5dfd1f-36d9-4d62-94cd-c6cc66e316ef 2e5dfd1f-36d9-4d62-94cd-c6cc66e316ef 虽然直接通过 OpenScope() 来构建子容器是可以解决 Scope 对象每次请求都为一个对象的 BUG，但是解析出来的子容器没有调用 Dispose() 方法进行释放。\n目前有一个临时的解决思路，即在 IIocManager 增加一个属性字段 ChildContainer ，用于存储每次请求创建的临时 Scope 对象，之后 IocManager 内部优先使用 ChildContainer 进行对象解析。\n首先我们来到 IIocManager 接口，为其添加一个 ChildContainer 只读属性与 InitializeChildContainer() 的初始化方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public interface IIocManager : IIocRegistrar, IIocResolver, IDisposable { // ... 其他代码 /// \u0026lt;summary\u0026gt; /// 子容器 /// \u0026lt;/summary\u0026gt; /// \u0026lt;remarks\u0026gt;本属性的值一般是由 DryIocAdapter 当中创建，而不应该在其他地方进行赋值。\u0026lt;/remarks\u0026gt; IResolverContext ChildContainer { get; } /// \u0026lt;summary\u0026gt; /// 初始化子容器 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;container\u0026#34;\u0026gt;用于初始化 IocManager 内部的子容器\u0026lt;/param\u0026gt; void InitializeChildContainer(IResolverContext container); } 在 IocManager 类型当中实现这两个新增的方法和属性，并且更改一个 Resolve() 方法的内部逻辑，优先使用子容器进行对象解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class IocManager : IIocManager { // ... 其他代码 /// \u0026lt;inheritdoc /\u0026gt; public IResolverContext ChildContainer { get; private set; } /// \u0026lt;inheritdoc /\u0026gt; public void InitializeChildContainer(IResolverContext container) { ChildContainer = container; } /// \u0026lt;summary\u0026gt; /// 从 Ioc 容器当中获取一个对象 /// 返回的对象必须通过 (see \u0026lt;see cref=\u0026#34;IIocResolver.Release\u0026#34;/\u0026gt;) 进行释放。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要解析的目标类型\u0026lt;/typeparam\u0026gt; /// \u0026lt;returns\u0026gt;解析出来的实例对象\u0026lt;/returns\u0026gt; public T Resolve\u0026lt;T\u0026gt;() { if (ChildContainer == null) return IocContainer.Resolve\u0026lt;T\u0026gt;(); if (!ChildContainer.IsDisposed) return ChildContainer.Resolve\u0026lt;T\u0026gt;(); return IocContainer.Resolve\u0026lt;T\u0026gt;(); } // ... 其他代码 } 这里仅更改了其中一个解析方法作为示范，如果正式使用的时候，请将 IocManager 的所有 Resolve() 实现都进行相应的更改。\n效果图：\n因为是同一个请求，所以 Scope 生命周期的对象在这个请求的生存周期内应该解析的都是同一个对象。下面是第二次请求时的情况：\n可以看到，第二次请求的时候解析出来的 ScopeClass 类型实例都是同一个对象，其 Guid 值都变成 abd004e0-3792-4e6d-85b3-e721d8dde009 。\n","date":"2018-12-09T13:55:56Z","permalink":"https://real-zony.github.io/p/about-the-problem-after-abp-replaced-the-dryioc-framework/","title":"关于 Abp 替换了 DryIoc 框架之后的问题"},{"content":"0. 简介 整个 Abp 框架最为核心的除了 Abp 库之外，其次就是 Abp.AspNetCore 库了。虽然 Abp 本身是可以用于控制台程序的，不过那样的话 Abp 就基本没什么用，还是需要集合 ASP.NET Core 才能发挥它真正的作用。\n在 Abp.AspNetCore 库里面，Abp 通过 WindsorRegistrationHelper.CreateServiceProvider() 接管了 ASP.NET Core 自带的 Ioc 容器。除此之外，还针对 Controller 的生成规则也进行了替换，以便实现 Dynamic API 功能。\n总的来说，整个 Abp 框架与 ASP.NET Core 集成的功能都放在这个库里面的，所以说这个库还是相当重要的。这个项目又依赖于 Abp.Web.Common 库，这个库是存放了很多公用方法或者工具类的，后面也会有讲述。\n1. 启动流程 首先在 Abp.AspNetCore 库里面，Abp 提供了两个扩展方法。\n第一个则是 AddAbp\u0026lt;TStartupModule\u0026gt;() 方法。\n该方法是 IServiceCollection 的扩展方法，用于在 ASP.NET Core 项目里面的 Startup 的 ConfigureService() 进行配置。通过该方法，Abp 会接管默认的 DI 框架，改为使用 Castle Windsor，并且进行一些 MVC 相关的配置。\n第二个则是 UseAbp() 方法。\n该方法是 IApplicationBuilder 的扩展方法，用于 Startup 类里面的 Configure() 配置。通过该方法，Abp 会执行一系列初始化操作，在这个时候 Abp 框架才算是真正地启动了起来。\n下面则是常规的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Startup { public IServiceProvider ConfigureServices(IServiceCollection services) { services.AddMvc(); return services.AddAbp\u0026lt;AspNetCoreAppModule\u0026gt;(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseMvc(); app.UseAbp(); } } 基本上可以说，UseAbp() 就是整个 Abp 框架的入口点，负责调用 AbpBootstrapper 来初始化整个 Abp 项目并加载各个模块。\n2. 代码分析 在 Abp.AspNetCore 库中，基本上都是针对 ASP.NET Core 的一些相关组件进行替换。大体上有过滤器、控制器、多语言、动态 API、CSRF 防御组件这几大块东西，下面我们先按照 AddAbp() 方法与 UseAbp() 方法内部注入的顺序依次进行讲解。\n首先我们讲解一下 AddAbp() 方法与 UseAbp() 方法的内部做了什么操作吧。\n2.1 初始化操作 2.1.1 组件替换与注册 我们首先查看 AddAbp() 方法，该方法存在于 AbpServiceCollectionExtensions.cs 文件之中。\n1 2 3 4 5 6 7 8 9 10 11 12 public static IServiceProvider AddAbp\u0026lt;TStartupModule\u0026gt;(this IServiceCollection services, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) where TStartupModule : AbpModule { // 传入启动模块，构建 AddAbpBootstrapper 对象，并将其注入到 Ioc 容器当中 var abpBootstrapper = AddAbpBootstrapper\u0026lt;TStartupModule\u0026gt;(services, optionsAction); // 配置 ASP.NET Core 相关的东西 ConfigureAspNetCore(services, abpBootstrapper.IocManager); // 返回一个新的 IServiceProvider 用于替换自带的 DI 框架 return WindsorRegistrationHelper.CreateServiceProvider(abpBootstrapper.IocManager.IocContainer, services); } 该方法作为 IServiceCollection 的扩展方法存在，方便用户进行使用，而在 ConfigureAspNetCore() 方法之中，主要针对 ASP.NET Core 进行了相关的配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 private static void ConfigureAspNetCore(IServiceCollection services, IIocResolver iocResolver) { // 手动注入 HTTPContext 访问器等 services.TryAddSingleton\u0026lt;IHttpContextAccessor, HttpContextAccessor\u0026gt;(); services.TryAddSingleton\u0026lt;IActionContextAccessor, ActionContextAccessor\u0026gt;(); // 替换掉默认的控制器构造类，改用 DI 框架负责控制器的创建 services.Replace(ServiceDescriptor.Transient\u0026lt;IControllerActivator, ServiceBasedControllerActivator\u0026gt;()); // 替换掉默认的视图组件构造类，改用 DI 框架负责视图组件的创建 services.Replace(ServiceDescriptor.Singleton\u0026lt;IViewComponentActivator, ServiceBasedViewComponentActivator\u0026gt;()); // 替换掉默认的 Antiforgery 类 (主要用于非浏览器的客户端进行调用) services.Replace(ServiceDescriptor.Transient\u0026lt;AutoValidateAntiforgeryTokenAuthorizationFilter, AbpAutoValidateAntiforgeryTokenAuthorizationFilter\u0026gt;()); services.Replace(ServiceDescriptor.Transient\u0026lt;ValidateAntiforgeryTokenAuthorizationFilter, AbpValidateAntiforgeryTokenAuthorizationFilter\u0026gt;()); // 添加 Feature Provider，用于判断某个类型是否为控制器 var partManager = services.GetSingletonServiceOrNull\u0026lt;ApplicationPartManager\u0026gt;(); partManager?.FeatureProviders.Add(new AbpAppServiceControllerFeatureProvider(iocResolver)); // 配置 JSON 序列化 services.Configure\u0026lt;MvcJsonOptions\u0026gt;(jsonOptions =\u0026gt; { jsonOptions.SerializerSettings.ContractResolver = new AbpMvcContractResolver(iocResolver) { NamingStrategy = new CamelCaseNamingStrategy() }; }); // 配置 MVC 相关的东西，包括控制器生成和过滤器绑定 services.Configure\u0026lt;MvcOptions\u0026gt;(mvcOptions =\u0026gt; { mvcOptions.AddAbp(services); }); // 配置 Razor 相关参数 services.Insert(0, ServiceDescriptor.Singleton\u0026lt;IConfigureOptions\u0026lt;RazorViewEngineOptions\u0026gt;\u0026gt;( new ConfigureOptions\u0026lt;RazorViewEngineOptions\u0026gt;( (options) =\u0026gt; { options.FileProviders.Add(new EmbeddedResourceViewFileProvider(iocResolver)); } ) ) ); } 之后来到 mvcOptions.AddAbp(services); 所指向的类型，可以看到如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 internal static class AbpMvcOptionsExtensions { public static void AddAbp(this MvcOptions options, IServiceCollection services) { AddConventions(options, services); AddFilters(options); AddModelBinders(options); } // 添加 Abp 定义的 Controller 约定，主要用于配置 Action 方法的 HttpMethod 与路由 private static void AddConventions(MvcOptions options, IServiceCollection services) { options.Conventions.Add(new AbpAppServiceConvention(services)); } // 添加各种过滤器 private static void AddFilters(MvcOptions options) { options.Filters.AddService(typeof(AbpAuthorizationFilter)); options.Filters.AddService(typeof(AbpAuditActionFilter)); options.Filters.AddService(typeof(AbpValidationActionFilter)); options.Filters.AddService(typeof(AbpUowActionFilter)); options.Filters.AddService(typeof(AbpExceptionFilter)); options.Filters.AddService(typeof(AbpResultFilter)); } // 添加 Abp 定义的模型绑定器，主要是为了处理时间类型 private static void AddModelBinders(MvcOptions options) { options.ModelBinderProviders.Insert(0, new AbpDateTimeModelBinderProvider()); } } 这里面所做的工作基本上都是进行一些组件的注入与替换操作。\n2.1.2 Abp 框架加载与初始化 Abp 框架的初始化与加载则是在 UseAbp() 方法里面进行的，首先看它的两个重载方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public static class AbpApplicationBuilderExtensions { public static void UseAbp(this IApplicationBuilder app) { app.UseAbp(null); } public static void UseAbp([NotNull] this IApplicationBuilder app, Action\u0026lt;AbpApplicationBuilderOptions\u0026gt; optionsAction) { Check.NotNull(app, nameof(app)); var options = new AbpApplicationBuilderOptions(); // 获取用户传入的配置操作 optionsAction?.Invoke(options); // 是否启用 Castle 的日志工厂 if (options.UseCastleLoggerFactory) { app.UseCastleLoggerFactory(); } // Abp 框架开始加载并初始化 InitializeAbp(app); // 是否根据请求进行本地化处理 if (options.UseAbpRequestLocalization) { //TODO: 这个中间件应该放在授权中间件之后 app.UseAbpRequestLocalization(); } // 是否使用安全头 if (options.UseSecurityHeaders) { app.UseAbpSecurityHeaders(); } } // ... 其他代码 } 在 UseAbp() 当中你需要注意的是 InitializeAbp(app); 方法。该方法在调用的时候，Abp 才会真正开始地进行初始化。在这个时候，Abp 会遍历所有项目并且执行它们的模块的三个生命周期方法。当所有模块都被调用过之后，Abp 框架就已经准备就绪了。\n1 2 3 4 5 6 7 8 9 10 11 12 private static void InitializeAbp(IApplicationBuilder app) { // 使用 IApplicationBuilder 从 IServiceCollection 中获取之前 AddAbp() 所注入的 AbpBootstrapper 对象 var abpBootstrapper = app.ApplicationServices.GetRequiredService\u0026lt;AbpBootstrapper\u0026gt;(); // 调用 AbpBootstrapper 的初始化方法，加载所有模块 abpBootstrapper.Initialize(); // 绑定 ASP.NET Core 的生命周期，当网站关闭时，调用 AbpBootstrapper 对象的 Dispose() 方法 var applicationLifetime = app.ApplicationServices.GetService\u0026lt;IApplicationLifetime\u0026gt;(); applicationLifetime.ApplicationStopping.Register(() =\u0026gt; abpBootstrapper.Dispose()); } 2.2 AbpAspNetCoreModule 模块 如果说要了解 Abp 某一个库的话，第一步肯定是阅读该库提供的模块类型。因为不管是哪一个库，都会有一个模块进行库的基本配置与初始化动作，而且肯定是这个库第一个被 Abp 框架所调用到的类型。\n首先我们按照模块的生命周期来阅读模块的源代码，下面是模块的预加载 (PreInitialize())方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [DependsOn(typeof(AbpWebCommonModule))] public class AbpAspNetCoreModule : AbpModule { public override void PreInitialize() { // 添加一个新的注册规约，用于批量注册视图组件 IocManager.AddConventionalRegistrar(new AbpAspNetCoreConventionalRegistrar()); IocManager.Register\u0026lt;IAbpAspNetCoreConfiguration, AbpAspNetCoreConfiguration\u0026gt;(); Configuration.ReplaceService\u0026lt;IPrincipalAccessor, AspNetCorePrincipalAccessor\u0026gt;(DependencyLifeStyle.Transient); Configuration.ReplaceService\u0026lt;IAbpAntiForgeryManager, AbpAspNetCoreAntiForgeryManager\u0026gt;(DependencyLifeStyle.Transient); Configuration.ReplaceService\u0026lt;IClientInfoProvider, HttpContextClientInfoProvider\u0026gt;(DependencyLifeStyle.Transient); Configuration.Modules.AbpAspNetCore().FormBodyBindingIgnoredTypes.Add(typeof(IFormFile)); Configuration.MultiTenancy.Resolvers.Add\u0026lt;DomainTenantResolveContributor\u0026gt;(); Configuration.MultiTenancy.Resolvers.Add\u0026lt;HttpHeaderTenantResolveContributor\u0026gt;(); Configuration.MultiTenancy.Resolvers.Add\u0026lt;HttpCookieTenantResolveContributor\u0026gt;(); } // ... 其他代码 } 可以看到在预加载方法内部，该模块通过 ReplaceService 替换了许多接口实现，也有很多注册了许多组件，这其中就包括模块的配置类 IAbpAspNetCoreConfiguration 。\n1 2 3 4 5 6 7 8 9 10 11 12 [DependsOn(typeof(AbpWebCommonModule))] public class AbpAspNetCoreModule : AbpModule { // ... 其他代码 public override void Initialize() { IocManager.RegisterAssemblyByConvention(typeof(AbpAspNetCoreModule).GetAssembly()); } // ... 其他代码 } 初始化方法也更加简洁，则是通过 IocManager 提供的程序集扫描注册来批量注册一些组件。这里执行了该方法之后，会调用 BasicConventionalRegistrar 与 AbpAspNetCoreConventionalRegistrar 这两个注册器来批量注册符合规则的组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 [DependsOn(typeof(AbpWebCommonModule))] public class AbpAspNetCoreModule : AbpModule { // ... 其他代码 public override void PostInitialize() { AddApplicationParts(); ConfigureAntiforgery(); } private void AddApplicationParts() { // 获得当前库的配置类 var configuration = IocManager.Resolve\u0026lt;AbpAspNetCoreConfiguration\u0026gt;(); // 获得 ApplicationPart 管理器，用于发现指定程序集的应用服务，使其作为控制器进行初始化 var partManager = IocManager.Resolve\u0026lt;ApplicationPartManager\u0026gt;(); // 获得模块管理器，用于插件模块的加载 var moduleManager = IocManager.Resolve\u0026lt;IAbpModuleManager\u0026gt;(); // 获得控制器所在的程序集集合 var controllerAssemblies = configuration.ControllerAssemblySettings.Select(s =\u0026gt; s.Assembly).Distinct(); foreach (var controllerAssembly in controllerAssemblies) { // 用程序集构造 AssemblyPart ，以便后面通过 AbpAppServiceControllerFeatureProvider 判断哪些类型是控制器 partManager.ApplicationParts.Add(new AssemblyPart(controllerAssembly)); } // 从插件的程序集 var plugInAssemblies = moduleManager.Modules.Where(m =\u0026gt; m.IsLoadedAsPlugIn).Select(m =\u0026gt; m.Assembly).Distinct(); foreach (var plugInAssembly in plugInAssemblies) { partManager.ApplicationParts.Add(new AssemblyPart(plugInAssembly)); } } // 配置安全相关设置 private void ConfigureAntiforgery() { IocManager.Using\u0026lt;IOptions\u0026lt;AntiforgeryOptions\u0026gt;\u0026gt;(optionsAccessor =\u0026gt; { optionsAccessor.Value.HeaderName = Configuration.Modules.AbpWebCommon().AntiForgery.TokenHeaderName; }); } } 该模块的第三个生命周期方法主要是为了提供控制器所在的程序集，以便 ASP.NET Core MVC 进行控制器构造，其实这里仅仅是添加程序集的，而程序集有那么多类型，那么 MVC 是如何判断哪些类型是控制器类型的呢？这个问题在下面一节进行解析。\n2.3 控制器与动态 API 接着上一节的疑问，那么 MVC 所需要的控制器从哪儿来呢？其实是通过在 AddAbp() 所添加的 AbpAppServiceControllerFeatureProvider 实现的。\n1 2 3 4 5 6 7 8 9 private static void ConfigureAspNetCore(IServiceCollection services, IIocResolver iocResolver) { // ... 其他代码 var partManager = services.GetSingletonServiceOrNull\u0026lt;ApplicationPartManager\u0026gt;(); partManager?.FeatureProviders.Add(new AbpAppServiceControllerFeatureProvider(iocResolver)); // ... 其他代码 } 下面我们分析一下该类型的内部构造是怎样的，首先看一下它的定义与构造器：\n1 2 3 4 5 6 7 8 9 10 11 public class AbpAppServiceControllerFeatureProvider : ControllerFeatureProvider { private readonly IIocResolver _iocResolver; public AbpAppServiceControllerFeatureProvider(IIocResolver iocResolver) { _iocResolver = iocResolver; } // ... 其他代码 } 类型定义都比较简单，继承自 ControllerFeatureProvider ，然后在构造函数传入了一个解析器。在该类型内部，重写了父类的一个 IsController() 方法，这个方法会传入一个 TypeInfo 对象。其实你看到这里应该就明白了，之前在模块当中添加的程序集，最终会被 MVC 解析出所有类型然后调用这个 Provider 来判断哪些类型是控制器。\n如果该类型是控制器的话，则返回 True，不是控制器则返回 False。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class AbpAppServiceControllerFeatureProvider : ControllerFeatureProvider { // ... 其他代码 protected override bool IsController(TypeInfo typeInfo) { // 获得 Type 对象 var type = typeInfo.AsType(); // 判断传入的类型是否继承自 IApplicationService 接口，并且不是泛型类型、不是抽象类型、访问级别为 public if (!typeof(IApplicationService).IsAssignableFrom(type) || !typeInfo.IsPublic || typeInfo.IsAbstract || typeInfo.IsGenericType) { // 不满足上述条件则说明这个类型不能作为一个控制器 return false; } // 获取类型上面是否标注有 RemoteServiceAttribute 特性。 var remoteServiceAttr = ReflectionHelper.GetSingleAttributeOrDefault\u0026lt;RemoteServiceAttribute\u0026gt;(typeInfo); // 如果有该特性，并且在特性内部的 IsEnabled 为 False 则该类型不能作为一个控制器 if (remoteServiceAttr != null \u0026amp;\u0026amp; !remoteServiceAttr.IsEnabledFor(type)) { return false; } // 从模块配置当中取得一个 Func 委托，该委托用于指定某些特性类型是否为一个控制器 var configuration = _iocResolver.Resolve\u0026lt;AbpAspNetCoreConfiguration\u0026gt;().ControllerAssemblySettings.GetSettingOrNull(type); return configuration != null \u0026amp;\u0026amp; configuration.TypePredicate(type); } } 2.3.1 路由与 HTTP.Method 配置 在 MVC 确定好哪些类型是控制器之后，来到了 AbpAppServiceConvention 内部，在这个方法内部则要进行路由和 Action 的一些具体参数。\n这里我们首先看一下这个 AbpAppServiceConvention 类型的基本定义与构造。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class AbpAppServiceConvention : IApplicationModelConvention { // 模块的配置类 private readonly Lazy\u0026lt;AbpAspNetCoreConfiguration\u0026gt; _configuration; public AbpAppServiceConvention(IServiceCollection services) { // 使用 Services 获得模块的配置类，并赋值 _configuration = new Lazy\u0026lt;AbpAspNetCoreConfiguration\u0026gt;(() =\u0026gt; services .GetSingletonService\u0026lt;AbpBootstrapper\u0026gt;() .IocManager .Resolve\u0026lt;AbpAspNetCoreConfiguration\u0026gt;(), true); } // 实现的 IApplicationModelConvention 定义的 Apply 方法 public void Apply(ApplicationModel application) { // 遍历控制器 foreach (var controller in application.Controllers) { var type = controller.ControllerType.AsType(); var configuration = GetControllerSettingOrNull(type); // 判断控制器类型是否继承自 IApplicationService 接口 if (typeof(IApplicationService).GetTypeInfo().IsAssignableFrom(type)) { // 重新定义控制器名字，如果控制器名字有以 ApplicationService.CommonPostfixes 定义的后缀结尾，则移除后缀之后，再作为控制器名字 controller.ControllerName = controller.ControllerName.RemovePostFix(ApplicationService.CommonPostfixes); // 模型绑定配置，如果有的话，默认为 NULL configuration?.ControllerModelConfigurer(controller); // 配置控制器 Area 路由 ConfigureArea(controller, configuration); // 配置控制器路由与 Action 等... ConfigureRemoteService(controller, configuration); } else { var remoteServiceAtt = ReflectionHelper.GetSingleAttributeOrDefault\u0026lt;RemoteServiceAttribute\u0026gt;(type.GetTypeInfo()); if (remoteServiceAtt != null \u0026amp;\u0026amp; remoteServiceAtt.IsEnabledFor(type)) { ConfigureRemoteService(controller, configuration); } } } } // ... 其他代码 } 这里我们再跳转到 ConfigureRemoteService() 方法内部可以看到其定义如下：\n1 2 3 4 5 6 7 8 9 private void ConfigureRemoteService(ControllerModel controller, [CanBeNull] AbpControllerAssemblySetting configuration) { // 配置控制器与其 Action 的可见性 ConfigureApiExplorer(controller); // 配置 Action 的路由 ConfigureSelector(controller, configuration); // 配置 Action 传参形式 ConfigureParameters(controller); } 【注意】\nAbpAppServiceControllerFeatureProvider 与 AbpAppServiceConvention 的调用都是在第一次请求接口的时候才会进行初始化，所以这就会造成第一次接口请求缓慢的问题，因为要做太多的初始化工作了。\n2.4 过滤器 过滤器是在 AddAbp() 的时候被注入到 MVC 里面的，这些过滤器其实大部分在之前的 Abp 源码分析都有见过。\n2.4.1 工作单元过滤器 工作单元过滤器是针对于启用了 UnitOfWorkAttribute 特性标签的应用服务/控制器进行处理。其核心思想就是在调用接口时，在最外层就使用 IUnitOfWorkManager 构建一个新的工作单元，然后将应用服务/控制器的调用就包在内部了。\n首先来看一下这个过滤器内部定义与构造器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class AbpUowActionFilter : IAsyncActionFilter, ITransientDependency { // 工作单元管理器 private readonly IUnitOfWorkManager _unitOfWorkManager; // ASP.NET Core 配置类 private readonly IAbpAspNetCoreConfiguration _aspnetCoreConfiguration; // 工作单元配置类 private readonly IUnitOfWorkDefaultOptions _unitOfWorkDefaultOptions; public AbpUowActionFilter( IUnitOfWorkManager unitOfWorkManager, IAbpAspNetCoreConfiguration aspnetCoreConfiguration, IUnitOfWorkDefaultOptions unitOfWorkDefaultOptions) { _unitOfWorkManager = unitOfWorkManager; _aspnetCoreConfiguration = aspnetCoreConfiguration; _unitOfWorkDefaultOptions = unitOfWorkDefaultOptions; } // ... 其他代码 } 可以看到在这个工作单元过滤器，他通过实现 ITransientDependency 来完成自动注入，之后使用构造注入了两个配置类和一个工作单元管理器。\n在其 OnActionExecutionAsync() 方法内部的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class AbpUowActionFilter : IAsyncActionFilter, ITransientDependency { // ... 其他代码 public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) { // 判断当前调用是否是控制器方法 if (!context.ActionDescriptor.IsControllerAction()) { // 如果不是，则不执行任何操作 await next(); return; } // 获得控制器/应用服务所标记的工作单元特性 var unitOfWorkAttr = _unitOfWorkDefaultOptions .GetUnitOfWorkAttributeOrNull(context.ActionDescriptor.GetMethodInfo()) ?? _aspnetCoreConfiguration.DefaultUnitOfWorkAttribute; // 如果特性的 IsDisabled 为 True 的话，不执行任何操作 if (unitOfWorkAttr.IsDisabled) { await next(); return; } // 使用工作单元管理器开启一个新的工作单元 using (var uow = _unitOfWorkManager.Begin(unitOfWorkAttr.CreateOptions())) { var result = await next(); if (result.Exception == null || result.ExceptionHandled) { await uow.CompleteAsync(); } } } } 逻辑也很简单，这里就不再赘述了。\n2.4.2 授权过滤器 授权过滤器的基本原理在文章 [《Abp 源码分析]十一、权限验证》 有讲到过，这里就不在赘述。\n2.4.3 参数校验过滤器 参数校验过滤器在文章 [《Abp 源码分析]十四、DTO 自动验证》 有讲到过，这里不再赘述。\n2.4.4 审计日志过滤器 其实这个过滤器，在文章 《十五、自动审计记录》 有讲到过，作用比较简单。就是构造一个 AuditInfo 对象，然后再调用 IAuditingStore 提供的持久化功能将审计信息储存起来。\n2.4.5 异常过滤器 异常过滤器在文章 [《Abp 源码分析]十、异常处理》 有讲解，这里不再赘述。\n2.4.6 返回值过滤器 这个东西其实就是用于包装返回值的，因为只要使用的 Abp 框架，其默认的返回值都会进行包装，那我们可以通过 DontWarpAttribute 来取消掉这层包装。\n那么包装是在什么地方进行的呢？其实就在 AbpResultFilter 的内部进行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class AbpResultFilter : IResultFilter, ITransientDependency { private readonly IAbpAspNetCoreConfiguration _configuration; private readonly IAbpActionResultWrapperFactory _actionResultWrapperFactory; public AbpResultFilter(IAbpAspNetCoreConfiguration configuration, IAbpActionResultWrapperFactory actionResultWrapper) { _configuration = configuration; _actionResultWrapperFactory = actionResultWrapper; } public virtual void OnResultExecuting(ResultExecutingContext context) { if (!context.ActionDescriptor.IsControllerAction()) { return; } var methodInfo = context.ActionDescriptor.GetMethodInfo(); var wrapResultAttribute = ReflectionHelper.GetSingleAttributeOfMemberOrDeclaringTypeOrDefault( methodInfo, _configuration.DefaultWrapResultAttribute ); if (!wrapResultAttribute.WrapOnSuccess) { return; } // 包装对象 _actionResultWrapperFactory.CreateFor(context).Wrap(context); } public virtual void OnResultExecuted(ResultExecutedContext context) { //no action } } 这里传入了 context ，然后基于这个返回值来进行不同的操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class AbpActionResultWrapperFactory : IAbpActionResultWrapperFactory { public IAbpActionResultWrapper CreateFor(ResultExecutingContext actionResult) { Check.NotNull(actionResult, nameof(actionResult)); if (actionResult.Result is ObjectResult) { return new AbpObjectActionResultWrapper(actionResult.HttpContext.RequestServices); } if (actionResult.Result is JsonResult) { return new AbpJsonActionResultWrapper(); } if (actionResult.Result is EmptyResult) { return new AbpEmptyActionResultWrapper(); } return new NullAbpActionResultWrapper(); } } 2.3 CSRF 防御组件 就继承自 MVC 的两个类型，然后重新做了一些判断逻辑进行处理，这里直接参考 AbpAutoValidateAntiforgeryTokenAuthorizationFilter 与 AbpValidateAntiforgeryTokenAuthorizationFilter 源码。\n如果不太懂 AntiforgeryToken 相关的知识，可以参考 这一篇 博文进行了解。\n2.4 多语言处理 针对于多语言的处理规则，其实在文章 [《Abp 源码分析]十三、多语言(本地化)处理》 就有讲解，这里只说明一下，在这个库里面通过 IApplicationBuilder 的一个扩展方法 UseAbpRequestLocalization() 注入的一堆多语言相关的组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public static void UseAbpRequestLocalization(this IApplicationBuilder app, Action\u0026lt;RequestLocalizationOptions\u0026gt; optionsAction = null) { var iocResolver = app.ApplicationServices.GetRequiredService\u0026lt;IIocResolver\u0026gt;(); using (var languageManager = iocResolver.ResolveAsDisposable\u0026lt;ILanguageManager\u0026gt;()) { // 获得当前服务器支持的区域文化列表 var supportedCultures = languageManager.Object .GetLanguages() .Select(l =\u0026gt; CultureInfo.GetCultureInfo(l.Name)) .ToArray(); var options = new RequestLocalizationOptions { SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures }; var userProvider = new AbpUserRequestCultureProvider(); //0: QueryStringRequestCultureProvider options.RequestCultureProviders.Insert(1, userProvider); options.RequestCultureProviders.Insert(2, new AbpLocalizationHeaderRequestCultureProvider()); //3: CookieRequestCultureProvider options.RequestCultureProviders.Insert(4, new AbpDefaultRequestCultureProvider()); //5: AcceptLanguageHeaderRequestCultureProvider optionsAction?.Invoke(options); userProvider.CookieProvider = options.RequestCultureProviders.OfType\u0026lt;CookieRequestCultureProvider\u0026gt;().FirstOrDefault(); userProvider.HeaderProvider = options.RequestCultureProviders.OfType\u0026lt;AbpLocalizationHeaderRequestCultureProvider\u0026gt;().FirstOrDefault(); app.UseRequestLocalization(options); } } 这些组件都存放在 Abp.AspNetCore 库下面的 Localization 文件夹里面。\n","date":"2018-11-21T03:36:35Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-seventeen-aspnet-core-integration/","title":"Abp 源码分析：十七、ASP.NET Core 集成"},{"content":"一、背景 你说我 Castle Windsor 库用得好好的，为啥要大费周章的替换成 DryIoc 库呢？那就是性能，DryIoc 是一款优秀而且轻量级的 DI 框架，整个项目代码就两个文件，加起来代码 1 万行左右(PS: 大部分都是注释)。\n在各个 Ioc 容器的性能评测当中，DryIoc 以其优异的性能成为我选择使用他的原因。Abp 使用的 Castle Windsor 在解析复杂对象的时候，速度非常慢，而替换为 DryIoc 之后速度可以提升 150% 以上。\n【注意】\n本文仅对 .NET Core 相关的库进行更改并测试，.NET Framework 相关的库并没有进行修改测试。\n二、准备 你需要准备如下原料：\nAbp 源码 一份。 测试用的项目一份。 Visual Studio 2017 或者 Rider 一份。 .NET 程序猿一枚。 三、分析 首先，Abp 框架的大部分动作基本上都是通过 IIocManager 这个接口对象进行实现的，它抽象了一层作为一个 DI 框架的操作类。它的默认实现是使用的 Castle Windsor 来进行组件的注入与解析，所以我们只需要将其改为使用 DryIoc 的容器其进行操作即可。\n其次，在 Abp 框架的很多地方都有用到 Castle Windsor 的 IWindsorContainer 对象，但一般用到该方法的地方都是注入或者绑定组件注册事件，这些我们都可以重新实现的。\n做完了以上的工作仅仅是代表我们的 Abp 的所有组件都可以通过 DryIoc 来进行注册和解析，不过要和 ASP.NET Core 集成的话，还需要 IServiceProvider 的适配器，针对于适配器 DryIoc 也给我们提供了，拿来用即可。\n所以，我们基本确定了需要变更的项目主要是 Abp 这个核心库，还有 Abp.AspNetCore 这个子模块。除了前面两个比较重要的模块之外，还有 Abp.EntityFrameworkCore 相关的库也需要变更，这是因为他们内部都直接使用到了 IWindsorContainer 对象对容器进行操作的。\n四、开撸 4.1 Abp 库改造 Abp 本身库里面需要改动的地方基本集中在 Dependency 文件夹里面，这个文件夹我们之前有讲过，基本所有依赖注入相关的类型与接口都存放在这里面的。\n除了依赖注入相关的类型需要更改以外，我们还需要更改各个拦截器注入的地方。因为在之前 Abp 如果需要为某个类型注入拦截器的话，是使用到了 IWindsorContainer 接口所提供的组件注入事件来进行拦截器注入的。\n首先我们针对于 Abp 库添加 DryIoc 库的 NuGet 包引用，这里我是安装的 3.1.0-preview-06 版本。\n4.1.1 IocManger 改造 首先看一下 IIocManager 接口，该接口定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// \u0026lt;summary\u0026gt; /// This interface is used to directly perform dependency injection tasks. /// \u0026lt;/summary\u0026gt; public interface IIocManager : IIocRegistrar, IIocResolver, IDisposable { /// \u0026lt;summary\u0026gt; /// Reference to the Castle Windsor Container. /// \u0026lt;/summary\u0026gt; IWindsorContainer IocContainer { get; } /// \u0026lt;summary\u0026gt; /// Checks whether given type is registered before. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;type\u0026#34;\u0026gt;Type to check\u0026lt;/param\u0026gt; new bool IsRegistered(Type type); /// \u0026lt;summary\u0026gt; /// Checks whether given type is registered before. /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;Type to check\u0026lt;/typeparam\u0026gt; new bool IsRegistered\u0026lt;T\u0026gt;(); } 可以看到他定义了一个 IWindsorContainer 的属性，我们将其改为 IContainer 。基本上做了这一步之后，在 Abp 的其他项目会出现一堆错误提示，先不慌，一步一步来。\n接着我们转到 IIocManager 的实现类 IocManager ，一样的更改 IocContainer 的类型为 IContainer 之后，我们继续来到其构造函数，可以看到有如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 public IocManager() { IocContainer = CreateContainer(); _conventionalRegistrars = new List\u0026lt;IConventionalDependencyRegistrar\u0026gt;(); //Register self! IocContainer.Register( Component .For\u0026lt;IocManager, IIocManager, IIocRegistrar, IIocResolver\u0026gt;() .Instance(this) ); } 因为我们的 IocContainer 跟着变更了，这里也不能使用 CreateContainer() 方法来创建 DryIoc 的容器。其次，在下面注册自己的时候，也是使用到了 IWindsorContainer 的注册方法，一样的需要进行更改。变更好的构造函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 public IocManager() { // 这里通过 Rules 启用了瞬态对象跟踪，默认是不启动的。 IocContainer = new Container(Rules.Default.WithTrackingDisposableTransients()); _conventionalRegistrars = new List\u0026lt;IConventionalDependencyRegistrar\u0026gt;(); // 注册自身 IocContainer.UseInstance(typeof(IocManager),this); IocContainer.UseInstance(typeof(IIocManager),this); IocContainer.UseInstance(typeof(IIocRegistrar),this); IocContainer.UseInstance(typeof(IIocResolver),this); } 接着就需要继续看一下报错的方法，另一个需要改的则是注册方法的一个辅助私有方法 ApplyLifestyle，该方法主要作用就是将 Abp 定义的生命周期转换为具体 Ioc 容器的生命周期常量。而且该方法原来是返回的一个 ComponentRegistration\u0026lt;T\u0026gt; 对象，这个对象是 Castle Windsor 的一个专属类，所以需要改造一下，变更之后如下：\n1 2 3 4 5 6 7 8 9 10 11 12 private static IReuse ApplyLifestyle(DependencyLifeStyle lifeStyle) { switch (lifeStyle) { case DependencyLifeStyle.Transient: return Reuse.Transient;; case DependencyLifeStyle.Singleton: return Reuse.Singleton; default: return Reuse.Transient; } } 做了这个改动之后，剩下的就是需要针对注册与解析方法进行一些改动了，因为 IocManger 提供的注册与解析方法也是调用的具体 Ioc 容器所提供的方法，而 IWindsorContainer 提供的，DryIoc 的 IContainer 基本上也都有提供 ，只是个别特殊的方法有一些不同而已。\n下面是改造完成的部分注册与解析接口(详细的可以查看 Github 代码)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public void Register(Type type, DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton) { IocContainer.Register(type,ApplyLifestyle(lifeStyle)); } // ... 其他接口 public void Register(Type type, Type impl, DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton) { if (type == impl) { // 这里通过 made 参数指定了解析对象时优先解析带有参数的构造函数 IocContainer.Register(type,impl,ApplyLifestyle(lifeStyle), made: Made.Of(FactoryMethod.ConstructorWithResolvableArguments)); RegisterTypeEventHandler?.Invoke(this,type,impl); } else { IocContainer.RegisterMany(new[] { type, impl }, impl, made: Made.Of(FactoryMethod.ConstructorWithResolvableArguments), reuse: ApplyLifestyle(lifeStyle)); RegisterTypeEventHandler?.Invoke(this,type,impl); RegisterTypeEventHandler?.Invoke(this,impl,impl); } } // ... 其他接口 这里需要注意一点的是带参数的解析方法 public T Resolve\u0026lt;T\u0026gt;(object argumentsAsAnonymousType) ，DryIoc 与 Castle Windsor 不同的是，它能够接收的只能是参数数组，而不能接收一个参数集合的匿名对象。所以我们需要将入参改为 object[] ，当然也因为变更了方法签名，所以我们需要更改 ScopedIocResolver、IIocResolver、IocResolverExtensions 定义里面带参数的解析方法签名。\n1 2 3 4 public T Resolve\u0026lt;T\u0026gt;(object[] argumentsAsAnonymousType) { return IocContainer.Resolve\u0026lt;T\u0026gt;(argumentsAsAnonymousType); } 其次，还有一个 public T[] ResolveAll\u0026lt;T\u0026gt;() 内部调用了 IocContainer.ResolveAll 方法，而 DryIoc 是没有提供这个方法的，但是有一个 ResolveMany() 方法是一样的作用。下面是进行更改之后的 ResolveAll() 方法的所有重载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ///\u0026lt;inheritdoc/\u0026gt; public T[] ResolveAll\u0026lt;T\u0026gt;() { return IocContainer.ResolveMany\u0026lt;T\u0026gt;().ToArray(); } ///\u0026lt;inheritdoc/\u0026gt; public T[] ResolveAll\u0026lt;T\u0026gt;(object[] argumentsAsAnonymousType) { return IocContainer.ResolveMany\u0026lt;T\u0026gt;(args:argumentsAsAnonymousType).ToArray(); } ///\u0026lt;inheritdoc/\u0026gt; public object[] ResolveAll(Type type) { return IocContainer.ResolveMany(type).ToArray(); } ///\u0026lt;inheritdoc/\u0026gt; public object[] ResolveAll(Type type, object[] argumentsAsAnonymousType) { return IocContainer.ResolveMany(type, args:argumentsAsAnonymousType).ToArray(); } 除了解析方法之外，还有对象释放的方法 Release，由于 DryIoc 没有提供释放方法，所以这里只能显式地调用对象的 Dispose() 方法来进行释放。\n1 2 3 4 5 6 7 public void Release(object obj) { if(obj is IDisposable disposeObj) { disposeObj.Dispose(); } } 做了以上变更之后，还有一个地方在提示错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void RegisterAssemblyByConvention(Assembly assembly, ConventionalRegistrationConfig config) { var context = new ConventionalRegistrationContext(assembly, this, config); foreach (var registerer in _conventionalRegistrars) { registerer.RegisterAssembly(context); } if (config.InstallInstallers) { // 这里仍然使用了 IWindsorContainr 的方法 IocContainer.Install(FromAssembly.Instance(assembly)); } } 看过博主之前更新的 Abp 源码分析的同学应该知道，这个 Install() 的作用其实很简单，就是直接遍历指定程序集的类型，查找是否有实现了 IWindsorInstaller 接口的对象，如果有则调用其 Install() 方法。而在其 Install() 方法里面，一般都是通过传入的 IIocContainer 或者是 IIocManager 对象来进行组件注册的功能。\n在这里，我们可以针对 IocManager 写两个扩展方法 Intsall() 和一个 IDryIocInstaller 接口用于实现相似的功能。\n1 2 3 4 5 6 7 namespace Abp.Dependency { public interface IDryIocInstaller { void Install(IIocManager iocManager); } } 扩展方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using System; using System.Linq; using System.Reflection; namespace Abp.Dependency { public static class IocManagerExtensions { public static void Install(this IIocManager iocManager,IDryIocInstaller installer) { installer.Install(iocManager); } public static void Install(this IIocManager iocManager, Assembly assembly) { // 获得指定程序集内部所有的 Installer 类型 var installers = assembly.GetTypes().Where(type =\u0026gt; type.GetInterfaces().Any(@interface =\u0026gt; @interface == typeof(IDryIocInstaller))); // 遍历类型并通过 Activator 进行构造并调用 foreach (var installer in installers) { (Activator.CreateInstance(installer) as IDryIocInstaller)?.Install(iocManager); } } } } 现在我们回到最开始报错的地方，将其 Install() 方法改为调用我们新的扩展方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void RegisterAssemblyByConvention(Assembly assembly, ConventionalRegistrationConfig config) { var context = new ConventionalRegistrationContext(assembly, this, config); foreach (var registerer in _conventionalRegistrars) { registerer.RegisterAssembly(context); } if (config.InstallInstallers) { // 调用之前编写的扩展方法 this.Install(assembly); } } 4.1.2 依赖注入辅助接口改造 Abp 库本身提供了两个接口 (ITransientDependency、ISingletonDependency ) 来帮助用户快速地注入某个对象，然后通过注册规约结合 IocManager 提供的 AddConventionalRegistrar() 方法和 RegisterAssemblyByConvention() 方法能够快速地将某个程序集内部符合规则的类型进行注入。(PS: 这里其实流程很像之前 Installer 的做法)\n在使用 Castle Windsor 的时候，Abp 本身并不需要做太多的工作，就可以实现上述的功能。而 DryIoc 本身是没有提供这些比较高级的特性的，但原理其实并不复杂， 就是扫描整个程序集的所有类型，然后挨个进行判断即可。\n在原来的 BasicConventionalRegistrar 类型内部，对实现了 ITransientDependency 、 ISingletonDependency 、 IInterceptor 接口的类型进行了自动注册。所以我们就有了以下的实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 using System; using System.Linq; using System.Reflection; using Abp.Extensions; using Castle.DynamicProxy; namespace Abp.Dependency { public class AssemblyType { public Type ServiceType { get; set; } public Type ImplType { get; set; } } /// \u0026lt;summary\u0026gt; /// 本类用于注册实现了 \u0026lt;see cref=\u0026#34;ITransientDependency\u0026#34;/\u0026gt; 和 \u0026lt;see cref=\u0026#34;ISingletonDependency\u0026#34;/\u0026gt; 接口的类型。 /// \u0026lt;/summary\u0026gt; public class BasicConventionalRegistrar : IConventionalDependencyRegistrar { public void RegisterAssembly(IConventionalRegistrationContext context) { // 瞬时对象注册 var waitRegisterTransient = GetTypes\u0026lt;ITransientDependency\u0026gt;(context.Assembly).ToList(); foreach (var transientType in waitRegisterTransient) { context.IocManager.RegisterIfNot(transientType.ServiceType,transientType.ImplType,DependencyLifeStyle.Transient); } // 单例对象注册 var waitRegisterSingleton = GetTypes\u0026lt;ISingletonDependency\u0026gt;(context.Assembly).ToList(); foreach (var singletonType in waitRegisterSingleton) { context.IocManager.RegisterIfNot(singletonType.ServiceType,singletonType.ImplType,DependencyLifeStyle.Singleton); } // Castle.DynamicProxy 拦截器注册 var waitRegisterInterceptor = GetTypes\u0026lt;IInterceptor\u0026gt;(context.Assembly).ToList(); foreach (var interceptorType in waitRegisterInterceptor) { context.IocManager.RegisterIfNot(interceptorType.ServiceType,interceptorType.ImplType,DependencyLifeStyle.Transient); } } private ParallelQuery\u0026lt;AssemblyType\u0026gt; GetTypes\u0026lt;TInterface\u0026gt;(Assembly assembly) { Type GetServiceType(Type type) { var interfaces = type.GetInterfaces().Where(i =\u0026gt; i != typeof(TInterface)); // 优先匹配去除 I 之后的接口 var defaultInterface = interfaces.FirstOrDefault(i =\u0026gt; type.Name.Equals(i.Name.RemovePreFix(\u0026#34;I\u0026#34;))); if (defaultInterface != null) return defaultInterface; if (interfaces.FirstOrDefault() != null) return interfaces.FirstOrDefault(); return type; } return assembly.GetTypes() .AsParallel() .Where(type =\u0026gt; typeof(TInterface).IsAssignableFrom(type)) .Where(type =\u0026gt; type.GetInterfaces().Any() \u0026amp;\u0026amp; !type.IsInterface) .Where(type =\u0026gt; !type.IsGenericTypeDefinition) .Where(type =\u0026gt; !type.IsAbstract) .Select(type =\u0026gt; new AssemblyType { ServiceType = GetServiceType(type), ImplType = type }); } } } 在我们实现的新的注册规约当中可以看到，其实最核心的代码在于 GetTypes() 方法内部，在其内部进行了比较复杂的判断逻辑，其余的瞬时对象与单例对象的注入，都是直接调用的 IIocManager 接口所提供的注册方法。\n4.1.3 拦截器绑定 因为没有使用 Castle Windsor ，那么我们拦截器如何使用？又如何与类型进行绑定的呢？\n在 DryIoc 官方文档已经说明，DryIoc 本身的拦截功能也是通过 Castle Dynamic Proxy 来实现的，所以我们只需要编写一个辅助的静态扩展类即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 using System; using System.Linq; using Castle.DynamicProxy; using DryIoc; using ImTools; public static class DryIocInterception { static readonly DefaultProxyBuilder ProxyBuilder = new DefaultProxyBuilder(); public static void Intercept(this IRegistrator registrator,Type serviceType,Type interceptorType,Type implType, object serviceKey = null) { // 判断传入的类型是接口还是类型，以便建立代理类 Type proxyType; if (serviceType.IsInterface()) proxyType = ProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface( serviceType, ArrayTools.Empty\u0026lt;Type\u0026gt;(), ProxyGenerationOptions.Default); else if (serviceType.IsClass()) proxyType = ProxyBuilder.CreateClassProxyTypeWithTarget( serviceType, ArrayTools.Empty\u0026lt;Type\u0026gt;(), ProxyGenerationOptions.Default); else throw new ArgumentException( $\u0026#34;Intercepted service type {serviceType} is not a supported, cause it is nor a class nor an interface\u0026#34;); // 创建 DryIoc 装饰器 var decoratorSetup = serviceKey == null ? Setup.DecoratorWith(useDecorateeReuse: true) : Setup.DecoratorWith(r =\u0026gt; serviceKey.Equals(r.ServiceKey), useDecorateeReuse: true); // 替换注册原来接口的解析，解析到新的代理类 registrator.Register(serviceType, proxyType, made: Made.Of((Type type) =\u0026gt; type.GetConstructors().SingleOrDefault(c =\u0026gt; c.GetParameters().Length != 0), Parameters.Of.Type\u0026lt;IInterceptor[]\u0026gt;(interceptorType.MakeArrayType()), // 一定要加上这个，不然属性注入无法使用 PropertiesAndFields.Auto), setup: decoratorSetup); } public static void Intercept\u0026lt;TService,TImplType, TInterceptor\u0026gt;(this IRegistrator registrator, object serviceKey = null) where TInterceptor : class, IInterceptor { Intercept(registrator,typeof(TService),typeof(TInterceptor),typeof(TImplType),serviceKey); } } 这个扩展类的用法，在后面就有体现。\n4.1.4 拦截器注册器绑定事件 最开始 Abp 拦截器是在什么时候与具体类型绑定的呢？其实就是在 Castle Windsor 注入组件的时候，各个拦截器注册器都会监听这个组件注入事件。当事件被触发的时候，Abp 各个拦截器注册器都会执行一系列的判断来确保当前类型应该绑定哪一个拦截器。\nAbp 自带的拦截器一共有 5 种：工作单元拦截器、参数验证拦截器、授权拦截器、审计日志拦截器、实体历史拦截器。这五种拦截器都是在 AbpBootstrapper 执行创建方法的时候会被调用，调用的时候会监听组件注册事件。\n现在的问题是，我们已经没有使用 Castle Windsor 也就没有办法使用 IWindsorContainer 来监听组件注册事件。而 DryIoc 本身也是没有提供这种注入事件的，所以这里我们就只有抽象到 IocManager 类型当中，当 IocManager 的几个注册方法被调用的时候，显式触发一个事件通知这些拦截器注册器对象。\n首先我们来到 IIocManager 接口，为其添加一个公开的委托属性，该委托的定义也在下面给出来了。\n委托定义：\n1 2 3 4 5 6 using System; namespace Abp.Dependency { public delegate void RegisterTypeEventHandler(IIocManager iocManager, Type registerType,Type implementationType); } IIocManager 接口处新增的属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System; using DryIoc; namespace Abp.Dependency { /// \u0026lt;summary\u0026gt; /// 依赖注入容器管理器, /// 本接口用于执行注入操作 /// \u0026lt;/summary\u0026gt; public interface IIocManager : IIocRegistrar, IIocResolver, IDisposable { IContainer IocContainer { get; } new bool IsRegistered(Type type); new bool IsRegistered\u0026lt;T\u0026gt;(); event RegisterTypeEventHandler RegisterTypeEventHandler; } } 之后呢，我们在 IocManager 的 Register() 注册方法内部都显式地触发这个事件。\n1 2 3 4 5 6 public void Register(Type type, DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton) { IocContainer.Register(type,ApplyLifestyle(lifeStyle), made: Made.Of(FactoryMethod.ConstructorWithResolvableArguments)); RegisterTypeEventHandler?.Invoke(this,type,type); } 就如同这样，实现的效果也是每当有组件注册的时候，都会触发该事件。而各个注册器内部的 Initialize() 方法都传入了一个 IIocManager 对象，所以我们只需要将原有的监听事件改为绑定我们自己定义的事件即可。\n下面以工作单元的拦截器注册器为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 using System.Linq; using System.Reflection; using Abp.Dependency; using Castle.Core; using Castle.MicroKernel; namespace Abp.Domain.Uow { /// \u0026lt;summary\u0026gt; /// This class is used to register interceptor for needed classes for Unit Of Work mechanism. /// \u0026lt;/summary\u0026gt; internal static class UnitOfWorkRegistrar { /// \u0026lt;summary\u0026gt; /// Initializes the registerer. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;iocManager\u0026#34;\u0026gt;IOC manager\u0026lt;/param\u0026gt; public static void Initialize(IIocManager iocManager) { iocManager.RegisterTypeEventHandler += (manager, type, implementationType) =\u0026gt; { var implType = implementationType.GetTypeInfo(); HandleTypesWithUnitOfWorkAttribute(implType,manager); HandleConventionalUnitOfWorkTypes(iocManager, implType); }; } private static void HandleTypesWithUnitOfWorkAttribute(TypeInfo implementationType,IIocManager iocManager) { if (IsUnitOfWorkType(implementationType) || AnyMethodHasUnitOfWork(implementationType)) { // 使用的是上面写的扩展方法 iocManager.IocContainer.Intercept(implementationType,typeof(UnitOfWorkInterceptor)); } } private static void HandleConventionalUnitOfWorkTypes(IIocManager iocManager, TypeInfo implementationType) { if (!iocManager.IsRegistered\u0026lt;IUnitOfWorkDefaultOptions\u0026gt;()) { return; } var uowOptions = iocManager.Resolve\u0026lt;IUnitOfWorkDefaultOptions\u0026gt;(); if (uowOptions.IsConventionalUowClass(implementationType.AsType())) { // 使用的是上面写的扩展方法 iocManager.IocContainer.Intercept(implementationType,typeof(UnitOfWorkInterceptor)); } } private static bool IsUnitOfWorkType(TypeInfo implementationType) { return UnitOfWorkHelper.HasUnitOfWorkAttribute(implementationType); } private static bool AnyMethodHasUnitOfWork(TypeInfo implementationType) { return implementationType .GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) .Any(UnitOfWorkHelper.HasUnitOfWorkAttribute); } } } 按照上面这种步骤，完成剩余拦截器注册器的更改。\n4.1.5 收尾工作 如果上述操作都已经完成了的话，那么基本上只剩下 AbpBootstrapper 类型与 AbpKernelModule 几处细小的错误了。\n首先我们看一下 AbpBootstrapper 还提示哪些错误，然后我们进行更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 第一处 public virtual void Initialize() { ResolveLogger(); try { RegisterBootstrapper(); // IocManager.IocContainer.Install(new AbpCoreInstaller()); // 此处使用的仍然是 IWindsorContainer 的 Install 方法，改为最新的 IocManager.Install(new AbpCoreInstaller()); IocManager.Resolve\u0026lt;AbpPlugInManager\u0026gt;().PlugInSources.AddRange(PlugInSources); IocManager.Resolve\u0026lt;AbpStartupConfiguration\u0026gt;().Initialize(); _moduleManager = IocManager.Resolve\u0026lt;AbpModuleManager\u0026gt;(); _moduleManager.Initialize(StartupModule); _moduleManager.StartModules(); } catch (Exception ex) { _logger.Fatal(ex.ToString(), ex); throw; } } 上面仍然报错，我们继续来到 AbpCoreInstaller 将其接口由 IWindsorInstaller 改为 IDryIocInstaller 并重新实现接口的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 using Abp.Application.Features; using Abp.Auditing; using Abp.BackgroundJobs; using Abp.Configuration.Startup; using Abp.Domain.Uow; using Abp.EntityHistory; using Abp.Localization; using Abp.Modules; using Abp.Notifications; using Abp.PlugIns; using Abp.Reflection; using Abp.Resources.Embedded; using Abp.Runtime.Caching.Configuration; using DryIoc; namespace Abp.Dependency.Installers { /// \u0026lt;summary\u0026gt; /// ABP 框架核心类安装器 /// 本类用于注册 ABP 框架当中核心组件 /// \u0026lt;/summary\u0026gt; internal class AbpCoreInstaller : IDryIocInstaller { public void Install(IIocManager iocManager) { iocManager.IocContainer.RegisterMany(new[] {typeof(IUnitOfWorkDefaultOptions), typeof(UnitOfWorkDefaultOptions)}, typeof(UnitOfWorkDefaultOptions), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(INavigationConfiguration), typeof(NavigationConfiguration)}, typeof(NavigationConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(ILocalizationConfiguration), typeof(LocalizationConfiguration)}, typeof(LocalizationConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IAuthorizationConfiguration), typeof(AuthorizationConfiguration)}, typeof(AuthorizationConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IValidationConfiguration), typeof(ValidationConfiguration)}, typeof(ValidationConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IFeatureConfiguration), typeof(FeatureConfiguration)}, typeof(FeatureConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(ISettingsConfiguration), typeof(SettingsConfiguration)}, typeof(SettingsConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IModuleConfigurations), typeof(ModuleConfigurations)}, typeof(ModuleConfigurations), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IEventBusConfiguration), typeof(EventBusConfiguration)}, typeof(EventBusConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IMultiTenancyConfig), typeof(MultiTenancyConfig)}, typeof(MultiTenancyConfig), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(ICachingConfiguration), typeof(CachingConfiguration)}, typeof(CachingConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IAuditingConfiguration), typeof(AuditingConfiguration)}, typeof(AuditingConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IBackgroundJobConfiguration), typeof(BackgroundJobConfiguration)}, typeof(BackgroundJobConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(INotificationConfiguration), typeof(NotificationConfiguration)}, typeof(NotificationConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IEmbeddedResourcesConfiguration), typeof(EmbeddedResourcesConfiguration)}, typeof(EmbeddedResourcesConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IAbpStartupConfiguration), typeof(AbpStartupConfiguration)}, typeof(AbpStartupConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IEntityHistoryConfiguration), typeof(EntityHistoryConfiguration)}, typeof(EntityHistoryConfiguration), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(ITypeFinder), typeof(TypeFinder)}, typeof(TypeFinder), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IAbpPlugInManager), typeof(AbpPlugInManager)}, typeof(AbpPlugInManager), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IAbpModuleManager), typeof(AbpModuleManager)}, typeof(AbpModuleManager), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(IAssemblyFinder), typeof(AbpAssemblyFinder)}, typeof(AbpAssemblyFinder), Reuse.Singleton); iocManager.IocContainer.RegisterMany(new[] {typeof(ILocalizationManager), typeof(LocalizationManager)}, typeof(LocalizationManager), Reuse.Singleton); } } } 而 AbpBootstrapper 类型还有一处问题一样是使用了 IWindsorContainer 提供的方法，这里改为 DryIoc 提供的方法即可。\n1 2 3 4 5 6 7 8 9 10 private void RegisterBootstrapper() { if (!IocManager.IsRegistered\u0026lt;AbpBootstrapper\u0026gt;()) { // IocManager.IocContainer.Register( // Component.For\u0026lt;AbpBootstrapper\u0026gt;().Instance(this) // ); IocManager.IocContainer.UseInstance(this); } } 第二个问题则是 AbpKernelModule 当中的报错，其实与上一个类型的错误一样，第一个是调用了之前的 Install 的方法，并且 Intsaller 也不是继承自 IDryIocInstaller，另一个问题则是使用了 IWindsorContainer 里面的注册方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public override void Initialize() { foreach (var replaceAction in ((AbpStartupConfiguration)Configuration).ServiceReplaceActions.Values) { replaceAction(); } // IocManager.IocContainer.Install(new EventBusInstaller(IocManager)); IocManager.Install(new EventBusInstaller(IocManager)); IocManager.Register(typeof(IOnlineClientManager\u0026lt;\u0026gt;), typeof(OnlineClientManager\u0026lt;\u0026gt;), DependencyLifeStyle.Singleton); IocManager.RegisterAssemblyByConvention(typeof(AbpKernelModule).GetAssembly(), new ConventionalRegistrationConfig { InstallInstallers = false }); } EventBusInstaller 的变更：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 using System.Reflection; using Abp.Configuration.Startup; using Abp.Dependency; using Abp.Events.Bus.Factories; using Abp.Events.Bus.Handlers; using Castle.MicroKernel; using Castle.MicroKernel.Registration; using Castle.MicroKernel.SubSystems.Configuration; using Castle.Windsor; using DryIoc; namespace Abp.Events.Bus { /// \u0026lt;summary\u0026gt; /// Installs event bus system and registers all handlers automatically. /// \u0026lt;/summary\u0026gt; internal class EventBusInstaller : IDryIocInstaller { private readonly IIocResolver _iocResolver; private readonly IEventBusConfiguration _eventBusConfiguration; private IEventBus _eventBus; public EventBusInstaller(IIocResolver iocResolver) { _iocResolver = iocResolver; _eventBusConfiguration = iocResolver.Resolve\u0026lt;IEventBusConfiguration\u0026gt;(); } public void Install(IIocManager iocManager) { if (_eventBusConfiguration.UseDefaultEventBus) { iocManager.IocContainer.UseInstance\u0026lt;IEventBus\u0026gt;(EventBus.Default); } else { iocManager.IocContainer.Register\u0026lt;IEventBus,EventBus\u0026gt;(Reuse.Singleton); } _eventBus = iocManager.Resolve\u0026lt;IEventBus\u0026gt;(); iocManager.RegisterTypeEventHandler += (manager, type, implementationType) =\u0026gt; { if (!typeof(IEventHandler).GetTypeInfo().IsAssignableFrom(implementationType)) { return; } var interfaces = implementationType.GetTypeInfo().GetInterfaces(); foreach (var @interface in interfaces) { if (!typeof(IEventHandler).GetTypeInfo().IsAssignableFrom(@interface)) { continue; } var genericArgs = @interface.GetGenericArguments(); if (genericArgs.Length == 1) { _eventBus.Register(genericArgs[0], new IocHandlerFactory(_iocResolver, implementationType)); } } }; } } } 另外一处的变更如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private void RegisterMissingComponents() { if (!IocManager.IsRegistered\u0026lt;IGuidGenerator\u0026gt;()) { // IocManager.IocContainer.Register( // Component // .For\u0026lt;IGuidGenerator, SequentialGuidGenerator\u0026gt;() // .Instance(SequentialGuidGenerator.Instance) // ); IocManager.IocContainer.UseInstance\u0026lt;IGuidGenerator\u0026gt;(SequentialGuidGenerator.Instance); IocManager.IocContainer.UseInstance\u0026lt;SequentialGuidGenerator\u0026gt;(SequentialGuidGenerator.Instance); } IocManager.RegisterIfNot\u0026lt;IUnitOfWork, NullUnitOfWork\u0026gt;(DependencyLifeStyle.Transient); IocManager.RegisterIfNot\u0026lt;IAuditingStore, SimpleLogAuditingStore\u0026gt;(DependencyLifeStyle.Singleton); IocManager.RegisterIfNot\u0026lt;IPermissionChecker, NullPermissionChecker\u0026gt;(DependencyLifeStyle.Singleton); IocManager.RegisterIfNot\u0026lt;IRealTimeNotifier, NullRealTimeNotifier\u0026gt;(DependencyLifeStyle.Singleton); IocManager.RegisterIfNot\u0026lt;INotificationStore, NullNotificationStore\u0026gt;(DependencyLifeStyle.Singleton); IocManager.RegisterIfNot\u0026lt;IUnitOfWorkFilterExecuter, NullUnitOfWorkFilterExecuter\u0026gt;(DependencyLifeStyle.Singleton); IocManager.RegisterIfNot\u0026lt;IClientInfoProvider, NullClientInfoProvider\u0026gt;(DependencyLifeStyle.Singleton); IocManager.RegisterIfNot\u0026lt;ITenantStore, NullTenantStore\u0026gt;(DependencyLifeStyle.Singleton); IocManager.RegisterIfNot\u0026lt;ITenantResolverCache, NullTenantResolverCache\u0026gt;(DependencyLifeStyle.Singleton); IocManager.RegisterIfNot\u0026lt;IEntityHistoryStore, NullEntityHistoryStore\u0026gt;(DependencyLifeStyle.Singleton); if (Configuration.BackgroundJobs.IsJobExecutionEnabled) { IocManager.RegisterIfNot\u0026lt;IBackgroundJobStore, InMemoryBackgroundJobStore\u0026gt;(DependencyLifeStyle.Singleton); } else { IocManager.RegisterIfNot\u0026lt;IBackgroundJobStore, NullBackgroundJobStore\u0026gt;(DependencyLifeStyle.Singleton); } } 4.1.6 测试 做完以上变更之后，新建一个控制台程序，引用这个 Abp 库项目，然后键入以下代码进行测试即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 using System; using Abp; using Abp.Modules; using Abp.Runtime.Session; namespace ConsoleApp { class Program { static void Main(string[] args) { // Abp 框架测试 using (var bootstarp = AbpBootstrapper.Create\u0026lt;StartupModule\u0026gt;()) { bootstarp.Initialize(); // 解析 IAbpSession 看是否正常地进行了注入 var session = bootstarp.IocManager.Resolve\u0026lt;IAbpSession\u0026gt;(); if (session != null \u0026amp;\u0026amp; session is ClaimsAbpSession claimsSession) { Console.WriteLine(\u0026#34;当前 Session 已经成功被注入为 ClaimAbpSession\u0026#34;); } } Console.ReadLine(); } } [DependsOn(typeof(AbpKernelModule))] public class StartupModule : AbpModule { } } 4.2 EFCore 库与相关库改造 针对 Abp 库进行测试之后，基本上我们 Abp 现在所有组件都是通过 DryIoc 来进行注册与解析的了。不过仅仅针对 Abp 做这些更改其实是不够的，除了 Abp 核心库之外，我们最常用的就是数据库操作了。因为在 Abp.EntityFrameworkCore 库 和 Abp.EntityFramework.Common 的内部也有部分代码在之前是直接通过 IWindsorContainer 进行注册与解析操作的，所以我们也得继续改报错的地方。\n4.2.1 仓储类注册 在 Abp.EntityFramework.Common 库的 EfGenericRepositoryRegistrar 类型内部，有使用到 IWindsorContainer 的组件注册方法，用于注入 IRepository\u0026lt;,\u0026gt; 泛型仓储。下面代码展示的更改后的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 private void RegisterForDbContext( Type dbContextType, IIocManager iocManager, Type repositoryInterface, Type repositoryInterfaceWithPrimaryKey, Type repositoryImplementation, Type repositoryImplementationWithPrimaryKey) { foreach (var entityTypeInfo in _dbContextEntityFinder.GetEntityTypeInfos(dbContextType)) { var primaryKeyType = EntityHelper.GetPrimaryKeyType(entityTypeInfo.EntityType); if (primaryKeyType == typeof(int)) { var genericRepositoryType = repositoryInterface.MakeGenericType(entityTypeInfo.EntityType); if (!iocManager.IsRegistered(genericRepositoryType)) { var implType = repositoryImplementation.GetGenericArguments().Length == 1 ? repositoryImplementation.MakeGenericType(entityTypeInfo.EntityType) : repositoryImplementation.MakeGenericType(entityTypeInfo.DeclaringType, entityTypeInfo.EntityType); // iocManager.IocContainer.Register( // Component // .For(genericRepositoryType) // .ImplementedBy(implType) // .Named(Guid.NewGuid().ToString(\u0026#34;N\u0026#34;)) // .LifestyleTransient() // ); iocManager.IocContainer.Register(genericRepositoryType,implType,Reuse.Transient); } } var genericRepositoryTypeWithPrimaryKey = repositoryInterfaceWithPrimaryKey.MakeGenericType(entityTypeInfo.EntityType,primaryKeyType); if (!iocManager.IsRegistered(genericRepositoryTypeWithPrimaryKey)) { var implType = repositoryImplementationWithPrimaryKey.GetGenericArguments().Length == 2 ? repositoryImplementationWithPrimaryKey.MakeGenericType(entityTypeInfo.EntityType, primaryKeyType) : repositoryImplementationWithPrimaryKey.MakeGenericType(entityTypeInfo.DeclaringType, entityTypeInfo.EntityType, primaryKeyType); // iocManager.IocContainer.Register( // Component // .For(genericRepositoryTypeWithPrimaryKey) // .ImplementedBy(implType) // .Named(Guid.NewGuid().ToString(\u0026#34;N\u0026#34;)) // .LifestyleTransient() // ); iocManager.IocContainer.Register(genericRepositoryTypeWithPrimaryKey,implType,Reuse.Transient); } } } 按照以上方法更改之后，Abp.EntityFramework.Common 应该可以正常地进行编译了。\n4.2.2 DbContext 配置类更改 在 AbpEfCoreConfiguration 类型当中，也有使用到 IWindsorContainer 接口的地方，进行如下变更即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 using System; using Abp.Dependency; using Castle.MicroKernel.Registration; using DryIoc; using Microsoft.EntityFrameworkCore; namespace Abp.EntityFrameworkCore.Configuration { public class AbpEfCoreConfiguration : IAbpEfCoreConfiguration { private readonly IIocManager _iocManager; public AbpEfCoreConfiguration(IIocManager iocManager) { _iocManager = iocManager; } public void AddDbContext\u0026lt;TDbContext\u0026gt;(Action\u0026lt;AbpDbContextConfiguration\u0026lt;TDbContext\u0026gt;\u0026gt; action) where TDbContext : DbContext { // _iocManager.IocContainer.Register( // Component.For\u0026lt;IAbpDbContextConfigurer\u0026lt;TDbContext\u0026gt;\u0026gt;().Instance( // new AbpDbContextConfigurerAction\u0026lt;TDbContext\u0026gt;(action) // ).IsDefault() // ); _iocManager.IocContainer.UseInstance\u0026lt;IAbpDbContextConfigurer\u0026lt;TDbContext\u0026gt;\u0026gt;(new AbpDbContextConfigurerAction\u0026lt;TDbContext\u0026gt;(action)); } } } 4.2.3 EFCore 库模块变更 该错误在 AbpEntityFrameworkCoreModule 模块的 Initialize() 方法里面，一样的是因为使用了 IWndsorContainer 的注册方法导致的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public override void Initialize() { IocManager.RegisterAssemblyByConvention(typeof(AbpEntityFrameworkCoreModule).Assembly); // IocManager.IocContainer.Register( // Component.For(typeof(IDbContextProvider\u0026lt;\u0026gt;)) // .ImplementedBy(typeof(UnitOfWorkDbContextProvider\u0026lt;\u0026gt;)) // .LifestyleTransient() // ); IocManager.IocContainer.Register(typeof(IDbContextProvider\u0026lt;\u0026gt;),typeof(UnitOfWorkDbContextProvider\u0026lt;\u0026gt;),Reuse.Transient); RegisterGenericRepositoriesAndMatchDbContexes(); } 而另一处错误则是在 RegisterGenericRepositoriesAndMatchDbContexes() 方法内部：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private void RegisterGenericRepositoriesAndMatchDbContexes() { // ... 其他的代码 using (IScopedIocResolver scope = IocManager.CreateScope()) { foreach (var dbContextType in dbContextTypes) { Logger.Debug(\u0026#34;Registering DbContext: \u0026#34; + dbContextType.AssemblyQualifiedName); scope.Resolve\u0026lt;IEfGenericRepositoryRegistrar\u0026gt;().RegisterForDbContext(dbContextType, IocManager, EfCoreAutoRepositoryTypes.Default); // IocManager.IocContainer.Register( // Component.For\u0026lt;ISecondaryOrmRegistrar\u0026gt;() // .Named(Guid.NewGuid().ToString(\u0026#34;N\u0026#34;)) // .Instance(new EfCoreBasedSecondaryOrmRegistrar(dbContextType, scope.Resolve\u0026lt;IDbContextEntityFinder\u0026gt;())) // .LifestyleTransient() // ); IocManager.IocContainer.UseInstance\u0026lt;ISecondaryOrmRegistrar\u0026gt;(new EfCoreBasedSecondaryOrmRegistrar(dbContextType, scope.Resolve\u0026lt;IDbContextEntityFinder\u0026gt;())); } scope.Resolve\u0026lt;IDbContextTypeMatcher\u0026gt;().Populate(dbContextTypes); } } 4.2.4 DbContext 解析器变更 这个解析器的主要问题则与前面的不一样，这里报错是因为在构造 DbContext 的时候需要传入构造参数。根据我们之前的改动，现在 Resolve() 方法传入的是一个 object[] 数组，而不是原来的 object 对象，所以这里需要进行一些细微的改动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 using Abp.Dependency; using Abp.EntityFramework; using Abp.EntityFrameworkCore.Configuration; using Microsoft.EntityFrameworkCore; using System; using System.Data.Common; using System.Reflection; using JetBrains.Annotations; using Microsoft.EntityFrameworkCore.Metadata.Internal; using System.Linq; namespace Abp.EntityFrameworkCore { public class DefaultDbContextResolver : IDbContextResolver, ITransientDependency { // ... 其他代码 public TDbContext Resolve\u0026lt;TDbContext\u0026gt;(string connectionString, DbConnection existingConnection) where TDbContext : DbContext { // ... 其他代码 try { if (isAbstractDbContext) { // return (TDbContext) _iocResolver.Resolve(concreteType, new // { // options = CreateOptionsForType(concreteType, connectionString, existingConnection) // }); return (TDbContext) _iocResolver.Resolve(concreteType, new object[] { CreateOptionsForType(concreteType, connectionString, existingConnection) }); } // return _iocResolver.Resolve\u0026lt;TDbContext\u0026gt;(new // { // options = CreateOptions\u0026lt;TDbContext\u0026gt;(connectionString, existingConnection) // }); return _iocResolver.Resolve\u0026lt;TDbContext\u0026gt;(new object[] { CreateOptions\u0026lt;TDbContext\u0026gt;(connectionString, existingConnection) }); } catch (Castle.MicroKernel.Resolvers.DependencyResolverException ex) { // ... 其他代码 } // ... 其他代码 } // ... 其他代码 } } 至此，针对于 EFCore 相关的库改造就已经成功完成了。\n4.3 ASP .NET Core 相关改造 到目前，我们已经针对 Abp 的核心库和 EF Core 库都进行了一些不算大的改动，现在就只剩 Abp.AspNetCore 库了。因为 .NET Core 自己使用了一套 DI 框架。而我们在之前的源码分析也有讲到过，通过更改 Startup 类的 ConfigureService() 方法的返回值为 IServiceProvider，就可以将原来内部的 DI 框架替换为其他的 DI 框架。\n在原来 Abp.AspNetCore 库的 AbpServiceCollectionExtensions 扩展类当中可以看到以下代码：\n1 2 3 4 5 6 7 8 9 public static IServiceProvider AddAbp\u0026lt;TStartupModule\u0026gt;(this IServiceCollection services, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) where TStartupModule : AbpModule { var abpBootstrapper = AddAbpBootstrapper\u0026lt;TStartupModule\u0026gt;(services, optionsAction); ConfigureAspNetCore(services, abpBootstrapper.IocManager); return WindsorRegistrationHelper.CreateServiceProvider(abpBootstrapper.IocManager.IocContainer, services); } 这里我们可以看到，Abp 通过 WindsorRegistrationHelper 类创建并返回了一个 IServiceProvider 对象。那么 DryIoc 是否也为我们提供了这样的扩展方法呢？答案是有的，DryIoc 通过 DryIoc.Microsoft.DependencyInjection 给我们提供了一个适配器，该适配器可以基于 DryIoc 创建一个 IServiceProvier 来替换掉默认的 DI 框架。\n首先我们为 Abp.AspNetCore 库添加 DryIoc.Microsoft.DependencyInjection 的 NuGet 包，然后编辑上述方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static IServiceProvider AddAbp\u0026lt;TStartupModule\u0026gt;(this IServiceCollection services, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) where TStartupModule : AbpModule { var abpBootstrapper = AddAbpBootstrapper\u0026lt;TStartupModule\u0026gt;(services, optionsAction); ConfigureAspNetCore(services, abpBootstrapper.IocManager); var newContainer = new Container(rules =\u0026gt; rules.WithAutoConcreteTypeResolution()) .WithDependencyInjectionAdapter(services); abpBootstrapper.IocManager.InitializeInternalContainer(newContainer); return abpBootstrapper.IocManager.IocContainer.BuildServiceProvider(); } 4.3.1 视图组件与其他组件的自动注册 除了更改上述问题之外，在 Abp.AspNetCore 库还有一个注册器 AbpAspNetCoreConventionalRegistrar，在里面也使用了 IWindsorContainer 接口的注册方法，此处也需要进行更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 using System.Linq; using Abp.Dependency; using Microsoft.AspNetCore.Mvc; namespace Abp.AspNetCore { public class AbpAspNetCoreConventionalRegistrar : IConventionalDependencyRegistrar { public void RegisterAssembly(IConventionalRegistrationContext context) { //ViewComponents var types = context.Assembly.GetTypes() .AsParallel() .Where(type =\u0026gt; typeof(ViewComponent).IsAssignableFrom(type)) .Where(type =\u0026gt; !type.IsGenericTypeDefinition) .Where(type =\u0026gt; !type.IsAbstract) .AsSequential(); foreach (var type in types) { context.IocManager.Register(type); } } } } 完成以上操作之后，我们新建 4 个项目，分别是 AspNetCoreApp(Web 项目) 、 AspNetCoreApp.Core(库项目) 、AspNetCore.Application(库项目) 、 AspNetCoreApp.EntityFrameworkCore(库项目) ，并且配置好各自的依赖关系。\n4.3.2 IServiceProvider 适配器 首先我们更改 AspNetCoreApp 下面的 ConfigureService() 方法与 Configure() 方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 using System; using Abp.AspNetCore; using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.DependencyInjection; namespace AspNetCoreApp { public class Startup { public IServiceProvider ConfigureServices(IServiceCollection services) { services.AddMvc(); return services.AddAbp\u0026lt;AspNetCoreAppModule\u0026gt;(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseMvc(); app.UseAbp(op=\u0026gt;op.UseCastleLoggerFactory = false); } } } 不出意外的话，会抛出以下异常信息：\n上述异常的意思是说无法解析 Microsoft.AspNetCore.Hosting.Internal.WebHostOptions 对象，这说明我们的 DryIoc 容器并没有将 MVC 服务初始化注入的对象获取到。\n我们在 AddAbp\u0026lt;TStartupModule\u0026gt;() 方法内打一个断点，看一下在 ConfigureAspNetCore() 方法内部注入的对象是否放在 IContainer 里面，结果发现并没有。\n所以之后呢，我经过测试，只有 new 一个新的 Container 对象，然后对其调用 WithDependencyInjectionAdapter() 方法才会正常的获取到注入的 MVC 组件。\n效果：\n那么就需要将 IocManager 内部的 IocContainer 赋值为这里创建的 newContainer 对象，而 IIocManager 接口所定义的 IocContainer 属性是只读的。所以这里我为 IIocManager 接口新增了一个 InitializeInternalContainer() 方法用于初始化 IocContainer 属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface IIocManager : IIocRegistrar, IIocResolver, IDisposable { // ... 其他代码 /// \u0026lt;summary\u0026gt; /// 类型注册事件 /// \u0026lt;/summary\u0026gt; event RegisterTypeEventHandler RegisterTypeEventHandler; /// \u0026lt;summary\u0026gt; /// 初始化 IocManager 内部的容器 /// \u0026lt;/summary\u0026gt; void InitializeInternalContainer(IContainer dryIocContainer); } IocManager 需要实现该方法，并且将其构造器内的相关注册方法移动到 InitializeInternalContainer() 内部。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class IocManager : IIocManager { // ... 其他代码 public IocManager() { _conventionalRegistrars = new List\u0026lt;IConventionalDependencyRegistrar\u0026gt;(); } public void InitializeInternalContainer(IContainer dryIocContainer) { IocContainer = dryIocContainer; //Register self! IocContainer.UseInstance(typeof(IocManager),this); IocContainer.UseInstance(typeof(IIocManager),this); IocContainer.UseInstance(typeof(IIocRegistrar),this); IocContainer.UseInstance(typeof(IIocResolver),this); } // ... 其他代码 } 之后再回到最开始的地方，我们最终 AddAbp\u0026lt;TStartupModule\u0026gt;() 方法的内部实现是下面这个样子的：\n1 2 3 4 5 6 7 8 9 10 11 12 public static IServiceProvider AddAbp\u0026lt;TStartupModule\u0026gt;(this IServiceCollection services, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) where TStartupModule : AbpModule { var abpBootstrapper = AddAbpBootstrapper\u0026lt;TStartupModule\u0026gt;(services, optionsAction); ConfigureAspNetCore(services, abpBootstrapper.IocManager); var newContainer = new Container().WithDependencyInjectionAdapter(services); abpBootstrapper.IocManager.InitializeInternalContainer(newContainer); return abpBootstrapper.IocManager.IocContainer.BuildServiceProvider(); } 运行 AspNetCoreApp 项目，我们可以看到正常运行了。\n五、存在的问题 5.1 ApplicationService 属性注入失效 在示例项目当中，我在 AspNetCoreApp.Application 库当中建立了一个 TestApplicationService 服务，该服务用有一个 GetJson() 方法。\n在其内部，我调用了父类提供的 AbpSession 属性，按照正常的情况下，该属性的实现应该是 ClaimsAbpSession 类型，不过通过测试之后我得到了以下结果：\n可以看到，它填充的是默认的空实现，造成这个问题的原因是，DryIoc 本身在注册对象的时候，需要显式提供属性注入的选项，否则默认是不启用属性注入的。\n鉴于此，我们为 IIocRegistrar 与 IocManager 内所提供的 Register() 方法增加一个 isAutoInjectProperty 字段，用于判断是否在注册的使用启用属性注入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface IIocRegistrar { /// \u0026lt;summary\u0026gt; /// Registers a type as self registration. /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;Type of the class\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;lifeStyle\u0026#34;\u0026gt;Lifestyle of the objects of this type\u0026lt;/param\u0026gt; void Register\u0026lt;T\u0026gt;(DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton,bool isAutoInjectProperty = false) where T : class; /// \u0026lt;summary\u0026gt; /// Registers a type as self registration. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;type\u0026#34;\u0026gt;Type of the class\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lifeStyle\u0026#34;\u0026gt;Lifestyle of the objects of this type\u0026lt;/param\u0026gt; void Register(Type type, DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton,bool isAutoInjectProperty = false); /// \u0026lt;summary\u0026gt; /// Registers a type with it\u0026#39;s implementation. /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TType\u0026#34;\u0026gt;Registering type\u0026lt;/typeparam\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TImpl\u0026#34;\u0026gt;The type that implements \u0026lt;see cref=\u0026#34;TType\u0026#34;/\u0026gt;\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;lifeStyle\u0026#34;\u0026gt;Lifestyle of the objects of this type\u0026lt;/param\u0026gt; void Register\u0026lt;TType, TImpl\u0026gt;(DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton,bool isAutoInjectProperty = false) where TType : class where TImpl : class, TType; /// \u0026lt;summary\u0026gt; /// Registers a type with it\u0026#39;s implementation. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;type\u0026#34;\u0026gt;Type of the class\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;impl\u0026#34;\u0026gt;The type that implements \u0026lt;paramref name=\u0026#34;type\u0026#34;/\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lifeStyle\u0026#34;\u0026gt;Lifestyle of the objects of this type\u0026lt;/param\u0026gt; void Register(Type type, Type impl, DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton,bool isAutoInjectProperty = false); } 而具体实现则需要使用 isAutoInjectProperty 来判断是否需要属性注入功能，下面随便以一个 Register() 方法为例。\n1 2 3 4 5 6 7 8 9 10 11 12 public void Register(Type type, DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton,bool isAutoInjectProperty = false) { IocContainer.Register(type, ApplyLifestyle(lifeStyle), made: Made.Of(FactoryMethod.ConstructorWithResolvableArguments, propertiesAndFields: isAutoInjectProperty ? PropertiesAndFields.Auto : null)); RegisterTypeEventHandler?.Invoke(this, type, type); } 写好之后，我们再回到 BasicConventionalRegistrar 注册器当中，因为应用服务类型个都是瞬时对象，并且应用服务都会继承 IApplicationService 接口。所以我们加一个判断，如果是应用服务的话，则在注册的时候，允许进行属性注入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class BasicConventionalRegistrar : IConventionalDependencyRegistrar { // ... 其他代码 public void RegisterAssembly(IConventionalRegistrationContext context) { // 瞬时对象注册 var waitRegisterTransient = GetTypes\u0026lt;ITransientDependency\u0026gt;(context.Assembly).ToList(); foreach (var transientType in waitRegisterTransient) { if (typeof(IApplicationService).IsAssignableFrom(transientType.ImplType)) { context.IocManager.Register(transientType.ServiceType,transientType.ImplType,DependencyLifeStyle.Transient,true); continue; } context.IocManager.RegisterIfNot(transientType.ServiceType,transientType.ImplType,DependencyLifeStyle.Transient); } // ... 其他代码 } } 进行了上述更改之后，再次调用接口进行测试可以看到属性已经被正常地注入了。\nPS:\n这里一定要注意 AspNetCoreApp.Application 库里面的 AspNetCoreAppAppicationModule 模块一定要在 Initialize() 方法调用 IocManager.RegisterAssemblyByConvention(typeof(AspNetCoreAppApplicationModule).Assembly); 否则应用服务不会被注入到 Ioc 容器当中的。\n5.2 无法获取拦截器真实类型 该问题主要出在拦截器里面，因为在 DryIoc 当中如果某个类型绑定了多个拦截器，那么就会形成一个层级关系。类似于下面截图的这样：\n所以如果你需要在外层的拦截器获取真实对象，目前只能通过递归来解决该问题。\n1 2 3 4 5 6 7 8 9 10 public static Type GetUnproxiedType(object instance) { if (instance is IProxyTargetAccessor proxyTargetAccessor) { var newInstance = proxyTargetAccessor.DynProxyGetTarget(); return GetUnproxiedType(newInstance); } return instance.GetType(); } 然后使用方式如下：\n1 2 3 4 5 public void Intercept(IInvocation invocation) { _authorizationHelper.Authorize(invocation.MethodInvocationTarget, TypeExtensions.GetUnproxiedType(invocation.Proxy)); invocation.Proceed(); } 该问题我在 Github 上面已经向作者提出，作者反馈正在解决。\n六、结语 虽然通过文章看起来整个过程十分简单轻松，但是博主当时在操作的时候遇到了不少的坑。结合博主之前关于 Abp 源码分析的文章，你可以更加地了解 Abp 整个框架的结构。\n通过这种方式，你除了可以将 DI 框架换成 DryIoc 之外，你也可以替换成你喜欢的其他 DI 框架。\n在 Abp vNext 当中的设计Ioc 容器是可以很方便替换的，你可以更加方便地替换 Ioc 容器，就不需要像现在这样麻烦。\nPS: 官方就有针对于 AutoFac 与 Castle Windsor 的扩展。\n改造完成的代码与 DEMO 的 GitHub 地址：https://github.com/GameBelial/Abp-DryIoc.git\n","date":"2018-11-20T02:50:39Z","permalink":"https://real-zony.github.io/p/replace-abps-di-framework-with-dryioc/","title":"使用 DryIoc 替换 Abp 的 DI 框架"},{"content":"一、CLR 线程池基础 一般来说如果计算机的 CPU 利用率没有 100% ，那么说明很多进程的部分线程没有运行。可能在等待 文件/网络/数据库等设备读取或者写入数据，又可能是等待按键、鼠标移动等事件。\n执行 I/O 限制的操作时，操作系统通过设备驱动程序通知硬件干活，而 CPU 处于一种空闲状态。而在现代应用程序当中，使用线程池来执行计算限制的操作，而不是手动创建线程。\n每个 CLR 都有自己独立的线程池，并且由各自 CLR 控制的所有 AppDomain 所共享。\n线程池本身维护了一个请求队列，当程序需要执行一个异步操作的时候，会将一个记录项追加到队列之中，然后由线程池将该记录项分派给线程池线程，如果没有线程则创建一个新的线程。线程任务处理完整之后，将该线程放入线程池中等待以后进行复用。\n线程池本身是启发式的，结合程序负载，他会自己根据当前线程池内线程的状态销毁/新增线程。\n二、执行简单的计算限制操作 通过 ThreadPool 静态类，我们可以方便地使用线程池中的线程为我们执行一些计算限制的异步操作。只需要调用 ThreadPool 的 QueueUserWorkItem(WaitCallBack callback) 方法，或者是他的另一个重载方法，接收一个 state 值作为参数。\n他的两个方法都是非阻塞的，调用之后会立即返回。\nWaitCallBack 的方法签名如下：\n1 delegate void WaitCallBack(Object state); 在 CLR 的线程池中，将 callback 委托作为工作项添加到队列当中，然后由线程池分发线程进行处理。\n【注意】\n一旦回调方法抛出了未处理的异常，CLR 会立即终止进程。\n三、执行上下文 每个线程都有一个执行上下文的数据结构，包含由安全设置，宿主设置和逻辑调用上下文数据(AsyncLocal 与 CallContext)。\n当在某个线程(例如主线程)使用了另外一个线程(辅助线程)，就会产生执行上下文由调用者线程流向被调用线程。这会对性能造成一定的影响，这是因为执行上下文包含有大量地信息。而如果辅助线程又调用了更多的辅助线程，这个时候执行上下问的复制开销就非常大。\n我们可以通过 ExecutionContext 类控制线程的执行上下文是否流向辅助线程，只有辅助线程不需要访问执行上下文时可以阻止执行上下文流动。当阻止了执行上下文流动时，辅助线程会使用最后一次与其关联的任意执行上下文，这个时候对于安全设置等就不可信，不应执行任何依赖于执行上下文的操作。\n一般来说在主线程，可以通过 ExecutionContext.SuppressFlow(); 方法阻止执行上下文流动，然后再通过 ExecutionContext.RestoreFlow(); 恢复流动。\n四、协作式取消和超时 .NET 提供了标准的取消操作模式，这个模式是协作式的，也就是你要取消的操作必须显式声明自己可以被取消。这是因为用户在执行某些长耗时的计算限制操作的时候，可能会因为等待时间太长或者其他原因需要取消这个操作。\n首先我们通过 System.Threading.CancellationTokenSource 对象管理或者取消对象状态，使用时直接 new 一个即可，而该对象拥有一个 CancellationToken 对象。\n这个 Token 对象用于传递给执行计算限制操作的方法，通过该 Token 的 IsCancellationRequested 属性你可以在方法内部确认任务是否被取消，如果被取消你就可以进行返回操作。\n例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void Main(string[] args) { var tokenSource = new CancellationTokenSource(); ThreadPool.QueueUserWorkItem(z =\u0026gt; Calculate(CancellationToken.None, 10000)); Console.ReadKey(); tokenSource.Cancel(); Console.ReadLine(); } private static void Calculate(CancellationToken token, int count) { for (int i = 0; i \u0026lt; count; i++) { if (token.IsCancellationRequested) { Console.WriteLine(\u0026#34;用户提前终止操作，退出线程..\u0026#34;); break; } Console.WriteLine(count); Thread.Sleep(200); } Console.WriteLine(\u0026#34;计数完成.\u0026#34;); } 【注意】\n如果你要执行一个不允许被取消的操作，可以为方法传递一个 CancellationToken.None 对象，因为该对象没有 Source 源，则不可能会被调用 Cancel() 进行取消。\n注册取消事件 CancellationToken 允许我们通过 Register() 方法注册多个委托，这些被注册了的委托会在 TokenSource 调用 Cancel 取消的时候优先调用，其调用的先后顺序为注册时的顺序。\n【注意】\n调用 Register() 方法的时候，他有两个 bool 类型的参数，分别是 useSyncContext 与 useExecutionContext。这两个参数用于指定，是否要用调用线程的同步上下文或者执行上下文来调用回调函数。\n同时在注册成功之后会返回一个 CancellationTokenRegistration 对象，通过调用该对象的 Dispose 方法可以删除已经注册的委托回调，这样在取消时就不会调用该回调。\nTokenSource 链接 可以通过 CancellationTokenSource.CreateLinkedTokenSource() 链接两个或多个对象，链接成功后会返回一个单独的 TokenSource 对象。\n一旦这个新对象链接的任何一个 TokenSource 对象被取消的时候，该对象也会被取消掉。\nCancel 的异常处理 在调用 TokenSource 的 Cancel() 方法时(默认为 false)，该方法还有另外一个重载传入 bool 值，如果为 true 的时候，有多个注册的回调委托，一旦某个出现异常直接会被抛出该异常，不会等待其他回调执行完毕。\n如果为 false，则会等到所有回调方法执行完成时，抛出一个 AggregateException 异常，内部的 InnerExceptions 包含有所有在执行过程中产生的异常信息集合。\n超时取消 除了直接调用 Cancel() 立即取消操作之外，还有一个延迟取消的方法 CancelAfter()，通过传递具体的延迟时间，我们可以在指定的之间之后取消某个任务。(PS：有点像 Polly 的 TimeOut )\n五、任务 为啥使用任务，虽然通过 ThreadPool 可以很方便地发起一次计算限制的操作，但是你不知道你的方法啥时候执行完成，也无法在操作完成之后获得返回值。\n使用任务执行一个计算限制操作有两种方式，两者也一样的可以传递 CancellationToken 进行取消操作：\nnew Task(Sum,20).Start(); Task.Run(()=\u0026gt;Sum(20)); 除此之外还可以在构造 Task 时 传递一些标志位，用于任务调度器进行一些特殊处理。\n等待任务完成并获取结果 任务除了标准的无返回值的 Task 类型之外，还有一个包含有泛型参数的 Task\u0026lt;TResult\u0026gt; 类型，其中 TResult 参数就是任务的返回值类型。\n在创建好 Task\u0026lt;TResult\u0026gt; 对象之后，可以通过 Task.Wait() 等待任务执行完成，Task 的 Wait() 方法会阻塞调用者线程直到任务执行完成。执行完成之后，可以通过 Task.Reuslt 获取任务执行之后的返回值。\nPS:\n这里获取 Result 属性值时，其内部也会调用 Wait() 方法。\n如果该 Task 内的计算限制操作抛出了未经处理的异常，这个异常会被吞噬掉，调用 Wait() 方法或者使用 Result 属性的时候，这些异常信息会被包裹在 AggregateException 内部并返回给调用者线程。\n【注意】\n不推荐直接调用 Wait() ，如果 Task 已经开始执行，该方法会阻塞调用者线程，直到执行完成。第二种情况是任务还没有开始执行的时候，调用者线程不会被阻塞，Task 立即执行并返回。而调度器可能会使用调用者线程来执行这些操作，这个时候，如果调用者线程获取了一个线程同步锁，而 Task 因为也是在调用者线程执行，尝试获取锁的时候，就会产生死锁。\nAggregateException 可能会包含有多个异常，这个时候可以使用该对象的 Handle(Func\u0026lt;Exception,bool\u0026gt; predicate) 方法来为每一个异常进行处理，处理返回 true，未处理返回 false。\n在调用了 Handle 方法之后，仍然有异常没有处理，这些没有处理的异常又会造成一个新的 AggregateException 被抛出。\n【注意】\n如果不知道有哪些 Task 内部未处理的异常，可以通过象任务调度器的 UnobservedTaskException 事件登记一个回调方法，如果存在一个没有处理到的异常，则会调用你的回调方法，并将异常传递给你。\n除了 Task.Wait() 方法，还有等待一组任务的 Task.WaitAny() 和 Task.WaitAll()。几个方法都会阻塞调用者线程，前者当传递的一组任务有任意一个完成则立即返回该任务的索引，后者则是要等待这一组任务全部完成之后才会唤醒调用线程。\n这两个方法一旦被取消，都会抛出 OperationCanceledException 异常。\n取消任务 可以通过一个 CancellationTokenSource 来取消 Task，一样的需要传入的计算限制方法添加 CancellationToken 参数。\n只不过呢，在 Task 任务内部我们不通过 IsCancellationRequested 来判断任务是否取消，而是通过调用 Token 的 ThrowIfCancellationRequested() 方法来抛出异常。\n该方法会判断当前任务是否被取消，如果被取消了，则抛出异常。这是因为与直接通过线程池添加任务不同，线程池无法知道任务何时完成，而任务则可以表示是否完成，并且还能返回值。\n任务完成时启动新任务 之前说过通过调用 Task.Wait() 或者在任务尚未完成的时候调用 Task.Result 属性，都会造成线程池创建新的线程。而我们可以通过在任务完成之后，立即开启一个新的任务，这样我们就可以通过新的任务知道前一个任务是否已经完成了。\n创建一个的计算限制任务对象，我们在启动了该任务对象之后，调用 Task.ContinueWith() 方法来创建一个延续任务，新的延续性任务会有一个 Task 参数，该参数就是最开始的任务。\n而在使用 Task.ContinueWith() 时，他还可以传递一个标识位。这个标识位用于表明这个延续性任务是在第一个任务什么情况下才会执行，一般有三种：OnlyOnCanceled(第一个任务取消时才被执行)、OnlyOnFaulted(第一个任务抛出未处理异常时执行)、OnlyOnRanToCompletion(第一个任务顺利完成时执行)。\n启动子任务 一个任务在其内部可以创建其子任务，只需要在内部构造 Task 对象的时候，传递一个标识位 TaskCreationOptions.AttachedToParent 将其与父任务关联。这样的话，除非其所有子任务执行完成，父任务不会被认为已经完成。\n延续性任务也可以作为第一个任务的子任务，指定对应的标识位即可。\n任务的内部构造 任务主要由以下几部分构成：\n任务唯一的 Task Id。 调度器的引用。 回调方法的引用。 执行上下文的引用。 其他\u0026hellip; 可以看到构造一个 Task 还是需要比较大的开销的，如果你不需要 Task 的附加特性，完全可以使用 TaskPool.QueueUserworkItem 来获得更好的性能与效率。\n通过 Task 的只读属性 Task.Status，我们可以知道任务目前处于哪种状态，其最终的状态主要有 3 种，分别是：RanToCompletion(已完成)、Canceled(被取消)、Faulted(出现异常失败)，这三种状态都属于任务完成状态。\n另外值得注意的是，通过 ContinueWith()、ContinueWhenAll()、ContinueWhenAny() 等方法创建的任务状态都为 WaitingForActivation，这个状态代表任务会自动开始。\n任务工厂 如果你需要在执行多个相同配置的 Task 对象，可以通过 TaskFactory 和 TaskFactory\u0026lt;TResult\u0026gt;，其大概含义与 Task 的含义相同。\n在创建工厂时，可以传递一些常用的配置标识位和 CancellationToken 对象，之后我们可以通过 StartNew() 方法来统一执行一堆任务。\n任务调度器 任务调度器一般有两种，第一种是线程池任务调度器，一般用于服务端程序。还有一种是同步上下文任务调度器，一般用于 GUI 程序。\n六、Parallel 的 For、Foreach、Invoke For 与 Foreach 基本用于操作一个集合，然后循环处理其值。而如果在某个方法内部需要执行多个方法，则可以通过 Invoke 来进行执行。使用 Parallel 类可以让 CPU 最大化地利用起来而不会阻塞主线程。\n不过一般不会将所有 For 与 Foreach 都替换为并行化的查询，这是因为某些循环会修改共享数据，这个时候使用 Parallel 的操作则会破坏数据，虽然可以通过增加线程同步锁来解决，不过这样会造成单线程访问，无法享受并行处理的好处。\n同时 Parallel 方法本身也会有开销，当然在大量重复性任务中这种开销可以忽略不计，但是如果仅为几十个短耗时的计算限制任务启用 Parallel 就会得不偿失。\n这三种操作都接受一个ParallelOptions 对象用于配置最大并行的工作项数目与调度器。\nParallel 的 For 与 Foreach 的一个重载方法允许传入 3 个委托，他们分别是：\n任务局部初始化委托(localInit)：该委托是在每次工作项处理之前被调用。 任务主体委托(body)：具体的工作项处理逻辑，参与工作的各个线程都会调用一次。 任务局部终结器委托(localFinally)：本委托是在每个工作项处理完成之后都会被调用。 从上述逻辑来看，可以看作局部初始化委托为一个父任务，后面两个为子级连续任务的构造。\n实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 static void Main(string[] args) { var files = new List\u0026lt;string\u0026gt;(); files.AddRange(Directory.GetFiles(@\u0026#34;E:\\Program Files\u0026#34;,\u0026#34;*.*\u0026#34;,SearchOption.AllDirectories)); files.AddRange(Directory.GetFiles(@\u0026#34;E:\\Program Files (x86)\u0026#34;,\u0026#34;*.*\u0026#34;,SearchOption.AllDirectories)); files.AddRange(Directory.GetFiles(@\u0026#34;E:\\Project\u0026#34;,\u0026#34;*.*\u0026#34;,SearchOption.AllDirectories)); files.AddRange(Directory.GetFiles(@\u0026#34;E:\\Cache\u0026#34;,\u0026#34;*.*\u0026#34;,SearchOption.AllDirectories)); files.AddRange(Directory.GetFiles(@\u0026#34;E:\\Windows Kits\u0026#34;,\u0026#34;*.*\u0026#34;,SearchOption.AllDirectories)); files.AddRange(Directory.GetFiles(@\u0026#34;C:\\Program Files\\dotnet\u0026#34;,\u0026#34;*.*\u0026#34;,SearchOption.AllDirectories)); Console.WriteLine($\u0026#34;总文件数量：{files.Count}\u0026#34;); long allFileCount = 0; var watch = new Stopwatch(); watch.Start(); Parallel.ForEach\u0026lt;string, long\u0026gt;(files, localInit: () =\u0026gt; { // 初始化文件大小为 0， // 这里的参数类型取决于任务返回的参数 return 0; }, body: (fileName, parallelStatus, index, fileCount) =\u0026gt; { // 计算文件大小并返回 long count = 0; try { var info = new FileInfo(fileName); count = info.Length; } catch (Exception e) { } // 这里因为该任务会被线程池复用，所以要进行累加 return count + fileCount; }, localFinally: fileCount =\u0026gt; { Interlocked.Add(ref allFileCount, fileCount); } ); watch.Stop(); Console.WriteLine($\u0026#34;并行效率:{watch.ElapsedMilliseconds} ms\u0026#34;); Console.WriteLine($\u0026#34;文件总大小:{allFileCount / 1024 / 1024 / 1024} Gb\u0026#34;); allFileCount = 0; watch.Reset(); watch.Start(); foreach (var file in files) { long count = 0; try { var info = new FileInfo(file); count = info.Length; } catch (Exception e) { } allFileCount+=count; } watch.Stop(); Console.WriteLine($\u0026#34;单线程效率:{watch.ElapsedMilliseconds} ms\u0026#34;); Console.WriteLine($\u0026#34;文件总大小:{allFileCount / 1024 / 1024 / 1024} Gb\u0026#34;); Console.ReadLine(); } 性能提升：\n通过 Parallel 的 Foreach 与普通的 foreach 遍历计算，性能总体提升了约 56%，越耗时的操作提升的效果就越明显。\n在 Body 的主体委托当中，传入了一个 ParallelLoopState 对象，该对象用于每个线程与其他任务进行交互。主要有两个方法 Stop() 与 Break()，前者用于停止循环，后者用于跳出循环，并且跳出循环之后，其 LowestBreakIteration 会返回调用过 Break() 方法的最低项。\n并且 Parallel 还会返回一个 ParallelLoopResult 对象，该通过该对象我们可以得知这些循环是否正常完成。\n七、并行语言集成查询 PLINQ LINQ 默认查询的方式是一个线程顺序处理数据集合中的所有项，称之为顺序查询。而 PLINQ 就是将这些操作分散到各个 CPU 并行执行，通过 AsParallel() 扩展方法可以将 IEnumerable\u0026lt;TSource\u0026gt; 转换为 ParallelQuery\u0026lt;TSource\u0026gt;。\n而从并行操作切换回顺序操作，只需要调用 ParallelEnumable 的 AsSequential() 方法即可。\n经过 PLINQ 处理后的数据项其结果是无序的，如果需要有序结果，可以调用 AsOrdered() 方法。但是该方法比较损耗性能，一般不推荐使用，如果需要排序应该直接使用与 LINQ 同名的 PLINQ 扩展方法。\nPLINQ 一般会自己分析使用最好的查询方式进行查询，有时候使用顺序查询性能更好。\nWithCancellation() ：允许取消某个 PLINQ 查询。 WithExecutionMode()：允许配置 PLINQ 执行模式，是否强制并行查询。 WithMergeOptions()：允许配置结果的缓冲与合并方式。 WithDegreeOfParallelism()：允许配置查询的最大并行数。 PS：\n不建议在多线程环镜中使用 Console.Write() 进行输出，因为 Console 类内部会对线程进行同步，确保只有一个线程可以访问控制台窗口，这样会损害性能。\n八、定时计算限制操作 通过 CLR 提供的 Timer 定时器，我们可以传入一个回调方法。这样的话计时器会可以根据传入的周期，来定时将我们的回调方法通过线程池线程进行调用。\n同时计时器还允许传入一个 dueTime 参数来指定这个计时器首次调用回调方法时需要等待多久（立即执行可以传入 0），而 period 可以指定 Timer 调用回调方法的周期。\n【原理】\n在线程池内部所有的 Timer 对象只使用了一个线程，当某个 Timer 到期的时候，这个线程就会被唤醒。该线程通过 ThreadPool.QueueUserWorkItem() 方法将一个工作项添加到线程池队列，这样你的回调方法就会得到执行。\n【注意】\n如果回调方法执行的时常超过了你设置的周期时常，这样会造成多个线程都在执行你的回调。因为 Timer 不知道你的回调执行完成没有，他只会到期执行你的回调方法。\n解决措施是构造一个 Timer 的时候，为 period 指定一个 Timeout.Infinite 常量，这样计时器只会触发一次。之后在你的回调方法执行完成之后，在其内部通过 Timer.Change() 方法指定一个执行周期，并且设置其 dueTime 为立即执行。\n这样做了之后，你的 Timer 就会确保你的回调被执行完成之后再开始下一个周期。\n这一点可以参考 Abp 实现的 AbpTimer 对象。\n九、线程池如何管理线程 CLR 允许开发人员设置线程池最大工作者线程数，但是一般不要轻易设置该值，但你可以通过 ThreadPool.GetMaxThreads()、ThreadPool.GetMinThreads()、GetAvailableThreads() 方法来获取一些相关信息。\n通过 ThreadPool.QueueUserWorkItem() 方法和 Timer 类处理的工作项总是存储到 CLR 线程池的 全局队列 中。工作者线程采用一个 FIFO 算法将工作项从 全局队列 取出，因为所有工作者线程都有可能去这个队列拿去工作项，这个时候会使用 线程同步锁 以确保工作项只会被工作者线程处理一次。这可能会造成性能瓶颈，对伸缩性和性能会造成某些限制。\n默认的任务调度器中，非工作者线程调度 Task 时都是存放在全局队列，而工作者线程调度 Task 则是存放在他自己的本地队列。\n工作者线程处理 Task 的步骤：\n首先从本地队列采用 LIFO 算法取得一个 Task 进行处理。 如果本地队列没有 Task，则从其他的工作者线程本地队列拿一个 Task 自己来处理。（会使用线程同步锁） 所有本地队列都为空，则工作者线程会使用 FIFO 算法去全局队列拿一个 Task 进行处理。 如果全局队列为空，则线程处于休眠状态，时间过长则销毁自身。 PS:\n结合上下文，说明工作项首先被添加到了全局队列，然后由工作者线程取到自己的本地队列进行处理。\n线程池会动态地根据工作项的多少动态地调整工作者线程的数量，一般不需要开发人员进行管控。\n","date":"2018-11-07T04:27:08Z","permalink":"https://real-zony.github.io/p/clr-via-csharp-reading-notes-27-asynchronous-operation-of-calculation-limit/","title":"《CLR Via C#》读书笔记：27.计算限制的异步操作"},{"content":"一、线程开销 操作系统创建线程是有代价的，其主要开销在下面列举出来了。\n内存开销 线程内核对象\n拥有线程描述属性与线程上下文，线程上下文占用的内存空间为 x86 架构 占用 700 字节、x64 架构 1240 字节 、ARM 架构 350 字节。\n线程环境块(TEB)\nTEB 消耗一个内存页，占用 4KB内存。\n用户模式栈。\n用户模式栈存储传递给方法的局部变量与实参，并且还存储有一个地址用于当前方法返回的时候，线程应该从哪个地方继续执行。默认 Windows 分配保留 1MB 内存。\n内核模式栈。\n32 位 Windows 占用 12 KB，64 位 Windows 占用 24 KB。\nDLL 线程连接与线程分离通知。\n这种策略只有 Windows 才会存在，当创建线程时， Windows 会调用进程所有非托管 DLL 的 DllMain 方法，并未其传递 DLL_THREAD_ATTACH 标志，线程终止时传递 DLL_THREAD_DETACH 标志。\n线程上下文切换与 CPU 之间的关系 Windows 在任何时刻都只会将 1 个线程分配给 1 个 CPU ，该线程享有一个时间片的运行时间。时间片到期之后，Windows 会将上下文切换到另外一个线程，动作如下：\n将 CPU 寄存器值存储在当前正在运行的线程的内核对象内部的上下文结构之中。 从先有线程集合选取一个线程供调度，如果该线程属于另一个进程，还得切换 CPU 能够操作的虚拟地址空间。 将上下文结构中的值加载到 CPU 寄存器之中。 以上操作做完之后，Windows 等待这个线程时间片到期，执行下次切换，每次切换的时间开销大概为 30 毫秒。\n如果一个线程时间片结束之后，下一个调度的线程还是之前的线程则不会产生线程上下文切换。\n所以在理想状态下，每个系统最佳的线程数应该与其核心数相同，(如果是 4 核 8 线程则最优应该为 8 个)因为这样上下文切换出现的情况就会少很多。\n最重要的是，Windows 系统上大部分程序线程都处于空闲状态，但是线程占用的内存空间是事实存在的。\n三、使用专用线程执行计算限制的异步操作 一般来说不推荐使用 Thread 手动创建线程，而应该使用线程池，不过在有以下需求时，可以手动创建线程。\n需要设定更高的线程优先级的时候。 需要将线程设置为前台线程。 某些长耗时的专用线程。 该线程可能会通过 Thread 的 Abort 方法终止自身。 在调用过程中，如果使用了 Thread.Join() 方法那么就会造成调用线程阻塞当前代码，直到创建的线程被终止。\n四、为什么要使用线程 针对于客户端程序而言，多线程可以增强响应性，不会因为耗时操作阻塞 UI 线程造成用户体验卡顿。 针对于服务器程序而言，可以并发地处理用户请求，充分利用多核 CPU 的优势。 作者的观点是，计算机的 CPU 使用率应该保持 100% 的使用率才不算是浪费计算资源。\n五、线程调度与优先级 抢占式系统通过优先级来判定线程在什么时候调度多少时间，每个线程都分配了从 0 到 31 的优先级，系统为 CPU 分配线程时，首先检查 31 的线程，并以轮询的方式调度他们(优先级都为 31)。\n如果高优先级的线程一直处于调度状态，那么操作系统不会将 CPU 分配给低优先级的线程，这样就会造成 线程饥饿。\n较高的优先级线程总会抢占低优先级线程，即便该线程的时间片没有用完。\nCPU 会创建一个优先级为 0 的 零页线程 ，该线程是系统唯一一个优先级为 0 的线程，只有在 CPU 空闲的时候会执行他，用于清理 RAM 中所有的空闲内存页。\n【注意】\n进程优先级类 + 线程优先级构成了一个基础优先级，Windows 还有一个动态优先级用于防止产生线程饥饿，会动态调成线程的优先级状态。\n但是动态优先级只会针对基础优先级在 0 ~ 15 的线程应用，16 ~ 31 不受这个管控。\nWindows 通过两个抽象层用于表示进程优先级类和线程优先级，单一般 C# 用户代码中能够控制的只有线程优先级，他们分别是：Lowest、BelowNormal、Normal、AboveNormal、Highest。\n六、前台线程与后台线程 在 CLR 中线程只有两种状态，前台线程和后台线程，而且当所有前台线程被终止之后，CLR 会强行关闭所有后台线程，并退出程序。\n线程在运行的生命周期当中可以变更其状态，但主线程默认为前台线程，使用 Thread 类型创建的线程默认也是前台线程。只有线程池的线程默认为后台线程，进入托管执行的本机代码创建的任何线程也会标记为后台线程。\n","date":"2018-11-04T14:19:50Z","permalink":"https://real-zony.github.io/p/clr-via-csharp-reading-notes-thread-basics/","title":"《CLR Via C#》读书笔记：26.线程基础"},{"content":"一、什么是运行时序列化 序列化的作用就是将对象图(特定时间点的对象连接图)转换为字节流，这样这些对象图就可以在文件系统/网络进行传输。\n二、序列化/反序列化快速入门 一般来说我们通过 FCL 提供的 BinaryFormatter 对象就可以将一个对象序列化为字节流进行存储，或者通过该 Formatter 将一个字节流反序列化为一个对象。\nFCL 的序列化与反序列化 序列化操作：\n1 2 3 4 5 6 7 8 9 public MemoryStream SerializeObj(object sourceObj) { var memStream = new MemoryStream(); var formatter = new BinaryFormatter(); formatter.Serialize(memStream, sourceObj); return memStream; } 反序列化操作：\n1 2 3 4 5 6 public object DeserializeFromStream(MemoryStream stream) { var formatter = new BinaryFormatter(); stream.Position = 0; return formatter.Deserialize(stream); } 反序列化通过 Formatter 的 Deserialize() 方法返回序列化好的对象图的根对象的一个引用。\n深拷贝 通过序列化与反序列化的特性，可以实现一个深拷贝的方法，用户创建源对象的一个克隆体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public object DeepClone(object originalObj) { using (var memoryStream = new MemoryStream()) { var formatter = new BinaryFormatter(); formatter.Serialize(memoryStream, originalObj); // 表明对象是被克隆的，可以安全的访问其他托管资源 formatter.Context = new StreamingContext(StreamingContextStates.Clone); memoryStream.Position = 0; return formatter.Deserialize(memoryStream); } } 另外一种技巧就是可以将多个对象图序列化到一个流当中，即调用多次 Serialize() 方法将多个对象图序列化到流当中。如果需要反序列化的时候，按照序列化时对象图的序列化顺序反向反序列化即可。\nBinaryFormatter 在序列化的时候会将类型的全名与程序集定义写入到流当中，这样在反序列化的时候，格式化器会获取这些信息，并且通过 System.Reflection.Assembly.Load() 方法将程序集加载到当前的 AppDomain。\n在程序集加载完成之后，会在该程序集搜索待反序列化的对象图类型，找不到则会抛出异常。\n【注意】\n某些应用程序通过 Assembly.LoadFrom() 来加载程序集，然后根据程序集中的类型来构造对象。序列化该对象是没问题的，但是反序列化的时候格式化器使用的是 Assembly.Load() 方法来加载程序集，这样的话就会导致无法正确加载对象。\n这个时候，你可以实现一个与 System.ResolveEventHandler 签名一样的委托，并且在反序列化注册到当前 AppDomain 的 AssemblyResolve 事件。\n这样当程序集加载失败的时候，你可以在该方法内部根据传入的事件参数与程序集标识自己使用 Assembly.LoadFrom() 来构造一个 Assembly 对象。\n记得在反序列化完成之后，马上向事件注销这个方法，否则会造成内存泄漏。\n三、使类型可序列化 在设计自定义类型时，你需要显式地通过 Serializable 特性来声明你的类型是可以被序列化的。如果没有这么做，在使用格式化器进行序列化的时候，则会抛出异常。\n1 2 3 4 5 6 [Serializable] public class DIYClass { public int x { get; set; } public int y { get; set; } } 【注意】\n正因为这样，我们一般都会现将结果保存到 MemoryStream 之中，当没有抛出异常之后再将这些数据写入到文件/网络。\nSerializable 特性 Serializable 特性只能用于值类型、引用类型、枚举类型(默认)、委托类型(默认)，而且是不可被子类继承。\n如果有一个 A 类与其派生类 B 类，那么 A 类没拥有 Serializable 特性，而子类拥有，一样的是无法进行序列化操作。\n而且序列化的时候，是将所有访问级别的字段成员都进行了序列化，包括 private 级别成员。\n四、简单控制序列化操作 禁止序列化某个字段 可以通过 System.NonSerializedAttribute 特性来确保某个字段在序列化时不被处理其值，例如下列代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [Serializable] public class DIYClass { public DIYClass() { x = 10; y = 100; z = 1000; } public int x { get; set; } public int y { get; set; } [NonSerialized] public int z; } 在序列化之前，该自定义对象 z 字段的值为 1000，在序列化时，检测到了忽略特性，则不会写入该字段的值到流当中。并且在反序列化之后，z 的值为 0，而 x ,y 的值是 10 和 100。\n序列化与反序列化的四个生命周期特性 通过 OnSerializing 、OnSerialized、OnDeserializing、OnDeserialized 这四个特性，我们可以在对象序列化与反序列化时进行一些自定义的控制。只需要将这四个特性分别加在四个方法上面即可，但是针对方法签名必须返回值为 void，同时也需要用有一个 StreamingContext 参数。\n而且一般建议将这四个方法标识为 private ，防止其他对象误调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 [Serializable] public class DIYClass { [OnDeserializing] private void OnDeserializing(StreamingContext context) { Console.WriteLine(\u0026#34;反序列化的时候，会调用本方法.\u0026#34;); } [OnDeserialized] private void OnDeserialized(StreamingContext context) { Console.WriteLine(\u0026#34;反序列化完成的时候，会调用本方法.\u0026#34;); } [OnSerializing] public void OnSerializing(StreamingContext context) { Console.WriteLine(\u0026#34;序列化的时候，会调用本方法.\u0026#34;); } [OnSerialized] public void OnSerialized(StreamingContext context) { Console.WriteLine(\u0026#34;序列化完成的时候，会调用本方法.\u0026#34;); } } 【注意】\n如果 A 类型有两个版本，第 1 个版本有 5 个字段，并被序列化存储到了文件当中。后面由于业务需要，针对于 A 类型增加了 2 个新的字段，这个时候如果从文件中读取第 1 个版本的对象流信息，就会抛出异常。\n我们可以通过 System.Runtime.Serialization.OptionalFieldAttribute 添加到我们新加的字段之上，这样的话在反序列化数据时就不会因为缺少字段而抛出异常。\n五、格式化器的序列化原理 格式化器的核心就是 FCL 提供的 FormatterServices 的静态工具类，下列步骤体现了序列化器如何结合 FormatterServices 工具类来进行序列化操作的。\n格式化器调用 FormatterService.GetSerializableMembers() 方法获得需要序列化的字段构成的 MemberInfo 数组。 格式化器调用 FormatterService.GetObjectData() 方法，通过之前获取的字段 MethodInfo 信息来取得每个字段存储的值数组。该数组与字段信息数组是并行的，下标一致。 格式化器写入类型的程序集等信息。 遍历两个数组，写入字段信息与其数据到流当中。 反序列化操作的步骤与上面相反。\n首先从流头部读取程序集标识与类型信息，如果当前 AppDomain 没有加载该程序集会抛出异常。如果类型的程序集已经加载，则通过 FormatterServices.GetTypeFromAssembly() 方法来构造一个 Type 对象。 格式化器调用 FormatterService.GetUninitializedObject() 方法为新对象分配内存，但是 不会调用对象的构造器。 格式化器通过 FormatterService.GetSerializableMembers() 初始化一个 MemberInfo 数组。 格式化器根据流中的数据创建一个 Object 数组，该数组就是字段的数据。 格式化器通过 FormatterService.PopulateObjectMembers() 方法，传入新分配的对象、字段信息数组、字段数据数组进行对象初始化。 六、控制序列化/反序列化的数据 一般来说通过在第四节说的那些特性控制就已经满足了大部分需求，但格式化器内部使用的是反射，反射性能开销比较大，如果你想要针对序列化/反序列化进行完全的控制，那么你可以实现 ISerializable 接口来进行控制。\n该接口只提供了一个 GetObjectData() 方法，原型如下：\n1 2 3 public interface ISerializable{ void GetObjectData(SerializationInfo info,StreamingContext context); } 【注意】\n使用了 ISerializable 接口的代价就是其集成类都必须实现它，而且还要保证子类必须调用基类的 GetObjectData() 方法与其构造函数。一般来说密封类才使用 ISerializable ，其他的类型使用特性控制即可满足。\n另外为了防止其他的代码调用 GetObjectData() 方法，可以通过一下特性来防止误操作：\n1 [SecurityPermissionAttribute(SecurityAction.Demand,SerializationFormatter = true)] 如果格式化器检测到了类型实现了该接口，则会忽略掉原有的特性，并且将字段值传入到 SerializationInfo 之中。\n通过这个 Info 我们可以被序列化的类型，因为 Info 提供了 FullTypeName 与 AssemblyName，不过一般推荐使用该对象提供的 SetType(Type type) 方法来进行操作。\n格式化器构造完成 Info 之后，则会调用 GetObjectData() 方法，这个时候将之前构造好的 Info 传入，而该方法则决定需要用哪些数据来序列化对象。这个时候我们就可以通过 Info 的 AddValue() 方法来添加一些信息用于反序列化时使用。\n在反序列化的时候，需要类型提供一个特殊的构造函数，对于密封类来说，该构造函数推荐为 private ，而一般的类型推荐为 protected，这个特殊的构造函数方法签名与 GetObjectData() 一样。\n因为在反序列化的时候，格式化器会调用这个特殊的构造函数。\n以下代码就是一个简单实践：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class DIYClass : ISerializable { public int X { get; set; } public int Y { get; set; } public DIYClass() { } protected DIYClass(SerializationInfo info, StreamingContext context) { X = info.GetInt32(\u0026#34;X\u0026#34;); Y = 20; } public void GetObjectData(SerializationInfo info, StreamingContext context) { info.AddValue(\u0026#34;X\u0026#34;, 10); } } 该类型的对象在反序列化之后，X 的值为序列化之前的值，而 Y 的值始终都会为 20。\n【注意】\n如果你存储的 X 值是 Int32 ，而在获取的时候是通过 GetInt64() 进行获取。那么格式化器就会尝试使用 System.Convert 提供的方法进行转换，并且可以通过实现 IConvertible 接口来自定义自己的转换。\n不过只有在 Get 方法转换失败的情况下才会使用上述机制。\n子类与基类的 ISerializable 如果某个子类集成了基类，那么子类在其 GetObjectData() 与特殊构造器中都要调用父类的方法，这样才能够完成正确的序列化/反序列化操作。\n如果基类没有实现 ISerializable 接口与特殊的构造器，那么子类就需要通过 FormatterService 来手动针对基类的字段进行赋值。\n七、流上下文 流上下文 StreamingContext 只有两个属性，第一个是状态标识位，用于标识序列化/反序列化对象的来源与目的地。而第二个属性就是一个 Object 引用，该引用则是一个附加的上下文信息，由用户进行提供。\n八、类型序列化为不同的类型与对象反序列化为不同的对象 在某些时候可能需要更改序列化完成之后的对象类型，这个时候只需要对象在其实现 ISerializable 接口的 GetObjectData() 方法内部通过 SerializationInfo 的 SetType() 方法变更了序列化的目标类型。\n下面的代码演示了如何序列化一个单例对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [Serializable] public sealed class Singleton : ISerializable { private static readonly Singleton _instance = new Singleton(); private Singleton() { } public static Singleton GetSingleton() { return _instance; } [SecurityPermissionAttribute(SecurityAction.Demand,SerializationFormatter =true)] void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) { info.SetType(typeof(SingletonHelper)); } } 这里通过显式实现接口的 GetObjectData() 方法来将序列化的目标类型设置为 SingletonHelper ，该类型的定义如下：\n1 2 3 4 5 6 7 8 [Serializable] public class SingletonHelper : IObjectReference { public object GetRealObject(StreamingContext context) { return Singleton.GetSingleton(); } } 这里因为 SingletonHelper 实现了 IObjectReference 接口，当格式化器尝试进行反序列化的时候，由于在 GetObjectData() 欺骗了转换器，因此反序列化的时候检测到类型有实现该接口，所以会尝试调用其 GetRealObject() 方法来进行反序列化操作。\n而以上动作完成之后，SingletonHelper 会立即变为不可达对象，等待 GC 进行回收处理。\n九、序列化代理 当某些时候需要对一个第三方库对象进行序列化的时候，没有其源码，但是想要进行序列化，则可以通过序列化代理来进行序列化操作。\n要实现序列化代理，需要实现 ISerializationSurrogate 接口，该接口拥有两个方法，其签名分别如下：\n1 2 void GetObjectData(Object obj,SerializationInfo info,StreamingContext context); void SetObjectData(Object obj,SerializationInfo info,StreamingContext context,ISurrogateSelector selector); GetObjectData() 方法会在对象序列化时进行调用，而 SetObjectData() 会在对象反序列化时调用。\n比如说我们有一个需求是希望 DateTime 类型在序列化的时候通过 UTC 时间序列化到流中，而在反序列化时则更改为本地时间。\n这个时候我们就可以自己实现一个序列化代理类 UTCToLocalTimeSerializationSurrogate：\n1 2 3 4 5 6 7 8 9 10 11 12 public sealed class UTCToLocalTimeSerializationSurrogate : ISerializationSurrogate { public void GetObjectData(object obj, SerializationInfo info, StreamingContext context) { info.AddValue(\u0026#34;Date\u0026#34;, ((DateTime)obj).ToUniversalTime().ToString(\u0026#34;u\u0026#34;)); } public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector) { return DateTime.ParseExact(info.GetString(\u0026#34;Date\u0026#34;), \u0026#34;u\u0026#34;, null).ToLocalTime(); } } 并且在使用的时候，通过构造一个 SurrogateSelector 代理选择器，传入我们针对于 DateTime 类型的代理，并且将格式化器与代理选择器相绑定。那么在使用格式化器的时候，就会通过我们的代理类来处理 DateTime 类型对象的序列化/反序列化操作了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void Main(string[] args) { using (var stream = new MemoryStream()) { var formatter = new BinaryFormatter(); // 创建一个代理选择器 var ss = new SurrogateSelector(); // 告诉代理选择器，针对于 DateTime 类型采用 UTCToLocal 代理类进行序列化/反序列化代理 ss.AddSurrogate(typeof(DateTime), formatter.Context, new UTCToLocalTimeSerializationSurrogate()); // 绑定代理选择器 formatter.SurrogateSelector = ss; formatter.Serialize(stream,DateTime.Now); stream.Position = 0; var oldValue = new StreamReader(stream).ReadToEnd(); stream.Position = 0; var newValue = (DateTime)formatter.Deserialize(stream); Console.WriteLine(oldValue); Console.WriteLine(newValue); } Console.ReadLine(); } 而一个代理选择器允许绑定多个代理类，选择器内部维护一个哈希表，通过 Type 与 StreamingContext 作为其键来进行搜索，通过 StreamintContext 地不同可以方便地为 DateTime 类型绑定不同用途的代理类。\n十、反序列化对象时重写程序集/类型 通过继承 SerializationBinder 抽象类，我们可以很方便地实现类型反序列化时转化为不同的类型，该抽象类有一个 Type BindToType(String assemblyName,String typeName) 方法。\n重写该方法你就可以在对象反序列化时，通过传入的两个参数来构造自己需要返回的真实类型。第一个参数是程序集名称，第二个参数是格式化器想要反序列化时转换的类型。\n编写好 Binder 类重写该方法之后，在格式化器的 Binder 属性当中绑定你的 Binder 类即可。\n【注意】\n抽象类还有一个 BindToName() 方法，该方法是在序列化时被调用，会传入他想要序列化的类型。\n","date":"2018-11-04T12:41:29Z","permalink":"https://real-zony.github.io/p/clr-via-csharp-reading-notes-runtime-serialization/","title":"《CLR Via C#》读书笔记：24.运行时序列化"},{"content":"0. 简介 在某些时候我们可能会需要执行后台任务，或者是执行一些周期性的任务。比如说可能每隔 1 个小时要清除某个临时文件夹内的数据，可能用户会要针对某一个用户群来群发一组短信。前面这些就是典型的应用场景，在 Abp 框架里面为我们准备了后台作业和后台工作者来帮助我们解决这个问题。\n后台作业与后台工作者的区别是，前者主要用于某些耗时较长的任务，而不想阻塞用户的时候所使用。后者主要用于周期性的执行某些任务，从 “工作者” 的名字可以看出来，就是一个个工人，而且他们每个工人都拥有单独的后台线程。\n0.1 典型场景 后台作业\n某个用户按下了报表按钮来生成一个需要长时间等待的报表。你添加这个工作到队列中，当报表生成完毕后，发送报表结果到该用户的邮箱。 在后台作业中发送一封邮件，有些问题可能会导致发送失败(网络连接异常，或者主机宕机)；由于有后台作业以及持久化机制，在问题排除后，可以重试以保证任务的成功执行。 后台工作者\n后台工作者能够周期性地执行旧日志的删除。 后台工作者可以周期性地筛选出非活跃性用户，并且发送回归邮件给这些用户。 1. 启动流程 后台作业与后台工作者都是通过各自的 Manager(IBackgroundJobManager/IBackgroundWorkerManager) 来进行管理的。而这两个 Manager 分别继承了 ISingletonDependency 接口，所以在启动的时候就会自动注入这两个管理器以便开发人员管理操作。\n这里值得注意的一点是，IBackgroundJobManager 接口是 IBackgroundWorker 的派生接口，而 IBackgroudWorker 是归属于 IBackgroundWorkerManager 进行管理的。\n所以，你可以在 AbpKernelModule 里面看到如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public sealed class AbpKernelModule : AbpModule { public override void PostInitialize() { // 注册可能缺少的组件 RegisterMissingComponents(); // ... 忽略的代码 // 各种管理器的初始化操作 // 从配置项中读取，是否启用了后台作业功能 if (Configuration.BackgroundJobs.IsJobExecutionEnabled) { var workerManager = IocManager.Resolve\u0026lt;IBackgroundWorkerManager\u0026gt;(); // 开始启动后台工作者 workerManager.Start(); // 增加后台作业管理器 workerManager.Add(IocManager.Resolve\u0026lt;IBackgroundJobManager\u0026gt;()); } } } 可以看到，后台作业管理器是作为一个后台工作者被添加到了 IBackgroundWorkerManager 当中来执行的。\n2. 代码分析 2.1 后台工作者 2.1.1 后台工作者管理器 Abp 通过后台工作者管理器来管理后台作业队列，所以我们首先来看一下后台工作者管理器接口的定义是什么样子的。\n1 2 3 4 public interface IBackgroundWorkerManager : IRunnable { void Add(IBackgroundWorker worker); } 还是相当简洁的，就一个 Add 方法用来添加一个新的后台工作者对象。只是在这个地方，可以看到该接口又是集成自 IRunnable 接口，那么该接口的作用又是什么呢？\n转到其定义可以看到，IRunable 接口定义了三个基本的方法：Start()、Stop()、WaitStop() ，而且他拥有一个默认实现 RunableBase，其实就是用来标识一个任务的运行状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public interface IRunnable { // 开始执行任务 void Start(); // 停止执行任务 void Stop(); // 阻塞线程，等待任务执行完成后标识为停止。 void WaitToStop(); } public abstract class RunnableBase : IRunnable { // 用于标识任务是否运行的布尔值变量 public bool IsRunning { get { return _isRunning; } } private volatile bool _isRunning; // 启动之后表示任务正在运行 public virtual void Start() { _isRunning = true; } // 停止之后表示任务结束运行 public virtual void Stop() { _isRunning = false; } public virtual void WaitToStop() { } } 到目前为止整个代码都还是比较简单清晰的，我们接着看 IBackgroundWorkerManager 的默认实现 BackgroundWorkerManager 类，首先我们看一下该类拥有哪些属性与字段。\n1 2 3 4 5 6 7 8 9 10 11 public class BackgroundWorkerManager : RunnableBase, IBackgroundWorkerManager, ISingletonDependency, IDisposable { private readonly IIocResolver _iocResolver; private readonly List\u0026lt;IBackgroundWorker\u0026gt; _backgroundJobs; public BackgroundWorkerManager(IIocResolver iocResolver) { _iocResolver = iocResolver; _backgroundJobs = new List\u0026lt;IBackgroundWorker\u0026gt;(); } } 在后台工作者管理器类的内部，默认有一个 List 集合，用于维护所有的后台工作者对象。那么其他的 Start() 等方法肯定是基于这个集合进行操作的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public override void Start() { base.Start(); _backgroundJobs.ForEach(job =\u0026gt; job.Start()); } public override void Stop() { _backgroundJobs.ForEach(job =\u0026gt; job.Stop()); base.Stop(); } public override void WaitToStop() { _backgroundJobs.ForEach(job =\u0026gt; job.WaitToStop()); base.WaitToStop(); } 可以看到实现还是比较简单的，接下来我们继续看他的 Add() 方法是如何进行操作的？\n1 2 3 4 5 6 7 8 9 public void Add(IBackgroundWorker worker) { _backgroundJobs.Add(worker); if (IsRunning) { worker.Start(); } } 在这里我们看到他会针对 IsRunning 进行判定是否立即启动加入的后台工作者对象。而这个 IsRunning 属性值唯一产生变化的情况就在于 Start() 方法与 Stop() 方法的调用。\n最后肯定也有相关的销毁方法，用于释放所有注入的后台工作者对象，并将集合清除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private bool _isDisposed; public void Dispose() { if (_isDisposed) { return; } _isDisposed = true; // 遍历集合，通过 Ioc 解析器的 Release 方法释放对象 _backgroundJobs.ForEach(_iocResolver.Release); // 清空集合 _backgroundJobs.Clear(); } 所以，针对于所有后台工作者的管理，都是通过 IBackgroundWorkerManager 来进行操作的。\n2.1.2 后台工作者 看完了管理器，我们来看一下 IBackgroundWorker 后台工作者对象是怎样的构成。\n1 2 3 4 public interface IBackgroundWorker : IRunnable { } 貌似只是一个空的接口，其作用主要是标识某个类型是否为后台工作者，转到其抽象类实现 BackgroundWorkerBase，里面只是注入了一些辅助对象与本地化的一些方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public abstract class BackgroundWorkerBase : RunnableBase, IBackgroundWorker { // 配置管理器 public ISettingManager SettingManager { protected get; set; } // 工作单元管理器 public IUnitOfWorkManager UnitOfWorkManager { get { if (_unitOfWorkManager == null) { throw new AbpException(\u0026#34;Must set UnitOfWorkManager before use it.\u0026#34;); } return _unitOfWorkManager; } set { _unitOfWorkManager = value; } } private IUnitOfWorkManager _unitOfWorkManager; // 获得当前的工作单元 protected IActiveUnitOfWork CurrentUnitOfWork { get { return UnitOfWorkManager.Current; } } // 本地化资源管理器 public ILocalizationManager LocalizationManager { protected get; set; } // 默认的本地化资源的源名称 protected string LocalizationSourceName { get; set; } protected ILocalizationSource LocalizationSource { get { // 如果没有配置源名称，直接抛出异常 if (LocalizationSourceName == null) { throw new AbpException(\u0026#34;Must set LocalizationSourceName before, in order to get LocalizationSource\u0026#34;); } if (_localizationSource == null || _localizationSource.Name != LocalizationSourceName) { _localizationSource = LocalizationManager.GetSource(LocalizationSourceName); } return _localizationSource; } } private ILocalizationSource _localizationSource; // 日志记录器 public ILogger Logger { protected get; set; } protected BackgroundWorkerBase() { Logger = NullLogger.Instance; LocalizationManager = NullLocalizationManager.Instance; } // ... 其他模板代码 } 我们接着看继承并实现了 BackgroundWorkerBase 的类型 PeriodicBackgroundWorkerBase，从字面意思上来看，该类型应该是一个定时后台工作者基类。\n重点在于 Periodic(定时)，从其类型内部的定义可以看到，该类型使用了一个 AbpTimer 对象来进行周期计时与具体工作任务的触发。我们暂时先不看这个 AbpTimer，仅仅看 PeriodicBackgroundWorkerBase 的内部实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public abstract class PeriodicBackgroundWorkerBase : BackgroundWorkerBase { protected readonly AbpTimer Timer; // 注入 AbpTimer protected PeriodicBackgroundWorkerBase(AbpTimer timer) { Timer = timer; // 绑定周期执行的任务，这里是 DoWork() Timer.Elapsed += Timer_Elapsed; } public override void Start() { base.Start(); Timer.Start(); } public override void Stop() { Timer.Stop(); base.Stop(); } public override void WaitToStop() { Timer.WaitToStop(); base.WaitToStop(); } private void Timer_Elapsed(object sender, System.EventArgs e) { try { DoWork(); } catch (Exception ex) { Logger.Warn(ex.ToString(), ex); } } protected abstract void DoWork(); } 可以看到，这里基类绑定了 DoWork() 作为其定时执行的方法，那么用户在使用的时候直接继承自该基类，然后重写 DoWork() 方法即可绑定自己的后台工作者的任务。\n2.1.3 AbpTimer 定时器 在上面的基类我们看到，基类的 Start()、Stop()、WaitTpStop() 方法都是调用的 AbpTimer 所提供的，所以说 AbpTimer 其实也继承了 RunableBase 基类并实现其具体的启动与停止操作。\n其实 AbpTimer 的核心就是通过 CLR 的 Timer 来实现周期性任务执行的，不过默认的 Timer 类有两个比较大的问题。\nCLR 的 Timer 并不会等待你的任务执行完再执行下一个周期的任务，如果你的某个任务耗时过长，超过了 Timer 定义的周期。那么 Timer 会开启一个新的线程执行，这样的话最后我们系统的资源会因为线程大量重复创建而被拖垮。 如何知道一个 Timer 所执行的业务方法已经真正地被结束了。 所以 Abp 才会重新封装一个 AbpTimer 作为一个基础的计时器。第一个问题的解决方法很简单，就是在执行具体绑定的业务方法之前，通过 Timer.Change() 方法来让 Timer 临时失效。等待业务方法执行完成之后，再将 Timer 的周期置为用户设定的周期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // CLR Timer 绑定的回调方法 private void TimerCallBack(object state) { lock (_taskTimer) { if (!_running || _performingTasks) { return; } // 暂时让 Timer 失效 _taskTimer.Change(Timeout.Infinite, Timeout.Infinite); // 设置执行标识为 TRUE，表示当前的 AbpTimer 正在执行 _performingTasks = true; } try { // 如果绑定了相应的触发事件 if (Elapsed != null) { // 执行相应的业务方法，这里就是最开始绑定的 DoWork() 方法 Elapsed(this, new EventArgs()); } } catch { } finally { lock (_taskTimer) { // 标识业务方法执行完成 _performingTasks = false; if (_running) { // 更改周期为用户指定的执行周期，等待下一次触发 _taskTimer.Change(Period, Timeout.Infinite); } Monitor.Pulse(_taskTimer); } } } 针对于第二个问题，Abp 通过 WaitToStop() 方法会阻塞调用这个 Timer 的线程，并且在 _performingTasks 标识位是 false 的时候释放。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public override void WaitToStop() { // 锁定 CLR 的 Timer 对象 lock (_taskTimer) { // 循环检测 while (_performingTasks) { Monitor.Wait(_taskTimer); } } base.WaitToStop(); } 至于其他的 Start() 方法就是使用 CLR 的 Timer 更改其执行周期，而 Stop() 就是直接将 Timer 的周期设置为无限大，使计时器失效。\n2.1.4 总结 Abp 后台工作者的核心就是通过 AbpTimer 来实现周期性任务的执行，用户只需要继承自 PeriodicBackgroundWorkerBase，然后将其添加到 IBackgroundWorkerManager 的集合当中。这样 Abp 在启动之后就会遍历这个工作者集合，然后周期执行这些后台工作者绑定的方法。\n当然如果你继承了 PeriodicBackgroundWorkerBase 之后，可以通过设置构造函数的 AbpTimer 来指定自己的执行周期。\n2.2 后台作业队列 后台工作队列的管理是通过 IBackgroundJobManager 来处理的，而该接口又继承自 IBackgroundWorker，所以一整个后台作业队列就是一个后台工作者，只不过这个工作者有点特殊。\n2.2.1 后台作业管理器 IBackgroundJobManager 接口的定义其实就两个方法，一个 EnqueueAsync\u0026lt;TJob, TArgs\u0026gt;() 用于将一个后台作业加入到执行队列当中。而 DeleteAsync() 方法呢，顾名思义就是从队列当中移除指定的后台作业。\n首先看一下其默认实现 BackgroundJobManager，该实现同样是继承自 PeriodicBackgroundWorkerBase 并且其默认周期为 5000 ms。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class BackgroundJobManager : PeriodicBackgroundWorkerBase, IBackgroundJobManager, ISingletonDependency { // 事件总线 public IEventBus EventBus { get; set; } // 轮训后台作业的间隔，默认值为 5000 毫秒. public static int JobPollPeriod { get; set; } // IOC 解析器 private readonly IIocResolver _iocResolver; // 后台作业队列存储 private readonly IBackgroundJobStore _store; static BackgroundJobManager() { JobPollPeriod = 5000; } public BackgroundJobManager( IIocResolver iocResolver, IBackgroundJobStore store, AbpTimer timer) : base(timer) { _store = store; _iocResolver = iocResolver; EventBus = NullEventBus.Instance; Timer.Period = JobPollPeriod; } } 基础结构基本上就这个样子，接下来看一下他的两个接口方法是如何实现的。\nEnqueueAsync\u0026lt;TJob, TArgs\u0026gt; 方法通过传入指定的后台作业对象和相应的参数，同时还有任务的优先级。将其通过 IBackgroundJobStore 进行持久化，并返回一个任务的唯一 JobId 以便进行删除操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public async Task\u0026lt;string\u0026gt; EnqueueAsync\u0026lt;TJob, TArgs\u0026gt;(TArgs args, BackgroundJobPriority priority = BackgroundJobPriority.Normal, TimeSpan? delay = null) where TJob : IBackgroundJob\u0026lt;TArgs\u0026gt; { // 通过 JobInfo 包装任务的基本信息 var jobInfo = new BackgroundJobInfo { JobType = typeof(TJob).AssemblyQualifiedName, JobArgs = args.ToJsonString(), Priority = priority }; // 如果需要延时执行的话，则用当前时间加上延时的时间作为任务下次运行的时间 if (delay.HasValue) { jobInfo.NextTryTime = Clock.Now.Add(delay.Value); } // 通过 Store 进行持久话存储 await _store.InsertAsync(jobInfo); // 返回后台任务的唯一标识 return jobInfo.Id.ToString(); } 至于删除操作，在 Manager 内部其实也是通过 IBackgroundJobStore 进行实际的删除操作的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public async Task\u0026lt;bool\u0026gt; DeleteAsync(string jobId) { // 判断 jobId 的值是否有效 if (long.TryParse(jobId, out long finalJobId) == false) { throw new ArgumentException($\u0026#34;The jobId \u0026#39;{jobId}\u0026#39; should be a number.\u0026#34;, nameof(jobId)); } // 使用 jobId 从 Store 处筛选到 JobInfo 对象的信息 BackgroundJobInfo jobInfo = await _store.GetAsync(finalJobId); if (jobInfo == null) { return false; } // 如果存在有 JobInfo 则使用 Store 进行删除操作 await _store.DeleteAsync(jobInfo); return true; } 后台作业管理器实质上是一个周期性执行的后台工作者，那么我们的后台作业是每 5000 ms 执行一次，那么他的 DoWork() 方法又在执行什么操作呢？\n1 2 3 4 5 6 7 8 9 10 11 protected override void DoWork() { // 从 Store 当中获得等待执行的后台作业集合 var waitingJobs = AsyncHelper.RunSync(() =\u0026gt; _store.GetWaitingJobsAsync(1000)); // 遍历这些等待执行的后台任务，然后通过 TryProcessJob 进行执行 foreach (var job in waitingJobs) { TryProcessJob(job); } } 可以看到每 5 秒钟我们的后台作业管理器就会从 IBackgroundJobStore 当中拿到最大 1000 条的后台作业信息，然后遍历这些信息。通过 TryProcessJob(job) 方法来执行后台作业。\n而 TryProcessJob() 方法，本质上就是通过反射构建出一个 IBackgroundJob 对象，然后取得序列化的参数值，通过反射得到的 MethodInfo 对象来执行我们的后台任务。执行完成之后，就会从 Store 当中移除掉执行完成的任务。\n针对于在执行过程当中所出现的异常，会通过 IEventBus 触发一个 AbpHandledExceptionData 事件记录后台作业执行失败时的异常信息。并且一旦在执行过程当中出现了任何异常的情况，都会将该任务的 IsAbandoned 字段置为 true，当该字段为 true 时，该任务将不再回被执行。\nPS：就是在 GetWaitingJobsAsync() 方法时，会过滤掉 IsAbandoned 值为 true 的任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 private void TryProcessJob(BackgroundJobInfo jobInfo) { try { // 任务执行次数自增 1 jobInfo.TryCount++; // 最后一次执行时间设置为当前时间 jobInfo.LastTryTime = Clock.Now; // 通过反射取得后台作业的类型 var jobType = Type.GetType(jobInfo.JobType); // 通过 Ioc 解析器得到一个临时的后台作业对象，执行完之后既被释放 using (var job = _iocResolver.ResolveAsDisposable(jobType)) { try { // 通过反射得到后台作业的 Execute 方法 var jobExecuteMethod = job.Object.GetType().GetTypeInfo().GetMethod(\u0026#34;Execute\u0026#34;); var argsType = jobExecuteMethod.GetParameters()[0].ParameterType; var argsObj = JsonConvert.DeserializeObject(jobInfo.JobArgs, argsType); // 结合持久话存储的参数信息，调用 Execute 方法进行后台作业 jobExecuteMethod.Invoke(job.Object, new[] { argsObj }); // 执行完成之后从 Store 删除该任务的信息 AsyncHelper.RunSync(() =\u0026gt; _store.DeleteAsync(jobInfo)); } catch (Exception ex) { Logger.Warn(ex.Message, ex); // 计算下一次执行的时间，一旦超过 2 天该任务都执行失败，则返回 null var nextTryTime = jobInfo.CalculateNextTryTime(); if (nextTryTime.HasValue) { jobInfo.NextTryTime = nextTryTime.Value; } else { // 如果为 null 则说明该任务在 2 天的时间内都没有执行成功，则放弃继续执行 jobInfo.IsAbandoned = true; } // 更新 Store 存储的任务信息 TryUpdate(jobInfo); // 触发异常事件 EventBus.Trigger( this, new AbpHandledExceptionData( new BackgroundJobException( \u0026#34;A background job execution is failed. See inner exception for details. See BackgroundJob property to get information on the background job.\u0026#34;, ex ) { BackgroundJob = jobInfo, JobObject = job.Object } ) ); } } } catch (Exception ex) { Logger.Warn(ex.ToString(), ex); // 表示任务不再执行 jobInfo.IsAbandoned = true; // 更新 Store TryUpdate(jobInfo); } } 2.2.2 后台作业 后台作业的默认接口定义为 IBackgroundJob\u0026lt;in TArgs\u0026gt; ，他只有一个 Execute(TArgs args) 方法，用于接收指定类型的作业参数，并执行。\n一般来说我们不建议直接通过继承 IBackgroundJob\u0026lt;in TArgs\u0026gt; 来实现后台作业，而是继承自 BackgroundJob\u0026lt;TArgs\u0026gt; 抽象类。该抽象类内部也没有什么特别的实现，主要是注入了一些基础设施，比如说 UOW 与 本地化资源管理器，方便我们开发使用。\n后台作业本身是具体执行的对象，而 BackgroundJobInfo 则是存储了后台作业的 Type 类型和参数，方便在需要执行的时候通过反射的方式执行后台作业。\n2.2.2 后台作业队列存储 从 IBackgroundJobStore 我们就可以猜到以 Abp 框架的套路，他肯定会有两种实现，第一种就是基于内存的 InMemoryBackgroundJobStore。而第二种呢，就是由 Abp.Zero 模块所提供的基于数据库的 BackgroundJobStore。\nIBackgroundJobStore 接口所定义的方法基本上就是增删改查，没有什么复杂的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public interface IBackgroundJobStore { // 通过 JobId 获取后台任务信息 Task\u0026lt;BackgroundJobInfo\u0026gt; GetAsync(long jobId); // 插入一个新的后台任务信息 Task InsertAsync(BackgroundJobInfo jobInfo); /// \u0026lt;summary\u0026gt; /// Gets waiting jobs. It should get jobs based on these: /// Conditions: !IsAbandoned And NextTryTime \u0026amp;lt;= Clock.Now. /// Order by: Priority DESC, TryCount ASC, NextTryTime ASC. /// Maximum result: \u0026lt;paramref name=\u0026#34;maxResultCount\u0026#34;/\u0026gt;. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;maxResultCount\u0026#34;\u0026gt;Maximum result count.\u0026lt;/param\u0026gt; Task\u0026lt;List\u0026lt;BackgroundJobInfo\u0026gt;\u0026gt; GetWaitingJobsAsync(int maxResultCount); /// \u0026lt;summary\u0026gt; /// Deletes a job. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;jobInfo\u0026#34;\u0026gt;Job information.\u0026lt;/param\u0026gt; Task DeleteAsync(BackgroundJobInfo jobInfo); /// \u0026lt;summary\u0026gt; /// Updates a job. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;jobInfo\u0026#34;\u0026gt;Job information.\u0026lt;/param\u0026gt; Task UpdateAsync(BackgroundJobInfo jobInfo); } 这里先从简单的内存 Store 说起，这个 InMemoryBackgroundJobStore 内部使用了一个并行字典来存储这些任务信息。\n1 2 3 4 5 6 7 8 9 10 public class InMemoryBackgroundJobStore : IBackgroundJobStore { private readonly ConcurrentDictionary\u0026lt;long, BackgroundJobInfo\u0026gt; _jobs; private long _lastId; public InMemoryBackgroundJobStore() { _jobs = new ConcurrentDictionary\u0026lt;long, BackgroundJobInfo\u0026gt;(); } } 相当简单，这几个接口方法基本上就是针对与这个并行字典操作的一层封装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public Task\u0026lt;BackgroundJobInfo\u0026gt; GetAsync(long jobId) { return Task.FromResult(_jobs[jobId]); } public Task InsertAsync(BackgroundJobInfo jobInfo) { jobInfo.Id = Interlocked.Increment(ref _lastId); _jobs[jobInfo.Id] = jobInfo; return Task.FromResult(0); } public Task\u0026lt;List\u0026lt;BackgroundJobInfo\u0026gt;\u0026gt; GetWaitingJobsAsync(int maxResultCount) { var waitingJobs = _jobs.Values // 首先筛选出不再执行的后台任务 .Where(t =\u0026gt; !t.IsAbandoned \u0026amp;\u0026amp; t.NextTryTime \u0026lt;= Clock.Now) // 第一次根据后台作业的优先级进行排序，高优先级优先执行 .OrderByDescending(t =\u0026gt; t.Priority) // 再根据执行次数排序，执行次数越少的，越靠前 .ThenBy(t =\u0026gt; t.TryCount) .ThenBy(t =\u0026gt; t.NextTryTime) .Take(maxResultCount) .ToList(); return Task.FromResult(waitingJobs); } public Task DeleteAsync(BackgroundJobInfo jobInfo) { _jobs.TryRemove(jobInfo.Id, out _); return Task.FromResult(0); } public Task UpdateAsync(BackgroundJobInfo jobInfo) { // 如果是不再执行的任务，删除 if (jobInfo.IsAbandoned) { return DeleteAsync(jobInfo); } return Task.FromResult(0); } 至于持久化到数据库，无非是注入一个仓储，然后针对这个仓储进行增删查改的操作罢了，这里就不在赘述。\n2.2.3 后台作业优先级 后台作业的优先级定义在 BackgroundJobPriority 枚举当中，一共有 5 个等级，分别是 Low、BelowNormal、Normal、AboveNormal、High ，他们从最低到最高排列。\n","date":"2018-10-24T01:28:08Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-sixteen-background-work-and-background-workers/","title":"Abp 源码分析：十六、后台工作与后台工作者"},{"content":"0. 简要介绍 WRK 是一款轻量且易用的 HTTP 压力测试工具，通过该工具我们可以方便地对我们所开发的 WebAPI 项目进行压力测试，并且针对测试的情况返回结果。\nPS：Wrk 并不能针对测试的结果生成动态的图表，如果有这种需要，可以尝试使用另一款工具 Vegeta。该项目使用的 Golang 进行编写，其 GitHub 地址为：https://github.com/tsenart/vegeta\n下面的内容就是一个标准的测试结果信息：\n1 2 3 4 5 6 7 8 9 10 11 # 针对 127.0.0.1:8080 进行压力测试 wrk -t12 -c400 -d30s http://127.0.0.1:8080/index.html # 这里是测试结果 Running 30s test @ http://127.0.0.1:8080/index.html 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 635.91us 0.89ms 12.92ms 93.69% Req/Sec 56.20k 8.07k 62.00k 86.54% 22464657 requests in 30.00s, 17.76GB read Requests/sec: 748868.53 Transfer/sec: 606.33MB 1. 安装 关于 OS X 与 Windows 的安装可以参考 Wrk 官方 WIKI 进行操作，本文主要讲解一下 CentOS 7.x 下如果进行编译。\n1 2 3 4 5 sudo yum groupinstall \u0026#39;Development Tools\u0026#39; sudo yum install -y openssl-devel git git clone https://github.com/wg/wrk.git wrk cd wrk make 编译之后，你会得到如下结果：\n可以看到生成了一个 wrk 的可执行文件，你可以将其添加到环境变量的 PATH 当中，这里就不再赘述，我们等会儿使用的时候直接 ./wrk 使用。\n2. 命令说明 1 ./wrk -H \u0026#34;Authorization: Bearer TokenValue\u0026#34; -t 2 -c 50 -d 10s --latency --timeout 1s \u0026#34;http://\u0026#34; 上面的命令就是一个典型的压力测试命令，关于参数的含义请看下表。\n执行命令时的参数 含义 示例 -c 与 HTTP 保持连接的连接数，最终每个线程能够处理的为 连接数/线程数。 -c 50 -d 指定压力测试的时间有多长。 -d 10s，其他单位有 2s,2m,2h 如果不带单位的话，默认为秒。 -t 压力测试时所使用的线程数目，最好为你 CPU 核心的数量。 -t 4 -s 指定要执行的 Lua 脚本 -s ./post.lua -H 执行请求的时候所附带的 Header 组。 -H \u0026ldquo;User-Agent: wrk\u0026rdquo; \u0026ndash;latency 打印详细的统计信息。 \u0026ndash;latency \u0026ndash;timeout 每次请求所返回响应体的时间，如果超过了配置的时间，则视为请求超时。 \u0026ndash;timeout 1s 3. 开始压力测试 执行了上述代码之后我们可以看到很直观的信息，第一个就是 20s 的时间内完成了 2887 次请求，一共接受到了 2.46MB 的数据。在 Socket errors 里面我们可以看到有 35 个请求产生了超时的情况，每秒执行的请求大概为 144.20 个，每秒的数据传输大概为 125.75 KB。\n除此之外，还说明了平均每次请求所消耗的时间为 338.44 ms，最极端的情况为 994.27ms。\n4. LUA 脚本 在第三节我们可以看到一些标准的 GET 请求我们可以直接通过指定命令来进行测试，即便该接口有授权验证，我们可以通过 -H 参数来指定 Authorization 头来实现权限验证。 但是针对一些复杂的情况，我们就需要编写 LUA 脚本来实现压力测试了。\n官方编写了很多的 LUA 脚本 DEMO ，存放在 GitHub 上面，其地址为：https://github.com/wg/wrk/tree/master/scripts。\n这里我们以实现 POST 请求为例：\n1 2 3 wrk.method = \u0026#34;POST\u0026#34; wrk.body = \u0026#39;{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123qwe\u0026#34;,\u0026#34;rememberClient\u0026#34;:true}\u0026#39; wrk.headers[\u0026#34;Content-Type\u0026#34;] = \u0026#34;application/json\u0026#34; 这里我们的接口地址更改了一下，改变成了 Login 接口，该接口需要传入用户名与密码，并且其 Method 为 POST。\n将上述 LUA 脚本保存为 post.lua 文件，然后通过 -s 参数指定 LUA 脚本的路径并执行。\n5. LUA 脚本相关详解 WRK 中执行 HTTP 请求的时候，调用 Lua 分为 3 个阶段，setup、running、done，每个 WRK 线程中都有独立的脚本环境。\n5.1 WRK 的全局属性 1 2 3 4 5 6 7 8 9 10 wrk = { scheme = \u0026#34;http\u0026#34;, host = \u0026#34;localhost\u0026#34;, port = nil, method = \u0026#34;GET\u0026#34;, path = \u0026#34;/\u0026#34;, headers = {}, body = nil, thread = \u0026lt;userdata\u0026gt;, } 5.2 WRK 的全局方法 1 2 3 4 5 6 7 8 9 10 -- 生成整个request的string，例如：返回 -- GET / HTTP/1.1 -- Host: tool.lu function wrk.format(method, path, headers, body) -- 获取域名的IP和端口，返回table，例如：返回 `{127.0.0.1:80}` function wrk.lookup(host, service) -- 判断addr是否能连接，例如：`127.0.0.1:80`，返回 true 或 false function wrk.connect(addr) 5.3 Setup 阶段 setup() 方法是在线程创建之后，启动之前。\n1 2 3 4 5 6 7 function setup(thread) -- thread提供了1个属性，3个方法 -- thread.addr 设置请求需要打到的ip -- thread:get(name) 获取线程全局变量 -- thread:set(name, value) 设置线程全局变量 -- thread:stop() 终止线程 5.4 Running 阶段 1 2 3 4 5 6 7 8 9 10 11 function init(args) -- 每个线程仅调用1次，args 用于获取命令行中传入的参数, 例如 --env=pre function delay() -- 每个线程调用多次，发送下一个请求之前的延迟, 单位为ms function request() -- 每个线程调用多次，返回http请求 function response(status, headers, body) -- 每个线程调用多次，返回http响应 5.5 Done 阶段 可以用于自定义结果报表，整个过程中只执行一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function done(summary, latency, requests) latency.min -- minimum value seen latency.max -- maximum value seen latency.mean -- average value seen latency.stdev -- standard deviation latency:percentile(99.0) -- 99th percentile value latency(i) -- raw value and count summary = { duration = N, -- run duration in microseconds requests = N, -- total completed requests bytes = N, -- total bytes received errors = { connect = N, -- total socket connection errors read = N, -- total socket read errors write = N, -- total socket write errors status = N, -- total HTTP status codes \u0026gt; 399 timeout = N -- total request timeouts } } 而官方的 setup.lua 脚本则是重载这些方法并使用的一个 DEMO：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 -- example script that demonstrates use of setup() to pass -- data to and from the threads local counter = 1 local threads = {} function setup(thread) thread:set(\u0026#34;id\u0026#34;, counter) table.insert(threads, thread) counter = counter + 1 end function init(args) requests = 0 responses = 0 local msg = \u0026#34;thread %d created\u0026#34; print(msg:format(id)) end function request() requests = requests + 1 return wrk.request() end function response(status, headers, body) responses = responses + 1 end function done(summary, latency, requests) for index, thread in ipairs(threads) do local id = thread:get(\u0026#34;id\u0026#34;) local requests = thread:get(\u0026#34;requests\u0026#34;) local responses = thread:get(\u0026#34;responses\u0026#34;) local msg = \u0026#34;thread %d made %d requests and got %d responses\u0026#34; print(msg:format(id, requests, responses)) end end 6. 参考资料 wrk中的lua脚本：https://type.so/linux/lua-script-in-wrk.html\nhttp 性能测试 wrk使用教程：https://juejin.im/post/5a59e74f5188257353008fea\n","date":"2018-10-16T07:18:10Z","permalink":"https://real-zony.github.io/p/use-the-wrk-stress-test-tool-to-stress-test-the-interface-of-aspnet-core/","title":"使用 WRK 压力测试工具对 ASP.NET Core 的接口进行压力测试"},{"content":"0.简介 Abp 框架为我们自带了审计日志功能，审计日志可以方便地查看每次请求接口所耗的时间，能够帮助我们快速定位到某些性能有问题的接口。除此之外，审计日志信息还包含有每次调用接口时客户端请求的参数信息，客户端的 IP 与客户端使用的浏览器。有了这些数据之后，我们就可以很方便地复现接口产生 BUG 时的一些环境信息。\n当然如果你脑洞更大的话，可以根据这些数据来开发一个可视化的图形界面，方便开发与测试人员来快速定位问题。\nPS:\n如果使用了 Abp.Zero 模块则自带的审计记录实现是存储到数据库当中的，但是在使用 EF Core + MySQL(EF Provider 为 Pomelo.EntityFrameworkCore.MySql) 在高并发的情况下会有数据库连接超时的问题，这块推荐是重写实现，自己采用 Redis 或者其他存储方式。\n如果需要禁用审计日志功能，则需要在任意模块的预加载方法(PreInitialize()) 当中增加如下代码关闭审计日志功能。\n1 2 3 4 5 6 7 8 public class XXXStartupModule { public override PreInitialize() { // 禁用审计日志 Configuration.Auditing.IsEnabled = false; } } 1.启动流程 审计组件与参数校验组件一样，都是通过 MVC 过滤器与 Castle 拦截器来实现记录的。也就是说，在每次调用接口/方法时都会进入 过滤器/拦截器 并将其写入到数据库表 AbpAuditLogs 当中。\n其核心思想十分简单，就是在执行具体接口方法的时候，先使用 StopWatch 对象来记录执行完一个方法所需要的时间，并且还能够通过 HttpContext 来获取到一些客户端的关键信息。\n2.1 过滤器注入 同上一篇文章所讲的一样，过滤器是在 AddAbp() 方法内部的 ConfigureAspNetCore() 方法注入的。\n1 2 3 4 5 6 7 8 9 10 11 12 private static void ConfigureAspNetCore(IServiceCollection services, IIocResolver iocResolver) { // ... 其他代码 //Configure MVC services.Configure\u0026lt;MvcOptions\u0026gt;(mvcOptions =\u0026gt; { mvcOptions.AddAbp(services); }); // ... 其他代码 } 而下面就是过滤器的注入方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 internal static class AbpMvcOptionsExtensions { public static void AddAbp(this MvcOptions options, IServiceCollection services) { // ... 其他代码 AddFilters(options); // ... 其他代码 } // ... 其他代码 private static void AddFilters(MvcOptions options) { // ... 其他过滤器注入 // 注入审计日志过滤器 options.Filters.AddService(typeof(AbpAuditActionFilter)); // ... 其他过滤器注入 } // ... 其他代码 } 2.2 拦截器注入 注入拦截器的地方与 DTO 自动验证的拦截器的位置一样，都是在 AbpBootstrapper 对象被构造的时候进行注册。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class AbpBootstrapper : IDisposable { private AbpBootstrapper([NotNull] Type startupModule, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) { // ... 其他代码 if (!options.DisableAllInterceptors) { AddInterceptorRegistrars(); } } // ... 其他代码 // 添加各种拦截器 private void AddInterceptorRegistrars() { ValidationInterceptorRegistrar.Initialize(IocManager); AuditingInterceptorRegistrar.Initialize(IocManager); EntityHistoryInterceptorRegistrar.Initialize(IocManager); UnitOfWorkRegistrar.Initialize(IocManager); AuthorizationInterceptorRegistrar.Initialize(IocManager); } // ... 其他代码 } 转到 AuditingInterceptorRegistrar 的具体实现可以发现，他在内部针对于审计日志拦截器的注入是区分了类型的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 internal static class AuditingInterceptorRegistrar { public static void Initialize(IIocManager iocManager) { iocManager.IocContainer.Kernel.ComponentRegistered += (key, handler) =\u0026gt; { // 如果审计日志配置类没有被注入，则直接跳过 if (!iocManager.IsRegistered\u0026lt;IAuditingConfiguration\u0026gt;()) { return; } var auditingConfiguration = iocManager.Resolve\u0026lt;IAuditingConfiguration\u0026gt;(); // 判断当前 DI 所注入的类型是否应该为其绑定审计日志拦截器 if (ShouldIntercept(auditingConfiguration, handler.ComponentModel.Implementation)) { handler.ComponentModel.Interceptors.Add(new InterceptorReference(typeof(AuditingInterceptor))); } }; } // 本方法主要用于判断当前类型是否符合绑定拦截器的条件 private static bool ShouldIntercept(IAuditingConfiguration auditingConfiguration, Type type) { // 首先判断当前类型是否在配置类的注册类型之中，如果是，则进行拦截器绑定 if (auditingConfiguration.Selectors.Any(selector =\u0026gt; selector.Predicate(type))) { return true; } // 当前类型如果拥有 Audited 特性，则进行拦截器绑定 if (type.GetTypeInfo().IsDefined(typeof(AuditedAttribute), true)) { return true; } // 如果当前类型内部的所有方法当中有一个方法拥有 Audited 特性，则进行拦截器绑定 if (type.GetMethods().Any(m =\u0026gt; m.IsDefined(typeof(AuditedAttribute), true))) { return true; } // 都不满足则返回 false,不对当前类型进行绑定 return false; } } 可以看到在判断是否绑定拦截器的时候，Abp 使用了 auditingConfiguration.Selectors 的属性来进行判断，那么默认 Abp 为我们添加了哪些类型是必定有审计日志的呢？\n通过代码追踪，我们来到了 AbpKernalModule 类的内部，在其预加载方法里面有一个 AddAuditingSelectors() 的方法，该方法的作用就是添加了一个针对于应用服务类型的一个选择器对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public sealed class AbpKernelModule : AbpModule { public override void PreInitialize() { // ... 其他代码 AddAuditingSelectors(); // ... 其他代码 } // ... 其他代码 private void AddAuditingSelectors() { Configuration.Auditing.Selectors.Add( new NamedTypeSelector( \u0026#34;Abp.ApplicationServices\u0026#34;, type =\u0026gt; typeof(IApplicationService).IsAssignableFrom(type) ) ); } // ... 其他代码 } 我们先看一下 NamedTypeSelector 的一个作用是什么，其基本类型定义由一个 string 和 Func\u0026lt;Type, bool\u0026gt; 组成，十分简单，重点就出在这个断言委托上面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class NamedTypeSelector { // 选择器名称 public string Name { get; set; } // 断言委托 public Func\u0026lt;Type, bool\u0026gt; Predicate { get; set; } public NamedTypeSelector(string name, Func\u0026lt;Type, bool\u0026gt; predicate) { Name = name; Predicate = predicate; } } 回到最开始的地方，当 Abp 为 Selectors 添加了一个名字为 \u0026ldquo;Abp.ApplicationServices\u0026rdquo; 的类型选择器。其断言委托的大体意思就是传入的 **type ** 参数是继承自 IApplicationService 接口的话，则返回 true,否则返回 false。\n这样在程序启动的时候，首先注入类型的时候，会首先进入上文所述的拦截器绑定类当中，这个时候会使用 Selectors 内部的类型选择器来调用这个集合内部的断言委托，只要这些选择器对象有一个返回 true,那么就直接与当前注入的 type 绑定拦截器。\n2.代码分析 2.1 过滤器代码分析 首先查看这个过滤器的整体类型结构，一个标准的过滤器，肯定要实现 IAsyncActionFilter 接口。从下面的代码我们可以看到其注入了 IAbpAspNetCoreConfiguration 和一个 IAuditingHelper 对象。这两个对象的作用分别是判断是否记录日志，另一个则是用来真正写入日志所使用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class AbpAuditActionFilter : IAsyncActionFilter, ITransientDependency { // 审计日志组件配置对象 private readonly IAbpAspNetCoreConfiguration _configuration; // 真正用来写入审计日志的工具类 private readonly IAuditingHelper _auditingHelper; public AbpAuditActionFilter(IAbpAspNetCoreConfiguration configuration, IAuditingHelper auditingHelper) { _configuration = configuration; _auditingHelper = auditingHelper; } public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) { // ... 代码实现 } // ... 其他代码 } 接着看 AbpAuditActionFilter() 方法内部的实现，进入这个过滤器的时候，通过 ShouldSaveAudit() 方法来判断是否要写审计日志。\n之后呢与 DTO 自动验证的过滤器一样，通过 AbpCrossCuttingConcerns.Applying() 方法为当前的对象增加了一个标识，用来告诉拦截器说我已经处理过了，你就不要再重复处理了。\n再往下就是创建审计信息，执行具体接口方法，并且如果产生了异常的话，也会存放到审计信息当中。\n最后接口无论是否执行成功，还是说出现了异常信息，都会将其性能计数信息同审计信息一起，通过 IAuditingHelper 存储起来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) { // 判断是否写日志 if (!ShouldSaveAudit(context)) { await next(); return; } // 为当前类型打上标识 using (AbpCrossCuttingConcerns.Applying(context.Controller, AbpCrossCuttingConcerns.Auditing)) { // 构造审计信息(AuditInfo) var auditInfo = _auditingHelper.CreateAuditInfo( context.ActionDescriptor.AsControllerActionDescriptor().ControllerTypeInfo.AsType(), context.ActionDescriptor.AsControllerActionDescriptor().MethodInfo, context.ActionArguments ); // 开始性能计数 var stopwatch = Stopwatch.StartNew(); try { // 尝试调用接口方法 var result = await next(); // 产生异常之后，将其异常信息存放在审计信息之中 if (result.Exception != null \u0026amp;\u0026amp; !result.ExceptionHandled) { auditInfo.Exception = result.Exception; } } catch (Exception ex) { // 产生异常之后，将其异常信息存放在审计信息之中 auditInfo.Exception = ex; throw; } finally { // 停止计数，并且存储审计信息 stopwatch.Stop(); auditInfo.ExecutionDuration = Convert.ToInt32(stopwatch.Elapsed.TotalMilliseconds); await _auditingHelper.SaveAsync(auditInfo); } } } 2.2 拦截器代码分析 拦截器处理时的总体思路与过滤器类似，其核心都是通过 IAuditingHelper 来创建审计信息和持久化审计信息的。只不过呢由于拦截器不仅仅是处理 MVC 接口，也会处理内部的一些类型的方法，所以针对同步方法与异步方法的处理肯定会复杂一点。\n拦截器呢，我们关心一下他的核心方法 Intercept() 就行了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 public void Intercept(IInvocation invocation) { // 判断过滤器是否已经处理了过了 if (AbpCrossCuttingConcerns.IsApplied(invocation.InvocationTarget, AbpCrossCuttingConcerns.Auditing)) { invocation.Proceed(); return; } // 通过 IAuditingHelper 来判断当前方法是否需要记录审计日志信息 if (!_auditingHelper.ShouldSaveAudit(invocation.MethodInvocationTarget)) { invocation.Proceed(); return; } // 构造审计信息 var auditInfo = _auditingHelper.CreateAuditInfo(invocation.TargetType, invocation.MethodInvocationTarget, invocation.Arguments); // 判断方法的类型，同步方法与异步方法的处理逻辑不一样 if (invocation.Method.IsAsync()) { PerformAsyncAuditing(invocation, auditInfo); } else { PerformSyncAuditing(invocation, auditInfo); } } // 同步方法的处理逻辑与 MVC 过滤器逻辑相似 private void PerformSyncAuditing(IInvocation invocation, AuditInfo auditInfo) { var stopwatch = Stopwatch.StartNew(); try { invocation.Proceed(); } catch (Exception ex) { auditInfo.Exception = ex; throw; } finally { stopwatch.Stop(); auditInfo.ExecutionDuration = Convert.ToInt32(stopwatch.Elapsed.TotalMilliseconds); _auditingHelper.Save(auditInfo); } } // 异步方法处理 private void PerformAsyncAuditing(IInvocation invocation, AuditInfo auditInfo) { var stopwatch = Stopwatch.StartNew(); invocation.Proceed(); if (invocation.Method.ReturnType == typeof(Task)) { invocation.ReturnValue = InternalAsyncHelper.AwaitTaskWithFinally( (Task) invocation.ReturnValue, exception =\u0026gt; SaveAuditInfo(auditInfo, stopwatch, exception) ); } else //Task\u0026lt;TResult\u0026gt; { invocation.ReturnValue = InternalAsyncHelper.CallAwaitTaskWithFinallyAndGetResult( invocation.Method.ReturnType.GenericTypeArguments[0], invocation.ReturnValue, exception =\u0026gt; SaveAuditInfo(auditInfo, stopwatch, exception) ); } } private void SaveAuditInfo(AuditInfo auditInfo, Stopwatch stopwatch, Exception exception) { stopwatch.Stop(); auditInfo.Exception = exception; auditInfo.ExecutionDuration = Convert.ToInt32(stopwatch.Elapsed.TotalMilliseconds); _auditingHelper.Save(auditInfo); } 这里异步方法的处理在很早之前的工作单元拦截器就有过讲述，这里就不再重复说明了。\n2.3 核心的 IAuditingHelper 从代码上我们就可以看到，不论是拦截器还是过滤器都是最终都是通过 IAuditingHelper 对象来储存审计日志的。Abp 依旧为我们实现了一个默认的 AuditingHelper ，实现了其接口的所有方法。我们先查看一下这个接口的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public interface IAuditingHelper { // 判断当前方法是否需要存储审计日志信息 bool ShouldSaveAudit(MethodInfo methodInfo, bool defaultValue = false); // 根据参数集合创建一个审计信息，一般用于拦截器 AuditInfo CreateAuditInfo(Type type, MethodInfo method, object[] arguments); // 根据一个参数字典类来创建一个审计信息，一般用于 MVC 过滤器 AuditInfo CreateAuditInfo(Type type, MethodInfo method, IDictionary\u0026lt;string, object\u0026gt; arguments); // 同步保存审计信息 void Save(AuditInfo auditInfo); // 异步保存审计信息 Task SaveAsync(AuditInfo auditInfo); } 我们来到其默认实现 AuditingHelper 类型，先看一下其内部注入了哪些接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class AuditingHelper : IAuditingHelper, ITransientDependency { // 日志记录器，用于记录日志 public ILogger Logger { get; set; } // 用于获取当前登录用户的信息 public IAbpSession AbpSession { get; set; } // 用于持久话审计日志信息 public IAuditingStore AuditingStore { get; set; } // 主要作用是填充审计信息的客户端调用信息 private readonly IAuditInfoProvider _auditInfoProvider; // 审计日志组件的配置相关 private readonly IAuditingConfiguration _configuration; // 在调用 AuditingStore 进行持久化的时候使用，创建一个工作单元 private readonly IUnitOfWorkManager _unitOfWorkManager; // 用于序列化参数信息为 JSON 字符串 private readonly IAuditSerializer _auditSerializer; public AuditingHelper( IAuditInfoProvider auditInfoProvider, IAuditingConfiguration configuration, IUnitOfWorkManager unitOfWorkManager, IAuditSerializer auditSerializer) { _auditInfoProvider = auditInfoProvider; _configuration = configuration; _unitOfWorkManager = unitOfWorkManager; _auditSerializer = auditSerializer; AbpSession = NullAbpSession.Instance; Logger = NullLogger.Instance; AuditingStore = SimpleLogAuditingStore.Instance; } // ... 其他实现的接口 } 2.3.1 判断是否创建审计信息 首先分析一下其内部的 ShouldSaveAudit() 方法，整个方法的核心作用就是根据传入的方法类型来判定是否为其创建审计信息。\n其实在这一串 if 当中，你可以发现有一句代码对方法是否标注了 DisableAuditingAttribute 特性进行了判断，如果标注了该特性，则不为该方法创建审计信息。所以我们就可以通过该特性来控制自己应用服务类，控制里面的的接口是否要创建审计信息。同理，我们也可以通过显式标注 AuditedAttribute 特性来让拦截器为这个方法创建审计信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public bool ShouldSaveAudit(MethodInfo methodInfo, bool defaultValue = false) { if (!_configuration.IsEnabled) { return false; } if (!_configuration.IsEnabledForAnonymousUsers \u0026amp;\u0026amp; (AbpSession?.UserId == null)) { return false; } if (methodInfo == null) { return false; } if (!methodInfo.IsPublic) { return false; } if (methodInfo.IsDefined(typeof(AuditedAttribute), true)) { return true; } if (methodInfo.IsDefined(typeof(DisableAuditingAttribute), true)) { return false; } var classType = methodInfo.DeclaringType; if (classType != null) { if (classType.GetTypeInfo().IsDefined(typeof(AuditedAttribute), true)) { return true; } if (classType.GetTypeInfo().IsDefined(typeof(DisableAuditingAttribute), true)) { return false; } if (_configuration.Selectors.Any(selector =\u0026gt; selector.Predicate(classType))) { return true; } } return defaultValue; } 2.3.2 创建审计信息 审计信息在创建的时候，就为我们将当前调用接口时的用户信息存放在了审计信息当中，之后通过 IAuditInfoProvider 的 Fill() 方法填充了客户端 IP 与浏览器信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public AuditInfo CreateAuditInfo(Type type, MethodInfo method, IDictionary\u0026lt;string, object\u0026gt; arguments) { // 构建一个审计信息对象 var auditInfo = new AuditInfo { TenantId = AbpSession.TenantId, UserId = AbpSession.UserId, ImpersonatorUserId = AbpSession.ImpersonatorUserId, ImpersonatorTenantId = AbpSession.ImpersonatorTenantId, ServiceName = type != null ? type.FullName : \u0026#34;\u0026#34;, MethodName = method.Name, // 将参数转换为 JSON 字符串 Parameters = ConvertArgumentsToJson(arguments), ExecutionTime = Clock.Now }; try { // 填充客户 IP 与浏览器信息等 _auditInfoProvider.Fill(auditInfo); } catch (Exception ex) { Logger.Warn(ex.ToString(), ex); } return auditInfo; } 2.4 审计信息持久化 通过上一小节我们知道了在调用审计信息保存接口的时候，实际上是调用的 IAuditingStore 所提供的 SaveAsync(AuditInfo auditInfo) 方法来持久化这些审计日志信息的。\n如果你没有集成 Abp.Zero 项目的话，则使用的是默认的实现，就是简单通过 ILogger 输出审计信息到日志当中。\n默认有这两种实现，至于第一种是 Abp 的单元测试项目所使用的。\n这里我们就简单将一下 AuditingStore 这个实现吧，其实很简单的，就是注入了一个仓储，在保存的时候往审计日志表插入一条数据即可。\n这里使用了 AuditLog.CreateFromAuditInfo() 方法将 AuditInfo 类型的审计信息转换为数据库实体，用于仓储进行插入操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class AuditingStore : IAuditingStore, ITransientDependency { private readonly IRepository\u0026lt;AuditLog, long\u0026gt; _auditLogRepository; public AuditingStore(IRepository\u0026lt;AuditLog, long\u0026gt; auditLogRepository) { _auditLogRepository = auditLogRepository; } public virtual Task SaveAsync(AuditInfo auditInfo) { // 向表中插入数据 return _auditLogRepository.InsertAsync(AuditLog.CreateFromAuditInfo(auditInfo)); } } 同样，这里建议重新实现一个 AuditingStore，存储在 Redis 或者其他地方。\n3. 后记 前几天发现 Abp 的团队有开了一个新坑，叫做 Abp vNext 框架，该框架全部基于 .NET Core 进行开发，而且会针对微服务项目进行专门的设计，有兴趣的朋友可以持续关注。\n其 GitHub 地址为：https://github.com/abpframework/abp/\n官方地址为：https://abp.io/\n","date":"2018-09-29T09:12:11Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-15-automatic-audit-records/","title":"Abp 源码分析：十五、自动审计记录"},{"content":"0.背景 在项目开发之中，前期可能主要以保证任务完成为主，对于性能优化主要在于开发完成之后再来进行。可能在测试的时候发现部分接口的代码执行时间过长，但是又毫无头绪，这个时候你就需要性能分析工具来协助你排查问题了。\n常规性能分析借助于 Visual Studio 强大的性能测试工具就可以进行分析，但是这些功能只包含在企业版当中。这个时候我们就可以使用 JetBrains 的 .NET 分析全家桶来进行这个操作了，其包含内存分析(dotMemory)与性能分析(dotTrace)，其实他的 dotCover(单元测试) 也是挺好用的。\n1.安装与下载 1.1 下载 安装步骤较为简单，前往 Jetbrains 官网，找到 dotTrace ，点击下载即可。\n其地址为 https://www.jetbrains.com/profiler/download/ ，选择自己需要的安装包形式，一般选择 WebInstaller 进行安装，当然这里推荐选择 Standalone (独立版)，直接下载运行就 OK 。\n1.2 安装 每个用户可以免费评估使用 10 天，当然你要使用某些补丁或者激活工具也是可以的，这里不再详述过程，只是注意一下（WebInstaller）在安装的时候选择自己需要的安装就可以了，不需要的直接选为 Skip 跳过。\n你也可以在安装的时候选择 \u0026ldquo;Visual Studio Integration\u0026rdquo;，这样就会与 VS 集成，在分析代码的时候可以快速跳转到相应的代码行。\n2.使用与分析 dotTrace 使用比较方便，本身支持 .NET Core 分析，分析时只是会有四种不同的分析模式，这里大概讲解一下各种分析模式的区别。\nProfiler Options 作用与描述 Sampling 通过获取 CLR 内部一个方法开始执行和结束执行的时间差来计算的分析时间。 这是最快的方法，它用于精确测量程序运行时间，但可能会丢失一些数据。 使用此配置类型可使你快速获取应用程序的的总体性能。 Tracing 慢于 Sampling 的方法，但是可以准确地测量特定方法被调用的准确次数。 它是通过获取 CLR 内部一个方法开始执行和结束执行的时间差来计算的分 析时间。 Line-by-line 通过收集代码执行的每条语句的时间来进行比较，它计算出的时间更加精确。 该方法适用于你已经知道性能问题大概在哪里出现，并要找到具体某一个出 现性能问题的时候。 Timeline 采取抽样的方式，每隔一段时间 (10 ms)，会暂停所有线程，并抓取堆栈里的 信息，然后才计算出代码执行时间差。使用这个方式可能会导致一些执行时间 少于 10 ms 的方法无法被抓取到。 一般来说我们使用的是 Tracing 来进行代码的性能分析，因为一般都是需要查看每个方法具体的调用时间。下面我就将以一个接口的实例来作为示范，看如何来排查调用缓慢的问题。\n2.1 获取快照信息 首先运行 dotTrace 之后，选择 .NET Core Application，之后右侧的 Profiler Options 则选择 Tracing。最后一步则是选择需要进行检测的 dll 文件，这里我选择的是一个基于 Abp 框架开发的 ASP.NET Core 项目。\n当然，你也可以勾选上 Advanced ，配置诸如启动参数之类的东西，之后点击 Run 则开始进行分析了。\n这里右下角的 Get Snapshot and Wait 点击之后呢，就会获取到快照文件了，当然现在先不慌，我们先来测试一下我们要测试的接口。\n比如说我这里有一个 TestMethod 方法，其代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class TestApplicationService : ApplicationService { private readonly IRepository\u0026lt;SysSystem\u0026gt; _tempRep; public TestApplicationService(IRepository\u0026lt;SysSystem\u0026gt; tempRep) { _tempRep = tempRep; } public async Task\u0026lt;string\u0026gt; TestMethod() { var systems = _tempRep.GetAll().ToList(); foreach (var system in systems) { system.Status = 10; await _tempRep.UpdateAsync(system); } int i = 0; for (int j = 0; j \u0026lt; 10000; j++) { i += j; } return systems[0].SystemCode; } } 现在我们通过 SwaggerUI 调用这个接口，看需要多长时间。\n可以看到平均时常都需要 300ms ，现在我们点击 GetSnapshot and Wait 按钮，会弹出分析窗口，并且我们随时可以通过再次点击 Start 按钮，继续分析。\n2.2 分析代码 2.2.1 概览信息 Tracing 分析的界面比较简单，一个 All Calls 页签与 Overview (概览) 的页签，首先我们大致看一下概览窗口。\n可以看到他给我们标识了用户代码执行周期最长的一些地方，其次也用柱状图很直观地体现了耗时最长的代码分类。\n右侧则提列了一些快照的信息与运行时的环境信息，以便用户作为参考。\n2.2.2 Threads Tree (线程信息) 本窗口主要的作用是分析应用程序里面发生的所有的线程活动，主线程有一个图标，而终结器线程则是拥有一个图标，剩下的都是线程池内部的工作线程。\n在这里我们以主线程为例，分析一下其具体内容所表达的意思。\nMain：代表不带命名空间的方法简称。 99 . 99 %：代表该方法针对于整个线程运行时间所占的百分比，这里的意思就是 Main 方法占用了整个主线程运行时间的 99.99 %。 523,732 ms：代表该方法与子方法执行的总时间。 1 call：方法在堆栈上所被调用的次数。 XXX.Web.Host.Startup.Program.Main(string[] )：被调用方法的全称， 2.2.3 Call Tree (调用树) 一般我们使用本页面的时候会多一点，这个页面会显示在所有线程中的所有被调用的方法。其每一个根节点代表的是每一个线程所执行的一个根函数，而下面每一个节点则代表其根函数内部调用的子函数的相关性能分析信息。\n那么我们如何快速定位我们刚才测试的接口呢？\n按下 Ctrl+F ，会弹出搜索框，在里面输入我们所编写的接口方法名字，按下回车就会快速定位了。\n之后我们会看到如下内容：\n通过展开节点我们可以知道最耗费时间的方法，即为 GetAll 方法，当点击节点的时候，右侧也会定位到相应的代码位置。\n这里可以看到整个 GetAll 方法使用了 1015ms 的时间，这是为什么呢？你可以看到在其右侧有一个 8 calls ，这个时间是 8 次调用总共所花费的时间。\n右键节点，你可以通过 Properties 可以看到该方法的平均执行时间：\n可以看到其自身只花费了 8.3 μs，说明真正执行缓慢的还在其更深层，这里就不再往里面跟了，如果需要更加详细的性能报告，可以不使用 Tracing 模式，而使用 Line-by-line 模式来进行分析。\n2.2.4 Plain List (简单列表) 以平铺的方式展示所有被调用过的方法列表，让你分析具体代码。\n2.2.5 Hot Spots (热点跟踪) 该视图会列举出所有耗时最长的方法。\n3.参考资料 CSDN：https://blog.csdn.net/weixin_38208401/article/details/75645021\n","date":"2018-09-29T08:29:56Z","permalink":"https://real-zony.github.io/p/analyze-net-core-code-issues-with-dottrace/","title":"使用 dotTrace 分析 .NET Core 代码问题"},{"content":"0.简介 在平时开发 API 接口的时候需要对前端传入的参数进行校验之后才能进入业务逻辑进行处理，否则一旦前端传入一些非法/无效数据到 API 当中，轻则导致程序报错，重则导致整个业务流程出现问题。\n用过传统 ASP.NET MVC 数据注解的同学应该知道，我们可以通过在 Model 上面指定各种数据特性，然后在前端调用 API 的时候就会根据这些注解来校验 Model 内部的字段是否合法。\n1.启动流程 Abp 针对于数据校验分为两个地方进行，第一个是 MVC 的过滤器，也是我们最常使用的。第二个则是借助于 Castle 的拦截器实现的 DTO 数据校验功能，前者只能用于控制器方法，而后者则支持普通方法。\n1.1 过滤器注入 在注入 Abp 的时候，通过 AddAbp() 方法内部的 ConfigureAspNetCore() 配置了诸多过滤器。\n1 2 3 4 5 6 7 8 9 10 11 12 private static void ConfigureAspNetCore(IServiceCollection services, IIocResolver iocResolver) { // ... 其他代码 //Configure MVC services.Configure\u0026lt;MvcOptions\u0026gt;(mvcOptions =\u0026gt; { mvcOptions.AddAbp(services); }); // ... 其他代码 } 过滤器注入方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 internal static class AbpMvcOptionsExtensions { public static void AddAbp(this MvcOptions options, IServiceCollection services) { // ... 其他代码 AddFilters(options); // ... 其他代码 } // ... 其他代码 private static void AddFilters(MvcOptions options) { // ... 其他过滤器注入 // 注入参数验证过滤器 options.Filters.AddService(typeof(AbpValidationActionFilter)); // ... 其他过滤器注入 } // ... 其他代码 } 1.2 拦截器注入 Abp 针对于验证拦截器的注册始于 AbpBootstrapper 类，该基类在之前曾经多次出现过，也就是在用户调用 IServiceCollection.AddAbp\u0026lt;TStartupModule\u0026gt;() 方法的时候会初始化该类的一个实例对象。在该类的构造函数当中，会调用一个 AddInterceptorRegistrars() 方法用于添加各种拦截器的注册类实例。代码如下：\n来到 ValidationInterceptorRegistrar 类型定义当中可以看到，其内部就是通过 Castle 的 IocContainer 来针对每次注入的应用服务应用上参数验证拦截器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 internal static class ValidationInterceptorRegistrar { public static void Initialize(IIocManager iocManager) { iocManager.IocContainer.Kernel.ComponentRegistered += Kernel_ComponentRegistered; } private static void Kernel_ComponentRegistered(string key, IHandler handler) { // 判断是否实现了 IApplicationService 接口，如果实现了，则为该对象添加拦截器 if (typeof(IApplicationService).GetTypeInfo().IsAssignableFrom(handler.ComponentModel.Implementation)) { handler.ComponentModel.Interceptors.Add(new InterceptorReference(typeof(ValidationInterceptor))); } } } 2.代码分析 从 Abp 库代码当中我们可以知道其拦截器与过滤器是在何时被注入的，下面我们就来具体分析一下他们的处理逻辑。\n2.1 过滤器代码分析 Abp 在框架初始化的时候就将 AbpValidationActionFilter 添加到 MVC 的配置当中，其自定义实现的拦截器实现了 IAsyncActionFilter 接口，也就是说当每次接口被调用的时候都会进入该拦截器的内部。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class AbpValidationActionFilter : IAsyncActionFilter, ITransientDependency { // Ioc 解析器，用于解析各种注入的组件 private readonly IIocResolver _iocResolver; // Abp 针对与 ASP.NET Core 的配置项，主要作用是判断用户是否需要检测控制器方法 private readonly IAbpAspNetCoreConfiguration _configuration; public AbpValidationActionFilter(IIocResolver iocResolver, IAbpAspNetCoreConfiguration configuration) { _iocResolver = iocResolver; _configuration = configuration; } public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) { // ... 处理逻辑 } } 在内部首先是结合配置项判断用户是否禁用了 MVC Controller 的参数验证功能，禁用了则不进行任何操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) { // 判断是否禁用了控制器检测 if (!_configuration.IsValidationEnabledForControllers || !context.ActionDescriptor.IsControllerAction()) { await next(); return; } // 针对应用服务增加一个验证完成标识 using (AbpCrossCuttingConcerns.Applying(context.Controller, AbpCrossCuttingConcerns.Validation)) { // 解析出方法验证器，传入请求上下文，并且调用这些验证器具体的验证方法 using (var validator = _iocResolver.ResolveAsDisposable\u0026lt;MvcActionInvocationValidator\u0026gt;()) { validator.Object.Initialize(context); validator.Object.Validate(); } await next(); } } 其实我们这里看到有一个 AbpCrossCuttingConcerns.Applying() 方法，那么该方法的作用是什么呢？\n在这里我先大体讲述一下该方法的作用，该方法主要是向应用服务对象 (也就是继承了 ApplicationService 类的对象) 内部的 AppliedCrossCuttingConcerns 属性增加一个常量值，在这里也就是 AbpCrossCuttingConcerns.Validation 的值，也就是一个字符串。\n那么其作用是什么呢，就是防止重复验证。从启动流程一节我们就已经知道 Abp 框架在启动的时候除了注入过滤器之外，还会注入拦截器进行接口参数验证，当过滤器验证过之后，其实没必要再使用拦截器进行二次验证。\n所以在拦截器的 Intercept() 方法内部会有这样一句代码：\n1 2 3 4 5 6 7 8 9 10 11 public void Intercept(IInvocation invocation) { // 判断是否拥有处理过的标识 if (AbpCrossCuttingConcerns.IsApplied(invocation.InvocationTarget, AbpCrossCuttingConcerns.Validation)) { invocation.Proceed(); return; } // ... 其他代码 } 解释完 AbpCrossCuttingConcerns.Applying() 之后，我们继续往下看代码。\n1 2 3 4 5 6 7 8 // 解析出方法验证器，传入请求上下文，并且调用这些验证器具体的验证方法 using (var validator = _iocResolver.ResolveAsDisposable\u0026lt;MvcActionInvocationValidator\u0026gt;()) { validator.Object.Initialize(context); validator.Object.Validate(); } await next(); 这里就比较简单了，过滤器通过 IocResolver 解析出来了一个 MvcActionInvocationValidator 对象，使用该对象来校验具体的参数内容。\n2.2 拦截器代码分析 看完过滤器代码之后，其实拦截器代码更加简单。整体逻辑上面与过滤器差不多，只不过针对于拦截器，它是通过一个 MethodInvocationValidator 对象来校验传入的参数内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class ValidationInterceptor : IInterceptor { // Ioc 解析器，用于解析各种注入的组件 private readonly IIocResolver _iocResolver; public ValidationInterceptor(IIocResolver iocResolver) { _iocResolver = iocResolver; } public void Intercept(IInvocation invocation) { // 判断过滤器是否已经处理过 if (AbpCrossCuttingConcerns.IsApplied(invocation.InvocationTarget, AbpCrossCuttingConcerns.Validation)) { // 处理过则直接进入具体方法内部，执行业务逻辑 invocation.Proceed(); return; } // 解析出方法验证器，传入请求上下文，并且调用这些验证器具体的验证方法 using (var validator = _iocResolver.ResolveAsDisposable\u0026lt;MethodInvocationValidator\u0026gt;()) { validator.Object.Initialize(invocation.MethodInvocationTarget, invocation.Arguments); validator.Object.Validate(); } invocation.Proceed(); } } 可以看到两个过滤器与拦截器业务逻辑相似，但都是通过验证器来进行处理的，那么验证器又是个什么鬼东西呢？\n2.3 验证器 验证器即是用来具体执行验证逻辑的工具，从上述代码里面我们可以看到过滤器和拦截器都是通过解析出 MethodInvocationValidator/MvcActionInvocationValidator 之后调用其验证方法进行验证的。\n首先我们来看一下 MVC 的验证器是如何进行处理的，看方法类型的定义，可以看到其继承了一个基类，叫 ActionInvocationValidatorBase，而这个基类呢，又继承自 MethodInvocationValidator。\n1 2 3 4 5 6 7 8 public class MvcActionInvocationValidator : ActionInvocationValidatorBase { // ... 其他代码 } public abstract class ActionInvocationValidatorBase : MethodInvocationValidator { // ... 其他代码 } 所以我们分析代码的顺序调整一下，先看一下 MethodInvocationValidator 的内部是如何做处理的吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 /// \u0026lt;summary\u0026gt; /// 本类用于需要参数验证的方法. /// \u0026lt;/summary\u0026gt; public class MethodInvocationValidator : ITransientDependency { // 最大迭代验证次数 private const int MaxRecursiveParameterValidationDepth = 8; // 待验证的方法信息 protected MethodInfo Method { get; private set; } // 传入的参数值 protected object[] ParameterValues { get; private set; } // 方法参数信息 protected ParameterInfo[] Parameters { get; private set; } protected List\u0026lt;ValidationResult\u0026gt; ValidationErrors { get; } protected List\u0026lt;IShouldNormalize\u0026gt; ObjectsToBeNormalized { get; } private readonly IValidationConfiguration _configuration; private readonly IIocResolver _iocResolver; public MethodInvocationValidator(IValidationConfiguration configuration, IIocResolver iocResolver) { _configuration = configuration; _iocResolver = iocResolver; ValidationErrors = new List\u0026lt;ValidationResult\u0026gt;(); ObjectsToBeNormalized = new List\u0026lt;IShouldNormalize\u0026gt;(); } // 初始化拦截器参数 public virtual void Initialize(MethodInfo method, object[] parameterValues) { Check.NotNull(method, nameof(method)); Check.NotNull(parameterValues, nameof(parameterValues)); Method = method; ParameterValues = parameterValues; Parameters = method.GetParameters(); } // 开始验证参数的有效性 public void Validate() { // 检测是否初始化 CheckInitialized(); if (Parameters.IsNullOrEmpty()) { return; } if (!Method.IsPublic) { return; } if (IsValidationDisabled()) { return; } if (Parameters.Length != ParameterValues.Length) { throw new Exception(\u0026#34;Method parameter count does not match with argument count!\u0026#34;); } for (var i = 0; i \u0026lt; Parameters.Length; i++) { ValidateMethodParameter(Parameters[i], ParameterValues[i]); } if (ValidationErrors.Any()) { ThrowValidationError(); } foreach (var objectToBeNormalized in ObjectsToBeNormalized) { objectToBeNormalized.Normalize(); } } protected virtual void CheckInitialized() { if (Method == null) { throw new AbpException(\u0026#34;This object has not been initialized. Call Initialize method first.\u0026#34;); } } protected virtual bool IsValidationDisabled() { if (Method.IsDefined(typeof(EnableValidationAttribute), true)) { return false; } return ReflectionHelper.GetSingleAttributeOfMemberOrDeclaringTypeOrDefault\u0026lt;DisableValidationAttribute\u0026gt;(Method) != null; } protected virtual void ThrowValidationError() { throw new AbpValidationException( \u0026#34;Method arguments are not valid! See ValidationErrors for details.\u0026#34;, ValidationErrors ); } /// \u0026lt;summary\u0026gt; /// Validates given parameter for given value. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;parameterInfo\u0026#34;\u0026gt;Parameter of the method to validate\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameterValue\u0026#34;\u0026gt;Value to validate\u0026lt;/param\u0026gt; protected virtual void ValidateMethodParameter(ParameterInfo parameterInfo, object parameterValue) { if (parameterValue == null) { if (!parameterInfo.IsOptional \u0026amp;\u0026amp; !parameterInfo.IsOut \u0026amp;\u0026amp; !TypeHelper.IsPrimitiveExtendedIncludingNullable(parameterInfo.ParameterType, includeEnums: true)) { ValidationErrors.Add(new ValidationResult(parameterInfo.Name + \u0026#34; is null!\u0026#34;, new[] { parameterInfo.Name })); } return; } ValidateObjectRecursively(parameterValue, 1); } protected virtual void ValidateObjectRecursively(object validatingObject, int currentDepth) { if (currentDepth \u0026gt; MaxRecursiveParameterValidationDepth) { return; } if (validatingObject == null) { return; } if (_configuration.IgnoredTypes.Any(t =\u0026gt; t.IsInstanceOfType(validatingObject))) { return; } if (TypeHelper.IsPrimitiveExtendedIncludingNullable(validatingObject.GetType())) { return; } SetValidationErrors(validatingObject); // Validate items of enumerable if (IsEnumerable(validatingObject)) { foreach (var item in (IEnumerable) validatingObject) { ValidateObjectRecursively(item, currentDepth + 1); } } // Add list to be normalized later if (validatingObject is IShouldNormalize) { ObjectsToBeNormalized.Add(validatingObject as IShouldNormalize); } if (ShouldMakeDeepValidation(validatingObject)) { var properties = TypeDescriptor.GetProperties(validatingObject).Cast\u0026lt;PropertyDescriptor\u0026gt;(); foreach (var property in properties) { if (property.Attributes.OfType\u0026lt;DisableValidationAttribute\u0026gt;().Any()) { continue; } ValidateObjectRecursively(property.GetValue(validatingObject), currentDepth + 1); } } } protected virtual void SetValidationErrors(object validatingObject) { foreach (var validatorType in _configuration.Validators) { if (ShouldValidateUsingValidator(validatingObject, validatorType)) { using (var validator = _iocResolver.ResolveAsDisposable\u0026lt;IMethodParameterValidator\u0026gt;(validatorType)) { var validationResults = validator.Object.Validate(validatingObject); ValidationErrors.AddRange(validationResults); } } } } protected virtual bool ShouldValidateUsingValidator(object validatingObject, Type validatorType) { return true; } protected virtual bool ShouldMakeDeepValidation(object validatingObject) { // Do not recursively validate for enumerable objects if (validatingObject is IEnumerable) { return false; } var validatingObjectType = validatingObject.GetType(); // Do not recursively validate for primitive objects if (TypeHelper.IsPrimitiveExtendedIncludingNullable(validatingObjectType)) { return false; } return true; } private bool IsEnumerable(object validatingObject) { return validatingObject is IEnumerable \u0026amp;\u0026amp; !(validatingObject is IQueryable) \u0026amp;\u0026amp; !TypeHelper.IsPrimitiveExtendedIncludingNullable(validatingObject.GetType()); } } 3. 后记 最近工作较忙，可能更新速度不会像原来那么快，不过我尽可能在国庆结束后完成剩余文章，谢谢大家的支持。\n","date":"2018-09-28T01:25:06Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-14-dto-automatic-verification/","title":"Abp 源码分析：十四、DTO 自动验证"},{"content":"在 Git 提交时我们可以通过附加 emoji 表情来着重提醒其他开发人员本次地更改重点，也就是说我们可通过不同的表情可以快速地知道这次提交具体做了哪方面地工作。\n比如说本次提交我添加了一个新的单元测试，那么我在 Git 的 Commit 里面就可以通过在第一行添加 :white_check_mark: (:white_check_mark: )来表示本次提交的重点。\n1 :white_check_mark: 添加了用户创建功能的单元测试代码; 效果大概就是这个样子：\n在 gitmoji 的网站上一共罗列了以下 emoji 表情与其对应的含义。\nEmoji 表情代码 图标预览 含义 :art: :art: 改进代码的结构与格式. :zap: :zap: 性能提升. :fire: :fire: 删除了代码/文件. :bug: :bug: 修复了某些 Bug. :ambulance: :ambulance: 重要的问题修复. :sparkles: :sparkles: 新的功能与特性. :memo: :memo: 增加项目文档. :rocket: :rocket: 项目部署相关的提交. :lipstick: :lipstick: 更新 UI 与样式文件. :tada: :tada: 首次提交. :white_check_mark: :white_check_mark: 添加测试用例. :lock: :lock: 修复安全相关的问题. :apple: :apple: 修复了在 macOS 系统上的某些问题. :penguin: :penguin: 修复了在 Linux 系统上的某些问题. :checkered_flag: :checkered_flag: 修复了在 Windows 系统上的某些问题. :robot: :robot: 修复了在 Android 系统上的某些问题. :green_apple: :green_apple: 修复了在 IOS 系统上的某些问题. :bookmark: :bookmark: 给代码增加版本化的 Tag(标签). :rotating_light: :rotating_light: 移除 Linter 的警告. :construction: :construction: 正在开发中. :green_heart: :green_heart: 修复 CI 构建相关的问题. :arrow_down: :arrow_down: 依赖项版本降级. :arrow_up: :arrow_up: 升级依赖项版本. :pushpin: :pushpin: 固定依赖项版本. :construction_worker: :construction_worker: 添加 CI 构建系统. :chart_with_upwards_trend: :chart_with_upwards_trend: 添加分析/跟踪代码. :recycle: :recycle: 重构代码. :heavy_minus_sign: :heavy_minus_sign: 移除一个依赖项. :whale: :whale: 与 Docker 相关的某些更改. :heavy_plus_sign: :heavy_plus_sign: 添加一个依赖项. :wrench: :wrench: 配置文件的相关更改. :globe_with_meridians: :globe_with_meridians: 针对多语言本地化的一些更改. :pencil2: :pencil2: 修正拼写错误. :hankey: :hankey: 提交了一些\u0026quot;坏\u0026quot;代码，后续需要改进. :rewind: :rewind: 回滚更改. :twisted_rightwards_arrows: :twisted_rightwards_arrows: 合并分支. :package: :package: 更新已编译的文件或包. :alien: :alien: 由于使用的外部 API 变化而需要更新代码. :truck: :truck: 移动/重命名文件. :page_facing_up: :page_facing_up: 添加或者更新许可. :boom: :boom: 本次 API 或者代码拥有某些重大的变化，会导致无法向下兼容. :bento: :bento: 添加或者更新某些资源文件. :ok_hand: :ok_hand: 为了代码审查而进行的某些更改. :wheelchair: :wheelchair: 提升无障碍体验. :bulb: :bulb: 编写源码相关的文档. :beers: :beers: 醉醺醺地编写代码，或许这些代码会有某些问题. :speech_balloon: :speech_balloon: 更改了某些注释文本和字符串数据. :card_file_box: :card_file_box: 执行了数据库相关的一些更改，例如 EF 迁移. :loud_sound: :loud_sound: 添加日志. :mute: :mute: 移除日志. :busts_in_silhouette: :busts_in_silhouette: 新增贡献者. :children_crossing: :children_crossing: 提升用户体验. :building_construction: :building_construction: 更改架构. :iphone: :iphone: 响应式设计相关变更. :clown_face: :clown_face: Mock 测试相关 :egg: :egg: 增加了彩蛋. :see_no_evil: :see_no_evil: 增加或者更新了 .gitignore 文件. :camera_flash: :camera_flash: 添加或者更新了快照文件. 参考资料：\n相关 GitHub 演示项目：https://github.com/carloscuesta/gitmoji\ngitmoji 网站：https://gitmoji.carloscuesta.me/\n","date":"2018-09-03T07:30:50Z","permalink":"https://real-zony.github.io/p/use-emoji-to-identify-the-information-of-each-commit-in-git/","title":"通过 Emoji 表情标识 Git 每次提交的信息"},{"content":"0.使用背景 因为现在的项目都是基于 .NET Core 的，但是某些需要调用第三方的 WebService 服务，故有了此文章。其基本思路是通过微软提供的 Svcutil 工具生成代理类，然后通过 System.ServiceModel 来调用代理类所提供的对象与方法。\n1.配置准备 1.1 新建并编辑项目 首先新建一个新的 .NET Core 控制台程序，通过命令行窗口或者 Powershell 执行以下命令新建一个项目。\n1 dotnet new console 然后编辑项目文件 WebServiceConsole.csproj ，并在其中加入以下内容：\n1 2 3 \u0026lt;ItemGroup\u0026gt; \u0026lt;DotNetCliToolReference Include=\u0026#34;dotnet-svcutil\u0026#34; Version=\u0026#34;1.0.*\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; 这样最终 WebServiceConsole.csproj 的内容会是这样子的。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;OutputType\u0026gt;Exe\u0026lt;/OutputType\u0026gt; \u0026lt;TargetFramework\u0026gt;netcoreapp2.1\u0026lt;/TargetFramework\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;DotNetCliToolReference Include=\u0026#34;dotnet-svcutil\u0026#34; Version=\u0026#34;1.0.*\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; 继续打开命令行窗口或者 Powershell 执行以下命令，还原项目文件的包。\n1 dotnet restore 1.2 代理类生成 现在准备工作做好了，现在我们可以使用 dotnet svcutil 命令来生成代理类，或者你可以到 WindowsSDKs 的目录下找到 SvcUtil.exe 来执行代理类生成操作。\n1 dotnet svcutil [WebService 地址] 上面是命令格式，比如说我这里有一个 WebService 提供的接口，其地址为 http://localhost:3000/bsp-oisp/ws/sfexpressService?wsdl ，那么我们需要打开命令行工具，执行以下命令来生成代理类。\n1 dotnet svcutil http://localhost:3000/bsp-oisp/ws/sfexpressService?wsdl](http://localhost:3000/bsp-oisp/ws/sfexpressService?wsdl 成功之后会看到文件夹里面多了一个文件夹。\n注意，在生成代理类之后，我们还需要再执行一次 dotnet restore 来还原代理类当中所使用到的 NuGet 包。\n2.调用 WebService 接口 生成代理类之后，重新打开项目，可以看到多了一个 ServiceModel1 的文件夹，在里面还有一个 Reference.cs 的文件，这个文件里面的内容就是根据我们之前提供的 Url 生成的代理类了。\n用法的话很简单，需要三步，在这里我直接在 Main() 方法内部写调用方法了，注意这里基本上所有生成的方法都是异步方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 using System; using System.ServiceModel; using System.Threading.Tasks; namespace WebServiceConsole { class Program { static async Task Main(string[] args) { // 创建 HTTP 绑定对象 var binding = new BasicHttpBinding(); // 根据 WebService 的 URL 构建终端点对象 var endpoint = new EndpointAddress(@\u0026#34; http://localhost:3000/bsp-oisp/ws/sfexpressService?wsdl](http://localhost:3000/bsp-oisp/ws/sfexpressService?wsdl\u0026#34;); // 创建调用接口的工厂，注意这里泛型只能传入接口 var factory = new ChannelFactory\u0026lt;IExpressService\u0026gt;(binding, endpoint); // 从工厂获取具体的调用实例 var callClient = factory.CreateChannel(); // 调用具体的方法，这里是 sfexpressServiceAsync 方法。 var result = await callClient.sfexpressServiceAsync(new sfexpressService()); Console.ReadLine(); } } } 3.参考资料 [1]https://docs.microsoft.com/en-us/dotnet/core/additional-tools/dotnet-svcutil-guide\n[2]https://www.jianshu.com/p/aae85122f20f?tdsourcetag=s_pctim_aiomsg\n","date":"2018-08-28T03:47:00Z","permalink":"https://real-zony.github.io/p/how-dotnet-core-calls-webservice/","title":"dotNET Core 如何调用 WebService"},{"content":"0.简介 如果你所开发的需要走向世界的话，那么肯定需要针对每一个用户进行不同的本地化处理，有可能你的客户在日本，需要使用日语作为显示文本，也有可能你的客户在美国，需要使用英语作为显示文本。如果你还是一样的写死错误信息，或者描述信息，那么就无法做到多语言适配。\nAbp 框架本身提供了一套多语言机制来帮助我们实现本地化，基本思路是 Abp 本身维护一个键值对集合。只需要将展示给客户的文字信息处都使用一个语言 Key 来进行填充，当用户登录系统之后，会取得当前用户的区域文化信息进行文本渲染。\n0.1 如何使用 我们首先来看一下如何定义一个多语言资源并使用。首先 Abp 自身支持三种类型的本地化资源来源，第一种是 XML 文件，第二种则是 JSON 文件，第三种则是内嵌资源文件，如果这三种都不能满足你的需求，你可以自行实现 ILocalizationSource 接口来返回多语言资源。\n小提示：\nAbp Zero 模块就提供了数据库持久化存储多语言资源的功能。\n0.1.1 定义应用程序支持的语言 如果你需要为你的应用程序添加不同语言的支持，就必须在你任意模块的预加载方法当中添加语言来进行配置：\n1 2 Configuration.Localization.Languages.Add(new LanguageInfo(\u0026#34;en\u0026#34;, \u0026#34;English\u0026#34;, \u0026#34;famfamfam-flag-england\u0026#34;, true)); Configuration.Localization.Languages.Add(new LanguageInfo(\u0026#34;tr\u0026#34;, \u0026#34;Türkçe\u0026#34;, \u0026#34;famfamfam-flag-tr\u0026#34;)); 例如以上代码，就能够让我们的程序拥有针对英语与土耳其语的多语言处理能力。\n这里的 famfamfam-flag-england 与 famfamfam-flag-tr 是一个 CSS 类型，是 Abp 为前端展示所封装的小国旗图标。\n0.1.2 建立多语言资源文件 有了语言之后，Abp 还需要你提供标准的多语言资源文件，这里我们以 自带的 XML 资源文件为例，其文件名称为 Abp-zh-Hans.xml ，路径为 Abp\\Localization\\Sources\\AbpXmlSource。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;localizationDictionary culture=\u0026#34;zh-Hans\u0026#34;\u0026gt; \u0026lt;texts\u0026gt; \u0026lt;text name=\u0026#34;SmtpHost\u0026#34;\u0026gt;SMTP主机\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;SmtpPort\u0026#34;\u0026gt;SMTP端口\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;Username\u0026#34;\u0026gt;用户名\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;Password\u0026#34;\u0026gt;密码\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;DomainName\u0026#34;\u0026gt;域名\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;UseSSL\u0026#34;\u0026gt;使用SSL\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;UseDefaultCredentials\u0026#34;\u0026gt;使用默认验证\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;DefaultFromSenderEmailAddress\u0026#34;\u0026gt;默认发件人邮箱地址\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;DefaultFromSenderDisplayName\u0026#34;\u0026gt;默认发件人名字\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;DefaultLanguage\u0026#34;\u0026gt;预设语言\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;ReceiveNotifications\u0026#34;\u0026gt;接收通知\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;CurrentUserDidNotLoginToTheApplication\u0026#34;\u0026gt;当前用户没有登录到系统！\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;TimeZone\u0026#34;\u0026gt;时区\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;AllOfThesePermissionsMustBeGranted\u0026#34;\u0026gt;您没有权限进行此操作,您需要以下权限: {0}\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;AtLeastOneOfThesePermissionsMustBeGranted\u0026#34;\u0026gt;您没有权限进行此操作,您至少需要下列权限的其中一项: {0}\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;MainMenu\u0026#34;\u0026gt;主菜单\u0026lt;/text\u0026gt; \u0026lt;/texts\u0026gt; \u0026lt;/localizationDictionary\u0026gt; 每个文件内部，会有一个 \u0026lt;localizationDictionary culture=\u0026quot;zh-Hans\u0026quot;\u0026gt; 节点用于说明当前文件是针对于哪个区域适用的，而在其 \u0026lt;texts\u0026gt; 内部则就是结合键值对的形式，name 里面的内容就是多语言文本项的键，在标签内部的就是其真正的值。\n打开一个针对俄语国家的 XML 资源文件，文件名称叫做 Abp-ru.xml。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;localizationDictionary culture=\u0026#34;ru\u0026#34;\u0026gt; \u0026lt;texts\u0026gt; \u0026lt;text name=\u0026#34;SmtpHost\u0026#34;\u0026gt;SMTP сервер\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;SmtpPort\u0026#34;\u0026gt;SMTP порт\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;Username\u0026#34;\u0026gt;Имя пользователя\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;Password\u0026#34;\u0026gt;Пароль\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;DomainName\u0026#34;\u0026gt;Домен\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;UseSSL\u0026#34;\u0026gt;Использовать SSL\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;UseDefaultCredentials\u0026#34;\u0026gt;Использовать учетные данные по умолчанию\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;DefaultFromSenderEmailAddress\u0026#34;\u0026gt;Электронный адрес отправителя по умолчанию\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;DefaultFromSenderDisplayName\u0026#34;\u0026gt;Имя отправителя по умолчанию\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;DefaultLanguage\u0026#34;\u0026gt;Язык по умолчанию\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;ReceiveNotifications\u0026#34;\u0026gt;Получать уведомления\u0026lt;/text\u0026gt; \u0026lt;text name=\u0026#34;CurrentUserDidNotLoginToTheApplication\u0026#34;\u0026gt;Текущий пользователь не вошёл в приложение!\u0026lt;/text\u0026gt; \u0026lt;/texts\u0026gt; \u0026lt;/localizationDictionary\u0026gt; 可以看到 Key 值都是一样的，只是其 \u0026lt;text\u0026gt; 内部的值根据区域国家的不同值不一样而已。\n其次从文件名我们就可以看到需要使用 XML 资源文件对于文件的命名格式会有一定要求，还是以 Abp 自带的资源文件为例，可以看一下他们基本上都是由 {SourceName}-{CultureInfo}.xml 这样构成的。\n0.1.3 注册本地化的 XML 资源 那么如果我们需要注册之前的两个 XML 资源到 Abp 框架当中的话，则需要在预加载模块处通过如下代码来执行注册，并且需要右键 XML 文件，更改其构建操作为 内嵌资源。\n1 2 3 4 5 6 7 8 Configuration.Localization.Sources.Add( new DictionaryBasedLocalizationSource( // 本地化资源名称 AbpConsts.LocalizationSourceName, // 数据源提供者，这里使用的是 XML ，除了 XML 提供者，还有 JSON 等 new XmlEmbeddedFileLocalizationDictionaryProvider( typeof(AbpKernelModule).GetAssembly(), \u0026#34;Abp.Localization.Sources.AbpXmlSource\u0026#34; ))); 0.1.4 获取多语言文本 如果你需要在某处获取指定 Key 所对应的具体显示文本，只需要注入 ILocalizationManager ，通过其 GetString() 方法就可以获得具体的值。如果你需要获取本地化资源的地方不能够使用依赖注入，你可以使用 LocalizationHelper 静态类来进行操作。\n1 var @string = _localizationManager.GetString(\u0026#34;Abp\u0026#34;, \u0026#34;MainMenu\u0026#34;); 它默认是从 Thread.CurrentThread.CurrentUICulture 获取到的当前区域信息，从而来取得某个 Key 所对应的显示值，而当前区域信息是由 Abp 注入的一系列 RequestCultureProviders 所提供的，他按照以下顺序来进行设置。\nQueryStringRequestCultureProvider(ASP .NET Core 默认提供)：该默认提供器使用的是 QueryString 的 culture\u0026amp;ui-culture 所提供的区域文化信息来初始化该值，例如：culture=es-MX\u0026amp;ui-culture=es-MX。 AbpUserRequestCultureProvider (Abp 提供)：该提供器会读取当前用户的 IAbpSession 信息，并且从 ISettingManager 中获取用户所配置的 \u0026quot;Abp.Localization.DefaultLanguageName\u0026quot; 属性，将其作为默认的区域文化信息。 **AbpLocalizationHeaderRequestCultureProvider ** (Abp 提供)：使用每次请求头当中的 .AspNetCore.Culture 值作为当前的区域文化信息，例如 c=en|uic=en-US。 CookieRequestCultureProvider (ASP .NET Core 提供)：使用每次请求的 Cookie 当中 Key 为 .AspNetCore.Culture 值作为当前区域文化信息。 AbpDefaultRequestCultureProvider (Abp 提供)：如果之前这些提供器都没有为当前区域文化赋值，则从 ISettingMananger 当中取得 Abp.Localization.DefaultLanguageName 的默认值。 AcceptLanguageHeaderRequestCultureProvider (ASP .NET Core 默认提供)：该提供器最终会使用用户每次请求时传递的 Accept-Language 头部作为当前区域文化信息。 小提示：\n这里 Abp 注入的提供器是有顺序的，注入这么多提供器就是为了最后确定当前用户的区域文化信息以便展示相应的语言文本。\n1.启动流程 1.1 启动流程图 1.2 代码流程 根据使用方法我们可以得知，要配置 Abp 的多语言，必须得等 IAbpStartupConfiguration 初始化完毕才可以。即在 AbpBootstrapper 的 Initialize() 方法之中：\n1 2 3 4 5 6 7 8 9 10 11 12 public virtual void Initialize() { // ... 其他代码 // 注入 IAbpStartupConfiguration 配置与本地化资源配置 IocManager.IocContainer.Install(new AbpCoreInstaller()); // ... 其他代码 // 初始化 AbpStartupConfiguration 类型 IocManager.Resolve\u0026lt;AbpStartupConfiguration\u0026gt;().Initialize(); // ... 其他代码 } 配置类里面包含了用户所配置的所有语言与多语言资源信息，在被成功注入到 Ioc 容器之后，Abp 就开始使用本地化资源管理器来初始化这些多语言数据了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public override void PostInitialize() { // 注册缺少的组件，防止遗漏注册组件 RegisterMissingComponents(); IocManager.Resolve\u0026lt;SettingDefinitionManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;FeatureManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;PermissionManager\u0026gt;().Initialize(); // 重点在这里，这个 PostInitialize 方法是存放在核心模块当中的，在这里调用了本地化资源管理器的初始化方法 IocManager.Resolve\u0026lt;LocalizationManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;NotificationDefinitionManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;NavigationManager\u0026gt;().Initialize(); if (Configuration.BackgroundJobs.IsJobExecutionEnabled) { var workerManager = IocManager.Resolve\u0026lt;IBackgroundWorkerManager\u0026gt;(); workerManager.Start(); workerManager.Add(IocManager.Resolve\u0026lt;IBackgroundJobManager\u0026gt;()); } } 具体 LocalizationManager 及其内部的实现我们在下一节代码分析中详细进行讲述。\n这些动作仅仅是在注入 Abp 框架的时候所需要执行的一些步骤，如果你要启用多语言，需要在 ASP .NET Core 程序的 Startup 类中的 Configure() 处通过更改 UseAbpRequestLocalization 状态为 True，才会将区域文化识别中间件注入到程序当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { app.UseAbp(options =\u0026gt; { options.UseAbpRequestLocalization = false; //disable automatic adding of request localization }); //...authentication middleware(s) app.UseAbpRequestLocalization(); //manually add request localization //...other middlewares app.UseMvc(routes =\u0026gt; { //... }); } 其实这里的 UseAbpRequestLocalization() 就已经将上文说的那些 RequestProvider 按照顺序依次注入到 MVC 之中了。\n2.代码分析 Abp 框架针对本地化处理相关的类型与方法定义都存放在 Abp 库的 Localization 文件夹下。关系还是相对复杂的，这里我们先从其核心的 Abp 库针对于多语言的处理开始讲起。\n2.1 多语言模块配置 Abp 需要使用的所有信息都是由用户在自己启动模块的 PreInitialize() 当中，通过 ILocalizationConfiguration 进行注入配置。也就是说在 ILocalizationConfiguration 内部，主要是包含了语言，与多语言资源提供者两种重点信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface ILocalizationConfiguration { // 当前应用程序可配置的语言列表 IList\u0026lt;LanguageInfo\u0026gt; Languages { get; } // 本地化资源列表 ILocalizationSourceList Sources { get; } // 是否启用多语言(本地化) 系统 bool IsEnabled { get; set; } // 以下四个布尔类型的参数主要用于确定当没有找到多语言文本时的处理逻辑，默认都为 True bool ReturnGivenTextIfNotFound { get; set; } bool WrapGivenTextIfNotFound { get; set; } bool HumanizeTextIfNotFound { get; set; } bool LogWarnMessageIfNotFound { get; set; } } 2.2 语言信息 当前应用程序能够支持哪一些语言，取决于用户在预加载的时候给多语言模块配置对象分配了哪些语言。通过第 0.1.1 节我们看到用户可以直接通过初始化一个新的 LanguageInfo 对象，将其添加到 Languages 属性之中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public class LanguageInfo { /// \u0026lt;summary\u0026gt; /// 区域文化代码名称 /// 应该是一个有效的区域文化代码名称，更多的可以通过 CultureInfo 静态类获得所有文化代码。 /// 例如: \u0026#34;en-US\u0026#34; 是北美适用的, \u0026#34;tr-TR\u0026#34; 适用于土耳其。 /// \u0026lt;/summary\u0026gt; public string Name { get; set; } /// \u0026lt;summary\u0026gt; /// 该语言默认应该展示的语言名称。 /// 例如: 英语应该展示为 \u0026#34;English\u0026#34;, \u0026#34;zh-Hans\u0026#34; 应该展示为 \u0026#34;简体中文\u0026#34; /// \u0026lt;/summary\u0026gt; public string DisplayName { get; set; } /// \u0026lt;summary\u0026gt; /// 用于展示的图标 CSS 类名，可选参数 /// \u0026lt;/summary\u0026gt; public string Icon { get; set; } /// \u0026lt;summary\u0026gt; /// 是否为默认语言 /// \u0026lt;/summary\u0026gt; public bool IsDefault { get; set; } /// \u0026lt;summary\u0026gt; /// 该语言是否被禁用 /// \u0026lt;/summary\u0026gt; public bool IsDisabled { get; set; } /// \u0026lt;summary\u0026gt; /// 语言的展示方式是自左向右还是自右向左 /// \u0026lt;/summary\u0026gt; public bool IsRightToLeft { get { try { return CultureInfo.GetCultureInfo(Name).TextInfo?.IsRightToLeft ?? false; } catch { return false; } } } public LanguageInfo(string name, string displayName, string icon = null, bool isDefault = false, bool isDisabled = false) { Name = name; DisplayName = displayName; Icon = icon; IsDefault = isDefault; IsDisabled = isDisabled; } } 关于语言的定义还是相当简单的，主要参数就是语言的 区域文化代码 与 展示的名称，其余的都可以是可选参数。\n小提示：\n关于当前系统所支持的区域文化代码，可以通过执行 CultureInfo.GetCultures(CultureTypes.AllCultures); 得到。\n2.3 语言管理器 Abp 针对语言也提供了一个管理器，接口叫做 ILanguageManager，定义简单，两个方法。\n1 2 3 4 5 6 7 8 public interface ILanguageManager { // 获得当前语言 LanguageInfo CurrentLanguage { get; } // 获得所有语言 IReadOnlyList\u0026lt;LanguageInfo\u0026gt; GetLanguages(); } 实现也不复杂，它内部的实现就是从一个 ILanguageProvider 拿取有哪一些语言数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private readonly ILanguageProvider _languageProvider; public IReadOnlyList\u0026lt;LanguageInfo\u0026gt; GetLanguages() { return _languageProvider.GetLanguages(); } // 获取当前语言，其实就是获取的 CultureInfo.CurrentUICulture.Name 的信息，然后去查询语言集合。 private LanguageInfo GetCurrentLanguage() { var languages = _languageProvider.GetLanguages(); // ... 省略了的代码 var currentCultureName = CultureInfo.CurrentUICulture.Name; var currentLanguage = languages.FirstOrDefault(l =\u0026gt; l.Name == currentCultureName); if (currentLanguage != null) { return currentLanguage; } // ... 省略了的代码 return languages[0]; } 默认实现就是直接读取之前通过 Configuration 的 Languages 里面的数据。\n在 Abp.Zero 模块还有两外一个实现，叫做 ApplicationLanguageProvider ，这个提供者则是从数据库表 ApplicationLanguage 获取的这些语言列表数据，并且这些语言信息还与租户有关，不同的租户他所能够获得到的语言数据也不一样。\n1 2 3 4 5 6 7 8 9 10 11 12 public IReadOnlyList\u0026lt;LanguageInfo\u0026gt; GetLanguages() { // 可以看到这里传入的当前登录用户的租户 Id，通过这个参数去查询的语言表数据 var languageInfos = AsyncHelper.RunSync(() =\u0026gt; _applicationLanguageManager.GetLanguagesAsync(AbpSession.TenantId)) .OrderBy(l =\u0026gt; l.DisplayName) .Select(l =\u0026gt; l.ToLanguageInfo()) .ToList(); SetDefaultLanguage(languageInfos); return languageInfos; } 2.4 本地化资源 2.4.1 本地化资源列表 在多语言模块配置内部使用的是 ILocalizationSourceList 类型的一个 Sources 属性，该类型其实就是继承自 IList\u0026lt;ILocalizationSource\u0026gt; 的一个具体实现而已，一个类型为 ILocalizationSource 的集合，不过其扩展了一个\nExtensions 属性用于存放扩展的多语言数据字段。\n2.4.2 本地化资源 其接口定义为 ILocalizationSource ，Abp 默认为我们实现了四种本地化资源的实现。\n第一个是空实现，可以跳过，第二个则是针对资源文件进行读取的的本地化资源，第三个是基于字典的的本地化资源定义，最后一个是由 Abp Zero 模块所提供的数据库版本的多语言资源定义。\n首先看一下该接口的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface ILocalizationSource { // 本地化资源唯一的名称 string Name { get; } // 用于初始化本地化资源,在 Abp 框架初始化的时候被调用 void Initialize(ILocalizationConfiguration configuration, IIocResolver iocResolver); // 从当前本地化资源中获取给定关键字的多语言文本项，为用户当前语言 string GetString(string name); // 从当前本地化资源中获取给定关键字与区域文化的多语言文本项 string GetString(string name, CultureInfo culture); // 作用同上，只不过不存在会返回 NULL string GetStringOrNull(string name, bool tryDefaults = true); // 作用同上，只不过不存在会返回 NULL string GetStringOrNull(string name, CultureInfo culture, bool tryDefaults = true); // 获得当前语言所有的多语言文本项集合 IReadOnlyList\u0026lt;LocalizedString\u0026gt; GetAllStrings(bool includeDefaults = true); // 获得给定区域文化的所有多语言文本项集合 IReadOnlyList\u0026lt;LocalizedString\u0026gt; GetAllStrings(CultureInfo culture, bool includeDefaults = true); } 也就可以这么来看，我们有几套本地化资源，他们通过 Name 来进行标识，如果你需要在本地化管理器获取某一套本地化资源，那么你可以直接通过 Name 来进行定位。而每一套本地化资源，自身都拥有具体的多语言数据，这些多语言数据有可能来自文件也有可能来自数据库，这取决于你具体的实现。\n2.4.3 基于字典的本地化资源 最开始我们在使用范例当中，通过 DictionaryBasedLocalizationSource 来建立我们的本地化资源对象。该对象实现了 ILocalizationSource 与 IDictionaryBasedLocalizationSource 接口，内部定义了一个本地化资源字典提供器。\n当调用本地化资源的 Initialize() 方法的时候，会使用具体的本地化资源字典提供器来获取数据，而这个字典提供器可以为 XmlFileLocalizationDictionaryProvider、JsonEmbeddedFileLocalizationDictionaryProvider 等。\n这些内部字典提供器在初始化的时候，会将自身的数据按照 语言/多语言项 的形式将多语言信息存放在一个字典之中，而这个字典又可以分为 XML、JSON 等等等等\u0026hellip;\n1 2 3 4 5 6 7 8 9 // 内部字典提供器 public interface ILocalizationDictionaryProvider { // 语言/多语言项字典 IDictionary\u0026lt;string, ILocalizationDictionary\u0026gt; Dictionaries { get; } // 本地化资源初始化时被调用 void Initialize(string sourceName); } 而这里的 ILocalizationDictionary 其实就是一个键值对，键关联的是多语言项的标识 KEY，例如 \u0026ldquo;Home\u0026rdquo;，而 Value 就是具体的展示文本信息了。\n而是用字典本地化资源对象获取数据的时候，其实也就是从其内部的字典提供器来获取数据。\n例如本地化资源有一个 GetString() 方法，它内部拥有一个字典提供器 DictionaryProvider，我要获取某个 KEY 为 \u0026ldquo;Home\u0026rdquo; 所需要经过的步骤如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public ILocalizationDictionaryProvider DictionaryProvider { get; } public string GetString(string name) { // 获取当前用户区域文化，标识为 \u0026#34;Home\u0026#34; 的展示文本 return GetString(name, CultureInfo.CurrentUICulture); } public string GetString(string name, CultureInfo culture) { // 获取值 var value = GetStringOrNull(name, culture); // 判断值为空的话，根据配置的要求是否抛出异常 if (value == null) { return ReturnGivenNameOrThrowException(name, culture); } return value; } // 获得 KEY 关联的文本 public string GetStringOrNull(string name, CultureInfo culture, bool tryDefaults = true) { var cultureName = culture.Name; var dictionaries = DictionaryProvider.Dictionaries; // 在这里就开始从初始化所加载完成的语言字典里面，获取具体的多语言项字典 ILocalizationDictionary originalDictionary; if (dictionaries.TryGetValue(cultureName, out originalDictionary)) { // 多语言项字典拿取具体的多语言文本值 var strOriginal = originalDictionary.GetOrNull(name); if (strOriginal != null) { return strOriginal.Value; } } if (!tryDefaults) { return null; } //Try to get from same language dictionary (without country code) if (cultureName.Contains(\u0026#34;-\u0026#34;)) //Example: \u0026#34;tr-TR\u0026#34; (length=5) { ILocalizationDictionary langDictionary; if (dictionaries.TryGetValue(GetBaseCultureName(cultureName), out langDictionary)) { var strLang = langDictionary.GetOrNull(name); if (strLang != null) { return strLang.Value; } } } //Try to get from default language var defaultDictionary = DictionaryProvider.DefaultDictionary; if (defaultDictionary == null) { return null; } var strDefault = defaultDictionary.GetOrNull(name); if (strDefault == null) { return null; } return strDefault.Value; } 2.3.4 基于数据库的本地化资源 如果你有集成 Abp.Zero 模块的话，可以通过在启动模块的预加载方法编写以下代码启用 Zero 的多语言机制。\n1 Configuration.Modules.Zero().LanguageManagement.EnableDbLocalization(); Abp.Zero 针对原有的本地化资源进行了扩展，新增的本地化资源类叫做 MultiTenantLocalizationSource，该类同语言管理器一样，是一个基于多租户实现的本地化资源，内部字典的值是从数据库当中获取的，其大体逻辑与字典本地化资源一样，都是内部维护有一个字典提供器。\n在通过 EnableDbLocalization() 方法的时候就直接替换掉了 ILanguageProvider 的默认实现，并且在配置的 Sources 源里面也增加了 MultiTenantLocalizationSource 作为一个本地化资源。\n2.5 本地化资源管理器 扯了这么多，让我们来看一下最为核心的 ILocalizationManager 接口，如果我们需要获取某个数据源的某个 Key 所对应的多语言值肯定是要注入这个本地化资源管理器来进行操作的。\n1 2 3 4 5 6 7 8 public interface ILocalizationManager { // 根据名称获得本地化数据源 ILocalizationSource GetSource(string name); // 获取所有的本地化数据源 IReadOnlyList\u0026lt;ILocalizationSource\u0026gt; GetAllSources(); } 这里的数据源标识的就是一个命名空间的作用，比如我在 A 模块当中有一个 Key 为 \u0026quot;Home\u0026quot; 的多语言项，在 B 模块也有一个 Key 为 \u0026quot;Home\u0026quot; 的多语言项，这个时候就可以用数据源标识来区分这两个 \u0026quot;Home\u0026quot; 。\n本地化资源管理器通过在初始化的时候调用其 Initialize() 来初始化所有被注入的本地化资源，最后并将其放在一个字典之中，以便后续使用。\n1 2 3 4 5 6 7 8 9 10 private readonly IDictionary\u0026lt;string, ILocalizationSource\u0026gt; _sources; foreach (var source in _configuration.Sources) { // ... 其他代码 _sources[source.Name] = source; source.Initialize(_configuration, _iocResolver); // ... 其他代码 } 3.结语 针对 Abp 的多语言处理本篇文章不太适合作为入门了解，其中大部分知识需要结合 Abp 源码进行阅读才能够加深理解，此文仅作抛砖引玉之用，如有任何意见或建议欢迎大家在评论当中指出。\n","date":"2018-08-18T03:22:41Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-thirteen-multi-language-localization-processing/","title":"Abp 源码分析：十三、多语言(本地化)处理"},{"content":"0.简介 承接上篇文章我们会在这篇文章详细解说一下 Abp 是如何结合 IPermissionChecker 与 IFeatureChecker 来实现一个完整的多租户系统的权限校验的。\n1.多租户的概念 多租户系统又被称之为 Saas ，比如阿里云就是一个典型的多租户系统，用户本身就是一个租户，可以在上面购买自己的 ECS 实例，并且自己的数据与其他使用者(租户)所隔绝，两者的数据都是不可见的。\n那么 Abp 是如何实现数据隔离的呢？\n1.1 单部署-单数据库 如果你的软件系统仅部署一个实例，并且所有租户的数据都是存放在一个数据库里面的，那么可以通过一个 TenantId (租户 Id) 来进行数据隔离。那么当我们执行 SELECT 操作的时候就会附加上当前登录用户租户 Id 作为过滤条件，那么查出来的数据也仅仅是当前租户的数据，而不会查询到其他租户的数据。\n1.2 单部署-多数据库 Abp 还提供了另外一种方式，即为每一个租户提供一个单独的数据库，在用户登录的时候根据用户对应的租户 ID，从一个数据库连接映射表获取到当前租户对应的数据库连接字符串，并且在查询数据与写入数据的时候，不同租户操作的数据库是不一样的。\n2.多租户系统的权限验证 从上一篇文章我们知道了在权限过滤器与权限拦截器当中，最终会使用 IFeatureChecker 与 IPermissionChecker 来进行权限校验，并且它还持久一个用户会话状态 IAbpSession 用于存储识别当前访问网站的用户是谁。\n2.1 用户会话状态 基本做过网站程序开发的同学都知道用于区分每一个用户，我们需要通过 Session 来保存当前用户的状态，以便进行权限验证或者其他操作。而 Abp 框架则为我们定义了一个统一的会话状态接口 IAbpSession ，用于标识当前用户的状态。在其接口当中主要定义了三个重要的属性，第一个 UserId (用户 Id)，第二个就是 TenantId (租户 Id)，以及用于确定当前用户是租户还是租主的 MultiTenancySides 属性。\n除此之外，还拥有一个 Use() 方法，用户在某些时候临时替换掉当前用户的 UserId 与 TenantId 的值，这个方法在我的《Abp + Grpc 如何实现用户会话状态传递》文章当中有讲到过。\n而针对这个方法的实现又可以扯出一大堆知识，这块我们放在后面再进行精讲，这里我们还是主要通篇讲解一下多租户体系下的数据过滤与权限验证。\n2.1.1 默认会话状态的实现 IAbpSession 当中的值默认是从 JWT 当中取得的，这取决于它的默认实现 ClaimsAbpSession，它还继承了一个抽象父类 AbpSessionBase ，这个父类主要是实现了 Use() 方法，这里略过。\n在其默认实现里面，重载了 UserId 与 TenantId 的获取方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public override long? UserId { get { // ... 其他代码 var userIdClaim = PrincipalAccessor.Principal?.Claims.FirstOrDefault(c =\u0026gt; c.Type == AbpClaimTypes.UserId); // ... 其他代码 long userId; if (!long.TryParse(userIdClaim.Value, out userId)) return null; return userId; } } 可以看到这里是通过 PrincipalAccessor 从当前请求的请求头中获取 Token ，并从 Claims 里面获取 Type 值为 AbpClaimTypes.UserId 的对象，将其转换为 long 类型的 UserId，这样就拿到了当前用户登录的 Id 了。\n2.1.2 获取当前请求的用户状态 这里的 PrincipalAccessor 是一个 IPrincipalAccessor 接口，在 ASP .NET Core 库当中他的实现名字叫做 AspNetCorePrincipalAccessor。其实你应该猜得到，在这个类的构造函数当中，注入了 HttpContext 的访问器对象 IHttpContextAccessor，这样 IAbpSession 就可以轻而易举地获得当前请求上下文当中的具体数据了。\n1 2 3 4 5 6 7 8 9 10 11 public class AspNetCorePrincipalAccessor : DefaultPrincipalAccessor { public override ClaimsPrincipal Principal =\u0026gt; _httpContextAccessor.HttpContext?.User ?? base.Principal; private readonly IHttpContextAccessor _httpContextAccessor; public AspNetCorePrincipalAccessor(IHttpContextAccessor httpContextAccessor) { _httpContextAccessor = httpContextAccessor; } } 2.1.3 小结 所以，Abp 通过 IAbpSession 可以轻松地知道我们当前用户的状态，包括用户 Id 与租户 Id，它只需要知道这两个东西，就可以很简单的在 IFeatureChecker 和 IPermissionChecker 当中来查询用户所绑定的权限来进行验证。\n2.2 功能(Feature) 首先我们的思绪回到上一章所讲的 AuthorizationHelper 类，在其 AuthorizeAsync() 方法当中，使用 IFeatureChecker 来检测用户是否拥有某种功能。\n1 2 3 4 5 6 7 public virtual async Task AuthorizeAsync(MethodInfo methodInfo, Type type) { // 检测功能 await CheckFeatures(methodInfo, type); // 检测权限 await CheckPermissions(methodInfo, type); } 然后呢，在 IFeatureChecker.CheckFeatures() 方法的内部，跟 IPermissionChecker 的套路一样，这里仍然是一个扩展方法，遍历方法/类上标记的 [RequiresFeatureAttribute] 特性，调用 IFeatureChecker 的 GetValueAsync() 方法传入功能的名称，然后将其值与 \u0026quot;true\u0026quot; 相比较，为真则是启用了该功能，其他值则说明没有启用。\n1 2 3 4 5 public static async Task\u0026lt;bool\u0026gt; IsEnabledAsync(this IFeatureChecker featureChecker, string featureName) { // 检查是否启用 return string.Equals(await featureChecker.GetValueAsync(featureName), \u0026#34;true\u0026#34;, StringComparison.OrdinalIgnoreCase); } IFeatureChecker 的定义：\n1 2 3 4 5 6 7 8 public interface IFeatureChecker { // 传入功能名字，获取真这对于当前租户其默认值 Task\u0026lt;string\u0026gt; GetValueAsync(string name); // 传入租户 Id 与功能名字，获取针对于指定 Id 租户的默认值 Task\u0026lt;string\u0026gt; GetValueAsync(int tenantId, string name); } 到这一步我们仍然是跟 IFeatureChecker 打交道，那么他的具体实现是怎样的呢？\n先来看一下这个 IFeatureChecker 的依赖关系图：\n目前看起来还是比较简单，他拥有一个默认实现 FeatureChecker ，其中 IFeatureValueStore 从名字就可以知道它是用来存储功能列表的，而 IFeatureManager 则是用来管理这些功能的，Feature 则是这些功能的定义。\n结合之前在 IsEnabledAsync() 方法的调用，可以看到它先进入的 GetValueAsync(string name) 方法，判断当前用户的租户 Id 是否有值，如果没有值则直接抛出异常，中断权限验证。如果有值得话，传入当前登录用户的租户 Id ，从 IFeatureManager 当中获取到定义的权限，之后呢从 IFeatureValueStore 当中拿到功能具体的值，因为功能是针对租户而言的，所以一个功能针对于多个租户的值肯定是不同的，所以在这里查询具体值的时候需要传入租户 Id。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class FeatureChecker : IFeatureChecker, ITransientDependency { public IAbpSession AbpSession { get; set; } public IFeatureValueStore FeatureValueStore { get; set; } private readonly IFeatureManager _featureManager; public FeatureChecker(IFeatureManager featureManager) { _featureManager = featureManager; FeatureValueStore = NullFeatureValueStore.Instance; AbpSession = NullAbpSession.Instance; } public Task\u0026lt;string\u0026gt; GetValueAsync(string name) { // 判断当前登录的用户是否拥有租户 ID if (!AbpSession.TenantId.HasValue) { throw new AbpException(\u0026#34;FeatureChecker can not get a feature value by name. TenantId is not set in the IAbpSession!\u0026#34;); } // 传入当前登录用户的租户 Id ，获取其值 return GetValueAsync(AbpSession.TenantId.Value, name); } public async Task\u0026lt;string\u0026gt; GetValueAsync(int tenantId, string name) { // 从功能管理器根据名字查询用户定义的功能 var feature = _featureManager.Get(name); // 获得功能的值，如果没有值则返回其默认值 var value = await FeatureValueStore.GetValueOrNullAsync(tenantId, feature); if (value == null) { return feature.DefaultValue; } return value; } } 聪明的你肯定猜到功能其实是用户在代码当中定义的，而功能的值则是存放在数据库当中，每个租户其值都是不一样的。这是不是让你想到了系列文章《[Abp 源码分析]五、系统设置》 SettingProvider 的实现呢？\nSo,这里的 IFeatureStore 的默认实现肯定是从数据库进行配置咯~\n2.2.1 功能的定义 首先功能、权限都是树形结构，他们都可以拥有自己的子节点，这样可以直接实现针对父节点赋值而拥有其子节点的所有权限。这里先来看一下功能的的基本定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class Feature { // 附加数据的一个索引器 public object this[string key] { get =\u0026gt; Attributes.GetOrDefault(key); set =\u0026gt; Attributes[key] = value; } // 功能的附加数据 public IDictionary\u0026lt;string, object\u0026gt; Attributes { get; private set; } // 父级功能 public Feature Parent { get; private set; } // 功能的名称 public string Name { get; private set; } // 功能的展示名称，这是一个本地化字符串 public ILocalizableString DisplayName { get; set; } // 功能的描述，一样的是一个本地化字符串 public ILocalizableString Description { get; set; } // 功能的输入类型 public IInputType InputType { get; set; } // 功能的默认值 public string DefaultValue { get; set; } // 功能所适用的范围 public FeatureScopes Scope { get; set; } // 如果当前功能的子节点的不可变集合 public IReadOnlyList\u0026lt;Feature\u0026gt; Children =\u0026gt; _children.ToImmutableList(); private readonly List\u0026lt;Feature\u0026gt; _children; public Feature(string name, string defaultValue, ILocalizableString displayName = null, ILocalizableString description = null, FeatureScopes scope = FeatureScopes.All, IInputType inputType = null) { Name = name ?? throw new ArgumentNullException(\u0026#34;name\u0026#34;); DisplayName = displayName; Description = description; Scope = scope; DefaultValue = defaultValue; InputType = inputType ?? new CheckboxInputType(); _children = new List\u0026lt;Feature\u0026gt;(); Attributes = new Dictionary\u0026lt;string, object\u0026gt;(); } public Feature CreateChildFeature(string name, string defaultValue, ILocalizableString displayName = null, ILocalizableString description = null, FeatureScopes scope = FeatureScopes.All, IInputType inputType = null) { var feature = new Feature(name, defaultValue, displayName, description, scope, inputType) { Parent = this }; _children.Add(feature); return feature; } public override string ToString() { return string.Format(\u0026#34;[Feature: {0}]\u0026#34;, Name); } } 这玩意儿光看着头还是有点疼的，其实就是关于功能的基础定义，他为啥附带了一个附加描述字典，因为可以存储一些额外的信息，比如说一个短信功能，他的配额和到期时间，至于他的 Scope 则说明了它的生效范围。\n2.2.2 功能管理器 接着看看 GetValueAsync(int tenantId, string name) 方法的第一句：\n1 var feature = _featureManager.Get(name); emmm，我要从 IFeatureManager 根据权限名称取得一个具体的 Feature 对象，那我们继续来看一下 IFeatureManager 接口。\n1 2 3 4 5 6 7 8 9 10 11 public interface IFeatureManager { // 根据名称获得一个具体的功能，这个名称应该是唯一的 Feature Get(string name); // 根据一个名称获得一个具体的功能，如果没找到则返回 NULL Feature GetOrNull(string name); // 获得所有定义的功能 IReadOnlyList\u0026lt;Feature\u0026gt; GetAll(); } 2.2.3 功能管理器实现 在看具体实现的时候，我们先不慌，先看一下它实现类所继承的东西。\n1 internal class FeatureManager : FeatureDefinitionContextBase, IFeatureManager, ISingletonDependency WTF，他又继承了什么奇奇怪怪的东西。我们又在此来到 FeatureDefinitionContextBase ，经过一番探查总算知道这玩意儿实现自 IFeatureDefinitionContext,看看他的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 // 功能定义上下文，主要功能是提供给 FeatureProvider 来创建功能的 public interface IFeatureDefinitionContext { // 创建一个功能 Feature Create(string name, string defaultValue, ILocalizableString displayName = null, ILocalizableString description = null, FeatureScopes scope = FeatureScopes.All, IInputType inputType = null); // 根据名称获得一个功能 Feature GetOrNull(string name); // 移除一个功能 void Remove(string name); } 所以，你要把这些功能存放在哪些地方呢？\n其实看到这个玩意儿 name-value，答案呼之欲出，其实现内部肯定是用的一个字典来存储数据的。\n接着我们来到了 FeatureDefinitionContextBase 的默认实现 FeatureDefinitionContextBase，然后发现里面也是别有洞天，Abp 又把字典再次封装了一遍，这次字典的名字叫做 FeatureDictionary，你只需要记住他只提供了一个作用，就是将字典内部的所有功能项与其子功能项按照平级关系存放在字典当中。\n除了内部封装了一个字典之外，在这个上下文当中，实现了创建，获取，和移除功能的方法，然后就没有了。我们再次回到功能管理器，\n功能管理器集成了这个上下文基类，集合之前 IFeatureManager 所定义的接口，它就具备了随时可以修改功能集的权力。那么这些功能是什么时候被定义的，而又是什么时候被初始化到这个字典的呢？\n在前面我们已经说过，Feature 的增加与之前文章所讲的系统设置是一样的，他们都是通过集成一个 Provider ，然后在模块预加载的时候，通过一个 IFeatureConfiguration 的东西被添加到 Abp 系统当中的。所以在 FeatureManager 内部注入了 IFeatureConfiguration 用来拿到用户在模块加载时所配置的功能项集合。\n1 2 3 4 5 6 7 public interface IFeatureConfiguration { /// \u0026lt;summary\u0026gt; /// Used to add/remove \u0026lt;see cref=\u0026#34;FeatureProvider\u0026#34;/\u0026gt;s. /// \u0026lt;/summary\u0026gt; ITypeList\u0026lt;FeatureProvider\u0026gt; Providers { get; } } 下面给你演示一下如何添加一个功能项：\n1 2 3 4 5 6 7 8 9 public class AppFeatureProvider : FeatureProvider { public override void SetFeatures(IFeatureDefinitionContext context) { var sampleBooleanFeature = context.Create(\u0026#34;SampleBooleanFeature\u0026#34;, defaultValue: \u0026#34;false\u0026#34;); sampleBooleanFeature.CreateChildFeature(\u0026#34;SampleNumericFeature\u0026#34;, defaultValue: \u0026#34;10\u0026#34;); context.Create(\u0026#34;SampleSelectionFeature\u0026#34;, defaultValue: \u0026#34;B\u0026#34;); } } 不用猜测 FeatureProvier 的实现了，他就是一个抽象类，定义了一个 SetFeatures 方法好让你实现而已。\n之后我又在模块的预加载方法吧 AppFeatureProvider 添加到了IFeatureConfiguration 里面：\n1 2 3 4 5 6 7 public class XXXModule : AbpModule { public override void PreInitialize() { Configuration.Features.Providers.Add\u0026lt;AppFeatureProvider\u0026gt;(); } } 而功能管理器则是在 Abp 核心模块 AbpKernalModule 初始化的时候，跟着权限管理器和系统设置管理器，一起被初始化了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public override void PostInitialize() { RegisterMissingComponents(); // 这里是系统的设置的管理器 IocManager.Resolve\u0026lt;SettingDefinitionManager\u0026gt;().Initialize(); // 功能管理器在这里 IocManager.Resolve\u0026lt;FeatureManager\u0026gt;().Initialize(); // 权限管理器 IocManager.Resolve\u0026lt;PermissionManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;LocalizationManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;NotificationDefinitionManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;NavigationManager\u0026gt;().Initialize(); if (Configuration.BackgroundJobs.IsJobExecutionEnabled) { var workerManager = IocManager.Resolve\u0026lt;IBackgroundWorkerManager\u0026gt;(); workerManager.Start(); workerManager.Add(IocManager.Resolve\u0026lt;IBackgroundJobManager\u0026gt;()); } } 看看功能管理器的定义就知道了：\n1 2 3 4 5 6 7 8 9 10 11 12 public void Initialize() { foreach (var providerType in _featureConfiguration.Providers) { using (var provider = CreateProvider(providerType)) { provider.Object.SetFeatures(this); } } Features.AddAllFeatures(); } 波澜不惊的我早已看透一切，可以看到这里他通过遍历注入的 FeatureProvider 集合，传入自己，让他们可以向自己注入定义的功能项。\n2.2.4 功能的存储 继续看 IFeatureChecker 的代码，最后从功能管理器拿到了功能项之后，就要根据租户的 Id 取得它具体的值了。值还能存在哪儿，除了数据库最合适放这种东西，其他的你愿意也可以存在 TXT 里面。\n1 2 3 4 5 public interface IFeatureValueStore { // 很简洁，你传入当前用户的租户 Id 与 当前需要校验的功能项，我给你他的值 Task\u0026lt;string\u0026gt; GetValueOrNullAsync(int tenantId, Feature feature); } 废话不多说，来到 Zero 关于这个功能存储类的定义 AbpFeatureValueStore\u0026lt;TTenant,TUser\u0026gt;，你先不着急看那两个泛型参数，这两个泛型就是你的用户与租户实体，我们先看看这玩意儿继承了啥东西：\n1 2 3 4 5 6 7 8 public class AbpFeatureValueStore\u0026lt;TTenant, TUser\u0026gt; : IAbpZeroFeatureValueStore, ITransientDependency, IEventHandler\u0026lt;EntityChangedEventData\u0026lt;Edition\u0026gt;\u0026gt;, IEventHandler\u0026lt;EntityChangedEventData\u0026lt;EditionFeatureSetting\u0026gt;\u0026gt; where TTenant : AbpTenant\u0026lt;TUser\u0026gt; where TUser : AbpUserBase 可以看到它首先继承了 IAbpZeroFeatureValueStore 接口，这里的 IAbpZeroFeatureValueStore 接口一样的继承的 IFeatureValueStore，所以在 Abp 底层框架能够直接使用。\n其次我们还看到它监听了两个实体变更事件，也就是 Edition 与 EditFeatureSettings 表产生变化的时候，会进入到本类进行处理，其实这里的处理就是发生改变之后，拿到改变实体的 Id，从缓存清除掉脏数据而已。\n然后我们直奔主题，找到方法的实现：\n1 2 3 4 public virtual Task\u0026lt;string\u0026gt; GetValueOrNullAsync(int tenantId, Feature feature) { return GetValueOrNullAsync(tenantId, feature.Name); } 发现又是一个空壳子，继续跳转：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public virtual async Task\u0026lt;string\u0026gt; GetValueOrNullAsync(int tenantId, string featureName) { // 首先从租户功能值表获取功能的值 var cacheItem = await GetTenantFeatureCacheItemAsync(tenantId); // 获得到值 var value = cacheItem.FeatureValues.GetOrDefault(featureName); // 不等于空，优先获取租户的值而忽略掉版本的值 if (value != null) { return value; } // 如果租户功能值表的缓存说我还有版本 Id，那么就去版本级别的功能值表查找功能的值 if (cacheItem.EditionId.HasValue) { value = await GetEditionValueOrNullAsync(cacheItem.EditionId.Value, featureName); if (value != null) { return value; } } return null; } 这才是真正的获取功能值的地方，其余方法就不再详细讲述，这两个从缓存获取的方法，都分别有一个工厂方法从数据库拿去数据的，所以你也不用担心缓存里面不存在值的情况。\n2.2.5 小结 总的来说功能是针对租户的一个权限，Abp 建议一个父母功能一般定义为 布尔功能。只有父母功能可用时，子功能才可用。ABP不强制这样做，但是建议这样做。\n在一个基于 Abp 框架的系统功能权限是可选的，具体使用还是取决于你所开发的业务系统是否有这种需求。\n2.3 权限(Permission) 2.3.1 权限的定义 权限的定义与 Feature 一样，都是存放了一些基本信息，比如说权限的唯一标识，权限的展示名称与描述，只不过少了 Feature 的附加属性而已。下面我们就会加快进度来说明一下权限相关的知识。\n2.3.2 权限检测器 权限相比于功能，权限更加细化到了用户与角色，角色通过与权限关联，角色就是一个权限组的集合，用户再跟角色进行关联。看看权限管理器的定义吧：\n1 2 3 public abstract class PermissionChecker\u0026lt;TRole, TUser\u0026gt; : IPermissionChecker, ITransientDependency, IIocManagerAccessor where TRole : AbpRole\u0026lt;TUser\u0026gt;, new() where TUser : AbpUser\u0026lt;TUser\u0026gt; 还是相对而言比较简单的，在这里你只需要关注两个东西：\n1 2 3 4 5 6 7 8 9 public virtual async Task\u0026lt;bool\u0026gt; IsGrantedAsync(string permissionName) { return AbpSession.UserId.HasValue \u0026amp;\u0026amp; await _userManager.IsGrantedAsync(AbpSession.UserId.Value, permissionName); } public virtual async Task\u0026lt;bool\u0026gt; IsGrantedAsync(long userId, string permissionName) { return await _userManager.IsGrantedAsync(userId, permissionName); } 这就是权限校验的实现，第一个是传入当前用户的 Id 扔到 _userManager 进行校验，而第二个则扔一个用户制定的 Id 进行校验。\n看到这里，我们又该到下一节了，讲解一下这个 _userManager 是何方神圣。\n2.3.3 用户管理器 如果读者接触过 ASP.NET Core MVC 的 Identity 肯定对于 UserManager\u0026lt;,\u0026gt; 不会陌生，没错，这里的 _userManager 就是继承自 UserManager\u0026lt;TUser, long\u0026gt;, 实现的 AbpUserManager\u0026lt;TRole, TUser\u0026gt;。\n继续我们还是看关键方法 IsGrantedAsync()。\n1 2 3 4 5 6 7 8 public virtual async Task\u0026lt;bool\u0026gt; IsGrantedAsync(long userId, string permissionName) { // 传入用户 ID 与需要检测的权限,通过权限管理器获得 Permission 对象 return await IsGrantedAsync( userId, _permissionManager.GetPermission(permissionName) ); } 还是个空壳子，继续跳转：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public virtual async Task\u0026lt;bool\u0026gt; IsGrantedAsync(long userId, Permission permission) { // 首先检测当前用户是否拥有租户信息 if (!permission.MultiTenancySides.HasFlag(GetCurrentMultiTenancySide())) { return false; } // 然后检测权限依赖的功能，如果功能没有启用，一样的是没权限的 if (permission.FeatureDependency != null \u0026amp;\u0026amp; GetCurrentMultiTenancySide() == MultiTenancySides.Tenant) { FeatureDependencyContext.TenantId = GetCurrentTenantId(); if (!await permission.FeatureDependency.IsSatisfiedAsync(FeatureDependencyContext)) { return false; } } // 获得当前用户所拥有的权限，没有权限一样滚蛋 var cacheItem = await GetUserPermissionCacheItemAsync(userId); if (cacheItem == null) { return false; } // 检测当前用户是否被授予了特许权限，没有的话则直接跳过，有的话说明这是个特权用户，拥有这个特殊权限 if (cacheItem.GrantedPermissions.Contains(permission.Name)) { return true; } // 检测禁用权限名单中是否拥有本权限，如果有，一样的不通过 if (cacheItem.ProhibitedPermissions.Contains(permission.Name)) { return false; } // 检测用户角色是否拥有改权限 foreach (var roleId in cacheItem.RoleIds) { if (await RoleManager.IsGrantedAsync(roleId, permission)) { return true; } } return false; } 这里我们没有讲解权限管理器与权限的注入是因为他们两个简直一毛一样好吧，你可以看看权限的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 public class MyAuthorizationProvider : AuthorizationProvider { public override void SetPermissions(IPermissionDefinitionContext context) { var administration = context.CreatePermission(\u0026#34;Administration\u0026#34;); var userManagement = administration.CreateChildPermission(\u0026#34;Administration.UserManagement\u0026#34;); userManagement.CreateChildPermission(\u0026#34;Administration.UserManagement.CreateUser\u0026#34;); var roleManagement = administration.CreateChildPermission(\u0026#34;Administration.RoleManagement\u0026#34;); } } 是不是感觉跟功能的 Provider 很像\u0026hellip;\n2.3.4 小结 权限仅仅会与用于和角色挂钩，与租户无关，它和功能的实现大同小异，但是也是值得我们借鉴学习的。\n3.多租户数据过滤 租户与租户之间是如何进行数据过滤的呢？\n这里简单讲一下单部署-单数据库的做法吧，在 EF Core 当中针对每一个实体都提供了一个全局过滤的方法 HasQueryFilter，有了这个东西，在每次 EF Core 进行查询的时候都会将查询表达式附加上你自定义的过滤器一起进行查询。\n在 Abp 内部定义了一个借口，叫做 IMustHaveTenant，这玩意儿有一个必须实现的属性 TenantId，所以只要在你的实体继承了该接口，肯定就是会有 TenantId 字段咯，那么 Abp 就可以先判断你当前的实体是否实现了 IMusHaveTenant 接口，如果有的话，就给你创建了一个过滤器拼接到你的查询表达式当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 protected override void OnModelCreating(ModelBuilder modelBuilder) { // DbContext 模型创建的时候 base.OnModelCreating(modelBuilder); // 遍历所有 DbContext 定义的实体 foreach (var entityType in modelBuilder.Model.GetEntityTypes()) { ConfigureGlobalFiltersMethodInfo .MakeGenericMethod(entityType.ClrType) .Invoke(this, new object[] { modelBuilder, entityType }); } } protected void ConfigureGlobalFilters\u0026lt;TEntity\u0026gt;(ModelBuilder modelBuilder, IMutableEntityType entityType) where TEntity : class { // 判断实体是否实现了租户或者软删除接口，实现了则添加一个过滤器 if (entityType.BaseType == null \u0026amp;\u0026amp; ShouldFilterEntity\u0026lt;TEntity\u0026gt;(entityType)) { var filterExpression = CreateFilterExpression\u0026lt;TEntity\u0026gt;(); if (filterExpression != null) { modelBuilder.Entity\u0026lt;TEntity\u0026gt;().HasQueryFilter(filterExpression); } } } // 数据过滤用的查询表达式构建 protected virtual Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; CreateFilterExpression\u0026lt;TEntity\u0026gt;() where TEntity : class { Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; expression = null; if (typeof(ISoftDelete).IsAssignableFrom(typeof(TEntity))) { /* This condition should normally be defined as below: * !IsSoftDeleteFilterEnabled || !((ISoftDelete) e).IsDeleted * But this causes a problem with EF Core (see https://github.com/aspnet/EntityFrameworkCore/issues/9502) * So, we made a workaround to make it working. It works same as above. */ Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; softDeleteFilter = e =\u0026gt; !((ISoftDelete)e).IsDeleted || ((ISoftDelete)e).IsDeleted != IsSoftDeleteFilterEnabled; expression = expression == null ? softDeleteFilter : CombineExpressions(expression, softDeleteFilter); } if (typeof(IMayHaveTenant).IsAssignableFrom(typeof(TEntity))) { /* This condition should normally be defined as below: * !IsMayHaveTenantFilterEnabled || ((IMayHaveTenant)e).TenantId == CurrentTenantId * But this causes a problem with EF Core (see https://github.com/aspnet/EntityFrameworkCore/issues/9502) * So, we made a workaround to make it working. It works same as above. */ Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; mayHaveTenantFilter = e =\u0026gt; ((IMayHaveTenant)e).TenantId == CurrentTenantId || (((IMayHaveTenant)e).TenantId == CurrentTenantId) == IsMayHaveTenantFilterEnabled; expression = expression == null ? mayHaveTenantFilter : CombineExpressions(expression, mayHaveTenantFilter); } if (typeof(IMustHaveTenant).IsAssignableFrom(typeof(TEntity))) { /* This condition should normally be defined as below: * !IsMustHaveTenantFilterEnabled || ((IMustHaveTenant)e).TenantId == CurrentTenantId * But this causes a problem with EF Core (see https://github.com/aspnet/EntityFrameworkCore/issues/9502) * So, we made a workaround to make it working. It works same as above. */ Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; mustHaveTenantFilter = e =\u0026gt; ((IMustHaveTenant)e).TenantId == CurrentTenantId || (((IMustHaveTenant)e).TenantId == CurrentTenantId) == IsMustHaveTenantFilterEnabled; expression = expression == null ? mustHaveTenantFilter : CombineExpressions(expression, mustHaveTenantFilter); } return expression; } 上面就是实现了，你每次使用 EF Core 查询某个表的实体都会应用这个过滤表达式。\n3.1 禁用过滤 但是可以看到在创建表达式的时候这里还有一些诸如 IsSoftDeleteFilterEnabled 的东西，这个就是用于你在某些时候需要禁用掉软删除过滤器的时候所需要用到的。\n看看是哪儿来的：\n1 protected virtual bool IsSoftDeleteFilterEnabled =\u0026gt; CurrentUnitOfWorkProvider?.Current?.IsFilterEnabled(AbpDataFilters.SoftDelete) == true; 可以看到这个玩意儿是使用当前的工作单元来进行控制的，检测当前工作单元的过滤器是否被启用，如果实体被打了软删除接口，并且被启用的话，那么就执行过滤，反之亦然。\n这些过滤器都是放在 AbpDataFilters 当中的，现在有以下几种定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static class AbpDataFilters { public const string SoftDelete = \u0026#34;SoftDelete\u0026#34;; public const string MustHaveTenant = \u0026#34;MustHaveTenant\u0026#34;; public const string MayHaveTenant = \u0026#34;MayHaveTenant\u0026#34;; public static class Parameters { public const string TenantId = \u0026#34;tenantId\u0026#34;; } } 而这些过滤器是在 AbpKernelModule 的预加载方法当中被添加到 UOW 的默认配置当中的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public override void PreInitialize() { // ... 其他代码 AddUnitOfWorkFilters(); // ... 其他代码 } private void AddUnitOfWorkFilters() { Configuration.UnitOfWork.RegisterFilter(AbpDataFilters.SoftDelete, true); Configuration.UnitOfWork.RegisterFilter(AbpDataFilters.MustHaveTenant, true); Configuration.UnitOfWork.RegisterFilter(AbpDataFilters.MayHaveTenant, true); } 这些东西被添加到了 IUnitOfWorkDefaultOptions 之后，每次初始化一个工作单元，其自带的 Filiters 都是从这个 IUnitOfWorkDefaultOptions 拿到的，除非用户显式指定 UowOptions 配置。\n","date":"2018-08-14T01:46:57Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-12-multi-tenant-system-and-permission-verification/","title":"Abp 源码分析：十二、多租户体系与权限验证"},{"content":"0.简介 Abp 本身集成了一套权限验证体系，通过 ASP.NET Core 的过滤器与 Castle 的拦截器进行拦截请求，并进行权限验证。在 Abp 框架内部，权限分为两块，一个是功能(Feature)，一个是权限项(Permission)，在更多的时候两者仅仅是概念不同而已，大体处理流程还是一样的。\n由于 Abp 本身是针对多租户架构进行设计的，功能是相对于租户而言，比如针对 A 租户他每月的短信发送配额为 10000 条，而针对 B 租户其配额为 5000 条，可能 C 租户该功能都没有开通。\n本篇文章仅针对基本的验证机制进行解析，后续文章会进行详解。\n0.1 验证流程图 1.启动流程 1.1 流程图 1.2 代码流程 首先在注入 Abp 框架的时候，通过注入过滤器一起将权限验证过滤器进行了注入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 internal static class AbpMvcOptionsExtensions { // ... 其他代码 private static void AddFilters(MvcOptions options) { // ... 其他注入的过滤器 options.Filters.AddService(typeof(AbpAuthorizationFilter)); // ... 其他注入的过滤器 } // ... 其他代码 } Abp 除了拦截验证 API 接口，同时也通过 Castle Windsor Interceptor 来验证普通类型的方法，来检测当前用户是否有权限进行调用。拦截器的注册则是存放在 AbpBootstrapper 对象初始化的时候，通过 AddInterceptorRegistrars() 方法注入 Abp 自带的拦截器对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private AbpBootstrapper([NotNull] Type startupModule, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) { Check.NotNull(startupModule, nameof(startupModule)); var options = new AbpBootstrapperOptions(); optionsAction?.Invoke(options); // 其他初始化代码 // 判断用户在启用 Abp 框架的是时候是否禁用了所有的拦截器 if (!options.DisableAllInterceptors) { // 初始化拦截器 AddInterceptorRegistrars(); } } private void AddInterceptorRegistrars() { // 参数验证拦截器注册 ValidationInterceptorRegistrar.Initialize(IocManager); // 审计信息记录拦截器注册 AuditingInterceptorRegistrar.Initialize(IocManager); // 实体变更追踪拦截器注册 EntityHistoryInterceptorRegistrar.Initialize(IocManager); // 工作单元拦截器注册 UnitOfWorkRegistrar.Initialize(IocManager); // 授权拦截器注册 AuthorizationInterceptorRegistrar.Initialize(IocManager); } Abp 通过注入过滤器与拦截器就能够从源头验证并控制权限校验逻辑，以上就是 Abp 在启动时所做的操作。\n2.代码分析 总体来说，Abp 针对权限的验证就是拦截+检测，整体思路即是这样，只是实现可能略微复杂，请耐心往下看。\n2.1 权限拦截器与权限过滤器 首先我们从入口点开始分析代码，在上一节我们说过 Abp 通过拦截器与过滤器来实现权限的拦截与处理，那么在其内部是如何进行处理的呢？\n其实很简单，在权限拦截器与权限过滤器的内部实现都使用了 IAuthorizationHelper 的 AuthorizeAsync() 方法来进行权限校验。\n2.1.1 权限过滤器代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 public class AbpAuthorizationFilter : IAsyncAuthorizationFilter, ITransientDependency { public ILogger Logger { get; set; } // 权限验证类，这个才是真正针对权限进行验证的对象 private readonly IAuthorizationHelper _authorizationHelper; // 异常包装器，这个玩意儿在我的《[Abp 源码分析]十、异常处理》有讲，主要是用来封装没有授权时返回的错误信息 private readonly IErrorInfoBuilder _errorInfoBuilder; // 事件总线处理器，同样在我的《[Abp 源码分析]九、事件总线》有讲，在这里用于触发一个未授权请求引发的事件，用户可以监听此事件来进行自己的处理 private readonly IEventBus _eventBus; // 构造注入 public AbpAuthorizationFilter( IAuthorizationHelper authorizationHelper, IErrorInfoBuilder errorInfoBuilder, IEventBus eventBus) { _authorizationHelper = authorizationHelper; _errorInfoBuilder = errorInfoBuilder; _eventBus = eventBus; Logger = NullLogger.Instance; } public async Task OnAuthorizationAsync(AuthorizationFilterContext context) { // 如果注入了 IAllowAnonymousFilter 过滤器则允许所有匿名请求 if (context.Filters.Any(item =\u0026gt; item is IAllowAnonymousFilter)) { return; } // 如果不是一个控制器方法则直接返回 if (!context.ActionDescriptor.IsControllerAction()) { return; } // 开始使用 IAuthorizationHelper 来进行权限校验 try { await _authorizationHelper.AuthorizeAsync( context.ActionDescriptor.GetMethodInfo(), context.ActionDescriptor.GetMethodInfo().DeclaringType ); } // 如果是未授权异常的处理逻辑 catch (AbpAuthorizationException ex) { // 记录日志 Logger.Warn(ex.ToString(), ex); // 触发异常事件 _eventBus.Trigger(this, new AbpHandledExceptionData(ex)); // 如果接口的返回类型为 ObjectResult，则采用 AjaxResponse 对象进行封装信息 if (ActionResultHelper.IsObjectResult(context.ActionDescriptor.GetMethodInfo().ReturnType)) { context.Result = new ObjectResult(new AjaxResponse(_errorInfoBuilder.BuildForException(ex), true)) { StatusCode = context.HttpContext.User.Identity.IsAuthenticated ? (int) System.Net.HttpStatusCode.Forbidden : (int) System.Net.HttpStatusCode.Unauthorized }; } else { context.Result = new ChallengeResult(); } } // 其他异常则显示为内部异常信息 catch (Exception ex) { Logger.Error(ex.ToString(), ex); _eventBus.Trigger(this, new AbpHandledExceptionData(ex)); if (ActionResultHelper.IsObjectResult(context.ActionDescriptor.GetMethodInfo().ReturnType)) { context.Result = new ObjectResult(new AjaxResponse(_errorInfoBuilder.BuildForException(ex))) { StatusCode = (int) System.Net.HttpStatusCode.InternalServerError }; } else { //TODO: How to return Error page? context.Result = new StatusCodeResult((int)System.Net.HttpStatusCode.InternalServerError); } } } } 2.1.2 权限拦截器初始化绑定 权限拦截器在 Abp 框架初始化完成的时候就开始监听了组件注册事件，只要被注入的类型实现了 AbpAuthorizeAttribute 特性与 RequiresFeatureAttribute 特性都会被注入 AuthorizationInterceptor 拦截器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 internal static class AuthorizationInterceptorRegistrar { public static void Initialize(IIocManager iocManager) { // 监听 DI 组件注册事件 iocManager.IocContainer.Kernel.ComponentRegistered += Kernel_ComponentRegistered; } private static void Kernel_ComponentRegistered(string key, IHandler handler) { // 判断注入的类型是否符合要求 if (ShouldIntercept(handler.ComponentModel.Implementation)) { // 符合要求，针对该组件添加权限拦截器 handler.ComponentModel.Interceptors.Add(new InterceptorReference(typeof(AuthorizationInterceptor))); } } private static bool ShouldIntercept(Type type) { if (SelfOrMethodsDefinesAttribute\u0026lt;AbpAuthorizeAttribute\u0026gt;(type)) { return true; } if (SelfOrMethodsDefinesAttribute\u0026lt;RequiresFeatureAttribute\u0026gt;(type)) { return true; } return false; } private static bool SelfOrMethodsDefinesAttribute\u0026lt;TAttr\u0026gt;(Type type) { // 判断传入的 Type 有定义 TAttr 类型的特性 if (type.GetTypeInfo().IsDefined(typeof(TAttr), true)) { return true; } // 或者说，该类型的所有公开的方法是否有方法标注了 TAttr 类型的特性 return type .GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) .Any(m =\u0026gt; m.IsDefined(typeof(TAttr), true)); } } 2.1.3 权限拦截器实现 Abp 框架针对权限拦截器的实现则是简单了许多，只是在被拦截的方法在执行的时候，会直接使用 IAuthorizationHelper 进行权限验证。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class AuthorizationInterceptor : IInterceptor { private readonly IAuthorizationHelper _authorizationHelper; public AuthorizationInterceptor(IAuthorizationHelper authorizationHelper) { _authorizationHelper = authorizationHelper; } public void Intercept(IInvocation invocation) { // 使用 IAuthorizationHelper 进行权限验证 _authorizationHelper.Authorize(invocation.MethodInvocationTarget, invocation.TargetType); invocation.Proceed(); } } 2.2 权限特性 在 Abp 框架里面定义了两组特性，第一个是 AbpMvcAuthorizeAttribute ，适用于 MVC 控制器，它是直接继承了 ASP .NET Core 自带的权限验证特性 AuthorizeAttribute，当控制器或者控制器内部的方法标注了该特性，就会进入之前 Abp 定义的权限过滤器 AbpAuthorizationFilter 内部。\n第二种特性则是 AbpAuthorizeAttribute ，该特性适用于应用服务层，也就是实现了 IApplicationService 接口的类型所使用的。\n它们两个的内部定义基本一样，传入一个或者多哦个具体的权限项，以便给 IAuthorizationHelper 作验证使用。\n在 Abp 框架内部，每一个权限其实就是一个字符串，比如说用户资料新增，是一个权限，那么你可以直接创建一个 \u0026quot;Administration.UserManagement.CreateUser\u0026quot; 字符作为其权限项，那么代码示例就如下：\n1 2 3 4 5 [AbpAuthorize(\u0026#34;Administration.UserManagement.CreateUser\u0026#34;)] public void CreateUser(CreateUserInput input) { // 如果用户没有 Administration.UserManagement.CreateUser 权限，则不会进入到本方法 } 下面是 AbpAuthorizeAttribute 权限特性的定义，另外一个 MVC 权限特性定义也是一样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)] public class AbpAuthorizeAttribute : Attribute, IAbpAuthorizeAttribute { // 特性拥有的权限项集合 public string[] Permissions { get; } // 用于确定是否需要验证用户是否拥有 Permission 数组内所有权限项，如果为 True 则用户需要拥有所有权限才能够操作接口，如果为 False 的话，用户只要拥有其中一个权限项则可以通过验证，默认值为：False public bool RequireAllPermissions { get; set; } public AbpAuthorizeAttribute(params string[] permissions) { Permissions = permissions; } } 权限特性一般都会打在你的控制器/应用服务层的类定义，或者方法之上，当你为你的 API 接口标注了权限特性，那么当前请求的用户没有所需要的权限，则一律会被拦截器/过滤器阻止请求。\n2.3 权限验证 当如果用户请求的方法或者控制器是标注了授权特性的话，都会通过 IAuthorizationHelper 进行验证，它一共有两个公开方法。\n1 2 3 4 5 6 7 8 public interface IAuthorizationHelper { // 判断用户是否拥有一组权限特性所标注的权限 Task AuthorizeAsync(IEnumerable\u0026lt;IAbpAuthorizeAttribute\u0026gt; authorizeAttributes); // 判断用户是否拥有，被调用的方法所标注的权限 Task AuthorizeAsync(MethodInfo methodInfo, Type type); } 在其默认的实现当中，注入了两个相对重要的组件，第一个是 IAbpSession，它是 Abp 框架定义的用户会话状态，如果当前用户处于登录状态的时候，其内部必定有值，在这里主要用于判断用户是否登录。\n第二个则是 IPermissionChecker ，它则是用于具体的检测逻辑，如果说 IAuthorizationHelper 是用来提供权限验证的工具，那么 IPermissionChecker 就是权限验证的核心，在 IPermissionChecker 内部则是真正的对传入的权限进行了验证逻辑。\nIPermissionChecker 本身只有两个方法，都返回的 bool 值，有权限则为 true 没有则为 false，其接口定义如下：\n1 2 3 4 5 6 7 8 9 // 权限检测器 public interface IPermissionChecker { // 传入一个权限项的值，判断当前用户是否拥有该权限 Task\u0026lt;bool\u0026gt; IsGrantedAsync(string permissionName); // 传入一个用户标识，判断该用户是否拥有制定的权限项 Task\u0026lt;bool\u0026gt; IsGrantedAsync(UserIdentifier user, string permissionName); } 可以看到 Abp 框架本身针对于设计来说，都考虑了各个组件的可替换性与扩展性，你可以随时通过替换 IAuthorizationHelper 或者是 IPermissionChecker 的实现来达到自己想要的效果，这点值得我们在编写代码的时候学习。\n说了这么多，下面我们来看一下 IAuthorizationHelper 的具体实现吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 public class AuthorizationHelper : IAuthorizationHelper, ITransientDependency { public IAbpSession AbpSession { get; set; } public IPermissionChecker PermissionChecker { get; set; } public IFeatureChecker FeatureChecker { get; set; } public ILocalizationManager LocalizationManager { get; set; } private readonly IFeatureChecker _featureChecker; private readonly IAuthorizationConfiguration _authConfiguration; public AuthorizationHelper(IFeatureChecker featureChecker, IAuthorizationConfiguration authConfiguration) { _featureChecker = featureChecker; _authConfiguration = authConfiguration; AbpSession = NullAbpSession.Instance; PermissionChecker = NullPermissionChecker.Instance; LocalizationManager = NullLocalizationManager.Instance; } public virtual async Task AuthorizeAsync(IEnumerable\u0026lt;IAbpAuthorizeAttribute\u0026gt; authorizeAttributes) { // 判断是否启用了授权系统，没有启用则直接跳过不做验证 if (!_authConfiguration.IsEnabled) { return; } // 如果当前的用户会话状态其 SessionId 没有值，则说明用户没有登录，抛出授权验证失败异常 if (!AbpSession.UserId.HasValue) { throw new AbpAuthorizationException( LocalizationManager.GetString(AbpConsts.LocalizationSourceName, \u0026#34;CurrentUserDidNotLoginToTheApplication\u0026#34;) ); } // 遍历所有授权特性，通过 IPermissionChecker 来验证用户是否拥有这些特性所标注的权限 foreach (var authorizeAttribute in authorizeAttributes) { await PermissionChecker.AuthorizeAsync(authorizeAttribute.RequireAllPermissions, authorizeAttribute.Permissions); } } // 授权过滤器与授权拦截器调用的方法，传入一个方法定义与方法所在的类的类型 public virtual async Task AuthorizeAsync(MethodInfo methodInfo, Type type) { // 检测产品功能 await CheckFeatures(methodInfo, type); // 检测权限 await CheckPermissions(methodInfo, type); } protected virtual async Task CheckFeatures(MethodInfo methodInfo, Type type) { var featureAttributes = ReflectionHelper.GetAttributesOfMemberAndType\u0026lt;RequiresFeatureAttribute\u0026gt;(methodInfo, type); if (featureAttributes.Count \u0026lt;= 0) { return; } foreach (var featureAttribute in featureAttributes) { // 检查当前用户是否启用了被调用方法标注上面的功能 await _featureChecker.CheckEnabledAsync(featureAttribute.RequiresAll, featureAttribute.Features); } } protected virtual async Task CheckPermissions(MethodInfo methodInfo, Type type) { // 判断是否启用了授权系统，没有启用则直接跳过不做验证 if (!_authConfiguration.IsEnabled) { return; } // 判断方法或者控制器类上是否标注了匿名访问特性，如果标注了，不做权限验证 if (AllowAnonymous(methodInfo, type)) { return; } // 获得方法和类上面定义的所有权限特性数组 var authorizeAttributes = ReflectionHelper .GetAttributesOfMemberAndType(methodInfo, type) .OfType\u0026lt;IAbpAuthorizeAttribute\u0026gt;() .ToArray(); // 如果一个都不存在，跳过验证 if (!authorizeAttributes.Any()) { return; } // 传入所有权限特性，调用另外一个重载方法，使用 IPermissionChecker 针对这些特性进行具体验证 await AuthorizeAsync(authorizeAttributes); } private static bool AllowAnonymous(MemberInfo memberInfo, Type type) { return ReflectionHelper .GetAttributesOfMemberAndType(memberInfo, type) .OfType\u0026lt;IAbpAllowAnonymousAttribute\u0026gt;() .Any(); } } 看完上面你似乎并没有看到哪儿有抛出 AbpAuthorizationException 的地方，这是因为 Abp 给 IPermissionChecker 添加了一个扩展方法，叫做 AuthorizeAsync() ，看他的具体实现你就知道，它在这个扩展方法里面才真正调用了 IPermissionChecker.IsGrantedAsync() 方法进行权限验证。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public static async Task AuthorizeAsync(this IPermissionChecker permissionChecker, bool requireAll, params string[] permissionNames) { // 这里还是调用的一个扩展方法，其内部是遍历传入的权限项集合，针对每一个权限进行检测 if (await IsGrantedAsync(permissionChecker, requireAll, permissionNames)) { return; } // 这儿呢就是本地化权限的名称，用于抛出异常的时候给前端展示用的，里面提列了你缺少的权限项有哪些 var localizedPermissionNames = LocalizePermissionNames(permissionChecker, permissionNames); if (requireAll) { throw new AbpAuthorizationException( string.Format( L( permissionChecker, \u0026#34;AllOfThesePermissionsMustBeGranted\u0026#34;, \u0026#34;Required permissions are not granted. All of these permissions must be granted: {0}\u0026#34; ), string.Join(\u0026#34;, \u0026#34;, localizedPermissionNames) ) ); } else { throw new AbpAuthorizationException( string.Format( L( permissionChecker, \u0026#34;AtLeastOneOfThesePermissionsMustBeGranted\u0026#34;, \u0026#34;Required permissions are not granted. At least one of these permissions must be granted: {0}\u0026#34; ), string.Join(\u0026#34;, \u0026#34;, localizedPermissionNames) ) ); } } 如果你感觉自己快被绕晕了，也不必惊慌\u0026hellip;因为 IPermissionChecker 本身只能针对单个权限进行检查，所以这里通过扩展了 IPermissionChecker 方法，使其能够一次检验一个集合而已。\n3.结语 本篇文章主要解析了 Abp 框架针对权限验证所做的基本操作，整体思路还是十分简单的，在 Abp 基本框架没有涉及到用户与角色的具体权限控制，这部分的内容是存放在 Abp.Zero 模块当中的，下一篇文章将会结合 Abp.Zero 来进行更加详细的讲解权限与功能的实现。\n","date":"2018-08-14T01:43:00Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-11-permission-verification/","title":"Abp 源码分析：十一、权限验证"},{"content":"0.简介 Abp 框架本身针对内部抛出异常进行了统一拦截，并且针对不同的异常也会采取不同的处理策略。在 Abp 当中主要提供了以下几种异常类型：\n异常类型 描述 AbpException Abp 框架定义的基本异常类型，Abp 所有内部定义的异常类型都继承自本类。 AbpInitializationException Abp 框架初始化时出现错误所抛出的异常。 AbpDbConcurrencyException 当 EF Core 执行数据库操作时产生了 DbUpdateConcurrencyException 异常 的时候 Abp 会封装为本异常并且抛出。 AbpValidationException 用户调用接口时，输入的DTO 参数有误会抛出本异常。 BackgroundJobException 后台作业执行过程中产生的异常。 EntityNotFoundException 当仓储执行 Get 操作时，实体未找到引发本异常。 UserFriendlyException 如果用户需要将异常信息发送给前端，请抛出本异常。 AbpRemoteCallException 远程调用一场，当使用 Abp 提供的 AbpWebApiClient 产生问题的时候 会抛出此异常。 1.启动流程 Abp 框架针对异常拦截的处理主要使用了 ASP .NET CORE MVC 过滤器机制，当外部请求接口的时候，所有异常都会被 Abp 框架捕获。Abp 异常过滤器的实现名称叫做 AbpExceptionFilter，它在注入 Abp 框架的时候就已经被注册到了 ASP .NET Core 的 MVC Filters 当中了。\n1.1 流程图 1.2 代码流程 注入 Abp 框架处：\n1 2 3 4 5 6 7 8 9 10 public static IServiceProvider AddAbp\u0026lt;TStartupModule\u0026gt;(this IServiceCollection services, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) where TStartupModule : AbpModule { var abpBootstrapper = AddAbpBootstrapper\u0026lt;TStartupModule\u0026gt;(services, optionsAction); // 配置 ASP .NET Core 参数 ConfigureAspNetCore(services, abpBootstrapper.IocManager); return WindsorRegistrationHelper.CreateServiceProvider(abpBootstrapper.IocManager.IocContainer, services); } ConfigureAspNetCore() 方法内部：\n1 2 3 4 5 6 7 8 9 10 11 12 private static void ConfigureAspNetCore(IServiceCollection services, IIocResolver iocResolver) { // ...省略掉的其他代码 // 配置 MVC services.Configure\u0026lt;MvcOptions\u0026gt;(mvcOptions =\u0026gt; { mvcOptions.AddAbp(services); }); // ...省略掉的其他代码 } AbpMvcOptionsExtensions 扩展类针对 MvcOptions 提供的扩展方法 AddAbp() ：\n1 2 3 4 5 6 7 public static void AddAbp(this MvcOptions options, IServiceCollection services) { AddConventions(options, services); // 添加 VC 过滤器 AddFilters(options); AddModelBinders(options); } AddFilters() 方法内部：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private static void AddFilters(MvcOptions options) { // 权限认证过滤器 options.Filters.AddService(typeof(AbpAuthorizationFilter)); // 审计信息过滤器 options.Filters.AddService(typeof(AbpAuditActionFilter)); // 参数验证过滤器 options.Filters.AddService(typeof(AbpValidationActionFilter)); // 工作单元过滤器 options.Filters.AddService(typeof(AbpUowActionFilter)); // 异常过滤器 options.Filters.AddService(typeof(AbpExceptionFilter)); // 接口结果过滤器 options.Filters.AddService(typeof(AbpResultFilter)); } 2.代码分析 2.1 基本定义 Abp 框架所提供的所有异常类型都继承自 AbpException ，我们可以看一下该类型的基本定义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Abp 基本异常定义 [Serializable] public class AbpException : Exception { public AbpException() { } public AbpException(SerializationInfo serializationInfo, StreamingContext context) : base(serializationInfo, context) { } // 构造函数1，接受一个异常描述信息 public AbpException(string message) : base(message) { } // 构造函数2，接受一个异常描述信息与内部异常 public AbpException(string message, Exception innerException) : base(message, innerException) { } } 类型的定义是十分简单的，基本上就是继承了原有的 Exception 类型，改了一个名字罢了。\n2.2 异常拦截 Abp 本身针对异常信息的核心处理就在于它的 AbpExceptionFilter 过滤器，过滤器实现很简单。它首先继承了 IExceptionFilter 接口，实现了其 OnException() 方法，只要用户请求接口的时候出现了任何异常都会调用 OnException() 方法。而在 OnException() 方法内部，Abp 根据不同的异常类型进行了不同的异常处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 public class AbpExceptionFilter : IExceptionFilter, ITransientDependency { // 日志记录器 public ILogger Logger { get; set; } // 事件总线 public IEventBus EventBus { get; set; } // 错误信息构建器 private readonly IErrorInfoBuilder _errorInfoBuilder; // AspNetCore 相关的配置信息 private readonly IAbpAspNetCoreConfiguration _configuration; // 注入并初始化内部成员对象 public AbpExceptionFilter(IErrorInfoBuilder errorInfoBuilder, IAbpAspNetCoreConfiguration configuration) { _errorInfoBuilder = errorInfoBuilder; _configuration = configuration; Logger = NullLogger.Instance; EventBus = NullEventBus.Instance; } // 异常触发时会调用此方法 public void OnException(ExceptionContext context) { // 判断是否由控制器触发，如果不是则不做任何处理 if (!context.ActionDescriptor.IsControllerAction()) { return; } // 获得方法的包装特性。决定后续操作,如果没有指定包装特性，则使用默认特性 var wrapResultAttribute = ReflectionHelper.GetSingleAttributeOfMemberOrDeclaringTypeOrDefault( context.ActionDescriptor.GetMethodInfo(), _configuration.DefaultWrapResultAttribute ); // 如果方法上面的包装特性要求记录日志，则记录日志 if (wrapResultAttribute.LogError) { LogHelper.LogException(Logger, context.Exception); } // 如果被调用的方法上的包装特性要求重新包装错误信息，则调用 HandleAndWrapException() 方法进行包装 if (wrapResultAttribute.WrapOnError) { HandleAndWrapException(context); } } // 处理并包装异常 private void HandleAndWrapException(ExceptionContext context) { // 判断被调用接口的返回值是否符合标准，不符合则直接返回 if (!ActionResultHelper.IsObjectResult(context.ActionDescriptor.GetMethodInfo().ReturnType)) { return; } // 设置 HTTP 上下文响应所返回的错误代码，由具体异常决定。 context.HttpContext.Response.StatusCode = GetStatusCode(context); // 重新封装响应返回的具体内容。采用 AjaxResponse 进行封装 context.Result = new ObjectResult( new AjaxResponse( _errorInfoBuilder.BuildForException(context.Exception), context.Exception is AbpAuthorizationException ) ); // 触发异常处理事件 EventBus.Trigger(this, new AbpHandledExceptionData(context.Exception)); // 处理完成，将异常上下文的内容置为空 context.Exception = null; //Handled! } // 根据不同的异常类型返回不同的 HTTP 错误码 protected virtual int GetStatusCode(ExceptionContext context) { if (context.Exception is AbpAuthorizationException) { return context.HttpContext.User.Identity.IsAuthenticated ? (int)HttpStatusCode.Forbidden : (int)HttpStatusCode.Unauthorized; } if (context.Exception is AbpValidationException) { return (int)HttpStatusCode.BadRequest; } if (context.Exception is EntityNotFoundException) { return (int)HttpStatusCode.NotFound; } return (int)HttpStatusCode.InternalServerError; } } 以上就是 Abp 针对异常处理的具体操作了，在这里面涉及到的 WrapResultAttribute 、 AjaxResponse 、 IErrorInfoBuilder 都会在后面说明，但是具体的逻辑已经在过滤器所体现了。\n2.3 接口返回值包装 Abp 针对所有 API 返回的数据都会进行一次包装，使得其返回值内容类似于下面的内容。\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;result\u0026#34;: { \u0026#34;totalCount\u0026#34;: 0, \u0026#34;items\u0026#34;: [] }, \u0026#34;targetUrl\u0026#34;: null, \u0026#34;success\u0026#34;: true, \u0026#34;error\u0026#34;: null, \u0026#34;unAuthorizedRequest\u0026#34;: false, \u0026#34;__abp\u0026#34;: true } 其中的 result 节点才是你接口真正返回的内容，其余的 targetUrl 之类的都是属于 Abp 包装器给你进行封装的。\n2.3.1 包装器特性 其中，Abp 预置的包装器有两种，第一个是 WrapResultAttribute 。它有两个 bool 类型的参数，默认均为 true ，一个叫 WrapOnSuccess 一个 叫做 WrapOnError ，分别用于确定成功或则失败后是否包装具体信息。像之前的 OnException() 方法里面就有用该值进行判断是否包装异常信息。\n除了 WarpResultAttribute 特性，还有一个 DontWrapResultAttribute 的特性，该特性直接继承自 WarpResultAttribute ，只不过它的 WrapOnSuccess 与 WrapOnError 都为 fasle 状态，也就是说无论接口调用结果是成功还是失败，都不会进行结果包装。该特性可以直接打在接口方法、控制器、接口之上，类似于这样：\n1 2 3 4 5 6 7 8 public class TestApplicationService : ApplicationService { [DontWrapResult] public async Task\u0026lt;string\u0026gt; Get() { return await Task.FromResult(\u0026#34;Hello World\u0026#34;); } } 那么这个接口的返回值就不会带有其他附加信息，而直接会按照 Json 来序列化返回你的对象。\n在拦截异常的时候，如果你没有给接口方法打上 DontWarpResult 特性，那么他就会直接使用 IAbpAspNetCoreConfiguration 的 DefaultWrapResultAttribute 属性指定的默认特性，该默认特性如果没有显式指定则为 WrapResultAttribute 。\n1 2 3 4 5 6 public AbpAspNetCoreConfiguration() { DefaultWrapResultAttribute = new WrapResultAttribute(); // ...IAbpAspNetCoreConfiguration 的默认实现的构造函数 // ...省略掉了其他代码 } 2.3.2 具体包装行为 Abp 针对正常的接口数据返回与异常数据返回都是采用的 AjaxResponse 来进行封装的，转到其基类的定义可以看到在里面定义的那几个属性就是我们接口返回出来的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public abstract class AjaxResponseBase { // 目标 Url 地址 public string TargetUrl { get; set; } // 接口调用是否成功 public bool Success { get; set; } // 当接口调用失败时，错误信息存放在此处 public ErrorInfo Error { get; set; } // 是否是未授权的请求 public bool UnAuthorizedRequest { get; set; } // 用于标识接口是否基于 Abp 框架开发 public bool __abp { get; } = true; } So，从刚才的 [2.2 节](#2.2 异常拦截) 可以看到他是直接 new 了一个 AjaxResponse 对象，然后使用 IErrorInfoBuilder 来构建了一个 ErrorInfo 错误信息对象传入到 AjaxResponse 对象当中并且返回。\n那么问题来了，这里的 IErrorInfoBuilder 是怎样来进行包装的呢？\n2.3.3 异常包装器 当 Abp 捕获到异常之后，会通过 IErrorInfoBuilder 的 BuildForException() 方法来将异常转换为 ErrorInfo 对象。它的默认实现只有一个，就是 ErrorInfoBuilder ，内部结构也很简单，其 BuildForException() 方法直接通过内部的一个转换器进行转换，也就是 IExceptionToErrorInfoConverter，直接调用的 IExceptionToErrorInfoConverter.Convert() 方法。\n同时它拥有另外一个方法，叫做 AddExceptionConverter()，可以传入你自己实现的异常转换器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class ErrorInfoBuilder : IErrorInfoBuilder, ISingletonDependency { private IExceptionToErrorInfoConverter Converter { get; set; } public ErrorInfoBuilder(IAbpWebCommonModuleConfiguration configuration, ILocalizationManager localizationManager) { // 异常包装器默认使用的 DefaultErrorInfoConverter 来进行转换 Converter = new DefaultErrorInfoConverter(configuration, localizationManager); } // 根据异常来构建异常信息 public ErrorInfo BuildForException(Exception exception) { return Converter.Convert(exception); } // 添加用户自定义的异常转换器 public void AddExceptionConverter(IExceptionToErrorInfoConverter converter) { converter.Next = Converter; Converter = converter; } } 2.3.4 异常转换器 Abp 要包装异常，具体的操作是由转换器来决定的，Abp 实现了一个默认的转换器，叫做 DefaultErrorInfoConverter，在其内部，注入了 IAbpWebCommonModuleConfiguration 配置项，而用户可以通过配置该选项的 SendAllExceptionsToClients 属性来决定是否将异常输出给客户端。\n我们先来看一下他的 Convert() 核心方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public ErrorInfo Convert(Exception exception) { // 封装 ErrorInfo 对象 var errorInfo = CreateErrorInfoWithoutCode(exception); // 如果具体的异常实现有 IHasErrorCode 接口，则将错误码也封装到 ErrorInfo 对象内部 if (exception is IHasErrorCode) { errorInfo.Code = (exception as IHasErrorCode).Code; } return errorInfo; } 核心十分简单，而 CreateErrorInfoWithoutCode() 方法内部呢也是一些具体的逻辑，根据异常类型的不同，执行不同的转换逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 private ErrorInfo CreateErrorInfoWithoutCode(Exception exception) { // 如果要发送所有异常，则使用 CreateDetailedErrorInfoFromException() 方法进行封装 if (SendAllExceptionsToClients) { return CreateDetailedErrorInfoFromException(exception); } // 如果有多个异常，并且其内部异常为 UserFriendlyException 或者 AbpValidationException 则将内部异常拿出来放在最外层进行包装 if (exception is AggregateException \u0026amp;\u0026amp; exception.InnerException != null) { var aggException = exception as AggregateException; if (aggException.InnerException is UserFriendlyException || aggException.InnerException is AbpValidationException) { exception = aggException.InnerException; } } // 如果一场类型为 UserFriendlyException 则直接通过 ErrorInfo 构造函数进行构建 if (exception is UserFriendlyException) { var userFriendlyException = exception as UserFriendlyException; return new ErrorInfo(userFriendlyException.Message, userFriendlyException.Details); } // 如果为参数类一场，则使用不同的构造函数进行构建，并且在这里可以看到他通过 L 函数调用的多语言提示 if (exception is AbpValidationException) { return new ErrorInfo(L(\u0026#34;ValidationError\u0026#34;)) { ValidationErrors = GetValidationErrorInfos(exception as AbpValidationException), Details = GetValidationErrorNarrative(exception as AbpValidationException) }; } // 如果是实体未找到的异常，则包含具体的实体类型信息与实体 ID 值 if (exception is EntityNotFoundException) { var entityNotFoundException = exception as EntityNotFoundException; if (entityNotFoundException.EntityType != null) { return new ErrorInfo( string.Format( L(\u0026#34;EntityNotFound\u0026#34;), entityNotFoundException.EntityType.Name, entityNotFoundException.Id ) ); } return new ErrorInfo( entityNotFoundException.Message ); } // 如果是未授权的一场，一样的执行不同的操作 if (exception is Abp.Authorization.AbpAuthorizationException) { var authorizationException = exception as Abp.Authorization.AbpAuthorizationException; return new ErrorInfo(authorizationException.Message); } // 除了以上这几个固定的异常需要处理之外，其他的所有异常统一返回内部服务器错误信息。 return new ErrorInfo(L(\u0026#34;InternalServerError\u0026#34;)); } 所以整体异常处理还是比较复杂的，进行了多层封装，但是结构还是十分清晰的。\n3.扩展 3.1 显示额外的异常信息 如果你需要在调用接口而产生异常的时候展示异常的详细信息，可以通过在启动模块的 PreInitialize() (预加载方法) 当中加入 Configuration.Modules.AbpWebCommon().SendAllExceptionsToClients = true; 即可，例如：\n1 2 3 4 5 6 7 8 [DependsOn(typeof(AbpAspNetCoreModule))] public class TestWebStartupModule : AbpModule { public override void PreInitialize() { Configuration.Modules.AbpWebCommon().SendAllExceptionsToClients = true; } } 3.2 监听异常事件 使用 Abp 框架的时候，你可以随时通过监听 AbpHandledExceptionData 事件来使用自己的逻辑处理产生的异常。比如说产生异常时向监控服务报警，或者说将异常信息持久化到其他数据库等等。\n你只需要编写如下代码即可实现监听异常事件：\n1 2 3 4 5 6 7 8 9 10 11 public class ExceptionEventHandler : IEventHandler\u0026lt;AbpHandledExceptionData\u0026gt;, ITransientDependency { /// \u0026lt;summary\u0026gt; /// Handler handles the event by implementing this method. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;eventData\u0026#34;\u0026gt;Event data\u0026lt;/param\u0026gt; public void HandleEvent(AbpHandledExceptionData eventData) { Console.WriteLine($\u0026#34;当前异常信息为：{eventData.Exception.Message}\u0026#34;); } } 如果你觉得看的有点吃力的话，可以跳转到 这里 了解 Abp 的事件总线实现。\n","date":"2018-08-11T08:24:07Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-10-exception-handling/","title":"Abp 源码分析：十、异常处理"},{"content":"0.背景 在实际项目当中，我们采用的是 Abp 框架，但是 Abp 框架官方并没有针对 Grpc 进行模块封装。基于此我结合 Abp 与 MagicOnion 封装了一个 Abp.Grpc 模块，它包括服务端和调用端两部分的包。通过这两个包，你可以很方便地在 Abp 框架当中集成 Grpc 实现服务内部通讯。\n但是在实际使用当中会出现一个问题，当 A 服务调用 B 服务的时候，A 服务当前登录用户为 admin，调用 B 服务的 IAbpSession 的值仍然为空，这个时候当 B 服务内部实现使用了 IAbpSession 时会出现问题。\n这是因为通过 Grpc 接口调用时，并没有传递诸如 Token 之类的东西，而在 B 服务内部的 IAbpSession 本身附加的数据是从 HttpContext 里面获取的，所以 B 服务当前是没有用户状态的。\n1.解决 所幸 IAbpSession 提供了一个 Use 方法，通过这个方法我们可以临时地改变 IAbpSession 内部的值，当 。定义如下：\n1 IDisposable Use(int? tenantId, long? userId); 使用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TestAppService : ITransientDependency { private readonly IAbpSession _abpSession; public TestAppService(IAbpSession abpSession) { _abpSession = abpSession; } public void TestMethod() { using(_abpSession.Use(10,20)) { // 其他操作 } // 出去 using 语句之后会自动释放之前的值 } } 2.Grpc 接口改造 这里 Abp.Grpc 库使用的是 MagicOnion 库实现 Grpc 接口的，底层序列化使用的是 MessagePack，速度也不比 Protocol Buffer 差。\n2.1 服务定义 服务定义接口时，必须附加一个 GrpcSession 参数，这个参数用于调用方传递其 IAbpSession 值所使用。例如我有一个接口方法如下，用于返回服务方接收到的用户 Id 值。\n1 2 3 4 5 6 7 8 public interface ITestGrpcService : IService\u0026lt;ITestGrpcService\u0026gt; { // 普通的 Grpc 接口定义 UnaryResult\u0026lt;int\u0026gt; Sum(int x, int y); // 带有 GrpcSession 的接口定义 UnaryResult\u0026lt;long?\u0026gt; TestGrpcSession(GrpcSession session); } 2.2 服务提供方 服务提供方在实现 ITestGrpcService 的时候，需要在代码起始点就开始使用 using 语句包裹代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class TestGrpcService : ServiceBase\u0026lt;ITestGrpcService\u0026gt;, ITestGrpcService { private readonly IAbpSession _abpSession; public TestGrpcService() { _abpSession = IocManager.Instance.Resolve\u0026lt;IIocManager\u0026gt;().Resolve\u0026lt;IAbpSession\u0026gt;(); } public UnaryResult\u0026lt;int\u0026gt; Sum(int x, int y) { return UnaryResult(x + y); } public UnaryResult\u0026lt;long?\u0026gt; TestGrpcSession(GrpcSession session) { // 赋值前 Session 的值 Console.WriteLine(_abpSession.UserId); // 临时改变 Session 值 using (_abpSession.Use(session.TenantId, session.UserId)) { Console.WriteLine(_abpSession.UserId); } // 离开 using 语句时 Session 的值 Console.WriteLine(_abpSession.UserId); return new UnaryResult\u0026lt;long?\u0026gt;(1000); } } 2.3 服务调用方 服务调用方则直接在调用 Grpc 接口的时候，传递给接口当前服务的 Session 状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TestApplicationService : ApplicationService { private readonly IGrpcConnectionUtility _utility; public TestApplicationService(IGrpcConnectionUtility utility) { _utility = utility; } public void TestAction() { // 获得指定的 Grpc 服务 var service = _utility.GetRemoteService\u0026lt;ITestGrpcService\u0026gt;(\u0026#34;Grpc 服务名称\u0026#34;); // 调用测试方法，传递当前调用方的 Session 值 var userId = service.TestGrpcSession(AbpSession as AbpSessionBase).GetAwaiter().GetResult(); Console.WriteLine(\u0026#34;TestGrpcSession 方法结果:\u0026#34; + userId); } } 2.4 最后的效果 当客户端调用 GRPC 接口时，会将自身的 Session 状态通过 GrpcSession 传递到服务端，这样服务端就能够共享客户端的绘画状态。\n3.Abp.Grpc 项目地址 Abp.Grpc 库地址：https://github.com/GameBelial/Abp.Grpc\n4.实现的 DEMO 地址 服务端：https://github.com/GameBelial/Abp.Grpc.Server.Demo\n客户端：https://github.com/GameBelial/Abp.Grpc.Client.Demo\n","date":"2018-08-10T08:02:39Z","permalink":"https://real-zony.github.io/p/how-abp-grpc-implements-user-session-state-transfer/","title":"Abp + Grpc 如何实现用户会话状态传递"},{"content":"0.背景 在开发项目的过程当中，生产环境与调试环境的配置肯定是不一样的。拿个最简单的例子来说，比如连接字符串这种东西，调试环境肯定是不能连接生产数据库的。在之前的话，这种情况只能说是你 COPY 两个同名的配置文件来进行处理。然后你在本地就使用本地的配置，生产环境就使用生产环境的配置文件，十分麻烦。\n而 ASP .NET CORE 支持利用环境变量来动态配置 JSON 文件，下面就来看一下吧。\n1.准备工作 首先在你的 ASP .NET CORE 项目当中添加一个 appsettings.json 文件，内容如下：\n1 2 3 4 5 { \u0026#34;ConnectionString\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Normal Database\u0026#34; } } 之后再继续添加一个 appsettings.Development.json，之后在你的解决方案管理器就会看到下面这种情况。\n更改其内容如下：\n1 2 3 4 5 { \u0026#34;ConnectionString\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Development Database\u0026#34; } } 之后呢，我们继续添加一个生产环境的配置文件，名字叫做 appsettings.Production.json ，更改其内容如下：\n1 2 3 4 5 { \u0026#34;ConnectionString\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Production Database\u0026#34; } } 最后我们的文件应该如下图：\n以上就是我们的准备工作，我们准备了两个环境的配置文件以及一个默认情况的配置文件，下面我就就来看看如何应用环境变量来达到我们想要的效果。\n2.环境控制 在项目调试的时候，我们可以通过右键项目属性，跳转到调试可以看到一个环境变量的设定，通过更改 ASPNETCORE_ENVIRONMENT 的值来切换不同环境。\n可以看到目前我们处于 Development 也就是开发环境，那么按照我们的设想，就应该读取 appsettings.Development.json 的文件数据了。\n2.编写代码 新建一个 AppConfigure 静态类，他的内部有一个字典，用于缓存不同环境不同路径的 IConfigurationRoot 配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public static class AppConfigure { // 缓存字典 private static readonly ConcurrentDictionary\u0026lt;string, IConfigurationRoot\u0026gt; _cacheDict; static AppConfigure() { _cacheDict = new ConcurrentDictionary\u0026lt;string, IConfigurationRoot\u0026gt;(); } // 传入 JSON 文件夹路径与当前的环境变量值 public static IConfigurationRoot GetConfigurationRoot(string jsonDir, string environmentName = null) { // 设置缓存的 KEY var cacheKey = $\u0026#34;{jsonDir}#{environmentName}\u0026#34;; // 添加默认的 JSON 配置 var builder = new ConfigurationBuilder().SetBasePath(jsonDir).AddJsonFile(\u0026#34;appsettings.json\u0026#34;, optional: true, reloadOnChange: true); // 根据环境变量添加相应的 JSON 配置文件 if (!string.IsNullOrEmpty(environmentName)) { builder = builder.AddJsonFile($\u0026#34;appsettings.{environmentName}.json\u0026#34;, optional: true, reloadOnChange: true); } // 返回构建成功的 IConfigurationRoot 对象 return builder.Build(); } } 用法的话也很简单：\n1 2 3 4 5 public Startup(IHostingEnvironment env) { var configurationRoot = AppConfigure.GetConfigurationRoot(env.ContentRootPath, env.EnvironmentName); Console.WriteLine(configurationRoot[\u0026#34;ConnectionString:Default\u0026#34;]); } 3.测试 测试的话直接更改环境变量就可以看到效果了，更改其值为 Production。\n现在我们来运行，并且添加一个监视变量。\n看样子它现在读取的就是我们的生产环境的数据了。\n4.代码分析 其实吧，也不用这么麻烦，在 Startup.cs 通过构造注入得到的 IConfiguration 就是按照 GetConfigurationRoot() 这个方法来进行构建的，你直接使用 Configuration/ConfigurationRoot 的索引器就可以访问到与环境变量相应的 JSON 文件了。\n可能你还不太理解，明明在 GetConfigurationRoot() 方法里面使用 AddJsonFile() 方法只是添加了两次个 Provider ，为什么在使用索引器访问 JSON 配置的时候就是使用的当前环境的 JSON 文件呢？\n我其实以为最开始 .NET CORE 对于 IConfiguration 的索引器实现就是读取了当前环境变量，然后根据这个环境变量去匹配对应的 Provider 取得值。\n最后翻阅了 .NET CORE 的源代码之后发现是我想错了，其实他就是单纯的翻转了一下 Providers 的集合，然后取的第一个元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // Copyright (c) .NET Foundation. All rights reserved. // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information. using System; using System.Collections.Generic; using System.Linq; using System.Threading; using Microsoft.Extensions.Primitives; namespace Microsoft.Extensions.Configuration { public class ConfigurationRoot : IConfigurationRoot { private IList\u0026lt;IConfigurationProvider\u0026gt; _providers; private ConfigurationReloadToken _changeToken = new ConfigurationReloadToken(); // 初始化 ConfigurationRoot 的时候传入配置提供者 public ConfigurationRoot(IList\u0026lt;IConfigurationProvider\u0026gt; providers) { if (providers == null) { throw new ArgumentNullException(nameof(providers)); } _providers = providers; foreach (var p in providers) { p.Load(); ChangeToken.OnChange(() =\u0026gt; p.GetReloadToken(), () =\u0026gt; RaiseChanged()); } } public IEnumerable\u0026lt;IConfigurationProvider\u0026gt; Providers =\u0026gt; _providers; public string this[string key] { get { // 反转 Providers ，之后遍历 foreach (var provider in _providers.Reverse()) { string value; // 如果拿到了值，直接返回，不再遍历 if (provider.TryGet(key, out value)) { return value; } } return null; } set { if (!_providers.Any()) { throw new InvalidOperationException(Resources.Error_NoSources); } foreach (var provider in _providers) { provider.Set(key, value); } } } } // ... 省略了的代码 } 回到第三节所写的代码，可以看到我们首先添加的是 appsettings.json 然后再根据环境变量添加的 $\u0026quot;appsettings.{environmentName}.json\u0026quot; ，所以反转之后取得的肯定就是带环境变量的配置文件咯。\n5.不同 OS 的环境变量配置 5.1 Windows 直接右键计算机手动添加环境变量。\n5.2 Linux 使用 export 命令直接进行环境变量设置。\n1 export ASPNETCORE_ENVIRONMEN=\u0026#39;Production\u0026#39; 5.3 Docker Docker 配置最为简单，直接在启动容器的时候加上 -e 参数即可，例如：\n1 docker run -d -e ASPNETCORE_ENVIRONMEN=Production --name testContainer testImage ","date":"2018-08-04T08:03:40Z","permalink":"https://real-zony.github.io/p/asp-.net-core-%E6%A0%B9%E6%8D%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%94%AF%E6%8C%81%E5%A4%9A%E4%B8%AA-appsettings.json/","title":"ASP .NET CORE 根据环境变量支持多个 appsettings.json"},{"content":"0.简介 事件总线就是订阅/发布模式的一种实现，本质上事件总线的存在是为了降低耦合而存在的。\n从上图可以看到事件由发布者发布到事件总线处理器当中，然后经由事件总线处理器调用订阅者的处理方法，而发布者和订阅者之间并没有耦合关系。\n像 Windows 本身的设计也是基于事件驱动，当用户点击了某个按钮，那么就会触发相应的按钮点击事件，而程序只需要监听这个按钮点击事件即可进行相应的处理，而事件被触发的时候往往都会附带相应的事件源，事件所产生的数据等。\n还是以按钮被点击为例，该事件被触发的时候会装填上触发时间，被谁触发的数据放在一个 EventArgs 内部，然后将其存放到事件处理器中，然后处理器根据事件的类型去查找订阅了该事件类型的对象，附带上事件数据去调用这些订阅者对象的处理方法。\nAbp 本身也实现了事件总线，并且在框架内部也实现了丰富的事件类型，例如实体更新事件、异常事件等等。\n注意：在下文当中处理器的含义等同于订阅者，请阅读的时候自行切换。\n0.1.使用方法 在引用了 Abp 框架的项目当中使用事件总线相当简单，只需要直接注入 IEventBus 即可触发相应的事件。如果你想要监听某个事件，并且你也想在事件被触发的时候进行处理，那么直接继承自 IEventHandler\u0026lt;TEventData\u0026gt; / IAsyncEventHandler\u0026lt;TEventData\u0026gt; 实现其接口方法 HandleEvent() 即可。\n比如说，我们首先定义了一个 TestEventData 的事件，如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// \u0026lt;summary\u0026gt; /// 测试事件 /// \u0026lt;/summary\u0026gt; public class TestEventData : EventData { public TestEventData(string code) { Code = code; } /// \u0026lt;summary\u0026gt; /// 待验证的编码 /// \u0026lt;/summary\u0026gt; public string Code { get; } } 很简单，这个事件触发的时候会传递一个 string 类型的 Code 参数。\n之后我们使用 TestEventHandler 订阅这个事件，当然订阅的方式很简单，实现接口即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class TestEventHandler : IAsyncEventHandler\u0026lt;TestEventData\u0026gt;, IEventHandler\u0026lt;TestEventData\u0026gt; { public Task HandleEventAsync(TestEventData eventData) { if (eventData.Code == \u0026#34;1\u0026#34;) Console.WriteLine(\u0026#34;# 异步测试，编码正确\u0026#34;); Console.WriteLine(\u0026#34;# 异步测试，编码错误\u0026#34;); return Task.FromResult(0); } public void HandleEvent(TestEventData eventData) { if (eventData.Code == \u0026#34;1\u0026#34;) Console.WriteLine(\u0026#34;# 同步测试，编码正确\u0026#34;); Console.WriteLine(\u0026#34;# 同步测试，编码错误\u0026#34;); } } Abp 在底层会扫描实现了 IEventHandler\u0026lt;TEventData\u0026gt; / IAsyncEventHandler\u0026lt;TEventData\u0026gt; 这两个接口的类型，将其自动注册为订阅者。\n当然你也可以手动订阅：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class TestAppService : ApplicationService { private readonly IEventBus _eventBus; public TestAppService(IEventBus eventBus) { _eventBus = eventBus; } public async Task TestMethod() { // 同步触发 _eventBus.Trigger(new TestEventData(\u0026#34;Code1\u0026#34;)); // 异步触发，3.6.x 版本新增的 await _eventBus.TriggerAsync(new TestEventData(\u0026#34;Code1\u0026#34;)); // 手动注册事件范例 _eventBus.Register\u0026lt;TestEventData, TestEventHandler\u0026gt;(); } } 这里的 Register() 方法会让你传入一个事件数据类型，以及该事件对应的处理器。\n同一个事件可以被多个对象所订阅，只要该对象实现 IEventHandler\u0026lt;TEventData\u0026gt; / IAsyncEventHandler\u0026lt;TEventData\u0026gt; 接口或者是显式地被 IEventBus.Register() 注册，他们都会在事件被触发的时候调用。\n2.启动流程 按照惯例我们来分析一下 Abp 针对事件总线的实现，看一下它的整体启动流程，什么时候被注入，被初始化。\n事件总线比起其他 Abp 基础设施来说他的注册点就一个，在 EventBusInstaller 里面，包含了针对 IEventBus 的注册以及对实现了 IEventHandler 处理器的注册。 EventBusInstaller 在 Abp 框架的核心模块 AbpKernelModule 的 Initialize 被注册调用：\n1 2 3 4 5 6 7 8 public override void Initialize() { // ...其他代码 IocManager.IocContainer.Install(new EventBusInstaller(IocManager)); // ... 其他代码 } 里面的 Install() 方法做了两个动作，第一是根据事件总线配置来决定 IEventBus 的注册方式，第二则是将订阅者(事件处理器)通过 IEventBus.Register() 方法自动放到事件总线管理器里面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public void Install(IWindsorContainer container, IConfigurationStore store) { // 这里是注入的配置类 if (_eventBusConfiguration.UseDefaultEventBus) { container.Register( Component.For\u0026lt;IEventBus\u0026gt;().UsingFactoryMethod(() =\u0026gt; EventBus.Default).LifestyleSingleton() ); } else { container.Register( Component.For\u0026lt;IEventBus\u0026gt;().ImplementedBy\u0026lt;EventBus\u0026gt;().LifestyleSingleton() ); } // 解析事件总线管理器 _eventBus = container.Resolve\u0026lt;IEventBus\u0026gt;(); // 注册订阅者对象 container.Kernel.ComponentRegistered += Kernel_ComponentRegistered; } Emmmm，具体的代码分析请看下面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private void Kernel_ComponentRegistered(string key, IHandler handler) { // 判断当前注入的对象是否实现了 IEventHandler 接口，没有实现则跳过 if (!typeof(IEventHandler).GetTypeInfo().IsAssignableFrom(handler.ComponentModel.Implementation)) { return; } // 获得当前注入对象实现的所有接口 var interfaces = handler.ComponentModel.Implementation.GetTypeInfo().GetInterfaces(); // 遍历获取到的所有接口 foreach (var @interface in interfaces) { // 如果当前被遍历的接口类型不是 IEventHandler 或者不是从 IEventHandler 继承的，则跳过 if (!typeof(IEventHandler).GetTypeInfo().IsAssignableFrom(@interface)) { continue; } // 到这里获取这个 IEventHandler 处理器的泛型参数 var genericArgs = @interface.GetGenericArguments(); // 并且它的泛型参数应该只有一个 if (genericArgs.Length == 1) { // 根据 IEventHandler 的定义，拿到的泛型参数肯定就是事件数据类型啦 // 第二个参数就是一个 Handler 的工厂咯，每次触发事件的时候都会从这个 // 工厂解析出具体的事件处理器来响应事件的操作。 _eventBus.Register(genericArgs[0], new IocHandlerFactory(_iocResolver, handler.ComponentModel.Implementation)); } } } 目前看来还是十分简单的。\n3.代码分析 3.1 事件总线管理器 整个事件总线的核心就是这个管理器(IEventBus/EventBus)，事件的注册，事件的触发，所有这些东西都是由它来提供的，其实嘛事件总线没你想象得那么复杂。\n它的基本原理很简单，就是用户向事件总线管理器注册我想要触发的事件，还有响应我事件的订阅者，将其放在一个字典里面。当 A 对象在数据库 断开连接 的时候，通过事件总线管理器触发 断开连接事件，事件总线管理器就会从之前注册的字典，根据触发时候传递的类型拿到响应的处理器集合，遍历这个集合调用对应的方法。\n说这么多，我们来看一下代码吧，首先看看事件总线管理器的定义（当然接口太多，这里是精简过的）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public interface IEventBus { // 注册并订阅事件 IDisposable Register(Type eventType, IEventHandlerFactory factory); // 这里没有异步注册的原因是它最后还是会调用上面这个方法 // 取消事件的订阅，这里传入的是一个 Action void Unregister\u0026lt;TEventData\u0026gt;(Action\u0026lt;TEventData\u0026gt; action) where TEventData : IEventData; // 这里传入的是一个 IEventHandler void Unregister\u0026lt;TEventData\u0026gt;(IEventHandler\u0026lt;TEventData\u0026gt; handler) where TEventData : IEventData; // 异步取消事件订阅 void AsyncUnregister\u0026lt;TEventData\u0026gt;(Func\u0026lt;TEventData, Task\u0026gt; action) where TEventData : IEventData; // 同样是取消事件订阅 void Unregister(Type eventType, IEventHandler handler); void Unregister(Type eventType, IEventHandlerFactory factory); void UnregisterAll(Type eventType); // 触发事件 void Trigger(Type eventType, object eventSource, IEventData eventData); // 异步触发事件 Task TriggerAsync(Type eventType, object eventSource, IEventData eventData); } Emm，看了一下，大概就分为三类，注册事件、取消事件的订阅、触发事件，其他定义的接口大多都是不同形式的重载，本质上还是会调用到上述方法的。\n首先在事件总线管理器内部有一个字典，这个字典就是我们刚才所提到的事件总线维护的事件字典，大概长这个样子：\n1 private readonly ConcurrentDictionary\u0026lt;Type, List\u0026lt;IEventHandlerFactory\u0026gt;\u0026gt; _handlerFactories; 可以看到，这个字典的 Key 是一个 Type 类型，其实就是我们所注册的事件类型罢了，后面那个呢就是事件处理器的工厂。那为什么这个工厂会用一个 List 来存储呢？\n原因有两点：\n因为我们对应的事件处理器的生命周期与生成方式都有所不同，比如说 Abp 它自己本身就提供了IocHandlerFactory、TransientEventHandlerFactory、SingleInstanceHandlerFactory 这三种实现。 因为一个事件可能会被多个处理器所订阅，那么一个处理器拥有一个工厂，所以会是一个集合。 3.1.1 注册事件 在默认的 Register() 方法里面就是使用的 IocHandlerFactory 来进行注册事件的，如果你需要手动注册事件呢，可以使用签名为：\n1 public IDisposable Register(Type eventType, IEventHandlerFactory factory); 的方法，来传入自己实现的处理器工厂或者是 Abp 提供的事件处理器工厂。\n看了它的定义之后，我们来看一下它的具体实现，首先来看看注册事件的 Register() 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public IDisposable Register(Type eventType, IEventHandlerFactory factory) { // 获得指定事件类型的工厂集合，然后往这个集合添加一个事件处理器工厂 GetOrCreateHandlerFactories(eventType) .Locking(factories =\u0026gt; factories.Add(factory)); // Emm，这里面就是一个 Dispose 方法，用于释放创建好的工厂对象，里面的 Dispose 方法 // 最终会调用 IEventBus 的 UnRegister 方法来卸载工厂 return new FactoryUnregistrar(this, eventType, factory); } private List\u0026lt;IEventHandlerFactory\u0026gt; GetOrCreateHandlerFactories(Type eventType) { // 根据事件类型创建/获取一个事件处理器工厂集合 return _handlerFactories.GetOrAdd(eventType, (type) =\u0026gt; new List\u0026lt;IEventHandlerFactory\u0026gt;()); } 可以看到调用了注册方法之后，它返回了一个 FactoryUnregistrar ，查看它的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 internal class FactoryUnregistrar : IDisposable { private readonly IEventBus _eventBus; private readonly Type _eventType; private readonly IEventHandlerFactory _factory; public FactoryUnregistrar(IEventBus eventBus, Type eventType, IEventHandlerFactory factory) { _eventBus = eventBus; _eventType = eventType; _factory = factory; } public void Dispose() { _eventBus.Unregister(_eventType, _factory); } } 很简单的一个类，重点就是在 Dispose() 内部调用了 IEventBus 的 Unregister() 方法，下面就会讲解这东西。\n3.1.2 取消事件的订阅 接着是 UnRegister() 方法，UnRegister 方法有很多个，一般分为两类，第一是取消订阅，第二就是卸载工厂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public void Unregister\u0026lt;TEventData\u0026gt;(Action\u0026lt;TEventData\u0026gt; action) where TEventData : IEventData { // 确保不为空 Check.NotNull(action, nameof(action)); // 根据类型得到该类型所有的事件处理器集合 GetOrCreateHandlerFactories(typeof(TEventData)) // 使用 lock 加锁，防止线程同步问题 .Locking(factories =\u0026gt; { // 调用 List 的 RemoveAll() 方法清除指定条件的工厂 factories.RemoveAll( factory =\u0026gt; { // 判断工厂是否为单例工厂 var singleInstanceFactory = factory as SingleInstanceHandlerFactory; // 如果不是单例工厂则不移除 if (singleInstanceFactory == null) { return false; } // 如果是单例工厂，拿到其内部的具体事件处理器，并强制换为 ActionEventHandler var actionHandler = singleInstanceFactory.HandlerInstance as ActionEventHandler\u0026lt;TEventData\u0026gt;; // 为空的话，不移除 if (actionHandler == null) { return false; } // 判断传入的处理逻辑是否与事件处理器逻辑相等，相等则移除 return actionHandler.Action == action; }); }); } // 取消订阅的另一种实现，只是针对 SingleInstanceHandlerFactory 进行了处理 public void Unregister(Type eventType, IEventHandler handler) { GetOrCreateHandlerFactories(eventType) .Locking(factories =\u0026gt; { factories.RemoveAll( factory =\u0026gt; factory is SingleInstanceHandlerFactory \u0026amp;\u0026amp; (factory as SingleInstanceHandlerFactory).HandlerInstance == handler ); }); } // 第二种情况，卸载工厂，也就是 Register() 之后返回的 FactoryUnregistrar 释放时调用的方法 public void Unregister(Type eventType, IEventHandlerFactory factory) { // 根据传入的类型，获得事件处理器工厂集合，移除相应工厂 GetOrCreateHandlerFactories(eventType).Locking(factories =\u0026gt; factories.Remove(factory)); } 在上方代码可以看到，似乎 Unregister() 方法只针对 SingleInstanceHandlerFactory 工厂进行了处理，而没有处理 IocHandlerFactory 与 TransientEventHandlerFactory 。\n这是因为在 IEventBus 当中实现了这两个方法：\n1 2 IDisposable Register(Type eventType, IEventHandler handler); IDisposable Register\u0026lt;TEventData\u0026gt;(Action\u0026lt;TEventData\u0026gt; action) where TEventData : IEventData; 可以看到这两个方法都没有传入工厂，第一个允许你传入一个事件处理器对象，第二个则是让你传入一个 Action 作为其事件订阅者。\n看看实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public IDisposable Register\u0026lt;TEventData\u0026gt;(Action\u0026lt;TEventData\u0026gt; action) where TEventData : IEventData { // new 了一个 ActionEventHandler 作为处理器 return Register(typeof(TEventData), new ActionEventHandler\u0026lt;TEventData\u0026gt;(action)); } public IDisposable Register\u0026lt;TEventData\u0026gt;(IEventHandler\u0026lt;TEventData\u0026gt; handler) where TEventData : IEventData { // 传入具体的处理器对象进行注册 return Register(typeof(TEventData), handler); } public IDisposable Register(Type eventType, IEventHandler handler) { // 使用 SingleInstanceHandlerFactory 工厂进行注册。 return Register(eventType, new SingleInstanceHandlerFactory(handler)); } 因为单例工厂与其他两个工厂不一样，单例工厂的生命周期贯穿整个程序的生命周期，也就是说除非程序被结束，那么单例工厂内部的事件处理器就会一直存在，所以在 UnRegister() 方法内部只会针对 SingleInstanceHandlerFactory 工厂进行处理。\nTransientEventHandlerFactory 。\nIocHandlerFactory 工厂产生的对象的生命周期是随着具体类型在被注入时候的生命周期所决定，有可能是瞬时对象，也有可能是单例对象，下文会详细解说。\n3.1.3 触发事件 当事件的发布者需要发布(触发)一个事件的时候，会调用 IEventBus 提供的 Trigger()/TriggerAsync() 方法。\n然后事件总线管理器从自己的字典内匹配对应的事件，得到对应的事件处理器工厂集合，然后呢使用工厂产生具体的处理器对象，调用其 HandleEvent / HandleEventAsync 方法，执行完成之后释放对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 public void Trigger(Type eventType, object eventSource, IEventData eventData) { // 异常集合 var exceptions = new List\u0026lt;Exception\u0026gt;(); eventData.EventSource = eventSource; // 获得所有需要触发的处理器工厂，遍历传入的事件类型以及他的子类事件 foreach (var handlerFactories in GetHandlerFactories(eventType)) { // 遍历事件类型绑定的工厂集合 foreach (var handlerFactory in handlerFactories.EventHandlerFactories) { // 获得处理器类型 var handlerType = handlerFactory.GetHandlerType(); // 如果是异步处理器，以同步方式运行 if (IsAsyncEventHandler(handlerType)) { AsyncHelper.RunSync(() =\u0026gt; TriggerAsyncHandlingException(handlerFactory, handlerFactories.EventType, eventData, exceptions)); } else if (IsEventHandler(handlerType)) { // 调用处理器的处理方法，并回收异常信息 TriggerHandlingException(handlerFactory, handlerFactories.EventType, eventData, exceptions); } else { // 说明这个事件没有对应的处理器实现，抛出异常 var message = $\u0026#34;Event handler to register for event type {eventType.Name} does not implement IEventHandler\u0026lt;{eventType.Name}\u0026gt; or IAsyncEventHandler\u0026lt;{eventType.Name}\u0026gt; interface!\u0026#34;; exceptions.Add(new AbpException(message)); } } } // 处理继承事件的情况 if (eventType.GetTypeInfo().IsGenericType \u0026amp;\u0026amp; eventType.GetGenericArguments().Length == 1 \u0026amp;\u0026amp; typeof(IEventDataWithInheritableGenericArgument).IsAssignableFrom(eventType)) { var genericArg = eventType.GetGenericArguments()[0]; var baseArg = genericArg.GetTypeInfo().BaseType; if (baseArg != null) { var baseEventType = eventType.GetGenericTypeDefinition().MakeGenericType(baseArg); var constructorArgs = ((IEventDataWithInheritableGenericArgument)eventData).GetConstructorArgs(); var baseEventData = (IEventData)Activator.CreateInstance(baseEventType, constructorArgs); baseEventData.EventTime = eventData.EventTime; Trigger(baseEventType, eventData.EventSource, baseEventData); } } if (exceptions.Any()) { // 如果产生的异常数量为 1 个的话，重新抛出具体的异常信息 if (exceptions.Count == 1) { exceptions[0].ReThrow(); } // 如果在执行过程中产生了多个异常，将异常集合放在内部异常当中并抛出 throw new AggregateException(\u0026#34;More than one error has occurred while triggering the event: \u0026#34; + eventType, exceptions); } } // 筛选所有需要触发的事件类型，并将其封装为 EventTypeWithEventHandlerFactories private IEnumerable\u0026lt;EventTypeWithEventHandlerFactories\u0026gt; GetHandlerFactories(Type eventType) { var handlerFactoryList = new List\u0026lt;EventTypeWithEventHandlerFactories\u0026gt;(); foreach (var handlerFactory in _handlerFactories.Where(hf =\u0026gt; ShouldTriggerEventForHandler(eventType, hf.Key))) { handlerFactoryList.Add(new EventTypeWithEventHandlerFactories(handlerFactory.Key, handlerFactory.Value)); } return handlerFactoryList.ToArray(); } // 判断传入的类型是否是事件类型的子类 private static bool ShouldTriggerEventForHandler(Type eventType, Type handlerType) { if (handlerType == eventType) { return true; } if (handlerType.IsAssignableFrom(eventType)) { return true; } return false; } // 拿着具体的处理器工厂去执行处理器的处理方法 private void TriggerHandlingException(IEventHandlerFactory handlerFactory, Type eventType, IEventData eventData, List\u0026lt;Exception\u0026gt; exceptions) { // 获得一个新鲜的处理器对象 var eventHandler = handlerFactory.GetHandler(); try { if (eventHandler == null) { throw new ArgumentNullException($\u0026#34;Registered event handler for event type {eventType.Name} is null!\u0026#34;); } var handlerType = typeof(IEventHandler\u0026lt;\u0026gt;).MakeGenericType(eventType); // 从这个处理器获取到处理方法 var method = handlerType.GetMethod( \u0026#34;HandleEvent\u0026#34;, new[] { eventType } ); // 调用处理方法，并传入事件数据 method.Invoke(eventHandler, new object[] { eventData }); } // 产生异常进行处理 catch (TargetInvocationException ex) { exceptions.Add(ex.InnerException); } catch (Exception ex) { exceptions.Add(ex); } finally { // 释放资源 handlerFactory.ReleaseHandler(eventHandler); } } 3.2 处理器工厂 所有事件所对应的处理器对象都是由工厂所创建的，当一个事件被触发，事件总线管理器就会从事件类型所对应的工厂产生一个相应的处理器对象执行调用。\n简而言之，每个事件处理器都拥有一个单独的工厂。\n其接口定义如下：\n1 2 3 4 5 6 7 8 9 10 11 public interface IEventHandlerFactory { // 获得一个事件处理器对象 IEventHandler GetHandler(); // 获得当前工厂所产生的处理器类型 Type GetHandlerType(); // 释放指定的处理器对象 void ReleaseHandler(IEventHandler handler); } 具体实现 生命周期 描述 TransientEventHandlerFactory 瞬时 工厂产生的事件处理器生命周期是瞬时的，是一个标准 的可以被 GC 回收的对象。 SingleInstanceHandlerFactory 单例 该工厂产生的对象都会被保存在一个 Instance 内部，每 次生成对象的时候都会使用该 Instance 的值。 IocHandlerFactory 由类型注册时决定 在使用 IocHandlerFactory 的时候，会传入事件处理 器，该工厂在创建事件处理器对象的时候会从 Ioc 容器当中 解析对应的对象出来，而该对象的生命周期取决于注册时 的定义。 4.扩展 4.1 实体更新事件 Abp 在仓储每次执行 CRUD 操作的时候都会自动触发响应的实体更新事件，这些事件的触发都存放在 EntityChangeEventHelper 类当中，一共有以下几个事件，你订阅该这些事件之后就会在实体产生更改的时候被触发。\nEntityChangedEventData\u0026lt;TEntity\u0026gt; 实体被更改的时候触发。 EntityCreatedEventData\u0026lt;TEntity\u0026gt; 实体创建完成后触发。 EntityCreatingEventData\u0026lt;TEntity\u0026gt; 实体创建时被触发。 EntityDeletedEventData\u0026lt;TEntity\u0026gt; 实体删除完成后触发。 EntityDeletingEventData\u0026lt;TEntity\u0026gt; 实体删除时被触发。 EntityUpdatedEventData\u0026lt;TEntity\u0026gt; 实体更新后触发。 EntityUpdatingEventData\u0026lt;TEntity\u0026gt; 实体更新时被触发。 1 2 3 4 5 6 7 public class TestHandler : IEventHandler\u0026lt;EntityChangedEventData\u0026lt;TestEntity\u0026gt;\u0026gt; { public void HandleEvent(EntityChangedEventData\u0026lt;TestEntity\u0026gt; eventData) { Console.WriteLine($\u0026#34;测试实体，ID为 {eventDate.Entity.Id} 被更改了\u0026#34;); } } 4.2 异常事件 Abp 在运行期间遇到的异常也会自动触发异常事件，其类型为 AbpHandledExceptionData 与 ExceptionData。\n","date":"2018-08-03T04:05:49Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-9-event-bus/","title":"Abp 源码分析：九、事件总线"},{"content":"0.简介 缓存在一个业务系统中十分重要，常用的场景就是用来储存调用频率较高的数据。Abp 也提供了一套缓存机制供用户使用，在使用 Abp 框架的时候可以通过注入 ICacheManager 来新建/设置缓存。\n同时 Abp 框架也提供了 Redis 版本的 ICacheManager 实现，你也可以很方便的将现有的内存缓存替换为 Redis 缓存。\n0.1 典型使用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class TestAppService : ApplicationService { private readonly ICacheManager _cacheMgr; private readonly IRepository\u0026lt;TestEntity\u0026gt; _rep; // 注入缓存管理器与测试实体的仓储 public TestAppService(ICacheManager cacheMgr, IRepository\u0026lt;TestEntity\u0026gt; rep) { _cacheMgr = cacheMgr; _rep = rep; } public void TestMethod() { // 获取/创建一个新的缓存 var cache = _cacheMgr.GetCache(\u0026#34;缓存1\u0026#34;); // 转换为强类型的缓存 var typedCache = cache.AsTyped\u0026lt;int, string\u0026gt;(); // 获取缓存的数据，如果存在则直接返回。 // 如果不存在则执行工厂方法，将其值存放到 // 缓存项当中，最后返回缓存项数据。 var cacheValue = typedCache.Get(10, id =\u0026gt; _rep.Get(id).Name); Console.WriteLine(cacheValue); } } 1.启动流程 同其他的基础设施一样，缓存管理器 ICacheManager 在 Abp 框架启动的时候就自动被注入到了 Ioc 容器当中，因为他的基类 CacheManagerBase 继承了 ISingletonDependency 接口。\n1 2 3 4 public abstract class CacheManagerBase : ICacheManager, ISingletonDependency { // ... 其他代码 } 其次就是他的 ICachingConfiguration 缓存配置是在 AbpCoreInstaller 注入到 Ioc 容器，并且同其他基础设施的配置一起被集成到了 IAbpStartupConfiguration 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 internal class AbpCoreInstaller : IWindsorInstaller { public void Install(IWindsorContainer container, IConfigurationStore store) { container.Register( // 其他被注入的基础设施配置 Component.For\u0026lt;ICachingConfiguration, CachingConfiguration\u0026gt;().ImplementedBy\u0026lt;CachingConfiguration\u0026gt;().LifestyleSingleton() // 其他被注入的基础设施配置 ); } } 你可以在其他模块的 PreInitialize() 方法里面可以直接通过 Configuration.Caching 来配置缓存过期时间等功能。\n1 2 3 4 public override void PreInitialize() { Configuration.Caching.ConfigureAll(z=\u0026gt;z.DefaultSlidingExpireTime = TimeSpan.FromHours(1)); } 2. 代码分析 缓存这块可能是 Abp 框架实现当中最简单的一部分了，代码量不多，但是设计思路还是值得借鉴的。\n2.1 缓存管理器 2.1.1 基本定义 缓存管理器即 ICacheManager ，通常它用于管理所有缓存，他的接口定义十分简单，就两个方法：\n1 2 3 4 5 6 7 8 public interface ICacheManager : IDisposable { // 获得所有缓存 IReadOnlyList\u0026lt;ICache\u0026gt; GetAllCaches(); // 根据缓存名称获取缓存 [NotNull] ICache GetCache([NotNull] string name); } 2.1.2 获取/创建缓存 Abp 实现了一个抽象基类 CacheBase 实现了本接口，在 CacheBase 内部维护了一个 ConcurrentDictionary\u0026lt;string,ICache\u0026gt; 字典，这个字典里面就是存放的所有缓存。\n同时在他的 GetCache(string name) 内部呢，通过传入的缓存名字来从字典获取已经存在的缓存，如果不存在呢，执行其工厂方法来创建一个新的缓存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public virtual ICache GetCache(string name) { Check.NotNull(name, nameof(name)); // 从字典根据名称取得缓存，不存在则使用工厂方法 return Caches.GetOrAdd(name, (cacheName) =\u0026gt; { // 得到创建成功的缓存 var cache = CreateCacheImplementation(cacheName); // 遍历缓存配置集合，查看当前名字的缓存是否存在配置项 var configurators = Configuration.Configurators.Where(c =\u0026gt; c.CacheName == null || c.CacheName == cacheName); // 遍历这些配置项执行配置操作，更改缓存的过期时间等参数 foreach (var configurator in configurators) { configurator.InitAction?.Invoke(cache); } // 返回配置完成的缓存 return cache; }); } // 真正创建缓存的方法 protected abstract ICache CreateCacheImplementation(string name); 这里的 CreateCacheImplementation()由具体的缓存管理器实现的缓存创建方法，因为 Redis 与 MemoryCache 的实现各不一样，所以这里定义了一个抽象方法。\n2.1.3 缓存管理器销毁 当缓存管理器被销毁的时候，首先是遍历字典内存储的所有缓存，并通过 IIocManager.Release() 方法来释放这些缓存，之后则是调用字典的 Clear() 方法清空字典。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public virtual void Dispose() { DisposeCaches(); // 清空字典 Caches.Clear(); } // 遍历字典，释放对象 protected virtual void DisposeCaches() { foreach (var cache in Caches) { IocManager.Release(cache.Value); } } 2.1.4 内存缓存管理器 Abp 对于缓存管理器的默认实现是 AbpMemoryCacheManager ，其实没多复杂，就是实现了基类的 CreateCacheImplementation() 返回特定的 ICache 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class AbpMemoryCacheManager : CacheManagerBase { // ... 忽略了的代码 protected override ICache CreateCacheImplementation(string name) { // 就 new 一个新的内存缓存而已，内存缓存的实现请看后面的 // 这里是因为 AbpMemory 没有注入到 IOC 容器，所以需要手动 new return new AbpMemoryCache(name) { Logger = Logger }; } // 重写了基类的缓存释放方法 protected override void DisposeCaches() { foreach (var cache in Caches.Values) { cache.Dispose(); } } } 2.1.5 Redis 缓存管理器 如果要使用 Redis 缓存管理器，根据模块的加载顺序，你需要在启动模块的 PreInitialize() 调用 Abp.Redis 库提供的集成方法即可。\n这里先来看看他的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class AbpRedisCacheManager : CacheManagerBase { public AbpRedisCacheManager(IIocManager iocManager, ICachingConfiguration configuration) : base(iocManager, configuration) { // 注册 Redis 缓存 IocManager.RegisterIfNot\u0026lt;AbpRedisCache\u0026gt;(DependencyLifeStyle.Transient); } protected override ICache CreateCacheImplementation(string name) { // 解析已经注入的 Redis 缓存 // 这里可以看到解析的时候如何传入构造参数 return IocManager.Resolve\u0026lt;AbpRedisCache\u0026gt;(new { name }); } } 一样的，非常简单，没什么可以说的。\n2.2 缓存 我们从缓存管理器当中拿到具体的缓存之后才能够进行真正的缓存操作，这里需要明确的一个概念是缓存是一个缓存项的集合，缓存项里面的值才是我们真正缓存的结果。\n就如同一个用户表，他拥有多条用户数据，那么我们要针对这个用户表做缓存，就会创建一个缓存名称叫做 \u0026ldquo;用户表\u0026rdquo; 的缓存，在需要获得用户数据的时候，我们拿去数据就直接从这个 \u0026ldquo;用户表\u0026rdquo; 缓存当中取得具体的缓存项，也就是具体的用户数据。\n其实每个缓存项也是几个 键值对 ，键就是缓存的键，以上面的 \u0026ldquo;用户表缓存\u0026rdquo; 为例子，那么他缓存项的键就是 int 型的 Id ，他的值呢就是一个用户实体。\n2.2.1 基本定义 所有缓存的定义都在 ICache 当中，每个缓存都拥有增删查改这些基本操作，并且还拥有过期时间与名称等属性。\n同样，缓存也有一个抽象基类的实现，名字叫做 CacheBase 。与缓存管理器的抽象基类一样，CacheBase 内部仅实现了 Get 方法的基本逻辑，其他的都是抽象方法，需要由具体的类型进行实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public interface ICache : IDisposable { // 缓存名称 string Name { get; } // 相对过期时间 TimeSpan DefaultSlidingExpireTime { get; set; } // 绝对过期时间 TimeSpan? DefaultAbsoluteExpireTime { get; set; } // 根据缓存项 Key 获取到缓存的数据,不存在则执行工厂方法 object Get(string key, Func\u0026lt;string, object\u0026gt; factory); // Get 的异步实现 Task\u0026lt;object\u0026gt; GetAsync(string key, Func\u0026lt;string, Task\u0026lt;object\u0026gt;\u0026gt; factory); // 根据缓存项 Key 获取到缓存的数据，没有则返回默认值，一般为 null object GetOrDefault(string key); // GetOrDefault 的异步实现 Task\u0026lt;object\u0026gt; GetOrDefaultAsync(string key); // 设置缓存项值和过期时间等参数 void Set(string key, object value, TimeSpan? slidingExpireTime = null, TimeSpan? absoluteExpireTime = null); // Set 的异步实现 Task SetAsync(string key, object value, TimeSpan? slidingExpireTime = null, TimeSpan? absoluteExpireTime = null); // 移除指定缓存名称的缓存项 void Remove(string key); // Remove 的异步实现 Task RemoveAsync(string key); // 清空缓存内所有缓存项 void Clear(); // Clear 的异步实现 Task ClearAsync(); } 2.2.2 内存缓存的实现 这里我们以 Abp 的默认 MemoryCache 实现为例子来看看里面是什么构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class AbpMemoryCache : CacheBase { private MemoryCache _memoryCache; // 初始化 MemoryCahce public AbpMemoryCache(string name) : base(name) { _memoryCache = new MemoryCache(new OptionsWrapper\u0026lt;MemoryCacheOptions\u0026gt;(new MemoryCacheOptions())); } // 从 MemoryCahce 取得缓存 public override object GetOrDefault(string key) { return _memoryCache.Get(key); } // 设置缓存 public override void Set(string key, object value, TimeSpan? slidingExpireTime = null, TimeSpan? absoluteExpireTime = null) { // 值为空的时候抛出异常 if (value == null) { throw new AbpException(\u0026#34;Can not insert null values to the cache!\u0026#34;); } if (absoluteExpireTime != null) { _memoryCache.Set(key, value, DateTimeOffset.Now.Add(absoluteExpireTime.Value)); } else if (slidingExpireTime != null) { _memoryCache.Set(key, value, slidingExpireTime.Value); } else if (DefaultAbsoluteExpireTime != null) { _memoryCache.Set(key, value, DateTimeOffset.Now.Add(DefaultAbsoluteExpireTime.Value)); } else { _memoryCache.Set(key, value, DefaultSlidingExpireTime); } } // 删除缓存 public override void Remove(string key) { _memoryCache.Remove(key); } // 清空缓存 public override void Clear() { _memoryCache.Dispose(); _memoryCache = new MemoryCache(new OptionsWrapper\u0026lt;MemoryCacheOptions\u0026gt;(new MemoryCacheOptions())); } public override void Dispose() { _memoryCache.Dispose(); base.Dispose(); } } 可以看到在 AbpMemoryCache 内部就是将 MemoryCahce 进行了一个二次包装而已。\n其实可以看到这些缓存超期时间之类的参数 Abp 自己并没有用到，而是将其传递给具体的缓存实现来进行管理。\n2.2.3 Redis 缓存的实现 Abp.Redis 库使用的是 StackExchange.Redis 库来实现对 Redis 的通讯的，其实现为 AbpRedisCache ，里面也没什么好说的，如同内存缓存一样，实现那些抽象方法就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class AbpRedisCache : CacheBase { private readonly IDatabase _database; private readonly IRedisCacheSerializer _serializer; public AbpRedisCache( string name, IAbpRedisCacheDatabaseProvider redisCacheDatabaseProvider, IRedisCacheSerializer redisCacheSerializer) : base(name) { _database = redisCacheDatabaseProvider.GetDatabase(); _serializer = redisCacheSerializer; } // 获取缓存 public override object GetOrDefault(string key) { var objbyte = _database.StringGet(GetLocalizedKey(key)); return objbyte.HasValue ? Deserialize(objbyte) : null; } public override void Set(string key, object value, TimeSpan? slidingExpireTime = null, TimeSpan? absoluteExpireTime = null) { if (value == null) { throw new AbpException(\u0026#34;Can not insert null values to the cache!\u0026#34;); } //TODO: 这里是一个解决实体序列化的方法. //TODO: 通常实体不应该存储在缓存当中，目前 Abp.Zero 包是这样来进行处理的，这个问题将会在未来被修正. var type = value.GetType(); if (EntityHelper.IsEntity(type) \u0026amp;\u0026amp; type.GetAssembly().FullName.Contains(\u0026#34;EntityFrameworkDynamicProxies\u0026#34;)) { type = type.GetTypeInfo().BaseType; } _database.StringSet( GetLocalizedKey(key), Serialize(value, type), absoluteExpireTime ?? slidingExpireTime ?? DefaultAbsoluteExpireTime ?? DefaultSlidingExpireTime ); } // 移除缓存 public override void Remove(string key) { _database.KeyDelete(GetLocalizedKey(key)); } // 清空缓存 public override void Clear() { _database.KeyDeleteWithPrefix(GetLocalizedKey(\u0026#34;*\u0026#34;)); } // 序列化对象 protected virtual string Serialize(object value, Type type) { return _serializer.Serialize(value, type); } // 反序列化对象 protected virtual object Deserialize(RedisValue objbyte) { return _serializer.Deserialize(objbyte); } // 获得缓存的 Key protected virtual string GetLocalizedKey(string key) { return \u0026#34;n:\u0026#34; + Name + \u0026#34;,c:\u0026#34; + key; } } 2.3 缓存配置 缓存配置的作用就是可以为每个缓存配置不同的过期时间，我们最开始说过 Abp 是通过 ICachingConfiguration 来配置缓存的，在这个接口里面呢定义了这样几个东西。\n1 2 3 4 5 6 7 8 9 10 11 public interface ICachingConfiguration { // 配置项集合 IReadOnlyList\u0026lt;ICacheConfigurator\u0026gt; Configurators { get; } // 配置所有缓存 void ConfigureAll(Action\u0026lt;ICache\u0026gt; initAction); // 配置指定名称的缓存 void Configure(string cacheName, Action\u0026lt;ICache\u0026gt; initAction); } Emmmm，可以看到他有个 Configurators 属性存了一大堆 ICacheConfigurator ，这个玩意儿呢就是对应到具体缓存的配置项了。\n1 2 3 4 5 6 7 8 public interface ICacheConfigurator { // 关联的缓存名称 string CacheName { get; } // 缓存初始化的时候执行的配置操作 Action\u0026lt;ICache\u0026gt; InitAction { get; } } 这玩意儿的实现也没什么好看的，跟接口差不多，这下我们知道了缓存的配置呢就是存放在 Configurators 里面的。\n然后呢，就在我们最开始的地方，缓存管理器创建缓存的时候不是根据名字去遍历这个 Configurators 集合么，在那里面就直接通过这个 ICacheConfigurator 的 Action\u0026lt;ICache\u0026gt; 来配置缓存的超期时间。\n至于 Configure() 和 ConfigureAll() 方法嘛，前者就是根据你传入的缓存名称初始化一个 CacheConfigurator ，然后扔到那个列表里面去。\n1 2 3 4 5 6 private readonly List\u0026lt;ICacheConfigurator\u0026gt; _configurators; public void Configure(string cacheName, Action\u0026lt;ICache\u0026gt; initAction) { _configurators.Add(new CacheConfigurator(cacheName, initAction)); } 后者的话则是添加了一个没有名字的 CacheConfigurator ，正因为没有名字，所以他的 cacheName 肯定 null，也就是在缓存管理器创建缓存的时候如果该缓存没有对应的配置，那么就会使用这个名字为空的 CacheConfigurator 了。\n2.4 强类型缓存 在最开始的使用方法里面可以看到我们通过 AsType\u0026lt;TKey,TValue\u0026gt;() 方法将 ICache 对象转换为 ITypedCache ，这样我们就无需再将缓存项手动进行强制类型转换。\n注：虽然这里是指定了泛型操作，但是呢，在其内部实现还是进行的强制类型转换，也是会发生装/拆箱操作的。\nAbp 自己则通过 TypedCacheWrapper\u0026lt;TKey, TValue\u0026gt; 来将原有的 ICache 缓存包装为 ITypedCache\u0026lt;TKey, TValue\u0026gt;。\n看看这个扩展方法的定义，他是放在 CacheExtensions 里面的：\n1 2 3 4 public static ITypedCache\u0026lt;TKey, TValue\u0026gt; AsTyped\u0026lt;TKey, TValue\u0026gt;(this ICache cache) { return new TypedCacheWrapper\u0026lt;TKey, TValue\u0026gt;(cache); } Emmm，这里是 new 了一个 TypedCacheWrapper 来处理的，从方法定义可以看出来 TypedCacheWrapper 是 ITypedCache 的一个默认实现。\nITypedCache\u0026lt;TKey,TValue\u0026gt; 拥有 ICache 的所有方法签名，所以使用 ITypedCache\u0026lt;TKey,TValue\u0026gt; 与使用 ICache 的方式是一样的。\nTypedCacheWrapper 的各种方法其实就是调用的传入的 ICache 对象的方法，只不过在返回值得时候他自己进行了强制类型转换而已，比如说，看看他的 Get 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class TypedCacheWrapper\u0026lt;TKey, TValue\u0026gt; : ITypedCache\u0026lt;TKey, TValue\u0026gt; { // 返回的是内部 ICache 的名称 public string Name { get { return InternalCache.Name; } } public TimeSpan DefaultSlidingExpireTime { get { return InternalCache.DefaultSlidingExpireTime; } set { InternalCache.DefaultSlidingExpireTime = value; } } public TimeSpan? DefaultAbsoluteExpireTime { get { return InternalCache.DefaultAbsoluteExpireTime; } set { InternalCache.DefaultAbsoluteExpireTime = value; } } // 调用 AsTyped() 方法时候传入的 ICache 对象 public ICache InternalCache { get; private set; } public TypedCacheWrapper(ICache internalCache) { InternalCache = internalCache; } // 调用的是一个 ICache 的扩展方法 public TValue Get(TKey key, Func\u0026lt;TKey, TValue\u0026gt; factory) { return InternalCache.Get(key, factory); } // ..... 忽略了其他方法 } 看看 InternalCache.Get(key, factory); 这个扩展方法的定义吧：\n1 2 3 4 5 public static TValue Get\u0026lt;TKey, TValue\u0026gt;(this ICache cache, TKey key, Func\u0026lt;TKey, TValue\u0026gt; factory) { // 本质上就是调用的 ICache 的 Get 方法，返回的时候进行了强制类型转换而已 return (TValue)cache.Get(key.ToString(), (k) =\u0026gt; (object)factory(key)); } ","date":"2018-07-27T07:35:17Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-8-cache-management/","title":"Abp 源码分析：八、缓存管理"},{"content":"0.简介 Abp 框架在其内部实现了仓储模式，并且支持 EF Core 与 Dapper 来进行数据库连接与管理，你可以很方便地通过注入通用仓储来操作你的数据，而不需要你自己来为每一个实体定义单独的仓储的实现，通用仓储包含了常用的 CRUD 接口和一些常用方法。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class TestAppService : ITransientDependency { private readonly IRepository\u0026lt;TestTable\u0026gt; _rep; // 注入通用仓储 public TestAppService(IRepository\u0026lt;TestTable\u0026gt; rep) { _rep = rep; } public void TestMethod() { // 插入一条新数据 _rep.Insert(new TestTable{ Name = \u0026#34;TestName\u0026#34; }); } } 1.通用仓储定义与实现 在 Abp 内部，仓储的基本定义存放在 Abp 项目的 Domain/Repositories 内部，包括以下几个文件：\n文件名称 作用描述 AbpRepositoryBase.cs 仓储基类 AutoRepositoryTypesAttribute.cs 自动构建仓储，用于实体标记 IRepository.cs 仓储基本接口定义 IRepositoryOfTEntity.cs 仓储接口定义，默认主键为 int 类型 IRepositoryOfTEntityAndTPrimaryKey.cs 仓储接口定义，主键与实体类型由用户定义 ISupportsExplicitLoading.cs 显式加载 RepositoryExtensions.cs 仓储相关的扩展方法 1.1 通用仓储定义 综上所述，仓储的基础定义是由 IRepository 决定的，这个接口没什么其他用处，就如同 ITransientDependency 接口与 ISingletonDependency 一样，只是做一个标识作用。\n真正定义了仓储接口的是在 IRepositoryOfTEntityAndTPrimaryKey\u0026lt;TEntity, TPrimaryKey\u0026gt; 内部，他的接口定义如下：\n1 2 3 4 public interface IRepository\u0026lt;TEntity, TPrimaryKey\u0026gt; : IRepository where TEntity : class, IEntity\u0026lt;TPrimaryKey\u0026gt; { // CRUD 方法 } 可以看到，他有两个泛型参数，第一个是实体类型，第二个是实体的主键类型，并且约束了 TEntity 必须实现了 IEntity\u0026lt;TPrimaryKey\u0026gt; 接口，这是因为在仓储接口内部的一些方法需要得到实体的主键才能够操作，比如修改与查询方法。\n在 Abp 内部还有另外一个仓储的定义，叫做 IRepository\u0026lt;TEntity\u0026gt; ，这个接口就是默认你的主键类型为 int类型，一般很少使用 IRepository\u0026lt;TEntity, TPrimaryKey\u0026gt; 更多的还是用的 IRepository\u0026lt;TEntity\u0026gt;。\n1.2 通用仓储的实现 在 Abp 库里面，有一个默认的抽象基类实现了仓储接口，这个基类内部主要注入了 IUnitOfWorkManager 用来控制事务，还有 IIocResolver 用来解析 Ioc 容器内部注册的组件。\n本身在这个抽象仓储类里面没有什么实质性的东西，它只是之前 IRepository\u0026lt;TEntity\u0026gt; 的简单实现，在 EfCoreRepositoryBase 类当中则才是具体调用 EF Core API 的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class EfCoreRepositoryBase\u0026lt;TDbContext, TEntity, TPrimaryKey\u0026gt; : AbpRepositoryBase\u0026lt;TEntity, TPrimaryKey\u0026gt;, ISupportsExplicitLoading\u0026lt;TEntity, TPrimaryKey\u0026gt;, IRepositoryWithDbContext where TEntity : class, IEntity\u0026lt;TPrimaryKey\u0026gt; where TDbContext : DbContext { /// \u0026lt;summary\u0026gt; /// 获得数据库上下文 /// \u0026lt;/summary\u0026gt; public virtual TDbContext Context =\u0026gt; _dbContextProvider.GetDbContext(MultiTenancySide); /// \u0026lt;summary\u0026gt; /// 具体的实体表 /// \u0026lt;/summary\u0026gt; public virtual DbSet\u0026lt;TEntity\u0026gt; Table =\u0026gt; Context.Set\u0026lt;TEntity\u0026gt;(); // 数据库事务 public virtual DbTransaction Transaction { get { return (DbTransaction) TransactionProvider?.GetActiveTransaction(new ActiveTransactionProviderArgs { {\u0026#34;ContextType\u0026#34;, typeof(TDbContext) }, {\u0026#34;MultiTenancySide\u0026#34;, MultiTenancySide } }); } } // 数据库连接 public virtual DbConnection Connection { get { var connection = Context.Database.GetDbConnection(); if (connection.State != ConnectionState.Open) { connection.Open(); } return connection; } } // 事务提供器，用于获取已经激活的事务 public IActiveTransactionProvider TransactionProvider { private get; set; } private readonly IDbContextProvider\u0026lt;TDbContext\u0026gt; _dbContextProvider; /// \u0026lt;summary\u0026gt; /// 构造函数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;dbContextProvider\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public EfCoreRepositoryBase(IDbContextProvider\u0026lt;TDbContext\u0026gt; dbContextProvider) { _dbContextProvider = dbContextProvider; } } 其实从上方就可以看出来，Abp 对于每一个仓储都会重新打开一个数据库链接，在 EfCoreRepositoryBase 里面的 CRUD 方法实际上都是针对 DbContext 来进行的操作。\n举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 插入数据 public override TEntity Insert(TEntity entity) { return Table.Add(entity).Entity; } // 更新数据 public override TEntity Update(TEntity entity) { AttachIfNot(entity); Context.Entry(entity).State = EntityState.Modified; return entity; } // 附加实体状态 protected virtual void AttachIfNot(TEntity entity) { var entry = Context.ChangeTracker.Entries().FirstOrDefault(ent =\u0026gt; ent.Entity == entity); if (entry != null) { return; } Table.Attach(entity); } 这里需要注意的是 Update() 方法，之前遇到过一个问题，假如我传入了一个实体，它的 ID 是不存在的，那么我将这个实体传入 Update() 方法之后执行 SaveChanges() 的时候，会抛出 DbUpdateConcurrencyException 异常。\n正确的操作是先使用实体的 ID 去查询数据库是否存在该条记录，存在再执行 Update() 操作。\n这里 AttachIfNot 作用是将实体附加到追踪上下文当中，如果你之前是通过 Get() 方法获取实体之后更改了某个实体，那么在调用 Context.ChangeTracker.Entries() 方法的时候会获取到已经发生变动的身体对象集合。\n1.3 通用仓储的注入 仓储的注入操作发生在 AbpEntityFrameworkCoreModule 模块执行 Initialize() 方法的时候，在 Initialize() 方法内部调用了 RegisterGenericRepositoriesAndMatchDbContexes() 方法，其定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 private void RegisterGenericRepositoriesAndMatchDbContexes() { // 查找所有数据库上下文 var dbContextTypes = _typeFinder.Find(type =\u0026gt; { var typeInfo = type.GetTypeInfo(); return typeInfo.IsPublic \u0026amp;\u0026amp; !typeInfo.IsAbstract \u0026amp;\u0026amp; typeInfo.IsClass \u0026amp;\u0026amp; typeof(AbpDbContext).IsAssignableFrom(type); }); if (dbContextTypes.IsNullOrEmpty()) { Logger.Warn(\u0026#34;No class found derived from AbpDbContext.\u0026#34;); return; } using (IScopedIocResolver scope = IocManager.CreateScope()) { // 遍历数据库上下文 foreach (var dbContextType in dbContextTypes) { Logger.Debug(\u0026#34;Registering DbContext: \u0026#34; + dbContextType.AssemblyQualifiedName); // 为数据库上下文每个实体注册仓储 scope.Resolve\u0026lt;IEfGenericRepositoryRegistrar\u0026gt;().RegisterForDbContext(dbContextType, IocManager, EfCoreAutoRepositoryTypes.Default); // 为自定义的 DbContext 注册仓储 IocManager.IocContainer.Register( Component.For\u0026lt;ISecondaryOrmRegistrar\u0026gt;() .Named(Guid.NewGuid().ToString(\u0026#34;N\u0026#34;)) .Instance(new EfCoreBasedSecondaryOrmRegistrar(dbContextType, scope.Resolve\u0026lt;IDbContextEntityFinder\u0026gt;())) .LifestyleTransient() ); } scope.Resolve\u0026lt;IDbContextTypeMatcher\u0026gt;().Populate(dbContextTypes); } } 方法很简单，注释已经说的很清楚了，就是遍历实体，通过 EfGenericRepositoryRegistrar 与 EfCoreBasedSecondaryOrmRegistrar 来注册仓储。\n来看一下具体的注册操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 private void RegisterForDbContext( Type dbContextType, IIocManager iocManager, Type repositoryInterface, Type repositoryInterfaceWithPrimaryKey, Type repositoryImplementation, Type repositoryImplementationWithPrimaryKey) { foreach (var entityTypeInfo in _dbContextEntityFinder.GetEntityTypeInfos(dbContextType)) { // 获取主键类型 var primaryKeyType = EntityHelper.GetPrimaryKeyType(entityTypeInfo.EntityType); if (primaryKeyType == typeof(int)) { // 建立仓储的封闭类型 var genericRepositoryType = repositoryInterface.MakeGenericType(entityTypeInfo.EntityType); if (!iocManager.IsRegistered(genericRepositoryType)) { // 构建具体的仓储实现类型 var implType = repositoryImplementation.GetGenericArguments().Length == 1 ? repositoryImplementation.MakeGenericType(entityTypeInfo.EntityType) : repositoryImplementation.MakeGenericType(entityTypeInfo.DeclaringType, entityTypeInfo.EntityType); // 注入 iocManager.IocContainer.Register( Component .For(genericRepositoryType) .ImplementedBy(implType) .Named(Guid.NewGuid().ToString(\u0026#34;N\u0026#34;)) .LifestyleTransient() ); } } // 如果主键类型为 int 之外的类型 var genericRepositoryTypeWithPrimaryKey = repositoryInterfaceWithPrimaryKey.MakeGenericType(entityTypeInfo.EntityType,primaryKeyType); if (!iocManager.IsRegistered(genericRepositoryTypeWithPrimaryKey)) { // 操作跟上面一样 var implType = repositoryImplementationWithPrimaryKey.GetGenericArguments().Length == 2 ? repositoryImplementationWithPrimaryKey.MakeGenericType(entityTypeInfo.EntityType, primaryKeyType) : repositoryImplementationWithPrimaryKey.MakeGenericType(entityTypeInfo.DeclaringType, entityTypeInfo.EntityType, primaryKeyType); iocManager.IocContainer.Register( Component .For(genericRepositoryTypeWithPrimaryKey) .ImplementedBy(implType) .Named(Guid.NewGuid().ToString(\u0026#34;N\u0026#34;)) .LifestyleTransient() ); } } } 这里 RegisterForDbContext() 方法传入的这些开放类型其实是通过 EfCoreAutoRepositoryTypes.Default 属性指定，其定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static class EfCoreAutoRepositoryTypes { public static AutoRepositoryTypesAttribute Default { get; } static EfCoreAutoRepositoryTypes() { Default = new AutoRepositoryTypesAttribute( typeof(IRepository\u0026lt;\u0026gt;), typeof(IRepository\u0026lt;,\u0026gt;), typeof(EfCoreRepositoryBase\u0026lt;,\u0026gt;), typeof(EfCoreRepositoryBase\u0026lt;,,\u0026gt;) ); } } 1.4 自定义仓储 当你觉得 Abp 所提供的通用仓储无法满足你的需求，你可以通过自定义仓储来操作。在 Abp 中,仓储类要实现 IRepository 接口。最好的方式是针对不同仓储对象定义各自不同的接口。\n针对 Person 实体的仓储接口声明的示例如下所示：\n1 2 3 4 public interface IPersonRepository : IRepository\u0026lt;Person\u0026gt; { void CustomMethod(Person input); } IPersonRepository 继承自 IRepository，用来定义 Id 的类型为 int(Int32) 的实体。如果你的实体 Id 数据类型不是 int ,你可以继承 IRepository 接口，如下所示:\n1 2 3 4 public interface IPersonRepository : IRepository\u0026lt;Person, long\u0026gt; { void CustomMethod(Person input); } 2.Entity Framework Core 2.1 工作单元 在之前的文章里面说过，Abp 本身只实现了一个抽象工作单元基类 UnitOfWorkBase ，而具体的事务处理是存放在具体的持久化模块里面进行实现的，在 EF Core 这里则是通过 EfCoreUnitOfWork 实现的。\n首先看一下 EfCoreUnitOfWork 注入了哪些东西：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class EfCoreUnitOfWork : UnitOfWorkBase, ITransientDependency { protected IDictionary\u0026lt;string, DbContext\u0026gt; ActiveDbContexts { get; } protected IIocResolver IocResolver { get; } private readonly IDbContextResolver _dbContextResolver; private readonly IDbContextTypeMatcher _dbContextTypeMatcher; private readonly IEfCoreTransactionStrategy _transactionStrategy; /// \u0026lt;summary\u0026gt; /// 创建一个新的 EF UOW 对象 /// \u0026lt;/summary\u0026gt; public EfCoreUnitOfWork( IIocResolver iocResolver, IConnectionStringResolver connectionStringResolver, IUnitOfWorkFilterExecuter filterExecuter, IDbContextResolver dbContextResolver, IUnitOfWorkDefaultOptions defaultOptions, IDbContextTypeMatcher dbContextTypeMatcher, IEfCoreTransactionStrategy transactionStrategy) : base( connectionStringResolver, defaultOptions, filterExecuter) { IocResolver = iocResolver; _dbContextResolver = dbContextResolver; _dbContextTypeMatcher = dbContextTypeMatcher; _transactionStrategy = transactionStrategy; ActiveDbContexts = new Dictionary\u0026lt;string, DbContext\u0026gt;(); } } emmm，他注入的基本上都是与 EfCore 有关的东西。\n第一个字典是存放处在激活状态的 DbContext 集合，第二个是 IIocResolver 用于解析组件所需要的解析器，第三个是数据库上下文的解析器用于创建 DbContext 的，第四个是用于查找 DbContext 的 Matcher，最后一个就是用于 EF Core 事物处理的东东。\n根据 UnitOfWork 的调用顺序，首先看查看 BeginUow() 方法：\n1 2 3 4 if (Options.IsTransactional == true) { _transactionStrategy.InitOptions(Options); } 没什么特殊操作，就拿着 UOW 对象的 Options 去初始化事物策略。\n之后按照 UOW 的调用顺序(PS：如果看的一头雾水可以去看一下之前文章针对 UOW 的讲解)，会调用基类的 CompleteAsync() 方法，在其内部则是会调用 EF Core UOW 实现的 CompleteUowAsync() 方法，其定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 protected override async Task CompleteUowAsync() { // 保存所有 DbContext 的更改 await SaveChangesAsync(); // 提交事务 CommitTransaction(); } public override async Task SaveChangesAsync() { foreach (var dbContext in GetAllActiveDbContexts()) { await SaveChangesInDbContextAsync(dbContext); } } private void CommitTransaction() { if (Options.IsTransactional == true) { _transactionStrategy.Commit(); } } 内部很简单，两句话，第一句话遍历所有激活的 DbContext ，然后调用其 SaveChanges() 提交更改到数据库当中。\n之后呢，第二句话就是使用 DbContext 的 dbContext.Database.CommitTransaction(); 方法来提交一个事务咯。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void Commit() { foreach (var activeTransaction in ActiveTransactions.Values) { activeTransaction.DbContextTransaction.Commit(); foreach (var dbContext in activeTransaction.AttendedDbContexts) { if (dbContext.HasRelationalTransactionManager()) { continue; //Relational databases use the shared transaction } dbContext.Database.CommitTransaction(); } } } 2.2 数据库上下文提供器 这个玩意儿的定义如下：\n1 2 3 4 5 6 7 public interface IDbContextProvider\u0026lt;out TDbContext\u0026gt; where TDbContext : DbContext { TDbContext GetDbContext(); TDbContext GetDbContext(MultiTenancySides? multiTenancySide ); } 很简单的作用，获取指定类型的数据库上下文，他的标准实现是 UnitOfWorkDbContextProvider\u0026lt;TDbContext\u0026gt;，它依赖于 UOW ，使用 UOW 的 GetDbContext\u0026lt;TDbContext\u0026gt;() 方法来取得数据库上下文。\n整个关系如下：\n1 2 3 4 5 6 7 8 9 10 11 st1=\u0026gt;start: IDbContextProvider\u0026lt;TDbContext\u0026gt;：GetDbContext() op1=\u0026gt;operation: UnitOfWorkExtensions：GetDbContext\u0026lt;TDbContext\u0026gt;() op2=\u0026gt;operation: EfCoreUnitOfWork：GetOrCreateDbContext\u0026lt;TDbContext\u0026gt;() pd1=\u0026gt;condition: 工作单元是否是事务性的 op3=\u0026gt;operation: DbContextEfCoreTransactionStrategy：CreateDbContext\u0026lt;TDbContext\u0026gt;(); op4=\u0026gt;operation: IDbContextResolver：Resolve\u0026lt;TDbContext\u0026gt;() e=\u0026gt;end: end st1-\u0026gt;op1-\u0026gt;op2-\u0026gt;pd1 pd1(yes)-\u0026gt;op3-\u0026gt;e pd1(no)-\u0026gt;op4-\u0026gt;e 2.3 多数据库支持 在 Abp 内部针对多数据库支持是通过覆写 IConnectionStringResolver 来实现的，这个操作在之前的文章里面已经讲过，这里仅讲解它如何在 Abp 内部实现解析的。\nIConnectionStringResolver 是在 EF 的 Uow 才会用到，也就是创建 DbContext 的时候：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public virtual TDbContext GetOrCreateDbContext\u0026lt;TDbContext\u0026gt;(MultiTenancySides? multiTenancySide = null) where TDbContext : DbContext { var concreteDbContextType = _dbContextTypeMatcher.GetConcreteType(typeof(TDbContext)); var connectionStringResolveArgs = new ConnectionStringResolveArgs(multiTenancySide); connectionStringResolveArgs[\u0026#34;DbContextType\u0026#34;] = typeof(TDbContext); connectionStringResolveArgs[\u0026#34;DbContextConcreteType\u0026#34;] = concreteDbContextType; // 这里调用了 Resolver var connectionString = ResolveConnectionString(connectionStringResolveArgs); // 创建 DbContext dbContext = _transactionStrategy.CreateDbContext\u0026lt;TDbContext\u0026gt;(connectionString, _dbContextResolver); return (TDbContext)dbContext; } // 传入了 ConnectionStringResolveArgs 里面包含了实体类型信息哦 protected virtual string ResolveConnectionString(ConnectionStringResolveArgs args) { return ConnectionStringResolver.GetNameOrConnectionString(args); } 他这里的默认实现叫做 DefaultConnectionStringResolver ，就是从 IAbpStartupConfiguration 里面拿去用户在启动模块配置的 DefaultNameOrConnectionString 字段作为自己的默认数据库连接字符串。\n在之前的 文章 的思路也是通过传入的 ConnectionStringResolveArgs 参数来判断传入的 Type，从而来根据不同的 DbContext 返回不同的连接串。\n","date":"2018-07-24T05:46:22Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-7-implementation-of-work-unit/","title":"Abp 源码分析：七、工作单元的实现"},{"content":"0.简要介绍 0.1 思路说明 AliDDNSNet 是基于 .NET Core 开发的动态 DNS 解析工具，借助于阿里云的 DNS API 来实现域名与动态 IP 的绑定功能。工具核心就是调用了阿里云 DNS 的两个 API ，一个 API 获取指定域名的所有解析记录，然后通过比对与当前公网 IP 是否一致，一致则不进行更改，不一致则通过另外一个修改 API 来修改指定子域名的修改记录。\n0.2 使用说明 使用时请更改同目录下的 settings.json.example 为 settings.json 文件，同时也可以显示通过 -f 参数来制定配置文件路径。例如：\n1 2 dotnet ./AliDDNSNet.dll -f ./settings.json2 ./AliDDNSNet -f ./settings.json3 NAS 运行效果图：\n0.3.配置说明 通过更改 settings.json/settings.json.example 的内容来实现 DDNS 更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { // 阿里云的 Access Id \u0026#34;access_id\u0026#34;: \u0026#34;\u0026#34;, // 阿里云的 Access Key \u0026#34;access_key\u0026#34;: \u0026#34;\u0026#34;, // TTL 时间 \u0026#34;interval\u0026#34;: 600, // 主域名 \u0026#34;domain\u0026#34;: \u0026#34;example.com\u0026#34;, // 子域名前缀 \u0026#34;sub_domain\u0026#34;: \u0026#34;test\u0026#34;, // 记录类型 \u0026#34;type\u0026#34;: \u0026#34;A\u0026#34; } 其中 Access Id 与 Access Key 可以登录阿里云之后在右上角可以得到。\n1.代码说明 1.1 主程序流程 主要流程代码在 Program.cs 文件当中编写，这里依次讲解一下。\n首先加载配置文件，如果用户传入了 -f 参数，则使用用户传入的配置文件路径，否则的话直接使用当前目录的默认 settings.json 配置文件，读取成功之后存放到 Utils.config 属性当中以便 Utils 使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 加载配置文件： var filePath = attachments.HasValue() ? attachments.Value() : $\u0026#34;{Environment.CurrentDirectory}{Path.DirectorySeparatorChar}settings.json\u0026#34;; if (!File.Exists(filePath)) { Console.WriteLine(\u0026#34;当前目录没有配置文件，或者配置文件位置不正确。\u0026#34;); return -1; } var config = await Utils.ReadConfigFile(filePath); Utils.config = config; 之后通过 Utils.GetCurentPublicIP() 方法获取到当前设备的公网 IP，再判断指定的二级域名解析是否存在，如果不存在的话，则直接返回，这里并没有做新增解析操作，后续版本可能会加上。\n1 2 3 4 5 6 7 8 9 // 获得当前 IP var currentIP = (await Utils.GetCurentPublicIP()).Replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;); var subDomains = JObject.Parse(await Utils.SendGetRequest(new DescribeDomainRecordsRequest(config.domain))); if (subDomains.SelectToken($\u0026#34;$.DomainRecords.Record[?(@.RR == \u0026#39;{config.sub_domain}\u0026#39;)]\u0026#34;) == null) { Console.WriteLine(\u0026#34;指定的子域名不存在，请新建一个子域名解析。\u0026#34;); return 0; } 如果找到了对应二级域名的解析，则输出当前解析的记录值，然后进行比较，如果当前主机的公网 IP 与记录值一样则无需进行变更。\n1 2 3 4 5 6 7 8 9 10 11 12 Console.WriteLine(\u0026#34;已经找到对应的域名与解析\u0026#34;); Console.WriteLine(\u0026#34;======================\u0026#34;); Console.WriteLine($\u0026#34;子域名:{config.sub_domain}{config.domain}\u0026#34;); var dnsIp = subDomains.SelectToken($\u0026#34;$.DomainRecords.Record[?(@.RR == \u0026#39;{config.sub_domain}\u0026#39;)].Value\u0026#34;).Value\u0026lt;string\u0026gt;(); Console.WriteLine($\u0026#34;目前的 A 记录解析 IP 地址:{dnsIp}\u0026#34;); if (currentIP == dnsIp) { Console.WriteLine(\u0026#34;解析地址与当前主机 IP 地址一致，无需更改.\u0026#34;); return 0; } 当阿里云 DNS 解析记录与当前主机公网 IP 不一致的时候调用更新 API，传入之前的域名的 rrId 去进行变更，完成即退出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Console.WriteLine(\u0026#34;检测到 IP 地址不一致，正在更改中......\u0026#34;); var rrId = subDomains.SelectToken($\u0026#34;$.DomainRecords.Record[?(@.RR == \u0026#39;{config.sub_domain}\u0026#39;)].RecordId\u0026#34;).Value\u0026lt;string\u0026gt;(); var response = await Utils.SendGetRequest(new UpdateDomainRecordRequest(rrId, config.sub_domain, config.type, currentIP, config.interval.ToString())); var resultRRId = JObject.Parse(response).SelectToken(\u0026#34;$.RecordId\u0026#34;).Value\u0026lt;string\u0026gt;(); if (resultRRId == null || resultRRId != rrId) { Console.WriteLine(\u0026#34;更改记录失败，请稍后再试。\u0026#34;); } else { Console.WriteLine(\u0026#34;更改记录成功。\u0026#34;); } return 0; 1.2 Utils 详解 1.2.1 生成通用参数字典 因为 API 请求的时候有很多共有参数，所以这里单独用了一个静态方法来生成这个公有请求参数的字典。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// \u0026lt;summary\u0026gt; /// 生成通用参数字典 /// \u0026lt;/summary\u0026gt; public static SortedDictionary\u0026lt;string, string\u0026gt; GenerateGenericParameters() { var dict = new SortedDictionary\u0026lt;string, string\u0026gt;(StringComparer.Ordinal) { {\u0026#34;Format\u0026#34;, \u0026#34;json\u0026#34;}, {\u0026#34;AccessKeyId\u0026#34;, config.access_id}, {\u0026#34;SignatureMethod\u0026#34;, \u0026#34;HMAC-SHA1\u0026#34;}, {\u0026#34;SignatureNonce\u0026#34;, Guid.NewGuid().ToString()}, {\u0026#34;Version\u0026#34;, \u0026#34;2015-01-09\u0026#34;}, {\u0026#34;SignatureVersion\u0026#34;, \u0026#34;1.0\u0026#34;}, {\u0026#34;Timestamp\u0026#34;, DateTime.UtcNow.ToString(\u0026#34;yyyy-MM-ddTHH:mm:ssZ\u0026#34;)} }; return dict; } 可以看到这里使用了 SortedDictionary\u0026lt;string,string\u0026gt; 来处理，这是因为阿里云 API 必须要求按大小写敏感来排序请求参数，所以这里直接使用了 ``````SortedDictionary``` 来处理这种情况。\n1.2.2 根据字典构建请求字符串 因为阿里云 DNS 的 API 基本上都是 GET 请求，所以通过这个方法可以将之前的 SortedDictionary\u0026lt;string,string\u0026gt; 字典构建成请求字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// \u0026lt;summary\u0026gt; /// 根据字典构建请求字符串 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;参数字典\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static string BuildRequestString(this SortedDictionary\u0026lt;string, string\u0026gt; parameters) { var sb = new StringBuilder(); foreach (var kvp in parameters) { sb.Append(\u0026#34;\u0026amp;\u0026#34;); sb.Append(HttpUtility.UrlEncode(kvp.Key)); sb.Append(\u0026#34;=\u0026#34;); sb.Append(HttpUtility.UrlEncode(kvp.Value)); } return sb.ToString().Substring(1); } 核心就是遍历这个字典，通过 StringBuilder 来构建这个请求字符串。\n1.2.3 生成请求签名 这一步也是最重要的一步，因为阿里云所有的 API 接口都需要传递签名参数，这个签名参数是根据你提交的参数集合 AccessKey 来进行计算的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /// \u0026lt;summary\u0026gt; /// 生成请求签名 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;srcStr\u0026#34;\u0026gt;请求体\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;HMAC-SHA1 的 Base64 编码\u0026lt;/returns\u0026gt; public static string GenerateSignature(this string srcStr) { var signStr = $\u0026#34;GET\u0026amp;{HttpUtility.UrlEncode(\u0026#34;/\u0026#34;)}\u0026amp;{HttpUtility.UrlEncode(srcStr)}\u0026#34;; // 替换已编码的 URL 字符为大写字符 signStr = signStr.Replace(\u0026#34;%2f\u0026#34;, \u0026#34;%2F\u0026#34;).Replace(\u0026#34;%3d\u0026#34;, \u0026#34;%3D\u0026#34;).Replace(\u0026#34;%2b\u0026#34;, \u0026#34;%2B\u0026#34;) .Replace(\u0026#34;%253a\u0026#34;, \u0026#34;%253A\u0026#34;); var hmac = new HMACSHA1(Encoding.UTF8.GetBytes($\u0026#34;{config.access_key}\u0026amp;\u0026#34;)); return Convert.ToBase64String(hmac.ComputeHash(Encoding.UTF8.GetBytes(signStr))); } 这里之前我是按照阿里云 API 来进行开发的，不过有一点需要注意的是，返回的 Signature 值是不需要进行 URL 编码的。就因为这一点，我白白浪费了 3 个小时来排查问题，看看官方 API 文档说的：\n说需要将签名值编码之后再提交，扯淡，如果编码之后再提交的话，接口会一直返回：\nSpecified signature is not matched with our calculation.\n这里直接返回 HMACSHA1 加密结果的 Base64 字符串即可。\n1.2.4 发送请求 构建好一切之后我们就需要发送请求了，这里统一是使用的 SendRequest() 方法来进行处理，可以看到我们先获得签名，然后将获取到的签名追加到请求体内部，一起进行请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /// \u0026lt;summary\u0026gt; /// 追加签名参数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;参数列表\u0026lt;/param\u0026gt; public static string AppendSignature(this SortedDictionary\u0026lt;string, string\u0026gt; parameters, string sign) { parameters.Add(\u0026#34;Signature\u0026#34;, sign); return parameters.BuildRequestString(); } /// \u0026lt;summary\u0026gt; /// 对阿里云 API 发送 GET 请求 /// \u0026lt;/summary\u0026gt; public static async Task\u0026lt;string\u0026gt; SendGetRequest(IRequest request) { var sign = request.Parameters.BuildRequestString().GenerateSignature(); var postUri = $\u0026#34;http://alidns.aliyuncs.com/?{request.Parameters.AppendSignature(sign)}\u0026#34;; using (var client = new HttpClient()) { using (var resuest = new HttpRequestMessage(HttpMethod.Get, postUri)) { using (var response = await client.SendAsync(resuest)) { return await response.Content.ReadAsStringAsync(); } } } } 这里传入的 IRequest 接口，是有具体实现的，可以转到 Main 方法里面看一下：\n1 2 await Utils.SendGetRequest(new DescribeDomainRecordsRequest(config.domain)); await Utils.SendGetRequest(new UpdateDomainRecordRequest(rrId, config.sub_domain, config.type, currentIP, config.interval.ToString())); 这里的 DescribeDomainRecordsRequest 与 UpdateDomainRecordRequest 就是具体的请求体，定义很简单，就是实现了 IRequest 接口而已，然后在各自的内部添加一些特殊的参数。\n1.3 异步 Main 方法 异步的 Main 方法需要 C# 7.1 以上版本才能支持，你只需要右键你的项目选择属性，左侧栏选择生成，找到高级按钮，更改当前 C# 语言版本即可。\n效果如下：\n1 2 3 4 5 static async Task\u0026lt;int\u0026gt; Main(string[] args) { // 代码.... return await Task.FromResult(0); } 1.4 好用的 CommandLine 库 编写控制台程序，最主要的是接受参数然后处理，而 Microsoft.Extensions.CommandLineUtils 库提供了方便快捷的方式来为我们处理用户输入的参数。\n使用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 using System; using McMaster.Extensions.CommandLineUtils; public class Program { public static int Main(string[] args) { var app = new CommandLineApplication(); app.HelpOption(); var optionSubject = app.Option(\u0026#34;-s|--subject \u0026lt;SUBJECT\u0026gt;\u0026#34;, \u0026#34;The subject\u0026#34;, CommandOptionType.SingleValue); var optionRepeat = app.Option\u0026lt;int\u0026gt;(\u0026#34;-n|--count \u0026lt;N\u0026gt;\u0026#34;, \u0026#34;Repeat\u0026#34;, CommandOptionType.SingleValue); // 启动时执行的委托 app.OnExecute(() =\u0026gt; { // 接收参数 var subject = optionSubject.HasValue() ? optionSubject.Value() : \u0026#34;world\u0026#34;; var count = optionRepeat.HasValue() ? optionRepeat.ParsedValue : 1; for (var i = 0; i \u0026lt; count; i++) { Console.WriteLine($\u0026#34;Hello {subject}!\u0026#34;); } // 执行完毕返回状态 0 return 0; }); // 真正启动控制台程序 return app.Execute(args); } } 2.GITHUB 开源地址 https://github.com/GameBelial/AliDDNSNet\n有兴趣的朋友可以 star 关注一下。\n3.二进制程序下载地址 程序打包了 Linux-x64 与 Linux arm 环境的二进制可执行文件，你可以直接下载对应的压缩包解压到你的路由器或者 NAS 里面进行运行。\n如果你的设备支持 Docker 环境，建议通过 Docker 运行 .NET Core 2.1 环境来执行本程序。\n下载地址在这儿\n","date":"2018-07-21T18:15:11Z","permalink":"https://real-zony.github.io/p/ddns-tool-based-on-alibaba-cloud-dns-api/","title":"基于阿里云 DNS API 实现的 DDNS 工具"},{"content":"0.引言 最近打算将现有项目的 Docker 部署到阿里云上面，但是之前是单机部署，现在阿里云上面有 3 台机器，所以想做一个 Docker 集群。之前考虑是用 Docker Swarm 来做这个事情的，不过后面看了一下现在 K8S 用的比较多，进而想在这三台机器上部署 K8S 集群。\n下面附上 Kubernetes 介绍：\nKubernetes 是 Google 团队发起的开源项目，它的目标是管理跨多个主机的容器，提供基本的部署，维护以及运用伸缩，主要实现语言为 Go 语言。Kubernetes 是：\n易学：轻量级，简单，容易理解 便携：支持公有云，私有云，混合云，以及多种云平台 可拓展：模块化，可插拔，支持钩子，可任意组合 自修复：自动重调度，自动重启，自动复制 看上去很牛掰的样子，下面我们就开始来部署吧。\n1.准备工作 万事开头难，本来如果没墙的话就没有这么多破事，首先我们要先配置好安装 Kubernetes 所需要的必备环境，这里我没有采用从零开始安装 Kubernetes 的方式，而是使用了 Kubeadm 来进行 K8S 集群的安装与配置。\n1.1 安装 Docker-CE 关于如何在 CentOS 安装 Docker-CE 的文章大家可以看一下我 这篇文章 ，几分钟的事情就可以安装完毕。\n1.2 安装 Kubeadm 安装 Kubeadm 首先我们要配置好阿里云的国内源，执行如下命令：\n1 2 3 4 5 6 7 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 EOF 之后呢，执行以下命令来重建 Yum 缓存：\n1 2 3 yum -y install epel-release yum clean all yum makecache 下面就开始正式安装 Kubeadm 了：\n1 yum -y install kubelet kubeadm kubectl kubernetes-cni 不出意外的话，安装完成之后，我们执行以下命令来启用 Kubeadm 服务：\n1 systemctl enable kubelet \u0026amp;\u0026amp; systemctl start kubelet 1.3 配置 Kubeadm 所用到的镜像 这里是重中之重，因为在国内的原因，无法访问到 Google 的镜像库，所以我们需要执行以下脚本来从 Docker Hub 仓库中获取相同的镜像，并且更改 TAG 让其变成与 Google 拉去镜像一致。\n新建一个 Shell 脚本，填入以下代码之后保存。\n1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash images=(kube-proxy-amd64:v1.11.0 kube-scheduler-amd64:v1.11.0 kube-controller-manager-amd64:v1.11.0 kube-apiserver-amd64:v1.11.0 etcd-amd64:3.2.18 coredns:1.1.3 pause-amd64:3.1 kubernetes-dashboard-amd64:v1.8.3 k8s-dns-sidecar-amd64:1.14.9 k8s-dns-kube-dns-amd64:1.14.9 k8s-dns-dnsmasq-nanny-amd64:1.14.9 ) for imageName in ${images[@]} ; do docker pull keveon/$imageName docker tag keveon/$imageName k8s.gcr.io/$imageName docker rmi keveon/$imageName done # 个人新加的一句，V 1.11.0 必加 docker tag da86e6ba6ca1 k8s.gcr.io/pause:3.1 注：这里我就遇到过一个坑，原作者是根据 1.10 来的，然后在 kubeadm init 执行的时候一直报错，说找不到镜像。之后镜像版本是下载对了，但还是在 [init] this might take a minute or longer if the control plane images have to be pulled 这一句卡住，在国外的 VPS 测试之后，发现多了一个 k8s.gcr.io/pause:3.1 镜像，他的 ID 其实与 pause-amd64:3.1 一样，然后加了一个新的 TAG 之后，正常部署。\n保存之后记得用 chmod 命令赋予 Shell 脚本可执行权限：\n1 chmod -R 777 ./xxx.sh 1.4 关闭 Swap 1 2 3 sudo swapoff -a #要永久禁掉swap分区，打开如下文件注释掉swap那一行 # sudo vi /etc/fstab 1.5 关闭 SELinux 1 2 3 4 5 # 临时禁用selinux # 永久关闭 修改/etc/sysconfig/selinux文件设置 sed -i \u0026#39;s/SELINUX=permissive/SELINUX=disabled/\u0026#39; /etc/sysconfig/selinux # 这里按回车，下面是第二条命令 setenforce 0 1.6 配置转发参数 1 2 3 4 5 6 7 8 # 配置转发相关参数，否则可能会出错 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 vm.swappiness=0 EOF # 这里按回车，下面是第二条命令 sysctl --system 2.【主机】正式安装 Kuberentes 如果你做好了准备工作，后面的一切都是小菜一碟。\n2.1 初始化相关镜像 要初始化镜像，请运行以下命令：\n1 kubeadm init --kubernetes-version=v1.11.0 --pod-network-cidr=10.244.0.0/16 前面是版本号，后面是你 POD 网络的 IP 段。\n执行之后，你大概会得到与我相近的输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 I0712 10:46:30.938979 13461 feature_gate.go:230] feature gates: \u0026amp;{map[]} [init] using Kubernetes version: v1.11.0 [preflight] running pre-flight checks I0712 10:46:30.961005 13461 kernel_validator.go:81] Validating kernel version I0712 10:46:30.961061 13461 kernel_validator.go:96] Validating kernel config [WARNING SystemVerification]: docker version is greater than the most recently validated version. Docker version: 18.03.1-ce. Max validated version: 17.03 [WARNING Hostname]: hostname \u0026#34;g2-apigateway\u0026#34; could not be reached [WARNING Hostname]: hostname \u0026#34;g2-apigateway\u0026#34; lookup g2-apigateway on 100.100.2.138:53: no such host [preflight/images] Pulling images required for setting up a Kubernetes cluster [preflight/images] This might take a minute or two, depending on the speed of your internet connection [preflight/images] You can also perform this action in beforehand using \u0026#39;kubeadm config images pull\u0026#39; [kubelet] Writing kubelet environment file with flags to file \u0026#34;/var/lib/kubelet/kubeadm-flags.env\u0026#34; [kubelet] Writing kubelet configuration to file \u0026#34;/var/lib/kubelet/config.yaml\u0026#34; [preflight] Activating the kubelet service [certificates] Generated ca certificate and key. [certificates] Generated apiserver certificate and key. [certificates] apiserver serving cert is signed for DNS names [g2-apigateway kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 172.16.8.62] [certificates] Generated apiserver-kubelet-client certificate and key. [certificates] Generated sa key and public key. [certificates] Generated front-proxy-ca certificate and key. [certificates] Generated front-proxy-client certificate and key. [certificates] Generated etcd/ca certificate and key. [certificates] Generated etcd/server certificate and key. [certificates] etcd/server serving cert is signed for DNS names [g2-apigateway localhost] and IPs [127.0.0.1 ::1] [certificates] Generated etcd/peer certificate and key. [certificates] etcd/peer serving cert is signed for DNS names [g2-apigateway localhost] and IPs [172.16.8.62 127.0.0.1 ::1] [certificates] Generated etcd/healthcheck-client certificate and key. [certificates] Generated apiserver-etcd-client certificate and key. [certificates] valid certificates and keys now exist in \u0026#34;/etc/kubernetes/pki\u0026#34; [kubeconfig] Wrote KubeConfig file to disk: \u0026#34;/etc/kubernetes/admin.conf\u0026#34; [kubeconfig] Wrote KubeConfig file to disk: \u0026#34;/etc/kubernetes/kubelet.conf\u0026#34; [kubeconfig] Wrote KubeConfig file to disk: \u0026#34;/etc/kubernetes/controller-manager.conf\u0026#34; [kubeconfig] Wrote KubeConfig file to disk: \u0026#34;/etc/kubernetes/scheduler.conf\u0026#34; [controlplane] wrote Static Pod manifest for component kube-apiserver to \u0026#34;/etc/kubernetes/manifests/kube-apiserver.yaml\u0026#34; [controlplane] wrote Static Pod manifest for component kube-controller-manager to \u0026#34;/etc/kubernetes/manifests/kube-controller-manager.yaml\u0026#34; [controlplane] wrote Static Pod manifest for component kube-scheduler to \u0026#34;/etc/kubernetes/manifests/kube-scheduler.yaml\u0026#34; [etcd] Wrote Static Pod manifest for a local etcd instance to \u0026#34;/etc/kubernetes/manifests/etcd.yaml\u0026#34; [init] waiting for the kubelet to boot up the control plane as Static Pods from directory \u0026#34;/etc/kubernetes/manifests\u0026#34; [init] this might take a minute or longer if the control plane images have to be pulled [apiclient] All control plane components are healthy after 41.001672 seconds [uploadconfig] storing the configuration used in ConfigMap \u0026#34;kubeadm-config\u0026#34; in the \u0026#34;kube-system\u0026#34; Namespace [kubelet] Creating a ConfigMap \u0026#34;kubelet-config-1.11\u0026#34; in namespace kube-system with the configuration for the kubelets in the cluster [markmaster] Marking the node g2-apigateway as master by adding the label \u0026#34;node-role.kubernetes.io/master=\u0026#39;\u0026#39;\u0026#34; [markmaster] Marking the node g2-apigateway as master by adding the taints [node-role.kubernetes.io/master:NoSchedule] [patchnode] Uploading the CRI Socket information \u0026#34;/var/run/dockershim.sock\u0026#34; to the Node API object \u0026#34;g2-apigateway\u0026#34; as an annotation [bootstraptoken] using token: o337m9.ceq32wg9g2gro7gx [bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials [bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token [bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster [bootstraptoken] creating the \u0026#34;cluster-info\u0026#34; ConfigMap in the \u0026#34;kube-public\u0026#34; namespace [addons] Applied essential addon: CoreDNS [addons] Applied essential addon: kube-proxy Your Kubernetes master has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config You should now deploy a pod network to the cluster. Run \u0026#34;kubectl apply -f [podnetwork].yaml\u0026#34; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ You can now join any number of machines by running the following on each node as root: kubeadm join 172.16.8.62:6443 --token o337m9.ceq32wg9g2gro7gx --discovery-token-ca-cert-hash sha256:e8adc6dc2bbe6bd18569c73e4c0468b4652655e7c5c97209a9ec214beac55ea3 2.2 配置 kubectl 认证信息 1 2 3 export KUBECONFIG=/etc/kubernetes/admin.conf # 如果你想持久化的话，直接执行以下命令【推荐】 echo \u0026#34;export KUBECONFIG=/etc/kubernetes/admin.conf\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile 2.3 安装 Flannel 网络 请依次执行以下命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 mkdir -p /etc/cni/net.d/ cat \u0026lt;\u0026lt;EOF\u0026gt; /etc/cni/net.d/10-flannel.conf { “name”: “cbr0”, “type”: “flannel”, “delegate”: { “isDefaultGateway”: true } } EOF mkdir /usr/share/oci-umount/oci-umount.d -p mkdir /run/flannel/ cat \u0026lt;\u0026lt;EOF\u0026gt; /run/flannel/subnet.env FLANNEL_NETWORK=10.244.0.0/16 FLANNEL_SUBNET=10.244.1.0/24 FLANNEL_MTU=1450 FLANNEL_IPMASQ=true EOF 最后，我们需要新建一个 flannel.yml 文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: flannel rules: - apiGroups: - \u0026#34;\u0026#34; resources: - pods verbs: - get - apiGroups: - \u0026#34;\u0026#34; resources: - nodes verbs: - list - watch - apiGroups: - \u0026#34;\u0026#34; resources: - nodes/status verbs: - patch --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: flannel roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: flannel subjects: - kind: ServiceAccount name: flannel namespace: kube-system --- apiVersion: v1 kind: ServiceAccount metadata: name: flannel namespace: kube-system --- kind: ConfigMap apiVersion: v1 metadata: name: kube-flannel-cfg namespace: kube-system labels: tier: node app: flannel data: cni-conf.json: | { \u0026#34;name\u0026#34;: \u0026#34;cbr0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;flannel\u0026#34;, \u0026#34;delegate\u0026#34;: { \u0026#34;isDefaultGateway\u0026#34;: true } } net-conf.json: | { \u0026#34;Network\u0026#34;: \u0026#34;10.244.0.0/16\u0026#34;, \u0026#34;Backend\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;vxlan\u0026#34; } } --- apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: kube-flannel-ds namespace: kube-system labels: tier: node app: flannel spec: template: metadata: labels: tier: node app: flannel spec: hostNetwork: true nodeSelector: beta.kubernetes.io/arch: amd64 tolerations: - key: node-role.kubernetes.io/master operator: Exists effect: NoSchedule serviceAccountName: flannel initContainers: - name: install-cni image: quay.io/coreos/flannel:v0.9.1-amd64 command: - cp args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conf volumeMounts: - name: cni mountPath: /etc/cni/net.d - name: flannel-cfg mountPath: /etc/kube-flannel/ containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.9.1-amd64 command: [ \u0026#34;/opt/bin/flanneld\u0026#34;, \u0026#34;--ip-masq\u0026#34;, \u0026#34;--kube-subnet-mgr\u0026#34; ] securityContext: privileged: true env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace volumeMounts: - name: run mountPath: /run - name: flannel-cfg mountPath: /etc/kube-flannel/ volumes: - name: run hostPath: path: /run - name: cni hostPath: path: /etc/cni/net.d - name: flannel-cfg configMap: name: kube-flannel-cfg 执行：\n1 kubectl create -f ./flannel.yml 执行完成之后，我们可以运行一下命令，查看现在的节点信息：\n1 kubectl get nodes 会得到类似于下面的输出：\n1 2 NAME STATUS ROLES AGE VERSION g2-master Ready master 46m v1.11.0 好了，我们主机已经配置完成。\n3.【Node 节点】配置 Node 节点所需要做的都在 [准备工作](# 准备工作) 里面，做完之后直接执行刚刚主机输出的：\n1 kubeadm join 172.16.8.62:6443 --token o337m9.ceq32wg9g2gro7gx --discovery-token-ca-cert-hash sha256:e8adc6dc2bbe6bd18569c73e4c0468b4652655e7c5c97209a9ec214beac55ea3 执行完就 OK 了。\n然后我们回到 62 主机服务器，我刚刚在两个从属的服务器执行了以上命令，然后运行：\n1 kubectl get nodes 得到输出：\n1 2 3 4 NAME STATUS ROLES AGE VERSION g2-master Ready master 46m v1.11.0 g2-node1 Ready \u0026lt;none\u0026gt; 41m v1.11.0 g2-node2 Ready \u0026lt;none\u0026gt; 41m v1.11.0 4.Dashboard 配置 Kuberentes 配置 DashBoard 也不简单，当然你可以使用官方的 dashboard 的 yaml 文件进行部署，也可以使用 Mr.Devin 这位博主所提供的修改版，避免踩坑。\n地址在：https://github.com/gh-Devin/kubernetes-dashboard，将这些 Yaml 文件下载下来，在其目录下（注意在 Yaml 文件所在目录），执行以下命令：\n1 kubectl -n kube-system create -f . 启动 Dashboard 所需要的所有容器。\n访问你 MASTER 主机的 IP:30090，可以看到如下界面：\n会发现报错。。。看不到容器，这个时候你需要新建一个 dashboard-admin.yaml 文件，然后填充如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: kubernetes-dashboard labels: k8s-app: kubernetes-dashboard roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: kubernetes-dashboard namespace: kube-system 填好之后呢，执行如下命令启动容器：\n1 kubectl -f ./dashboard-admin.yaml create 再次访问，正常了。\n5.结语 参考资料：https://www.kubernetes.org.cn/3805.html\nDashboard Web-UI 配置 ：https://www.kubernetes.org.cn/3834.html\nDashboard 问题解决：https://medium.com/@osamasaad_94885/i-got-it-to-work-finally-27514babede3\n","date":"2018-07-12T04:02:57Z","permalink":"https://real-zony.github.io/p/problems-encountered-when-installing-k8s-v1.11.0-cluster-on-centos-7.4/","title":"CentOS 7.4 安装 K8S v1.11.0 集群所遇到的问题"},{"content":"0.简介 在 Abp 框架内部实现了工作单元，在这里讲解一下，什么是工作单元？\nUnit Of Work(工作单元)模式用来维护一个由已经被业务事物修改（增加、删除或更新）的业务对象组成的列表。Unit Of Work模式负责协调这些修改的持久化工作以及所有标记的并发问题。在数据访问层中采用Unit Of Work模式带来的好处是能够确保数据完整性。如果在持久化一系列业务对象（他们属于同一个事物）的过程中出现问题，那么应该将所有的修改回滚，以确保数据始终处于有效状态。\n而在 Abp 的内部则是结合 Castle 的 Dynamic Proxy 拦截 UnitOfwork Attribute 来进行动态代理注入，实现了当执行标注了 [UnitOfwork] 方法时能够通过 UnitOfworkManager 来进行事务控制。\n其大概流程如下：\n1 启动流程 首先我们来看一下 Abp 内部是什么时候注入 UOW 相关的代码的，翻阅源码，在 AbpBootstrapper 内部我们就可以看到 Abp 作者为 UOW 写了一个拦截器，并且在 Abp 框架初始化的时候就通过 AddInterceptorRegistrars() 方法来监听 IocManager 的组件注册事件，当触发事件的时候就来判断是否满足条件，如果满足则将拦截器与该类型进行一个绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 public class AbpBootstrapper : IDisposable { private AbpBootstrapper([NotNull] Type startupModule, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) { // 其他代码 if (!options.DisableAllInterceptors) { // 添加拦截器 AddInterceptorRegistrars(); } } private void AddInterceptorRegistrars() { ValidationInterceptorRegistrar.Initialize(IocManager); AuditingInterceptorRegistrar.Initialize(IocManager); EntityHistoryInterceptorRegistrar.Initialize(IocManager); UnitOfWorkRegistrar.Initialize(IocManager); AuthorizationInterceptorRegistrar.Initialize(IocManager); } } internal static class UnitOfWorkRegistrar { public static void Initialize(IIocManager iocManager) { // 监听组件注册事件 iocManager.IocContainer.Kernel.ComponentRegistered += (key, handler) =\u0026gt; { var implementationType = handler.ComponentModel.Implementation.GetTypeInfo(); // 按 UOW 特性注册 HandleTypesWithUnitOfWorkAttribute(implementationType, handler); // 按规约注册 HandleConventionalUnitOfWorkTypes(iocManager, implementationType, handler); }; } private static void HandleTypesWithUnitOfWorkAttribute(TypeInfo implementationType, IHandler handler) { if (IsUnitOfWorkType(implementationType) || AnyMethodHasUnitOfWork(implementationType)) { handler.ComponentModel.Interceptors.Add(new InterceptorReference(typeof(UnitOfWorkInterceptor))); } } private static void HandleConventionalUnitOfWorkTypes(IIocManager iocManager, TypeInfo implementationType, IHandler handler) { if (!iocManager.IsRegistered\u0026lt;IUnitOfWorkDefaultOptions\u0026gt;()) { return; } var uowOptions = iocManager.Resolve\u0026lt;IUnitOfWorkDefaultOptions\u0026gt;(); if (uowOptions.IsConventionalUowClass(implementationType.AsType())) { handler.ComponentModel.Interceptors.Add(new InterceptorReference(typeof(UnitOfWorkInterceptor))); } } private static bool IsUnitOfWorkType(TypeInfo implementationType) { return UnitOfWorkHelper.HasUnitOfWorkAttribute(implementationType); } private static bool AnyMethodHasUnitOfWork(TypeInfo implementationType) { return implementationType .GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) .Any(UnitOfWorkHelper.HasUnitOfWorkAttribute); } } 可以看到在这个 Registrar 里面他拥有两种注册方式，第一种很简单，就是判断注册的组件类型是否拥有 UOW 标签，第二种则是通过规约来注入拦截器。\nAbp 默认针对仓储与应用服务会自动将拦截器挂载到这两个类型以及他的所有子类的。这里的 UnitOfWorkDefaultOptionsExtensions.IsConventionalUowClass() 方法就是用来判断传入的 Type 是否属于规约的 Type。\n1 2 3 4 public static bool IsConventionalUowClass(this IUnitOfWorkDefaultOptions unitOfWorkDefaultOptions, Type type) { return unitOfWorkDefaultOptions.ConventionalUowSelectors.Any(selector =\u0026gt; selector(type)); } 又牵扯到了一个 IUnitOfWorkDefaultOptions ，看一下他的默认实现 UnitOfWorkDefaultOptions 就会发现这样的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public UnitOfWorkDefaultOptions() { _filters = new List\u0026lt;DataFilterConfiguration\u0026gt;(); IsTransactional = true; Scope = TransactionScopeOption.Required; IsTransactionScopeAvailable = true; // 默认类型 ConventionalUowSelectors = new List\u0026lt;Func\u0026lt;Type, bool\u0026gt;\u0026gt; { type =\u0026gt; typeof(IRepository).IsAssignableFrom(type) || typeof(IApplicationService).IsAssignableFrom(type) }; } 2. 实现原理 2.1 工作单元拦截器 在上一步我们通过两种注入方式将拦截器注入到需要应用工作单元特性的类型里面，那么我们程序在执行的时候就会使用 Dyncmic Proxy 来拦截包裹这些方法。\n下面我们就来看一下刚刚注入的拦截器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 internal class UnitOfWorkInterceptor : IInterceptor { // ... // 其他代码 public void Intercept(IInvocation invocation) { MethodInfo method; try { method = invocation.MethodInvocationTarget; } catch { method = invocation.GetConcreteMethod(); } // 判断当前进入的方法是否带有 UnitOfWork 特性 var unitOfWorkAttr = _unitOfWorkOptions.GetUnitOfWorkAttributeOrNull(method); if (unitOfWorkAttr == null || unitOfWorkAttr.IsDisabled) { // 没有则直接执行该方法 invocation.Proceed(); return; } PerformUow(invocation, unitOfWorkAttr.CreateOptions()); } // ... // 其他代码 } 拦截器内部方法很简单，如果是 UOW 方法则执行 PerformUow() 即可，在该方法内部则对方法类型进行了不同的判断，同步与异步的处理方法是不一样的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ... // 其他代码 private void PerformUow(IInvocation invocation, UnitOfWorkOptions options) { // 判断方法是同步还是异步方法，不同则执行不同的处理操作 if (invocation.Method.IsAsync()) { PerformAsyncUow(invocation, options); } else { PerformSyncUow(invocation, options); } } // ... // 其他代码 那么我们就先来看一下同步方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ... // 其他代码 private void PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) { using (var uow = _unitOfWorkManager.Begin(options)) { // 继续执行 invocation.Proceed(); uow.Complete(); } } // ... // 其他代码 同步方法针对 UOW 的操作十分简单，直接使用 UnitOfWorkManager.Begin() 方法开启一个事务，然后在内部执行原有方法的代码，执行完成之后调用 Complete() 完成此次调用。\n假如我拥有两个应用服务类，他们都拥有 UnitOfWork 特性，然后我再一个 A 方法调用他们两个 B 类的 Run() 方法，而 Ｂ类的内部也调用了C 的 Run() 方法，大体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class A { private readonly B B; public A(B b) { B = b; } public void TestMethod() { B.Run(); } } internal class B { private readonly C C; public B(C c) { C = c; } [UnitOfWork] public void Run() { // 数据库操作 C.Run(); Console.WriteLine(\u0026#34;B 的 Run 方法被调用.\u0026#34;); } } internal class C { [UnitOfWork] public void Run() { Console.WriteLine(\u0026#34;C 的 Run 方法被调用.\u0026#34;); } } 然后在拦截器内部的执行过程就类似于下面这种：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 internal class UnitOfWorkInterceptor { public void TestMethod() { using (var uow = _unitOfWorkManager.Begin(options)) { using(var uow2 = _unitOfWorkManager.Begin(options)) { // C 方法的代码 Console.WriteLine(\u0026#34;C 的 Run 方法被调用.\u0026#34;); uow2.Complete(); } // B 方法的代码 Console.WriteLine(\u0026#34;B 的 Run 方法被调用.\u0026#34;); uow.Complete(); } } } 两个工作单元之间的调用会被嵌套在一个 using 语句块之中，一旦任何代码抛出了异常，都会导致最外层的 uow.Complete() 不会被执行，而 Complete() 方法没有执行，则会导致 uow 对象被释放的时候，uow.Dispose() 内部检测到 Complete() 没有被调用，Abp 框架也会自己抛出异常。\n所以 Abp 巧妙结合 Castle Dynamic 实现了 UOW 模式。\n下面我们继续看一下他是如何处理异步 UOW 方法的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private void PerformAsyncUow(IInvocation invocation, UnitOfWorkOptions options) { var uow = _unitOfWorkManager.Begin(options); try { invocation.Proceed(); } catch { uow.Dispose(); throw; } // 如果是无返回值的异步方法 if (invocation.Method.ReturnType == typeof(Task)) { invocation.ReturnValue = InternalAsyncHelper.AwaitTaskWithPostActionAndFinally( (Task) invocation.ReturnValue, async () =\u0026gt; await uow.CompleteAsync(), exception =\u0026gt; uow.Dispose() ); } // 有返回值的异步方法处理 else { invocation.ReturnValue = InternalAsyncHelper.CallAwaitTaskWithPostActionAndFinallyAndGetResult( invocation.Method.ReturnType.GenericTypeArguments[0], invocation.ReturnValue, async () =\u0026gt; await uow.CompleteAsync(), exception =\u0026gt; uow.Dispose() ); } } 相比而言，针对拦截到的异步方法处理起来更加复杂一点，但是总体思路仍然是一样的，将这些工作单元的方法一层层地嵌套起来，依次执行就是核心。而在上面代码里面，一样的首先使用 UnitOfManager.Begin() 获得了一个新的工作单元之后，继续执行原有的操作，下面则主要是通过内部的 InternalAsyncHelper 封装的两个辅助方法来确保等待原有任务执行完成之后，再执行 CompleteAsync() 方法。\n我们可以来看一下这个内部类的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 异步无返回值处理 public static async Task AwaitTaskWithPostActionAndFinally(Task actualReturnValue, Func\u0026lt;Task\u0026gt; postAction, Action\u0026lt;Exception\u0026gt; finalAction) { Exception exception = null; try { // 等待原有任务执行完成 await actualReturnValue; // 执行 CompleteAsync() 表示本工作单元已经顺利执行 await postAction(); } // 捕获异常 catch (Exception ex) { exception = ex; throw; } finally { // 不论是否抛出异常，都调用之前传入的 uow.Dispose() 方法 finalAction(exception); } } // 原理基本同上，只是多了一个返回值 public static async Task\u0026lt;T\u0026gt; AwaitTaskWithPostActionAndFinallyAndGetResult\u0026lt;T\u0026gt;(Task\u0026lt;T\u0026gt; actualReturnValue, Func\u0026lt;Task\u0026gt; postAction, Action\u0026lt;Exception\u0026gt; finalAction) { Exception exception = null; try { var result = await actualReturnValue; await postAction(); return result; } catch (Exception ex) { exception = ex; throw; } finally { finalAction(exception); } } // 异步有返回值处理 public static object CallAwaitTaskWithPostActionAndFinallyAndGetResult(Type taskReturnType, object actualReturnValue, Func\u0026lt;Task\u0026gt; action, Action\u0026lt;Exception\u0026gt; finalAction) { // 这里通过反射获取到 AwaitTaskWithPostActionAndFinallyAndGetResult 方法，并调用。 return typeof (InternalAsyncHelper) .GetMethod(\u0026#34;AwaitTaskWithPostActionAndFinallyAndGetResult\u0026#34;, BindingFlags.Public | BindingFlags.Static) .MakeGenericMethod(taskReturnType) .Invoke(null, new object[] { actualReturnValue, action, finalAction }); } 并不复杂，以上即是拦截器所做的操作。\n2.2 工作单元管理器 通过上文我们可以看到一个工作单元是通过 IUnitOfWorkManager.Begin() 拿到的，那 IUnitOfWorkManager 又是个什么东西呢？\n根据字面意思我们大概知道应该类似于管理 UOW 的东西，它其实只有两个作用。第一，获取当前处于激活状态的工作单元，什么叫激活状态我们后面再讲。第二个作用就是我们之前看到的，可以通过 Begin() 方法来创建一个新的工作单元。\nIUnitOfWorkManager 在 Abp 框架初始化的时候就被注入了，其默认实现为 UnitOfWorkManager ，其核心方法就是 Begin() 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public IUnitOfWorkCompleteHandle Begin(UnitOfWorkOptions options) { // 如果没有传入 UOW 参数，则填充一个默认的参数 options.FillDefaultsForNonProvidedOptions(_defaultOptions); // 获取当前的外部工作单元 var outerUow = _currentUnitOfWorkProvider.Current; // 如果已经存在有外部工作单元，则直接构建一个内部工作单元 if (options.Scope == TransactionScopeOption.Required \u0026amp;\u0026amp; outerUow != null) { return new InnerUnitOfWorkCompleteHandle(); } // 不存在外部工作单元，则从 IOC 容器当中获取一个新的出来 var uow = _iocResolver.Resolve\u0026lt;IUnitOfWork\u0026gt;(); // 绑定外部工作单元的事件 uow.Completed += (sender, args) =\u0026gt; { _currentUnitOfWorkProvider.Current = null; }; uow.Failed += (sender, args) =\u0026gt; { _currentUnitOfWorkProvider.Current = null; }; uow.Disposed += (sender, args) =\u0026gt; { _iocResolver.Release(uow); }; // 设置过滤器 if (outerUow != null) { options.FillOuterUowFiltersForNonProvidedOptions(outerUow.Filters.ToList()); } uow.Begin(options); // 绑定租户 ID if (outerUow != null) { uow.SetTenantId(outerUow.GetTenantId(), false); } // 设置当前的外部工作单元为刚刚初始化的工作单元 _currentUnitOfWorkProvider.Current = uow; return uow; } 可以看到 Begin() 方法返回的是一个类型为 IUnitOfWorkCompleteHandle 的东西，转到其定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /// \u0026lt;summary\u0026gt; /// Used to complete a unit of work. /// This interface can not be injected or directly used. /// Use \u0026lt;see cref=\u0026#34;IUnitOfWorkManager\u0026#34;/\u0026gt; instead. /// \u0026lt;/summary\u0026gt; public interface IUnitOfWorkCompleteHandle : IDisposable { /// \u0026lt;summary\u0026gt; /// Completes this unit of work. /// It saves all changes and commit transaction if exists. /// \u0026lt;/summary\u0026gt; void Complete(); /// \u0026lt;summary\u0026gt; /// Completes this unit of work. /// It saves all changes and commit transaction if exists. /// \u0026lt;/summary\u0026gt; Task CompleteAsync(); } 他只有两个方法，都是标识 UOW 处于已经完成的状态。\n在方法上面右键查看其实现可以看到有这样一种依赖关系：\n可以看到 IUnitOfWorkCompleteHandle 有两个实现，一个是 InnerUnitOfWorkCompleteHandle 还有一个则是 IUnitOfWork 接口。\n首先看一下 InnerUnitOfWorkCompleteHandle：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 internal class InnerUnitOfWorkCompleteHandle : IUnitOfWorkCompleteHandle { public const string DidNotCallCompleteMethodExceptionMessage = \u0026#34;Did not call Complete method of a unit of work.\u0026#34;; private volatile bool _isCompleteCalled; private volatile bool _isDisposed; public void Complete() { _isCompleteCalled = true; } public Task CompleteAsync() { _isCompleteCalled = true; return Task.FromResult(0); } public void Dispose() { if (_isDisposed) { return; } _isDisposed = true; if (!_isCompleteCalled) { if (HasException()) { return; } throw new AbpException(DidNotCallCompleteMethodExceptionMessage); } } private static bool HasException() { try { return Marshal.GetExceptionCode() != 0; } catch (Exception) { return false; } } } 代码很简单，调用 Complete()/CompleteAsync() 会将 _isCompleteCalled 置为 true，然后在 Dispose() 方法内会进行检测，为 faslse 的话直接抛出异常。可以看到在 InnerUnitOfWorkCompleteHandle 内部并不会真正地调用 DbContext.SaveChanges() 进行数据保存。\n那么谁才是真正进行数据库操作的工作单元呢？\n答案就是之前在 IUnitOfWorkManager.Begin() 里面，可以看到在创建 UOW 对象的时候，他在内部进行了一个判断，如果不存在外部工作单元的情况下才会创建 InnerUnitOfWorkCompleteHandle 对象，否则是解析的一个 IUnitOfWork 对象。\n也就是说你可以想象有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public void TestUowMethod() { using(var outerUOW = Manager.Begin()) // 这里返回的是 IOC 解析出的 IUnitOfWork { OperationOuter(); using(var innerUOW1 = Manager.Begin()) // 内部 UOW { Operation1(); using(var innerUOW2 = Manager.Begin()) // 内部 UOW { Operation2(); Complete(); } Complete(); } Complete(); } } 当代码执行的时候，如同俄罗斯套娃，从内部依次到外部执行，内部工作单元仅会在调用 Complete 方法的时候将 completed 标记为 true，但一旦操作抛出异常，Complete() 无法得到执行，则会直接抛出异常，中断外层代码执行。\n在 ABP 内部针对 EF Core 框架实现了一套 UOW，其继承自 UnitOfWorkBase，而在 UnitOfWorkBase 内部有部分针对接口 IActiveUnitOfWork 的实现，同时由于 IUnifOfWork 也实现了 IUnitOfWorkCompleteHandle 接口，所以在 Begin() 方法处能够向上转型。\n2.3 抽象工作单元 根据上图可以知道 Abp 默认实现了一个 UnitOfWorkBase 作为工作单元的抽象基类，他主要的属性就是 Id 与 Outer 属性。\n1 2 3 4 5 6 7 public abstract class UnitOfWorkBase : IUnitOfWork { public string Id { get; } [DoNotWire] public IUnitOfWork Outer { get; set; } } 这里的 Id 是使用的 Guid 生成的，用于标识每个工作单元。\n而 Outer 则是当前 UOW 对象的引用对象。\n这里重点说一下 Outer 是哪儿来的，Outer 他的值是在之前的 UnitOfWorkManager.Begin() 里面的 _currentUnitOfWorkProvider.Current = uow; 进行设置的，_currentUnitOfWorkProvider 的实现在 AsyncLocalCurrentUnitOfWorkProvider 内部，其作用是维护一个 UOW 链，确保当前的工作单元始终是最新的，这里的代码原本是使用 CallContext 实现的，现在已经换为 AsyncLocal\u0026lt;T\u0026gt; 了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 public class AsyncLocalCurrentUnitOfWorkProvider : ICurrentUnitOfWorkProvider, ITransientDependency { /// \u0026lt;inheritdoc /\u0026gt; [DoNotWire] public IUnitOfWork Current { get { return GetCurrentUow(); } set { SetCurrentUow(value); } } public ILogger Logger { get; set; } private static readonly AsyncLocal\u0026lt;LocalUowWrapper\u0026gt; AsyncLocalUow = new AsyncLocal\u0026lt;LocalUowWrapper\u0026gt;(); public AsyncLocalCurrentUnitOfWorkProvider() { Logger = NullLogger.Instance; } private static IUnitOfWork GetCurrentUow() { var uow = AsyncLocalUow.Value?.UnitOfWork; if (uow == null) { return null; } if (uow.IsDisposed) { AsyncLocalUow.Value = null; return null; } return uow; } private static void SetCurrentUow(IUnitOfWork value) { lock (AsyncLocalUow) { if (value == null) { if (AsyncLocalUow.Value == null) { return; } if (AsyncLocalUow.Value.UnitOfWork?.Outer == null) { AsyncLocalUow.Value.UnitOfWork = null; AsyncLocalUow.Value = null; return; } AsyncLocalUow.Value.UnitOfWork = AsyncLocalUow.Value.UnitOfWork.Outer; } else { if (AsyncLocalUow.Value?.UnitOfWork == null) { if (AsyncLocalUow.Value != null) { AsyncLocalUow.Value.UnitOfWork = value; } AsyncLocalUow.Value = new LocalUowWrapper(value); return; } value.Outer = AsyncLocalUow.Value.UnitOfWork; AsyncLocalUow.Value.UnitOfWork = value; } } } private class LocalUowWrapper { public IUnitOfWork UnitOfWork { get; set; } public LocalUowWrapper(IUnitOfWork unitOfWork) { UnitOfWork = unitOfWork; } } } 继续往下看，在 UnitOfWorkBase 的里面也是有个 Complete() 与 CompleteAsync() 方法的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protected abstract void CompleteUow(); /// \u0026lt;inheritdoc/\u0026gt; public void Complete() { // 判断是否重复完成 PreventMultipleComplete(); try { CompleteUow(); _succeed = true; OnCompleted(); } catch (Exception ex) { _exception = ex; throw; } } 这里的 CompleteUow() 仍然只是一个抽象方法，具体的实现在具体的访问层里面。\n2.4 EF Core 实际处理 Abp 针对 EF Core 的 UOW 实现是 EfCoreUnitOfWork，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 protected override void BeginUow() { if (Options.IsTransactional == true) { _transactionStrategy.InitOptions(Options); } } public override void SaveChanges() { foreach (var dbContext in GetAllActiveDbContexts()) { SaveChangesInDbContext(dbContext); } } public override async Task SaveChangesAsync() { // 遍历所有激活的 DbContext foreach (var dbContext in GetAllActiveDbContexts()) { await SaveChangesInDbContextAsync(dbContext); } } protected override void CompleteUow() { SaveChanges(); CommitTransaction(); } protected override async Task CompleteUowAsync() { await SaveChangesAsync(); CommitTransaction(); } private void CommitTransaction() { if (Options.IsTransactional == true) { _transactionStrategy.Commit(); } } public IReadOnlyList\u0026lt;DbContext\u0026gt; GetAllActiveDbContexts() { return ActiveDbContexts.Values.ToImmutableList(); } 根本就是遍历 DbContext 调用其 SaveChanges() 来提交所有数据库更改。\n余下更加详细的东西会放在 《七、仓储与 Entity Framework Core》 当中说明的。\n3.常见问题 3.1 待写 ","date":"2018-07-09T10:08:45Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-6-implementation-of-work-unit/","title":"Abp 源码分析：六、工作单元的实现"},{"content":"0.简要介绍 Abp 本身有两种设置，一种就是 上一篇文章 所介绍的模块配置 Configuration，该配置主要用于一些复杂的数据类型设置，不仅仅是字符串，也有可能是一些 C# 运行时的一些变量。另外一种则是本篇文章所讲的 Setting，Setting 主要用于配置一些简单的参数，比如 SMTP 地址，数据库连接字符串等一些基本的配置类型可以使用 Setting 来进行处理。\n1.代码分析 1.1 启动流程 我们先来看一下设置是怎样被加入到 Abp 框架当中，并且是如何来使用它的。\n在 Abp 框架内部开发人员可以通过 ISettingsConfiguration 的 Providers 属性来添加自己实现的 SettingProvider ，而 ISettingsConfiguration 的初始化是在上一篇文章所写的 AbpBootstrapper.Initialize() 里面进行初始化的。\n开发人员通过继承 SettingProvider 来提供这些设置信息，并且在模块的 PreInitialize() 方法当中通过 Configuration 来添加书写好的配置提供者。\n在模块进行初始化之后(也就是在 PostInitiailze() 方法内部)，所有开发人员定义的 SettingProvider 通过 ISettingDefinitionManager 的 Initialize() 方法存储到一个 Dictionary 里面。\n1 2 3 4 5 6 7 8 9 10 public sealed class AbpKernelModule : AbpModule { // 其他代码 public override void PostInitialize() { // 其他代码 IocManager.Resolve\u0026lt;SettingDefinitionManager\u0026gt;().Initialize(); // 其他代码 } } Initialize() 方法内部：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private readonly IDictionary\u0026lt;string, SettingDefinition\u0026gt; _settings; public void Initialize() { var context = new SettingDefinitionProviderContext(this); foreach (var providerType in _settingsConfiguration.Providers) { using (var provider = CreateProvider(providerType)) { foreach (var settings in provider.Object.GetSettingDefinitions(context)) { _settings[settings.Name] = settings; } } } } 对外则是通过 ISettingManager 来进行管理的。\n所有的设置项是通过 ServiceProvider 来提供的。\n设置的持久化配置则是通过 ISettingStore 来实现的，开发者可以通过替换 ISettingStore 的实现达到持久化到数据库或者是其他位置。\n1.2 典型用法 1.2.1 设置提供者定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 internal class EmailSettingProvider : SettingProvider { public override IEnumerable\u0026lt;SettingDefinition\u0026gt; GetSettingDefinitions(SettingDefinitionProviderContext context) { return new[] { new SettingDefinition(EmailSettingNames.Smtp.Host, \u0026#34;127.0.0.1\u0026#34;, L(\u0026#34;SmtpHost\u0026#34;), scopes: SettingScopes.Application | SettingScopes.Tenant), new SettingDefinition(EmailSettingNames.Smtp.Port, \u0026#34;25\u0026#34;, L(\u0026#34;SmtpPort\u0026#34;), scopes: SettingScopes.Application | SettingScopes.Tenant), new SettingDefinition(EmailSettingNames.Smtp.UserName, \u0026#34;\u0026#34;, L(\u0026#34;Username\u0026#34;), scopes: SettingScopes.Application | SettingScopes.Tenant), new SettingDefinition(EmailSettingNames.Smtp.Password, \u0026#34;\u0026#34;, L(\u0026#34;Password\u0026#34;), scopes: SettingScopes.Application | SettingScopes.Tenant), new SettingDefinition(EmailSettingNames.Smtp.Domain, \u0026#34;\u0026#34;, L(\u0026#34;DomainName\u0026#34;), scopes: SettingScopes.Application | SettingScopes.Tenant), new SettingDefinition(EmailSettingNames.Smtp.EnableSsl, \u0026#34;false\u0026#34;, L(\u0026#34;UseSSL\u0026#34;), scopes: SettingScopes.Application | SettingScopes.Tenant), new SettingDefinition(EmailSettingNames.Smtp.UseDefaultCredentials, \u0026#34;true\u0026#34;, L(\u0026#34;UseDefaultCredentials\u0026#34;), scopes: SettingScopes.Application | SettingScopes.Tenant), new SettingDefinition(EmailSettingNames.DefaultFromAddress, \u0026#34;\u0026#34;, L(\u0026#34;DefaultFromSenderEmailAddress\u0026#34;), scopes: SettingScopes.Application | SettingScopes.Tenant), new SettingDefinition(EmailSettingNames.DefaultFromDisplayName, \u0026#34;\u0026#34;, L(\u0026#34;DefaultFromSenderDisplayName\u0026#34;), scopes: SettingScopes.Application | SettingScopes.Tenant) }; } private static LocalizableString L(string name) { return new LocalizableString(name, AbpConsts.LocalizationSourceName); } } 1.2.2 注入设置提供者 1 2 3 4 5 6 7 8 9 public sealed class AbpKernelModule : AbpModule { public override void PreInitialize() { // 其他代码 Configuration.Settings.Providers.Add\u0026lt;EmailSettingProvider\u0026gt;(); // 其他代码 } } 注入之后，那么相应的模块如何得到已经注入的配置项呢？\n我们拿一个最直观的例子来展示一下，这里我们来到 Abp 项目的 Email 模块，来看看它是如何使用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class DefaultMailKitSmtpBuilder : IMailKitSmtpBuilder, ITransientDependency { private readonly ISmtpEmailSenderConfiguration _smtpEmailSenderConfiguration; public DefaultMailKitSmtpBuilder(ISmtpEmailSenderConfiguration smtpEmailSenderConfiguration) { _smtpEmailSenderConfiguration = smtpEmailSenderConfiguration; } public virtual SmtpClient Build() { var client = new SmtpClient(); try { ConfigureClient(client); return client; } catch { client.Dispose(); throw; } } protected virtual void ConfigureClient(SmtpClient client) { client.Connect( _smtpEmailSenderConfiguration.Host, _smtpEmailSenderConfiguration.Port, _smtpEmailSenderConfiguration.EnableSsl ); if (_smtpEmailSenderConfiguration.UseDefaultCredentials) { return; } client.Authenticate( _smtpEmailSenderConfiguration.UserName, _smtpEmailSenderConfiguration.Password ); } } 可以看到以上代码通过 ISmtpEmailSenderConfiguration 来拿到 SMTP 对应的主机名与端口号，那这与我们的 ISettingManager 又有何关系呢？\n其实我们转到 ISmtpEmailSenderConfiguration 的实现 SmtpEmailSenderConfiguration 就清楚了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public class SmtpEmailSenderConfiguration : EmailSenderConfiguration, ISmtpEmailSenderConfiguration, ITransientDependency { /// \u0026lt;summary\u0026gt; /// SMTP Host name/IP. /// \u0026lt;/summary\u0026gt; public virtual string Host { get { return GetNotEmptySettingValue(EmailSettingNames.Smtp.Host); } } /// \u0026lt;summary\u0026gt; /// SMTP Port. /// \u0026lt;/summary\u0026gt; public virtual int Port { get { return SettingManager.GetSettingValue\u0026lt;int\u0026gt;(EmailSettingNames.Smtp.Port); } } /// \u0026lt;summary\u0026gt; /// User name to login to SMTP server. /// \u0026lt;/summary\u0026gt; public virtual string UserName { get { return GetNotEmptySettingValue(EmailSettingNames.Smtp.UserName); } } /// \u0026lt;summary\u0026gt; /// Password to login to SMTP server. /// \u0026lt;/summary\u0026gt; public virtual string Password { get { return GetNotEmptySettingValue(EmailSettingNames.Smtp.Password); } } /// \u0026lt;summary\u0026gt; /// Domain name to login to SMTP server. /// \u0026lt;/summary\u0026gt; public virtual string Domain { get { return SettingManager.GetSettingValue(EmailSettingNames.Smtp.Domain); } } /// \u0026lt;summary\u0026gt; /// Is SSL enabled? /// \u0026lt;/summary\u0026gt; public virtual bool EnableSsl { get { return SettingManager.GetSettingValue\u0026lt;bool\u0026gt;(EmailSettingNames.Smtp.EnableSsl); } } /// \u0026lt;summary\u0026gt; /// Use default credentials? /// \u0026lt;/summary\u0026gt; public virtual bool UseDefaultCredentials { get { return SettingManager.GetSettingValue\u0026lt;bool\u0026gt;(EmailSettingNames.Smtp.UseDefaultCredentials); } } /// \u0026lt;summary\u0026gt; /// Creates a new \u0026lt;see cref=\u0026#34;SmtpEmailSenderConfiguration\u0026#34;/\u0026gt;. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;settingManager\u0026#34;\u0026gt;Setting manager\u0026lt;/param\u0026gt; public SmtpEmailSenderConfiguration(ISettingManager settingManager) : base(settingManager) { } } 在这里我们可以看到这些配置项其实是通过一个名字叫做 GetNotEmptySettingValue() 的方法来得到的，该方法定义在 SmtpEmailSenderConfiguration 的基类 EmailSenderConfiguration 当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class EmailSenderConfiguration : IEmailSenderConfiguration { // 其他代码，已经省略 /// \u0026lt;summary\u0026gt; /// Creates a new \u0026lt;see cref=\u0026#34;EmailSenderConfiguration\u0026#34;/\u0026gt;. /// \u0026lt;/summary\u0026gt; protected EmailSenderConfiguration(ISettingManager settingManager) { SettingManager = settingManager; } /// \u0026lt;summary\u0026gt; /// Gets a setting value by checking. Throws \u0026lt;see cref=\u0026#34;AbpException\u0026#34;/\u0026gt; if it\u0026#39;s null or empty. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;name\u0026#34;\u0026gt;Name of the setting\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;Value of the setting\u0026lt;/returns\u0026gt; protected string GetNotEmptySettingValue(string name) { var value = SettingManager.GetSettingValue(name); if (value.IsNullOrEmpty()) { throw new AbpException($\u0026#34;Setting value for \u0026#39;{name}\u0026#39; is null or empty!\u0026#34;); } return value; } } 总而言之，如果你想要获取已经添加好的设置项，直接注入 ISettingManager 通过其 GetSettingValue() 就可以拿到这些设置项。\n1.3 具体代码分析 Abp 系统设置相关的最核心的部分就是 ISettingManager、ISettingDefinitionManager、ISettingStore，SettingProvider、SettingDefinition 下面就这几个类进行一些细致的解析。\n1.3.1 SettingDefinition 在 Abp 当中，一个设置项就是一个 SettingDefinition，每个 SettingDefinition 的 Name 与 Value 是必填的，其中 Scopes 字段对应一个 SettingScopes 枚举，该属性用于确定这个设置项的使用应用范围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 public class SettingDefinition { /// \u0026lt;summary\u0026gt; /// Unique name of the setting. /// \u0026lt;/summary\u0026gt; public string Name { get; private set; } /// \u0026lt;summary\u0026gt; /// Display name of the setting. /// This can be used to show setting to the user. /// \u0026lt;/summary\u0026gt; public ILocalizableString DisplayName { get; set; } /// \u0026lt;summary\u0026gt; /// A brief description for this setting. /// \u0026lt;/summary\u0026gt; public ILocalizableString Description { get; set; } /// \u0026lt;summary\u0026gt; /// Scopes of this setting. /// Default value: \u0026lt;see cref=\u0026#34;SettingScopes.Application\u0026#34;/\u0026gt;. /// \u0026lt;/summary\u0026gt; public SettingScopes Scopes { get; set; } /// \u0026lt;summary\u0026gt; /// Is this setting inherited from parent scopes. /// Default: True. /// \u0026lt;/summary\u0026gt; public bool IsInherited { get; set; } /// \u0026lt;summary\u0026gt; /// Gets/sets group for this setting. /// \u0026lt;/summary\u0026gt; public SettingDefinitionGroup Group { get; set; } /// \u0026lt;summary\u0026gt; /// Default value of the setting. /// \u0026lt;/summary\u0026gt; public string DefaultValue { get; set; } /// \u0026lt;summary\u0026gt; /// Can clients see this setting and it\u0026#39;s value. /// It maybe dangerous for some settings to be visible to clients (such as email server password). /// Default: false. /// \u0026lt;/summary\u0026gt; [Obsolete(\u0026#34;Use ClientVisibilityProvider instead.\u0026#34;)] public bool IsVisibleToClients { get; set; } /// \u0026lt;summary\u0026gt; /// Client visibility definition for the setting. /// \u0026lt;/summary\u0026gt; public ISettingClientVisibilityProvider ClientVisibilityProvider { get; set; } /// \u0026lt;summary\u0026gt; /// Can be used to store a custom object related to this setting. /// \u0026lt;/summary\u0026gt; public object CustomData { get; set; } public SettingDefinition( string name, string defaultValue, ILocalizableString displayName = null, SettingDefinitionGroup group = null, ILocalizableString description = null, SettingScopes scopes = SettingScopes.Application, bool isVisibleToClients = false, bool isInherited = true, object customData = null, ISettingClientVisibilityProvider clientVisibilityProvider = null) { if (string.IsNullOrEmpty(name)) { throw new ArgumentNullException(nameof(name)); } Name = name; DefaultValue = defaultValue; DisplayName = displayName; Group = @group; Description = description; Scopes = scopes; IsVisibleToClients = isVisibleToClients; IsInherited = isInherited; CustomData = customData; ClientVisibilityProvider = new HiddenSettingClientVisibilityProvider(); if (isVisibleToClients) { ClientVisibilityProvider = new VisibleSettingClientVisibilityProvider(); } else if (clientVisibilityProvider != null) { ClientVisibilityProvider = clientVisibilityProvider; } } } 1.3.2 ISettingManager 首先我们看一下 ISettingManager 的默认实现 SettingManager。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class SettingManager : ISettingManager, ISingletonDependency { public const string ApplicationSettingsCacheKey = \u0026#34;ApplicationSettings\u0026#34;; /// \u0026lt;summary\u0026gt; /// Reference to the current Session. /// \u0026lt;/summary\u0026gt; public IAbpSession AbpSession { get; set; } /// \u0026lt;summary\u0026gt; /// Reference to the setting store. /// \u0026lt;/summary\u0026gt; public ISettingStore SettingStore { get; set; } private readonly ISettingDefinitionManager _settingDefinitionManager; private readonly ITypedCache\u0026lt;string, Dictionary\u0026lt;string, SettingInfo\u0026gt;\u0026gt; _applicationSettingCache; private readonly ITypedCache\u0026lt;int, Dictionary\u0026lt;string, SettingInfo\u0026gt;\u0026gt; _tenantSettingCache; private readonly ITypedCache\u0026lt;string, Dictionary\u0026lt;string, SettingInfo\u0026gt;\u0026gt; _userSettingCache; /// \u0026lt;inheritdoc/\u0026gt; public SettingManager(ISettingDefinitionManager settingDefinitionManager, ICacheManager cacheManager) { _settingDefinitionManager = settingDefinitionManager; AbpSession = NullAbpSession.Instance; SettingStore = DefaultConfigSettingStore.Instance; _applicationSettingCache = cacheManager.GetApplicationSettingsCache(); _tenantSettingCache = cacheManager.GetTenantSettingsCache(); _userSettingCache = cacheManager.GetUserSettingsCache(); } } 可以看到在这里面，他注入了 ISetingStore 与 ISettingDefinitionManager ，并且使用了三个 ITypedCache 来为这些设置进行一个缓存。\n下面这个 GetSettingValueAsync() 方法则是获取一个指定名称的设置值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public Task\u0026lt;string\u0026gt; GetSettingValueAsync(string name) { return GetSettingValueInternalAsync(name, AbpSession.TenantId, AbpSession.UserId); } private async Task\u0026lt;string\u0026gt; GetSettingValueInternalAsync(string name, int? tenantId = null, long? userId = null, bool fallbackToDefault = true) { // 获取指定 Name 的 SettingDefine var settingDefinition = _settingDefinitionManager.GetSettingDefinition(name); // 判断该设置项的使用范围是否为 User if (settingDefinition.Scopes.HasFlag(SettingScopes.User) \u0026amp;\u0026amp; userId.HasValue) { var settingValue = await GetSettingValueForUserOrNullAsync(new UserIdentifier(tenantId, userId.Value), name); if (settingValue != null) { return settingValue.Value; } if (!fallbackToDefault) { return null; } if (!settingDefinition.IsInherited) { return settingDefinition.DefaultValue; } } // 判断该设置项的使用范围是否为 Tenant if (settingDefinition.Scopes.HasFlag(SettingScopes.Tenant) \u0026amp;\u0026amp; tenantId.HasValue) { var settingValue = await GetSettingValueForTenantOrNullAsync(tenantId.Value, name); if (settingValue != null) { return settingValue.Value; } if (!fallbackToDefault) { return null; } if (!settingDefinition.IsInherited) { return settingDefinition.DefaultValue; } } // 判断该设置项的使用范围是否为 Application if (settingDefinition.Scopes.HasFlag(SettingScopes.Application)) { var settingValue = await GetSettingValueForApplicationOrNullAsync(name); if (settingValue != null) { return settingValue.Value; } if (!fallbackToDefault) { return null; } } // 如果都没有定义，则返回默认的设置值 return settingDefinition.DefaultValue; } 这里又为每个判断内部封装了一个方法，这里以 GetSettingValueForApplicationOrNullAsync() 为例，转到其定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private async Task\u0026lt;SettingInfo\u0026gt; GetSettingValueForApplicationOrNullAsync(string name) { return (await GetApplicationSettingsAsync()).GetOrDefault(name); } private async Task\u0026lt;Dictionary\u0026lt;string, SettingInfo\u0026gt;\u0026gt; GetApplicationSettingsAsync() { // 从缓存当中获取设置信息，如果不存在，则执行其工厂方法 return await _applicationSettingCache.GetAsync(ApplicationSettingsCacheKey, async () =\u0026gt; { var dictionary = new Dictionary\u0026lt;string, SettingInfo\u0026gt;(); // 从 ISettingStore 当中获取对应的 Value 值 var settingValues = await SettingStore.GetAllListAsync(null, null); foreach (var settingValue in settingValues) { dictionary[settingValue.Name] = settingValue; } return dictionary; }); } 1.3.3 ISettingDefinitionManager 这个管理器作用最开始已经说明了，就是单纯的获取到用户注册到 Providers 里面的 SettingDefinition。\n1.3.4 SettingProvider SettingProvider 用于开发人员配置自己的配置项，所有的设置提供者只需要继承自本类，实现其 GetSettingDefinitions 方法即可。\n1.3.5 ISettingStore 本类用于设置项值的存储，其本身并不做设置项的新增，仅仅是相同的名称的设置项，优先从 ISettingStore 当中进行获取，如果不存在的话，才会使用开发人员在 SettingProvider 定义的值。\nAbp 项目默认的 DefaultConfigSettingStore 实现并不会进行任何实质性的操作，只有 Zero.Common 项目当中重新实现的 SettingStore 类才是针对这些设置的值进行了持久化操作。\n2.扩展：Abp.MailKit 模块配置 如果要在 .NetCore 环境下面使用邮件发送的话，首先推荐的就是 MailKit 这个库，而 Abp 针对 MailKit 库封装了一个新的模块，叫做 Abp.MailKit ，只需要进行简单的设置就可以发送邮件了。\n在需要使用的模块上面添加：\n1 2 3 4 5 [DependsOn(typeof(AbpMailKitModule))] public class TestModule : AbpModule { // 其他代码 } 之后需要自己定义一个 SettingProvider 并且在里面做好 SMTP 发件服务器配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class DevEmailSettings : SettingProvider { public override IEnumerable\u0026lt;SettingDefinition\u0026gt; GetSettingDefinitions(SettingDefinitionProviderContext context) { return new[] { // smtp 服务器地址 new SettingDefiniion(EmailSettingNames.Smtp.Host, \u0026#34;smtpserver\u0026#34;), // smtp 用户名称 new SettingDefinition(EmailSettingNames.Smtp.UserName, \u0026#34;yourusername\u0026#34;), // smtp 服务端口 new SettingDefinition(EmailSettingNames.Smtp.Port, \u0026#34;25\u0026#34;), // smtp 用户密码 new SettingDefinition(EmailSettingNames.Smtp.Password, \u0026#34;yourpassword\u0026#34;), // 发件人邮箱地址 new SettingDefinition(EmailSettingNames.DefaultFromAddress, \u0026#34;youremailaddress\u0026#34;), // 是否启用默认验证 new SettingDefinition(EmailSettingNames.Smtp.UseDefaultCredentials,\u0026#34;false\u0026#34;) }; } } 然后在之前的模块预加载当中添加这个 Provider 到全局设置当中：\n1 2 3 4 5 6 7 8 [DependsOn(typeof(AbpMailKitModule))] public class TestModule : AbpModule { public override void PreInitialize() { Configuration.Settings.Providers.Add\u0026lt;DevEmailSettings\u0026gt;(); } } 发送邮件十分简单，直接在需要使用的地方注入 IEmailSender 调用其 Send 或者 SendAsync 方法即可，下面是一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class TestApplicationService : ApplicationService { private readonly IEmailSender _emailSender; public TestApplicationService(IEmailSender emailSender) { _emailSender = emailSender; } public Task TestMethod() { _emailSender.Send(\u0026#34;xxxxxx@qq.com\u0026#34;,\u0026#34;无主题\u0026#34;,\u0026#34;测试正文\u0026#34;,false); return Task.FromResult(0); } } ","date":"2018-07-02T03:52:27Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-5-system-settings/","title":"Abp 源码分析：五、系统设置"},{"content":"0.介绍 Sonar 是一款开源的代码分析工具，可能有很多人已经用过，本篇文章主要是讲解如何在 Docker 里面安装 Sonar 并且用其来分析 .Net Core 项目。\nSonar 是一个用于代码质量管理的开放平台。通过插件机制，Sonar 可以集成不同的测试工具，代码分析工具，以及持续集成工具。\n与持续集成工具（例如 Hudson/Jenkins 等）不同，Sonar 并不是简单地把不同的代码检查工具结果（例如 FindBugs，PMD 等）直接显示在 Web 页面上，而是通过不同的插件对这些结果进行再加工处理，通过量化的方式度量代码质量的变化，从而可以方便地对不同规模和种类的工程进行代码质量管理。\n1.安装 安装的话，秉承一贯的懒人原则，在本篇文章当中是直接使用的 Sonar 的 Docker 镜像来进行安装配置的。\n1.1 安装 Docker 安装 Docker-CE 的教程在我的**这篇文章**里面有讲到过，这里就不再多加赘述。\n1.2 建立私有网络 执行以下命令：\n1 docker network create sonar 将会创建一个 Docker 内部网络，名字为 sonar。\n1.2 启动 PostgreSql 容器 使用以下命令拉取 **PostgreSql **的镜像：\n1 docker pull postgres 然后我们启动一个 PostgreSql 容器，名字叫做 sonar-db。\n1 docker run -d --name sonar-db --network sonar -e POSTGRES_USER=sonar -e POSTGRES_PASSWORD=sonar postgres 这里启动容器的时候指定了容器的网络是 sonar-db ，那么后面在 sonar 容器启动的时候加入这个网络即可，其余两个环境变量是用作 PostgreSql 数据库默认的账号密码。\n1.3 启动 Sonar 容器 使用以下命令拉取 Sonar 镜像：\n1 docker pull sonarqube 启动 Sonar 容器：\n1 docker run -d --name sonar --network sonar -p 9000:9000 -p 9092:9092 -e SONARQUBE_JDBC_USERNAME=sonar -e SONARQUBE_JDBC_PASSWORD=sonar -e SONARQUBE_JDBC_URL=jdbc:postgresql://sonar-db:5432/sonar sonarqube 至此，我们的 Sonar 已经部署完成了，访问你服务器或者本地 IP 的 9000 端口即可看到我们最终的效果。\n注意：在这里我们没有针对这两个容器进行数据卷挂载，挂载可以参考下列 YML 文件进行自己的配置，推荐在实际生产环境部署的时候使用 Docker-Compose 来进行部署。\n1.3：扩展：使用 Docker-Compose 来运行 Sonar 如果你每次都需要手动输入这么多命令，其实很麻烦的，在 Sonar 官方的 GitHub 上面有一个 docker-compose.yml 文件，你直接通过 Docker-Compose 就可以运行好环境的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 version: \u0026#34;2\u0026#34; services: sonarqube: image: sonarqube ports: - \u0026#34;9000:9000\u0026#34; networks: - sonarnet environment: - SONARQUBE_JDBC_URL=jdbc:postgresql://db:5432/sonar volumes: - sonarqube_conf:/opt/sonarqube/conf - sonarqube_data:/opt/sonarqube/data - sonarqube_extensions:/opt/sonarqube/extensions - sonarqube_bundled-plugins:/opt/sonarqube/lib/bundled-plugins db: image: postgres networks: - sonarnet environment: - POSTGRES_USER=sonar - POSTGRES_PASSWORD=sonar volumes: - postgresql:/var/lib/postgresql # This needs explicit mapping due to https://github.com/docker-library/postgres/blob/4e48e3228a30763913ece952c611e5e9b95c8759/Dockerfile.template#L52 - postgresql_data:/var/lib/postgresql/data networks: sonarnet: driver: bridge volumes: sonarqube_conf: sonarqube_data: sonarqube_extensions: sonarqube_bundled-plugins: postgresql: postgresql_data: 将其保存到你的 Linux 服务器上，运行以下命令：\n1 docker-compose up 如果需要重启的话则运行以下命令即可：\n1 docker-compose restart sonarqube 1.4 新建项目 Sonar 镜像安装的默认管理员账号和密码都是 admin，直接输入进入到 Sonar 的项目管理界面。\n步骤：\n首先输入你的项目名称，生成一个 Token。 点击生成之后，点击 Continue ，这时候会提示你选择项目类型，并输入一个项目的唯一 Key，这里我还是输入的 TestProject。 点击 Done 之后右边会生成相关的 Scanner 执行步骤，你可以 Copy 下来。 2.分析 如果你需要分析项目的话，有两种选择，第一种就是使用工具1，而如果你是拥有 DotNet Core 2.1 环境的话可以使用 Global Tool 来直接安装分析器。\n2.1 安装 dotnet scanner 参照 Sonar 官方的文档 ，运行命令行工具，并且键入以下命令：\n1 dotnet tool install --global dotnet-sonarscanner --version 4.3.1 就成功安装好 Sonar Scanner 了。\n2.2 分析项目 跳转到你需要分析的项目的根目录，这里我新建了一个测试用的控制台程序，代码很简单，传入了一个 NULL 对象，并且判断这个变量不等于空。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using System; namespace TestConsoleApp { class Program { static void Main(string[] args) { string c = null; if (c != null) { Console.WriteLine(\u0026#34;不可能执行的代码.\u0026#34;); } Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } } 在命令行工具当中分步执行以下命令：\n1 2 3 dotnet sonarscanner begin /k:\u0026#34;TestProject\u0026#34; /d:sonar.host.url=\u0026#34;http://192.168.100.107:9000\u0026#34; /d:sonar.login=\u0026#34;cfe594fd605f2e4821835e43c69da82e489c2f23\u0026#34; dotnet build dotnet sonarscanner end /d:sonar.login=\u0026#34;cfe594fd605f2e4821835e43c69da82e489c2f23\u0026#34; 这里的 /k 指定你的项目，/d 这些参数分别是你 Sonar 的地址与你刚才生成的 Token。\n动图在这里：\n2.3 查看结果 现在来到 Sonar 的站点就可以看到我们刚刚分析的结果啦。\n可以看到说我有一个 BUG。\n3.汉化 可能有的朋友需要中文界面，这个在 Sonar 社区里面提供了中文插件，地址如下 https://github.com/SonarQubeCommunity/sonar-l10n-zh。你可以根据你的 Sonar 版本来选择下载安装哪一个版本的插件，博主目前是基于 Sonar 的 7.1 镜像的，所以下载的是 1.21 版本。\n下载完成之后，使用在之前运行容器的时候，加上 -v 参数，将容器目录 /opt/sonarqube/extensions/plugins 映射到你宿主机来，将你的这个文件拷贝到映射好的目录之下，然后重启 Sonar 容器即可。\n如果你是使用的 Docker-Compose 文件来运行的容器，只需要找到相应的卷，比如说博主插件的数据卷目录在\n/var/lib/docker/volumes/docker-ymls_sonarqube_extensions/_data 里面，我直接拷贝过去重启容器即可，大家的目录路径可能不一样，使用 docker volume ls 命令可以看到存在的数据卷，比如说我的：\n1 2 3 4 5 6 7 8 9 10 11 12 DRIVER VOLUME NAME local 09d0144ebeb8fd9dc382bb14f33d35e156c6e7f29dcfa42ac52f2b82422fab98 local 2c6c4d351a919c9550de94797ce77805fbe178c9226e71bf99c07c44fd303af1 local c8b5b6cd301d4cea2e64866e12a9cf6a2bb4e257e5875449f62dede59ebc52c7 local docker-ymls_postgresql local docker-ymls_postgresql_data local docker-ymls_sonarqube_bundled-plugins local docker-ymls_sonarqube_conf local docker-ymls_sonarqube_data local docker-ymls_sonarqube_extensions local fd1127a3cec43dc992cbf0eefd053bd9dd8f3e93dc9fb0348c70048846f82308 local portainer_data 可以看到插件目录是放在 docker-ymls_sonarqube_extensions 这个数据卷里面的。\n汉化完成的界面如下：\n4.结语 后面会分享如何与 Jenkins + Git(Gogs) 来进行集成的。\n","date":"2018-06-27T06:33:32Z","permalink":"https://real-zony.github.io/p/use-sonarqube-to-analyze-netcore-project-code-problems/","title":"使用 SonarQube 来分析 NetCore 项目代码问题"},{"content":"0.简要介绍 在 Abp 框架当中通过各种 Configuration 来实现模块的配置，Abp 本身提供的很多基础设施功能的一些在运行时的行为是通过很多不同的 Configuration 来开放给用户进行一些自定义配置的。\n比如说缓存模块，我要配置缓存的过期时间，Abp 默认是 1 个小时，但是我也可以自己来定义，直接赋值或者从配置项来读取都是由具体使用者来控制的，所以 Abp 通过各种 Configuration 类来控制一些运行时参数。\n这些 Abp 本身基础设施的配置类都是存放在 \\Abp\\src\\Abp\\Configuration\\Startup\\ 这个文件夹内部的，我们来看一下他们的依赖关系。\n1.启动流程 从上图可以看到在 IAbpStartupConfiguration 内部拥有诸多引用(可能没有列举完成，可以在其定义看到)，基本上 Abp 自己的基础设施配置都在这里面。\n那么 IAbpStartupConfiguration 自己内部的这些属性是在哪儿初始化的呢，其实就是在之前讲过的 AbpBootstrapper 的 Initialize() 内部初始化的。再看下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public virtual void Initialize() { try { // 其他代码 IocManager.IocContainer.Install(new AbpCoreInstaller()); IocManager.Resolve\u0026lt;AbpStartupConfiguration\u0026gt;().Initialize(); // 其他代码 } catch (Exception ex) { _logger.Fatal(ex.ToString(), ex); throw; } } 在 AbpCoreInstaller 类内部之前也说过，在这里面统一注入了这些 Configuration 的单例，同时解析出 AbpStartupConfiguration ，调用其 Initialzie() 方法来对自己的那些 xxxConfiguration 接口赋值，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public void Initialize() { Localization = IocManager.Resolve\u0026lt;ILocalizationConfiguration\u0026gt;(); Modules = IocManager.Resolve\u0026lt;IModuleConfigurations\u0026gt;(); Features = IocManager.Resolve\u0026lt;IFeatureConfiguration\u0026gt;(); Navigation = IocManager.Resolve\u0026lt;INavigationConfiguration\u0026gt;(); Authorization = IocManager.Resolve\u0026lt;IAuthorizationConfiguration\u0026gt;(); Validation = IocManager.Resolve\u0026lt;IValidationConfiguration\u0026gt;(); Settings = IocManager.Resolve\u0026lt;ISettingsConfiguration\u0026gt;(); UnitOfWork = IocManager.Resolve\u0026lt;IUnitOfWorkDefaultOptions\u0026gt;(); EventBus = IocManager.Resolve\u0026lt;IEventBusConfiguration\u0026gt;(); MultiTenancy = IocManager.Resolve\u0026lt;IMultiTenancyConfig\u0026gt;(); Auditing = IocManager.Resolve\u0026lt;IAuditingConfiguration\u0026gt;(); Caching = IocManager.Resolve\u0026lt;ICachingConfiguration\u0026gt;(); BackgroundJobs = IocManager.Resolve\u0026lt;IBackgroundJobConfiguration\u0026gt;(); Notifications = IocManager.Resolve\u0026lt;INotificationConfiguration\u0026gt;(); EmbeddedResources = IocManager.Resolve\u0026lt;IEmbeddedResourcesConfiguration\u0026gt;(); EntityHistory = IocManager.Resolve\u0026lt;IEntityHistoryConfiguration\u0026gt;(); CustomConfigProviders = new List\u0026lt;ICustomConfigProvider\u0026gt;(); ServiceReplaceActions = new Dictionary\u0026lt;Type, Action\u0026gt;(); } 所以，在模块定义的基类 AbpModule 当中，早就注入了 IAbpStartupConfiguration 接口，让你很方便的就可以在模块的预加载的时候配置各种基础设施的参数。举个栗子：\n1 2 3 4 public override void PreInitialize() { Configuration.Caching.ConfigureAll(z=\u0026gt;z.DefaultSlidingExpireTime = TimeSpan.FromHours(1)); } 可以看到这里我们的 Configuration 属性其实就是 IAbpStartupConfiguration 接口。\n2.代码分析 2.1自定义模块配置 我们可以看到 IAbpStartupConfiguration 除了自己拥有大量基础设施的配置类，同时他还继承一个基类叫做 DictionaryBasedConfig ，那么 Abp 框架为什么要这么写呢？\n其实这个基类的作用就是存放用户自定义的 Configuration 类型的，细心观察的话会发现在 AbpStartupConfiguration 的内部有一个 Get 方法，该方法就是用来获取存储的配置类型。\n1 2 3 4 5 public T Get\u0026lt;T\u0026gt;() { // 调用基类的 GetOrCreate 方法，不存在的话直接从 IocContainer 中解析 return GetOrCreate(typeof(T).FullName, () =\u0026gt; IocManager.Resolve\u0026lt;T\u0026gt;()); } 在 DictionaryBasedConfig 中维护了一个字典 CustomSettings ，其 Key/Value 类型为 string/object ，因为在 Abp 框架当中是不知道你自定义模块配置类的类型的，所以存了一个 object 对象。\n然后就有以下用法，首先在模块 PreInitialize() 方法当中注入你需要注入的配置类：\n1 2 3 4 5 6 7 8 9 10 public override void PreInitialize() { // 注入配置类 IocManager.Register\u0026lt;IAbpAspNetCoreConfiguration, AbpAspNetCoreConfiguration\u0026gt;(); // 替换服务，后面讲解 Configuration.ReplaceService\u0026lt;IPrincipalAccessor, AspNetCorePrincipalAccessor\u0026gt;(DependencyLifeStyle.Transient); Configuration.ReplaceService\u0026lt;IAbpAntiForgeryManager, AbpAspNetCoreAntiForgeryManager\u0026gt;(DependencyLifeStyle.Transient); Configuration.ReplaceService\u0026lt;IClientInfoProvider, HttpContextClientInfoProvider\u0026gt;(DependencyLifeStyle.Transient); } 然后针对 IModuleConfigurations 写一个扩展方法，因为在 IModuleConfigurations 内部就有一个 IAbpAspNetCoreConfiguration 的实例，IModuleConfigurations 的注释就说该接口是用于配置模块的，模块可以通过编写扩展方法来添加自己的 Configuration 类：\n1 2 3 4 5 6 7 8 9 10 11 12 public static class AbpAspNetCoreConfigurationExtensions { /// \u0026lt;summary\u0026gt; /// Used to configure ABP ASP.NET Core module. /// \u0026lt;/summary\u0026gt; public static IAbpAspNetCoreConfiguration AbpAspNetCore(this IModuleConfigurations configurations) { // 两种写法都差不多 return configurations.AbpConfiguration.GetOrCreate(\u0026#34;AbpModule\u0026#34;, () =\u0026gt; IocManager.Resolve\u0026lt;IAbpAspNetCoreConfiguration\u0026gt;()); return configurations.AbpConfiguration.Get\u0026lt;IAbpAspNetCoreConfiguration\u0026gt;(); } } 2.2 服务实现替换 在 Abp 当中允许我们替换一些他本身的一些实现，只要你是在模块进行预加载的时候替换的话，都是可以的。而 Abp 他本身在 IAbpStartupConfiguration 当中提供了一个方法叫做 ReplaceService() 方法专门来让你替换服务。\n我们来看一下他的定义：\n1 void ReplaceService(Type type, Action replaceAction); emmmm，传入一个 Type 和 Action,咋跟我看到的不一样呢，Ctrl + N 搜索了一下，发现在模块里面使用的 ReplaceService() 方法是存放在 AbpStartupConfigurationExtensions 里面编写的一个静态方法，其定义如下：\n1 2 3 4 5 6 7 8 9 public static void ReplaceService\u0026lt;TType, TImpl\u0026gt;(this IAbpStartupConfiguration configuration, DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton) where TType : class where TImpl : class, TType { configuration.ReplaceService(typeof(TType), () =\u0026gt; { configuration.IocManager.Register\u0026lt;TType, TImpl\u0026gt;(lifeStyle); }); } 我来看看，传入一个 Type 和 一个 Action ，Type 用来调用 IAbpStartupConfiguration 的同名方法，Action 则是用来注册组件的。\n原来如此，我们再来到 IAbpStartupConfiguration.ReplaceService(Type type, Action replaceAction) 的具体实现：\n1 2 3 4 5 6 public Dictionary\u0026lt;Type, Action\u0026gt; ServiceReplaceActions { get; private set; } public void ReplaceService(Type type, Action replaceAction) { ServiceReplaceActions[type] = replaceAction; } 唔，就是一个字典嘛，我们来看看在什么地方用到过它。\n1 2 3 4 5 6 7 8 9 public override void Initialize() { foreach (var replaceAction in ((AbpStartupConfiguration)Configuration).ServiceReplaceActions.Values) { replaceAction(); } // 其他代码 } 最后我们看到在 AbpKernelModule 的 Initialize() 方法里面就会遍历这个字典，来调用之前存入的 Action 。\n因为 Abp 所有组件的注册都是在模块 Initialize() 内部来进行注册的，而这串代码刚好又放在 AbpKernelModule 的初始化方法的第一行就开始执行，所以确保你替换的组件能够在 Abp 内部组件注册前执行。\n所以当你要替换 Abp 内置组件服务的时候一定要记住在模块的 PreInitialize() 里面执行哦~\n3. 扩展：Abp 支持多数据库 如果你的 Abp 项目有多个数据库上下文实体的时候怎么办呢？\n在 Abp 官方 Demo 当中就有说明，你可以通过替换默认的 IConnectionStringResolver 来实现不同数据库的解析哦~，我们继承 DefaultConnectionStringResolver 实现一个 MulitDbContextConnectionStringResolver。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class MulitDbContextConnectionStringResolver : DefaultConnectionStringResolver { public HKERPConnectionStringResolver(IAbpStartupConfiguration configuration) : base(configuration) { } public override string GetNameOrConnectionString(ConnectionStringResolveArgs args) { if (args[\u0026#34;DbContextConcreteType\u0026#34;] as Type == typeof(ADbContext)) { var configuration = AppConfigurations.Get(WebContentDirectoryFinder.CalculateContentRootFolder()); // 返回 ADbContext 的 ConnectionString return configuration.GetConnectionString(AllConsts.ADbConnectionStringName); } if (args[\u0026#34;DbContextConcreteType\u0026#34;] as Type == typeof(BDbContext)) { var configuration = AppConfigurations.Get(WebContentDirectoryFinder.CalculateContentRootFolder()); // 返回 BDbContext 的 ConnectionString return configuration.GetConnectionString(HKERPCRMConsts.BDbConnectionStringName); } // 都不是则使用默认的数据库连接字符串 return base.GetNameOrConnectionString(args); } } 然后在我们的 EFCore 模块的预加载方法当中加入以下代码：\n1 2 3 4 5 6 7 8 Configuration.ReplaceService(typeof(IConnectionStringResolver), () =\u0026gt; { IocManager.IocContainer.Register( Component.For\u0026lt;IConnectionStringResolver, IDbPerTenantConnectionStringResolver\u0026gt;() .ImplementedBy\u0026lt;MulitDbContextConnectionStringResolver\u0026gt;() .LifestyleTransient() ); }); 当然你也不要忘记在后面通过 AddDbContext() 方法来把你的数据库上下文添加到 Abp 里面去哦。\n1 2 Configuration.Modules.AbpEfCore().AddDbContext\u0026lt;ADbContext\u0026gt;(options=\u0026gt;{ /*配置代码*/}); Configuration.Modules.AbpEfCore().AddDbContext\u0026lt;BDbContext\u0026gt;(options=\u0026gt;{ /*配置代码*/}); ","date":"2018-06-26T10:15:27Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-4-module-configuration/","title":"Abp 源码分析：四、模块配置"},{"content":"0.简要介绍 在 Abp 框架里面，无时无刻不存在依赖注入，关于依赖注入的作用与好处我就不在这里多加赘述了，网上有很多解释的教程。在 [Abp 源码分析]一、Abp 框架启动流程分析 里面已经说过，Abp 本身在框架初始化的时候我们就可以看到它使用 Castle Windsor 将 Asp.Net Core 自带的 IServiceProvider 替换掉了。\n1.大体结构 在 Abp 框架当中，它的依赖注入相关的类型基本上都放在 Abp 项目的 Dependency 文件夹里面，下图是他们之间的依赖关系：\n2 代码解析 2.1 基本实现 IIocManager 是直接继承 IIocRegistrar 与 IIocResolver 的一个接口，通过名称我们就可以看出来他们的作用，IIocRegistrar 内部提供了组件注册的方法定义，而 IIocResolver 内部则是提供了解析已经注入的组件方法。在 IIocManager 本身则是封装了一个 Castle Windsor 的 Ioc 容器，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// \u0026lt;summary\u0026gt; /// This interface is used to directly perform dependency injection tasks. /// \u0026lt;/summary\u0026gt; public interface IIocManager : IIocRegistrar, IIocResolver, IDisposable { /// \u0026lt;summary\u0026gt; /// Reference to the Castle Windsor Container. /// \u0026lt;/summary\u0026gt; IWindsorContainer IocContainer { get; } /// \u0026lt;summary\u0026gt; /// Checks whether given type is registered before. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;type\u0026#34;\u0026gt;Type to check\u0026lt;/param\u0026gt; new bool IsRegistered(Type type); /// \u0026lt;summary\u0026gt; /// Checks whether given type is registered before. /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;Type to check\u0026lt;/typeparam\u0026gt; new bool IsRegistered\u0026lt;T\u0026gt;(); } 那么我们来看看 IIocManager 的具体实现。\n方法虽然看起来挺多，不过更多的只是在 Castle Windsor 上面进行了一层封装而已，可以看到 Register() 这个注册方法在其内部也是直接调用的 IWindsorContainer.Register() 来进行注入。\n那么 Abp 为什么还要再包装一层呢，因为对外开放的你在使用的时候都使用的是 IIocManager 提供的注册方法，那么你需要替换 DI 框架的时候可以很快捷的替换掉整个依赖注入框架而不会影响现有代码。\n1 2 3 4 public void Register(Type type, DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton) { IocContainer.Register(ApplyLifestyle(Component.For(type), lifeStyle)); } 2.2 规约注入 我们重点说一说它的规约注入，什么是规约注入？\n在上面的类图当中，可以看到有一个 IConventionalDependencyRegistrar 接口，并且该接口还拥有四个实现，我们以 BasicConventionalRegistrar 类为例子看看里面做了什么操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /// \u0026lt;summary\u0026gt; /// This class is used to register basic dependency implementations such as \u0026lt;see cref=\u0026#34;ITransientDependency\u0026#34;/\u0026gt; and \u0026lt;see cref=\u0026#34;ISingletonDependency\u0026#34;/\u0026gt;. /// \u0026lt;/summary\u0026gt; public class BasicConventionalRegistrar : IConventionalDependencyRegistrar { public void RegisterAssembly(IConventionalRegistrationContext context) { //Transient context.IocManager.IocContainer.Register( Classes.FromAssembly(context.Assembly) .IncludeNonPublicTypes() .BasedOn\u0026lt;ITransientDependency\u0026gt;() .If(type =\u0026gt; !type.GetTypeInfo().IsGenericTypeDefinition) .WithService.Self() .WithService.DefaultInterfaces() .LifestyleTransient() ); //Singleton context.IocManager.IocContainer.Register( Classes.FromAssembly(context.Assembly) .IncludeNonPublicTypes() .BasedOn\u0026lt;ISingletonDependency\u0026gt;() .If(type =\u0026gt; !type.GetTypeInfo().IsGenericTypeDefinition) .WithService.Self() .WithService.DefaultInterfaces() .LifestyleSingleton() ); //Windsor Interceptors context.IocManager.IocContainer.Register( Classes.FromAssembly(context.Assembly) .IncludeNonPublicTypes() .BasedOn\u0026lt;IInterceptor\u0026gt;() .If(type =\u0026gt; !type.GetTypeInfo().IsGenericTypeDefinition) .WithService.Self() .LifestyleTransient() ); } } 在 BasicConventionalRegistrar 内部，他会扫描传入的程序集，并且根据类型所继承的接口来进行自动注入，所以 Abp 定义了两个辅助注入接口，叫做ITransientDependency 和 ISingletonDependency，并且在下面还注入了拦截器。\n这样的话，我们自己就不需要频繁的使用 IIocManager.Register() 方法来手动注入，只需要在自己的实现类或者接口上面，继承上述两个接口之一即可。\n在 IocManager 内部维护了一个集合 _conventionalRegistrars。\n1 2 3 4 /// \u0026lt;summary\u0026gt; /// List of all registered conventional registrars. /// \u0026lt;/summary\u0026gt; private readonly List\u0026lt;IConventionalDependencyRegistrar\u0026gt; _conventionalRegistrars; 这个集合就是已经存在的规约注册器，在 AbpKernelModule 的预加载方法里面就使用 AddConventionalRegistrar() 方法来添加了 BasicConventionalRegistrar 注册器。代码在 AbpKernelModule.cs 的 45 行：\n1 2 3 4 5 6 public override void PreInitialize() { IocManager.AddConventionalRegistrar(new BasicConventionalRegistrar()); // 其他代码 } 之后每当程序调用 IIocManager.RegisterAssemblyByConvention(Assembly assembly) 方法的时候，就会根据传入的 Assembly 来循环调用存放在集合里面注册器的 RegisterAssembly() 方法，当然你也可以随时定义一个 Registrar ，注册约定你也可以自己来编写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void RegisterAssemblyByConvention(Assembly assembly, ConventionalRegistrationConfig config) { var context = new ConventionalRegistrationContext(assembly, this, config); foreach (var registerer in _conventionalRegistrars) { registerer.RegisterAssembly(context); } if (config.InstallInstallers) { IocContainer.Install(FromAssembly.Instance(assembly)); } } 注：一般来说，每个模块都会在它的 Initialize 方法当中调用 IocManager.RegisterAssemblyByConvention()，将自己传入该方法当中来注入当前模块程序集所有符合规约的组件。\n这里值得注意的是 RegisterAssemblyByConvention() 方法还有一个重载 RegisterAssemblyByConvention(Assembly assembly, ConventionalRegistrationConfig config)，他将会传入一个 ConventionalRegistrationConfig 对象，该对象只有一个 bool InstallInstallers 属性，主要是在注册的时候告诉 Abp 框架是否使用该程序集内部的 IWindsorInstaller 接口规则。\n2.3 初始化过程 呐，首先呢在我们初始化 AbpBootstrapper 的时候，就已经创建好了我们的 IocManager 实例，我们可以来到 AbpBootstrapper.cs 的构造函数有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public IIocManager IocManager { get; } private AbpBootstrapper([NotNull] Type startupModule, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) { Check.NotNull(startupModule, nameof(startupModule)); var options = new AbpBootstrapperOptions(); optionsAction?.Invoke(options); if (!typeof(AbpModule).GetTypeInfo().IsAssignableFrom(startupModule)) { throw new ArgumentException($\u0026#34;{nameof(startupModule)} should be derived from {nameof(AbpModule)}.\u0026#34;); } StartupModule = startupModule; IocManager = options.IocManager; PlugInSources = options.PlugInSources; _logger = NullLogger.Instance; if (!options.DisableAllInterceptors) { AddInterceptorRegistrars(); } } 可以看到在 new 了一个 AbpBootstrapperOptions 对象，并且在第 17 行将 options 创建好的 IocManager 赋值给 AbpBootstrapper 本身的 IocManager 属性。\n那么在 options 内部是如何创建 IIocManager 的呢？\n1 2 3 4 5 public AbpBootstrapperOptions() { IocManager = Abp.Dependency.IocManager.Instance; PlugInSources = new PlugInSourceList(); } 可以看到他直接是使用的 IocManager 这个类所提供的一个静态实例。\n也就是在 IocManager 类里面他有一个静态构造函数：\n1 2 3 4 static IocManager() { Instance = new IocManager(); } 就是这种操作，之后在 IocManager 的构造函数里面呢就将自己再注册到了 Castle Windsor 的容器里面，这样其他的组件就可以直接注入使用 IIocManager 了。\n1 2 3 4 5 6 7 8 9 10 public IocManager() { IocContainer = new WindsorContainer(); _conventionalRegistrars = new List\u0026lt;IConventionalDependencyRegistrar\u0026gt;(); //Register self! IocContainer.Register( Component.For\u0026lt;IocManager, IIocManager, IIocRegistrar, IIocResolver\u0026gt;().UsingFactoryMethod(() =\u0026gt; this) ); } 我们可以回顾一下在替换 Asp.Net Core 自身的 Ioc 容器的时候，在使用的 CreateServiceProvider 就是 Castle Windsor 提供的 IocContainer 对象，该对象就是我们上文在 AbpBootstrapperOptions 里面创建的静态实例。\n1 2 3 4 5 6 7 8 9 public static IServiceProvider AddAbp\u0026lt;TStartupModule\u0026gt;(this IServiceCollection services, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) where TStartupModule : AbpModule { var abpBootstrapper = AddAbpBootstrapper\u0026lt;TStartupModule\u0026gt;(services, optionsAction); ConfigureAspNetCore(services, abpBootstrapper.IocManager); return WindsorRegistrationHelper.CreateServiceProvider(abpBootstrapper.IocManager.IocContainer, services); } 3.初始化流程图 总的来说呢，整个 Abp 框架的依赖注入相关的初始化流程图就像这样。\n","date":"2018-06-22T10:54:00Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-3-dependency-injection/","title":"Abp 源码分析：三、依赖注入"},{"content":"0.参考资料 尊重他人的劳动成果，贴上参考的资料地址，本文仅作学习记录之用。\nhttps://www.codeproject.com/Articles/869059/Topological-sorting-in-Csharp https://songlee24.github.io/2015/05/07/topological-sorting/ https://www.cnblogs.com/skywang12345/p/3711483.html 1.介绍 自己之前并没有接触过拓扑排序，顶多听说过拓扑图。在写前一篇文章的时候，看到 Abp 框架在处理模块依赖项的时候使用了拓扑排序，来确保顶级节点始终是最先进行加载的。第一次看到觉得很神奇，看了一下维基百科头也是略微大，自己的水平也是停留在冒泡排序的层次。ヽ(≧□≦)ノ\n看了第二篇参考资料才大致了解，在此记录一下。\n2.原理 先来一个基本定义：\n在图论中，**拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）**的所有顶点的线性序列。且该序列必须满足下面两个条件：\n每个顶点出现且只出现一次。 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。 有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。\n例如，有一个集合它的依赖关系如下图：\n可以看到他有一个依赖关系:\nModule D 依赖于 Module E 与 Module B 。 Module E 依赖于 Module B 与 Module C 。 Module B 依赖于 Module A 与 Module C 。 Module C 依赖于 Module A 。 Module A 无依赖 。 这个就是一个 DAG 图，我们要得到它的拓扑排序，一个简单的步骤如下：\n从 DAG 图中选择一个没有前驱的顶点并输出。 从 DAG 图中删除该顶点，以及以它为起点的有向边。 重复步骤 1、2 直到当前的 DAG 图为空，或者当前图不存在无前驱的顶点为止。 按照以上步骤，我们来进行一个排序试试。\n最后的排序结果就是：\nModule D -\u0026gt; Module E -\u0026gt; Module B -\u0026gt; Module C -\u0026gt; Module A\nemmmm，其实一个有向无环图可以有一个或者多个拓扑序列的，因为有的时候会存在一种情况，即以下这种情况：\n这个时候你就可能会有这两种结果\nD-\u0026gt;E-\u0026gt;B-\u0026gt;C-\u0026gt;F-\u0026gt;A\nD-\u0026gt;E-\u0026gt;B-\u0026gt;F-\u0026gt;C-\u0026gt;A\n因为 F 与 C 是平级的，他们初始化顺序即便不同也没有什么影响，因为他们的依赖层级是一致的，不过细心的朋友可能会发现这个顺序好像是反的，我们还需要将其再反转一次。\n3.实现 上面这种方法仅适用于已知入度的时候，也就是说这些内容本身就是存在于一个有向无环图之中的，如果按照以上方法进行拓扑排序，你需要维护一个入度为 0 的队列，然后每次迭代移除入度为 0 顶点所指向的顶点入度。\n例如有以下图：\n按照我们之前的算法，\n首先初始化队列，将 5 与 4 这两个入度为 0 的顶点加入队列当中。 执行 While 循环，条件是队列不为空。 之后首先拿出 4 。 然后针对其指向的顶点 0 与 顶点 1 的入度减去 1。 减去指向顶点入度的时候同时判断，被减去入度的顶点其值是否为 0 。 这里 1 入度被减去 1 ，为 0 ，添加到队列。 0 顶点入度减去 1 ，为 1。 队列现在有 5 与 1 这两个顶点，循环判断队列不为空。 5 指向的顶点 0 入度 减去 1，顶点 0 入度为 0 ，插入队列。 这样反复循环，最终队列全部清空，退出循环，得到拓扑排序的结果4, 5, 2, 0, 3, 1 。\n4.深度优先搜索实现 在参考资料 1 的代码当中使用的是深度优先算法，它适用于有向无环图。\n有以下有向环图 G2：\n对上图 G2 进行深度优先遍历，首先从入度为 0 的顶点 A 开始遍历：\n它的步骤如下：\n访问 A 。\n访问 B 。\n访问 C 。\n在访问了 B 后应该是访问 B 的另外一个顶点，这里可以是随机的也可以是有序的，具体取决于你存储的序列顺序，这里先访问 C 。\n访问 E 。\n访问 D 。\n这里访问 D 是因为 B 已经被访问过了，所以访问顶点 D 。\n访问 F 。\n因为顶点 C 已经被访问过，所以应该回溯访问顶点 B 的另一个有向边指向的顶点 F 。\n访问 G 。\n因此最后的访问顺序就是 A -\u0026gt; B -\u0026gt; C -\u0026gt; E -\u0026gt; D -\u0026gt; F -\u0026gt; G ，注意顺序还是不太对哦。\n看起来跟之前的方法差不多，实现当中，其 Sort() 方法内部包含一个 visited 字典，用于标记已经访问过的顶点，sorted 则是已经排序完成的集合列表。\n在字典里 Key 是顶点的值，其 value 值用来标识是否已经访问完所有路径，为 true 则表示正在处理该顶点，为 false 则表示已经处理完成。\n现在我们来写实现吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public static IList\u0026lt;T\u0026gt; Sort\u0026lt;T\u0026gt;(IEnumerable\u0026lt;T\u0026gt; source, Func\u0026lt;T, IEnumerable\u0026lt;T\u0026gt;\u0026gt; getDependencies) { var sorted = new List\u0026lt;T\u0026gt;(); var visited = new Dictionary\u0026lt;T, bool\u0026gt;(); foreach (var item in source) { Visit(item, getDependencies, sorted, visited); } return sorted; } public static void Visit\u0026lt;T\u0026gt;(T item, Func\u0026lt;T, IEnumerable\u0026lt;T\u0026gt;\u0026gt; getDependencies, List\u0026lt;T\u0026gt; sorted, Dictionary\u0026lt;T, bool\u0026gt; visited) { bool inProcess; var alreadyVisited = visited.TryGetValue(item, out inProcess); // 如果已经访问该顶点，则直接返回 if (alreadyVisited) { // 如果处理的为当前节点，则说明存在循环引用 if (inProcess) { throw new ArgumentException(\u0026#34;Cyclic dependency found.\u0026#34;); } } else { // 正在处理当前顶点 visited[item] = true; // 获得所有依赖项 var dependencies = getDependencies(item); // 如果依赖项集合不为空，遍历访问其依赖节点 if (dependencies != null) { foreach (var dependency in dependencies) { // 递归遍历访问 Visit(dependency, getDependencies, sorted, visited); } } // 处理完成置为 false visited[item] = false; sorted.Add(item); } } 顶点定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Item 定义 public class Item { // 条目名称 public string Name { get; private set; } // 依赖项 public Item[] Dependencies { get; set; } public Item(string name, params Item[] dependencies) { Name = name; Dependencies = dependencies; } public override string ToString() { return Name; } } 调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static void Main(string[] args) { var moduleA = new Item(\u0026#34;Module A\u0026#34;); var moduleC = new Item(\u0026#34;Module C\u0026#34;, moduleA); var moduleB = new Item(\u0026#34;Module B\u0026#34;, moduleC); var moduleE = new Item(\u0026#34;Module E\u0026#34;, moduleB); var moduleD = new Item(\u0026#34;Module D\u0026#34;, moduleE); var unsorted = new[] { moduleE, moduleA, moduleD, moduleB, moduleC }; var sorted = Sort(unsorted, x =\u0026gt; x.Dependencies); foreach (var item in sorted) { Console.WriteLine(item.Name); } Console.ReadLine(); } 结果：\n","date":"2018-06-19T23:09:00Z","permalink":"https://real-zony.github.io/p/topological-sorting-using-csharp-code/","title":"使用 C# 代码实现拓扑排序"},{"content":"0.简介 整个 Abp 框架由各个模块组成，基本上可以看做一个程序集一个模块，不排除一个程序集有多个模块的可能性。可以看看他官方的这些扩展库：\n可以看到每个项目文件下面都会有一个 xxxModule 的文件，这里就是存放的模块文件，一个模块拥有四个生命周期，分别为 PreInitialize()(预加载)、Initialize()（初始化）、PostInitialize(初始化完成)、Shutdown()(销毁)，前三个根据我们上一篇文章的代码可以看到，他是先执行预加载方法，然后执行初始化，最后执行初始化完成方法，销毁方法则是程序退出的时候执行。\n模块的主要作用就是在 Abp 框架加载的时候程序集执行初始化操作的，比如说 Abp 库自身的 AbpKernelModule 模块，里面就是各种注入基础设施，执行初始化操作。\n可以看看其中代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public sealed class AbpKernelModule : AbpModule { public override void PreInitialize() { // 注册各种过滤器与基础组件 IocManager.AddConventionalRegistrar(new BasicConventionalRegistrar()); IocManager.Register\u0026lt;IScopedIocResolver, ScopedIocResolver\u0026gt;(DependencyLifeStyle.Transient); IocManager.Register(typeof(IAmbientScopeProvider\u0026lt;\u0026gt;), typeof(DataContextAmbientScopeProvider\u0026lt;\u0026gt;), DependencyLifeStyle.Transient); AddAuditingSelectors(); AddLocalizationSources(); AddSettingProviders(); AddUnitOfWorkFilters(); ConfigureCaches(); AddIgnoredTypes(); AddMethodParameterValidators(); } public override void Initialize() { // 这里是执行替换服务的 Action，Abp 允许用户在预加载操作替换基础设施的服务 foreach (var replaceAction in ((AbpStartupConfiguration)Configuration).ServiceReplaceActions.Values) { replaceAction(); } // 安装领域事件总线的基础设施 IocManager.IocContainer.Install(new EventBusInstaller(IocManager)); IocManager.Register(typeof(IOnlineClientManager\u0026lt;\u0026gt;), typeof(OnlineClientManager\u0026lt;\u0026gt;), DependencyLifeStyle.Singleton); IocManager.RegisterAssemblyByConvention(typeof(AbpKernelModule).GetAssembly(), new ConventionalRegistrationConfig { InstallInstallers = false }); } public override void PostInitialize() { // 权限管理器等初始化才做 RegisterMissingComponents(); IocManager.Resolve\u0026lt;SettingDefinitionManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;FeatureManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;PermissionManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;LocalizationManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;NotificationDefinitionManager\u0026gt;().Initialize(); IocManager.Resolve\u0026lt;NavigationManager\u0026gt;().Initialize(); if (Configuration.BackgroundJobs.IsJobExecutionEnabled) { var workerManager = IocManager.Resolve\u0026lt;IBackgroundWorkerManager\u0026gt;(); workerManager.Start(); workerManager.Add(IocManager.Resolve\u0026lt;IBackgroundJobManager\u0026gt;()); } } public override void Shutdown() { // 停止所有后台工作者 if (Configuration.BackgroundJobs.IsJobExecutionEnabled) { IocManager.Resolve\u0026lt;IBackgroundWorkerManager\u0026gt;().StopAndWaitToStop(); } } } 1.模块发现与注册 1.1 发现模块 1.1.1 搜索所有定义的模块类型 我们定义好模块之后，Abp 如何发现我们的模块呢？\n在最外部，我们使用 services.AddAbp\u0026lt;TStartModule\u0026gt;() 的时候，就传入了启动模块类型。\n在之前 AbpBootstrapper 的 Initialize() 初始化方法当中通过调用 AbpModuleManager.Initialize(Type startupModule) 方法来初始化，在其内部可以看到：\n1 2 3 4 5 public virtual void Initialize(Type startupModule) { _modules = new AbpModuleCollection(startupModule); LoadAllModules(); } 这里通过传入启动模块来初始化 AboModuleCollection 类。\n1 2 3 4 5 6 7 8 9 10 11 internal class AbpModuleCollection : List\u0026lt;AbpModuleInfo\u0026gt; { public Type StartupModuleType { get; } public AbpModuleCollection(Type startupModuleType) { StartupModuleType = startupModuleType; } // 其他代码 } 初始化完成之后，继续调用 LoadAllModules() 方法，这里就开始加载模块了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private void LoadAllModules() { Logger.Debug(\u0026#34;Loading Abp modules...\u0026#34;); List\u0026lt;Type\u0026gt; plugInModuleTypes; // 发现所有 Abp 模块 var moduleTypes = FindAllModuleTypes(out plugInModuleTypes).Distinct().ToList(); Logger.Debug(\u0026#34;Found \u0026#34; + moduleTypes.Count + \u0026#34; ABP modules in total.\u0026#34;); // 注册 Abp 模块 RegisterModules(moduleTypes); // 创建模块对应的 AbpModuleInfo 包装类 CreateModules(moduleTypes, plugInModuleTypes); // 将核心模块放在第一位初始化 _modules.EnsureKernelModuleToBeFirst(); // 将启动模块放在最后一位进行初始化 _modules.EnsureStartupModuleToBeLast(); // 设置每个 ModuleInfo 的依赖关系 SetDependencies(); Logger.DebugFormat(\u0026#34;{0} modules loaded.\u0026#34;, _modules.Count); } 继续跳转，来到内部 FindAllModuleTypes() 方法，在这个方法里面我们可以看到他调用了 AbpModule 的一个静态方法来根据其启动模块，之后通过启动模块上面的 DependsOnAttribute 特性来递归找到它所有的依赖模块。\n1 2 3 4 5 6 7 8 9 private List\u0026lt;Type\u0026gt; FindAllModuleTypes(out List\u0026lt;Type\u0026gt; plugInModuleTypes) { plugInModuleTypes = new List\u0026lt;Type\u0026gt;(); var modules = AbpModule.FindDependedModuleTypesRecursivelyIncludingGivenModule(_modules.StartupModuleType); // 其他代码 return modules; } 找到模块之后，在 RegisterModules() 里面通过 IocManager 的注册方法，将所有模块都注入到 Ioc 容器当中，注意这里注册的所有的 Abp 模块都是单例对象。\n1.1.2 包装模块信息 在 LoadAllModules() 方法里面，通过 CreateModules() 方法来包装好 ModuleInfo 类并且将其放在之前初始化完成的 AbpModuleCollection 对象 _modules 里面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private void CreateModules(ICollection\u0026lt;Type\u0026gt; moduleTypes, List\u0026lt;Type\u0026gt; plugInModuleTypes) { foreach (var moduleType in moduleTypes) { // 解析刚才在 RegisterModules 里面注册的单例模块对象 var moduleObject = _iocManager.Resolve(moduleType) as AbpModule; if (moduleObject == null) { throw new AbpInitializationException(\u0026#34;This type is not an ABP module: \u0026#34; + moduleType.AssemblyQualifiedName); } // 为这些模块对象初始化基础设施 moduleObject.IocManager = _iocManager; moduleObject.Configuration = _iocManager.Resolve\u0026lt;IAbpStartupConfiguration\u0026gt;(); // 包装成为 ModuleInfo var moduleInfo = new AbpModuleInfo(moduleType, moduleObject, plugInModuleTypes.Contains(moduleType)); _modules.Add(moduleInfo); if (moduleType == _modules.StartupModuleType) { StartupModule = moduleInfo; } Logger.DebugFormat(\u0026#34;Loaded module: \u0026#34; + moduleType.AssemblyQualifiedName); } } 在每个 ModuleInfo 对象内部都存放有该模块的模块类型信息，以及他的单例对象实例。\n1.1.3 确定基本的模块加载顺序 模块在进行加载的时候，第一个加载的模块一定是从核心模块，最后加载的模块肯定是启动模块。所以，这里的 AbpModuleCollection 提供了两个方法，一个是 EnsureKernelModuleToBeFirst() ，一个是 EnsureStartupModuleToBeLast() 。这两个方法的作用第一个就是将 AbpKernelModule 放在第一位，第二个就是将启动模块放在集合的末尾。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static void EnsureKernelModuleToBeFirst(List\u0026lt;AbpModuleInfo\u0026gt; modules) { var kernelModuleIndex = modules.FindIndex(m =\u0026gt; m.Type == typeof(AbpKernelModule)); if (kernelModuleIndex \u0026lt;= 0) { // 如果 AbpKernelModule 位于首位则不移动位置 return; } var kernelModule = modules[kernelModuleIndex]; modules.RemoveAt(kernelModuleIndex); modules.Insert(0, kernelModule); } public static void EnsureStartupModuleToBeLast(List\u0026lt;AbpModuleInfo\u0026gt; modules, Type startupModuleType) { var startupModuleIndex = modules.FindIndex(m =\u0026gt; m.Type == startupModuleType); if (startupModuleIndex \u0026gt;= modules.Count - 1) { // 如果启动模块位于尾部则则不移动位置 return; } var startupModule = modules[startupModuleIndex]; modules.RemoveAt(startupModuleIndex); modules.Add(startupModule); } 1.2 依赖解析 之前这些步骤已经将我们程序所使用到的所有模块已经加载完成，并且进行了一个基本的排序操作，以确保我们的模块加载顺序没有大问题。但是仅仅这样是不够的， 我们还需要确保我们依赖的模块比被引用的模块要先加载，这个时候就需要确定每个模块的依赖关系，并且根据这个依赖关系再次进行排序。\n1.2.1 设置每个模块的依赖模块 因为我们之前为每个模块包装了一个 ModuleInfo实例，在 ModuleInfo 内部还有一个属性，叫做：\n1 2 3 4 /// \u0026lt;summary\u0026gt; /// All dependent modules of this module. /// \u0026lt;/summary\u0026gt; public List\u0026lt;AbpModuleInfo\u0026gt; Dependencies { get; } 所以，在 LoadAllModules() 方法里面还调用了一个方法，叫做 SetDependencies()，这个方法也是很简单的，遍历已经加载完成的 _modules 集合，在里面再根据 AbpModule 提供的 FindDependedModuleTypes() 方法来获取该模块的所有依赖模块类型。找到之后，在 AbpModuleInfo 集合里面查找对应的依赖模块的的 ModuleInfo 信息添加到目标模块的 Dependencies 集合内部。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void SetDependencies() { foreach (var moduleInfo in _modules) { moduleInfo.Dependencies.Clear(); //Set dependencies for defined DependsOnAttribute attribute(s). foreach (var dependedModuleType in AbpModule.FindDependedModuleTypes(moduleInfo.Type)) { var dependedModuleInfo = _modules.FirstOrDefault(m =\u0026gt; m.Type == dependedModuleType); if (dependedModuleInfo == null) { throw new AbpInitializationException(\u0026#34;Could not find a depended module \u0026#34; + dependedModuleType.AssemblyQualifiedName + \u0026#34; for \u0026#34; + moduleInfo.Type.AssemblyQualifiedName); } if ((moduleInfo.Dependencies.FirstOrDefault(dm =\u0026gt; dm.Type == dependedModuleType) == null)) { moduleInfo.Dependencies.Add(dependedModuleInfo); } } } } 1.2.2 确定正确的模块加载顺序 在所有基本信息加载完成之后，Abp 并没有在 AbpModuleManager 的 Initialize() 里面来进行这个重新排序操作，而是在 StartModules() 方法里面来重新排序。\n在 StartModules() 通过 AbpModuleCollection 提供的 GetSortedModuleListByDependency() 方法来根据依赖项重新进行了一次排序。\n1 2 3 4 5 6 7 public List\u0026lt;AbpModuleInfo\u0026gt; GetSortedModuleListByDependency() { var sortedModules = this.SortByDependencies(x =\u0026gt; x.Dependencies); EnsureKernelModuleToBeFirst(sortedModules); EnsureStartupModuleToBeLast(sortedModules, StartupModuleType); return sortedModules; } 这里使用的是存放在 \\Abp\\src\\Abp\\Collections\\Extensions\\ListExtensions.cs 的一个扩展方法 List\u0026lt;T\u0026gt; SortByDependencies\u0026lt;T\u0026gt;(this IEnumerable\u0026lt;T\u0026gt; source, Func\u0026lt;T, IEnumerable\u0026lt;T\u0026gt;\u0026gt; getDependencies)，他是针对 List\u0026lt;T\u0026gt; 集合实现的一种拓扑排序。\n排序之后的结果就是按照依赖关系来存放的一个集合，之后通过 List 的 Foreach 方法循环调用其三个生命周期方法即可。\n1 2 3 4 5 6 7 public virtual void StartModules() { var sortedModules = _modules.GetSortedModuleListByDependency(); sortedModules.ForEach(module =\u0026gt; module.Instance.PreInitialize()); sortedModules.ForEach(module =\u0026gt; module.Instance.Initialize()); sortedModules.ForEach(module =\u0026gt; module.Instance.PostInitialize()); } 1.2.3 扩展：拓扑排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 /// \u0026lt;summary\u0026gt; /// Extension methods for \u0026lt;see cref=\u0026#34;IList{T}\u0026#34;/\u0026gt;. /// \u0026lt;/summary\u0026gt; public static class ListExtensions { /// \u0026lt;summary\u0026gt; /// Sort a list by a topological sorting, which consider their dependencies /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;The type of the members of values.\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;source\u0026#34;\u0026gt;A list of objects to sort\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;getDependencies\u0026#34;\u0026gt;Function to resolve the dependencies\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static List\u0026lt;T\u0026gt; SortByDependencies\u0026lt;T\u0026gt;(this IEnumerable\u0026lt;T\u0026gt; source, Func\u0026lt;T, IEnumerable\u0026lt;T\u0026gt;\u0026gt; getDependencies) { /* See: http://www.codeproject.com/Articles/869059/Topological-sorting-in-Csharp * http://en.wikipedia.org/wiki/Topological_sorting */ var sorted = new List\u0026lt;T\u0026gt;(); var visited = new Dictionary\u0026lt;T, bool\u0026gt;(); foreach (var item in source) { SortByDependenciesVisit(item, getDependencies, sorted, visited); } return sorted; } /// \u0026lt;summary\u0026gt; /// /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;The type of the members of values.\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;Item to resolve\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;getDependencies\u0026#34;\u0026gt;Function to resolve the dependencies\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;sorted\u0026#34;\u0026gt;List with the sortet items\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;visited\u0026#34;\u0026gt;Dictionary with the visited items\u0026lt;/param\u0026gt; private static void SortByDependenciesVisit\u0026lt;T\u0026gt;(T item, Func\u0026lt;T, IEnumerable\u0026lt;T\u0026gt;\u0026gt; getDependencies, List\u0026lt;T\u0026gt; sorted, Dictionary\u0026lt;T, bool\u0026gt; visited) { bool inProcess; var alreadyVisited = visited.TryGetValue(item, out inProcess); if (alreadyVisited) { if (inProcess) { throw new ArgumentException(\u0026#34;Cyclic dependency found! Item: \u0026#34; + item); } } else { visited[item] = true; var dependencies = getDependencies(item); if (dependencies != null) { foreach (var dependency in dependencies) { SortByDependenciesVisit(dependency, getDependencies, sorted, visited); } } visited[item] = false; sorted.Add(item); } } } 后面专门写文章讲解一下拓扑排序，这里贴上代码，后面会改为文章链接的。 贴上详解链接： https://blog.myzony.com/shi-yong-c-dai-ma-shi-xian-tuo-bu-pai-xu/\n2.结语 本篇文章主要针对模块系统进行了一个较为详细地分析，后面将会讲解 Abp 依赖注入相关的代码，如果你觉得对你有用请点个赞，谢谢。\n","date":"2018-06-19T07:57:00Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-2-module-system/","title":"Abp 源码分析：二、模块系统"},{"content":" Abp 不一定仅用于 Asp.Net Core 项目，他也可以在 Console 与 WinFrom 项目当中进行使用，所以关于启动流程可以分为两种，一种是 Asp.Net Core 项目的启动流程，另外则是 ConsoleApplication/WinFrom 项目的启动流程，在这里我则是通过 Asp.Net Core 项目的启动流程来分析，但是他们的核心都是 AbpBootstrapper 这个类。\n本文章基于 Abp 框架的最新版本 v3.7.2 。\n一、Abp 的入口点 1.1 添加服务与启用中间件 要在 Asp.Net Core 项目当中使用 Abp 框架的话，第一步当然是先添加 Abp.AspNetCore 库啦，之后在我们 Startup 类的 ConfigureAbpService(IServiceCollection services) 方法里面使用 AddAbp\u0026lt;TStartupModule\u0026gt;。比如像这样：\n1 2 3 4 public IServiceProvider ConfigureServices(IServiceCollection services) { return services.AddAbp\u0026lt;HKAbpDemoHostModule\u0026gt;(); } 注意，这里我们 ConfigureService 返回类型变成了 IServiceProvider ，这是因为在 AddAbp 方法内部替换了 Ioc 容器，变成了 CastleWindsor，后面会接着分析的。\n然后我们的 Configure(IApplicationBuilder app, IHostingEnvironment env) 方法里面也会有如下代码：\n1 2 3 4 public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseAbp(); } 1.2 配置服务 之后来到 AddAbp 方法内部，文件目录位置如下：\n1 2 3 4 5 6 7 8 9 10 Abp\\src\\Abp.AspNetCore\\AspNetCore\\AbpServiceCollectionExtensions.cs public static IServiceProvider AddAbp\u0026lt;TStartupModule\u0026gt;(this IServiceCollection services, [CanBeNull] Action\u0026lt;AbpBootstrapperOptions\u0026gt; optionsAction = null) where TStartupModule : AbpModule { var abpBootstrapper = AddAbpBootstrapper\u0026lt;TStartupModule\u0026gt;(services, optionsAction); ConfigureAspNetCore(services, abpBootstrapper.IocManager); return WindsorRegistrationHelper.CreateServiceProvider(abpBootstrapper.IocManager.IocContainer, services); } 1.2.1 注入 AbpBootstrapper 在 AddAbpBootstrapper() 方法内部将使用 AbpBootstrapper 的 Create 方法创建一个新的 AbpBootstrapper 实例。并且通过 IServiceCollection 将其注入到 Ioc 容器当中。\n1.2.2 配置 AspNetCore 相关参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 private static void ConfigureAspNetCore(IServiceCollection services, IIocResolver iocResolver) { //See https://github.com/aspnet/Mvc/issues/3936 to know why we added these services. services.TryAddSingleton\u0026lt;IHttpContextAccessor, HttpContextAccessor\u0026gt;(); services.TryAddSingleton\u0026lt;IActionContextAccessor, ActionContextAccessor\u0026gt;(); //Use DI to create controllers services.Replace(ServiceDescriptor.Transient\u0026lt;IControllerActivator, ServiceBasedControllerActivator\u0026gt;()); //Use DI to create view components services.Replace(ServiceDescriptor.Singleton\u0026lt;IViewComponentActivator, ServiceBasedViewComponentActivator\u0026gt;()); //Change anti forgery filters (to work proper with non-browser clients) services.Replace(ServiceDescriptor.Transient\u0026lt;AutoValidateAntiforgeryTokenAuthorizationFilter, AbpAutoValidateAntiforgeryTokenAuthorizationFilter\u0026gt;()); services.Replace(ServiceDescriptor.Transient\u0026lt;ValidateAntiforgeryTokenAuthorizationFilter, AbpValidateAntiforgeryTokenAuthorizationFilter\u0026gt;()); //Add feature providers var partManager = services.GetSingletonServiceOrNull\u0026lt;ApplicationPartManager\u0026gt;(); partManager?.FeatureProviders.Add(new AbpAppServiceControllerFeatureProvider(iocResolver)); //Configure JSON serializer services.Configure\u0026lt;MvcJsonOptions\u0026gt;(jsonOptions =\u0026gt; { jsonOptions.SerializerSettings.ContractResolver = new AbpContractResolver { NamingStrategy = new CamelCaseNamingStrategy() }; }); //Configure MVC services.Configure\u0026lt;MvcOptions\u0026gt;(mvcOptions =\u0026gt; { mvcOptions.AddAbp(services); }); //Configure Razor services.Insert(0, ServiceDescriptor.Singleton\u0026lt;IConfigureOptions\u0026lt;RazorViewEngineOptions\u0026gt;\u0026gt;( new ConfigureOptions\u0026lt;RazorViewEngineOptions\u0026gt;( (options) =\u0026gt; { options.FileProviders.Add(new EmbeddedResourceViewFileProvider(iocResolver)); } ) ) ); } 其方法内部做了比较多的工作，主要是配置与 Asp.Net Core 相关的一些配置，比如替换一些默认的服务呀这些。这里重点注意一下这段代码：\n1 mvcOptions.AddAbp(services); 这是 Abp 所写的一个静态方法，这里面就是添加 Abp 内部所实现的过滤器的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 internal static class AbpMvcOptionsExtensions { public static void AddAbp(this MvcOptions options, IServiceCollection services) { AddConventions(options, services); AddFilters(options); AddModelBinders(options); } private static void AddConventions(MvcOptions options, IServiceCollection services) { options.Conventions.Add(new AbpAppServiceConvention(services)); } private static void AddFilters(MvcOptions options) { options.Filters.AddService(typeof(AbpAuthorizationFilter)); options.Filters.AddService(typeof(AbpAuditActionFilter)); options.Filters.AddService(typeof(AbpValidationActionFilter)); options.Filters.AddService(typeof(AbpUowActionFilter)); options.Filters.AddService(typeof(AbpExceptionFilter)); options.Filters.AddService(typeof(AbpResultFilter)); } private static void AddModelBinders(MvcOptions options) { options.ModelBinderProviders.Insert(0, new AbpDateTimeModelBinderProvider()); } } 1.2.3 替换 Ioc 容器 最后一句话即：\n1 return WindsorRegistrationHelper.CreateServiceProvider(abpBootstrapper.IocManager.IocContainer, services); 就是替换掉了 Asp.Net Core 默认的 Ioc 容器，不是 IServiceCollection 了，而是 CastleWindsor 的 IocContainer。\n1.3 启用服务 在 Startup 的 Configure 方法当中我们使用了 app.UseAbp() 来启用 Abp 框架，他的定义可以在以下位置找到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Abp\\src\\Abp.AspNetCore\\AspNetCore\\AbpApplicationBuilderExtensions.cs public static void UseAbp([NotNull] this IApplicationBuilder app, Action\u0026lt;AbpApplicationBuilderOptions\u0026gt; optionsAction) { Check.NotNull(app, nameof(app)); var options = new AbpApplicationBuilderOptions(); optionsAction?.Invoke(options); if (options.UseCastleLoggerFactory) { app.UseCastleLoggerFactory(); } InitializeAbp(app); if (options.UseAbpRequestLocalization) { //TODO: This should be added later than authorization middleware! app.UseAbpRequestLocalization(); } if (options.UseSecurityHeaders) { app.UseAbpSecurityHeaders(); } } 它可以允许用户自己配置一些相关的参数，并且在 InitializeAbp(app) 里面进行了初始化操作。\n跳转到 InitializeAbp(app) 定义的地方：\n1 2 3 4 5 6 7 8 private static void InitializeAbp(IApplicationBuilder app) { var abpBootstrapper = app.ApplicationServices.GetRequiredService\u0026lt;AbpBootstrapper\u0026gt;(); abpBootstrapper.Initialize(); var applicationLifetime = app.ApplicationServices.GetService\u0026lt;IApplicationLifetime\u0026gt;(); applicationLifetime.ApplicationStopping.Register(() =\u0026gt; abpBootstrapper.Dispose()); } 这里通过 IServiceProvider 获取到之前 AddAbp 注入的 AbpBootstrapper 对象，并且调用其初始化方法。\n这里还注册了一个生命周期事件，当程序停止的时候调用 AbpBootstrapper 的销毁方法。\n二、Abp 框架初始化 整个 Abp 框架启动之后的初始化操作都存放在 AbpBootstrapper 当中，包括框架内部的各种基础设施的注入与所有模块加载操作，在上文可以看到是调用的 Initialize() 方法来进行初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public virtual void Initialize() { ResolveLogger(); try { RegisterBootstrapper(); IocManager.IocContainer.Install(new AbpCoreInstaller()); IocManager.Resolve\u0026lt;AbpPlugInManager\u0026gt;().PlugInSources.AddRange(PlugInSources); IocManager.Resolve\u0026lt;AbpStartupConfiguration\u0026gt;().Initialize(); _moduleManager = IocManager.Resolve\u0026lt;AbpModuleManager\u0026gt;(); _moduleManager.Initialize(StartupModule); _moduleManager.StartModules(); } catch (Exception ex) { _logger.Fatal(ex.ToString(), ex); throw; } } 1.1 注入基础设施 基础设施的注入是通过 Windsor 的 IocContainer 来注册所有基础设施的，可以看到他使用 Install() 方法来注册。我们可以看一下 AbpCoreInstaller 的定义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 internal class AbpCoreInstaller : IWindsorInstaller { public void Install(IWindsorContainer container, IConfigurationStore store) { container.Register( Component.For\u0026lt;IUnitOfWorkDefaultOptions, UnitOfWorkDefaultOptions\u0026gt;().ImplementedBy\u0026lt;UnitOfWorkDefaultOptions\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;INavigationConfiguration, NavigationConfiguration\u0026gt;().ImplementedBy\u0026lt;NavigationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ILocalizationConfiguration, LocalizationConfiguration\u0026gt;().ImplementedBy\u0026lt;LocalizationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAuthorizationConfiguration, AuthorizationConfiguration\u0026gt;().ImplementedBy\u0026lt;AuthorizationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IValidationConfiguration, ValidationConfiguration\u0026gt;().ImplementedBy\u0026lt;ValidationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IFeatureConfiguration, FeatureConfiguration\u0026gt;().ImplementedBy\u0026lt;FeatureConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ISettingsConfiguration, SettingsConfiguration\u0026gt;().ImplementedBy\u0026lt;SettingsConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IModuleConfigurations, ModuleConfigurations\u0026gt;().ImplementedBy\u0026lt;ModuleConfigurations\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IEventBusConfiguration, EventBusConfiguration\u0026gt;().ImplementedBy\u0026lt;EventBusConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IMultiTenancyConfig, MultiTenancyConfig\u0026gt;().ImplementedBy\u0026lt;MultiTenancyConfig\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ICachingConfiguration, CachingConfiguration\u0026gt;().ImplementedBy\u0026lt;CachingConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAuditingConfiguration, AuditingConfiguration\u0026gt;().ImplementedBy\u0026lt;AuditingConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IBackgroundJobConfiguration, BackgroundJobConfiguration\u0026gt;().ImplementedBy\u0026lt;BackgroundJobConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;INotificationConfiguration, NotificationConfiguration\u0026gt;().ImplementedBy\u0026lt;NotificationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IEmbeddedResourcesConfiguration, EmbeddedResourcesConfiguration\u0026gt;().ImplementedBy\u0026lt;EmbeddedResourcesConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAbpStartupConfiguration, AbpStartupConfiguration\u0026gt;().ImplementedBy\u0026lt;AbpStartupConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IEntityHistoryConfiguration, EntityHistoryConfiguration\u0026gt;().ImplementedBy\u0026lt;EntityHistoryConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ITypeFinder, TypeFinder\u0026gt;().ImplementedBy\u0026lt;TypeFinder\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAbpPlugInManager, AbpPlugInManager\u0026gt;().ImplementedBy\u0026lt;AbpPlugInManager\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAbpModuleManager, AbpModuleManager\u0026gt;().ImplementedBy\u0026lt;AbpModuleManager\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAssemblyFinder, AbpAssemblyFinder\u0026gt;().ImplementedBy\u0026lt;AbpAssemblyFinder\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ILocalizationManager, LocalizationManager\u0026gt;().ImplementedBy\u0026lt;LocalizationManager\u0026gt;().LifestyleSingleton() ); } } 可以看到他注入了很多配置项，比如说缓存，权限配置，还有模块管理器之类的，这些我会在以后的文章当中进行具体解释。\n他继承了 IWindsorInstaller 接口，这个是 CastleWindsor 所提供的，专门用于某一些功能的类型进行统一注册，除了 AbpCoreInstaller 其实还有 EventBusInstaller 这个是用于注册事件总线相关类型的，后面再讲。\n1.2 模块初始化 1.2.1 加载模块 1 2 _moduleManager = IocManager.Resolve\u0026lt;AbpModuleManager\u0026gt;(); _moduleManager.Initialize(StartupModule); 通过 ModuleManager.Initialize() 来加载所有模块。\n1 2 3 4 5 public virtual void Initialize(Type startupModule) { _modules = new AbpModuleCollection(startupModule); LoadAllModules(); } 他的内部首先初始化了一个集合，这是 Abp 自己定义的，它的本质就是一个集合，只不过提供了一些诸如根据依赖关系来排序的操作，下面的 LoadAllModules() 则是真正的加载模块了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private void LoadAllModules() { Logger.Debug(\u0026#34;Loading Abp modules...\u0026#34;); List\u0026lt;Type\u0026gt; plugInModuleTypes; var moduleTypes = FindAllModuleTypes(out plugInModuleTypes).Distinct().ToList(); Logger.Debug(\u0026#34;Found \u0026#34; + moduleTypes.Count + \u0026#34; ABP modules in total.\u0026#34;); RegisterModules(moduleTypes); CreateModules(moduleTypes, plugInModuleTypes); _modules.EnsureKernelModuleToBeFirst(); _modules.EnsureStartupModuleToBeLast(); SetDependencies(); Logger.DebugFormat(\u0026#34;{0} modules loaded.\u0026#34;, _modules.Count); } 这里很简单了，首先在 FindAllModuleTypes() 方法内部通过启动模块上面的 [DependsOn] 标签来从最外层加载插件形式的模块与内部模块。\n之后将通过 RegisterModules 所有模块单例注入到 Ioc 容器内部，而 CreateModules() 方法则为每个模块来配置里面的一些公有属性，并且将其包装到 AbpModuleInfo 里面。\n你可能会有疑问，已经有了模块的类型，为什么还要一层包装。\n因为为了确保模块按正确的顺序来进行加载，所以需要拥有每个模块的详细信息，主要是依赖信息，正确的顺序应该是核心模块在最里层，而启动模块应该是在最底层的。所以在后面他还调用了 AbpModuleManager 的 EnsureKernelModuleToBeFirst() 方法与 EnsureStartupModuleToBeLast() 方法，以确保正确的加载顺序。\n而 SetDependencies() 方法则是来为每一个 ModuleInfo 配置正确的依赖关系。\n1.2.2 初始化模块 所有模块的依赖关系与实例都已经被存放到了 AbpModuleCollection 里面了，下面就来启动这些模块了，启动模块的方法则是 StartModules()。\n1 2 3 4 5 6 7 public virtual void StartModules() { var sortedModules = _modules.GetSortedModuleListByDependency(); sortedModules.ForEach(module =\u0026gt; module.Instance.PreInitialize()); sortedModules.ForEach(module =\u0026gt; module.Instance.Initialize()); sortedModules.ForEach(module =\u0026gt; module.Instance.PostInitialize()); } 可以看到这里的 GetSortedModuleListByDependency() 方法就是根据依赖关系来进行最后的排序，以确保模块加载顺序的正确。\n后面则没什么了，使用 ForEach 来按照正常的生命周期来调用所有模块的几个生命周期方法。\n可以看到这里没有调用 ShutDown() 方法是因为这个方法只有当程序结束的时候才会调用，他被单独包装到了一个方法当中。\n1 2 3 4 5 6 7 8 9 10 public virtual void ShutdownModules() { Logger.Debug(\u0026#34;Shutting down has been started\u0026#34;); var sortedModules = _modules.GetSortedModuleListByDependency(); sortedModules.Reverse(); sortedModules.ForEach(sm =\u0026gt; sm.Instance.Shutdown()); Logger.Debug(\u0026#34;Shutting down completed.\u0026#34;); } 而 ShutdownModules() 则是在我们的 AbpBootStrapper 的 Dispose 时候才被调用，他什么时候被销毁的呢？就是我们最开始 app.UseAbp() 的时候与 IApplicationLifetime 的 ApplicationStopping 绑定的。\n三、结束语 本篇文章主要将了 ABP 框架的一个基本启动流程，很简单并不深入，后续会继续发文，因为之前看的是 HK Zhang 的文章，但是他是基于很早之前的版本，在工作中也经常针对 Abp 源码进行一些扩展和更改，所以想写一些这方面的文章，后续也会在分析当中贴上具体应用 Abp 框架时候的坑。\n","date":"2018-06-15T04:48:00Z","permalink":"https://real-zony.github.io/p/abp-source-code-analysis-1-analysis-of-abp-framework-startup-process/","title":"Abp 源码分析：一、Abp 框架启动流程分析"},{"content":"0.简介 0.1 什么是 Consul Consul是HashiCorp公司推出的开源工具，用于实现分布式系统的服务发现与配置。\n这里所谓的服务，不仅仅包括常用的 Api 这些服务，也包括软件开发过程当中所需要的诸如 Rpc、Redis、Mysql 等需要调用的资源。\n简而言之 Consul 就是根据 Key/Value 存储了一套所有服务的 IP/Port 集合，当你 Grpc 客户端需要请求某种服务的时候，具体的 IP 与端口不需要你自己来进行指定，而是通过与 Consul Agent 通信获得某个服务下面可用的 IP/Port 集合。\n而 Consul 还提供了健康检查等附加的功能，你可以通过对可用服务节点的遍历来自己进行负载均衡或者服务选择。\n0.2 为什么要用 Consul 没用 Consul 之前的情况是，我 new 一个 Channel 的话，需要指定 Grpc Server 的地址与端口，一单服务挂掉或者 Grpc Server 的 IP 地址或者端口有变更，那么我还得重新更改 setting 才能够使用我的服务。\n使用了 Consul 之后我只需要去 Consul Agent 里面查询我指定的服务有哪些节点可用，返回给我对应的 IP 地址和端口，我就可以进行连接了。\n1.准备工作 1.1 Consul 集群安装与配置 Consul 我是直接使用 Docker 的官方 Consul 镜像来进行安装的，直接执行以下命令 pull 到最新的镜像：\n1 docker pull consul 拿到之后我们先运行一个服务：\n1 docker run -d --name=dev-consul-server1 -e CONSUL_BIND_INTERFACE=eth0 consul agent -server -bootstrap 之后我们再运行两个 Consul Server:\n1 docker run -d --name=dev-consul-server2 -e CONSUL_BIND_INTERFACE=eth0 consul agent -server -retry-join 172.17.0.20 这里 172.17.0.20 是之前 dev-consul-server1 的 IP 地址。\n1 docker run -d --name=dev-consul-server3 -e CONSUL_BIND_INTERFACE=eth0 consul agent -server -retry-join 172.17.0.20 我们可以运行 consul members 命令来查看 Consul 集群信息：\n1 2 3 4 5 docker exec -t dev-consul-server1 consul members Node Address Status Type Build Protocol DC Segment 5019b941791a 172.17.0.20:8301 alive server 1.1.0 2 dc1 \u0026lt;all\u0026gt; ac53858f8c34 172.17.0.21:8301 alive server 1.1.0 2 dc1 \u0026lt;all\u0026gt; fc3aba2ddc25 172.17.0.22:8301 alive server 1.1.0 2 dc1 \u0026lt;all\u0026gt; 可以看到已经有 3 个 Consul Server 启动了。\n下面我们再来运行一个 Consul Client 作为服务注册与发现的端口：\n1 docker run -d -p 8500:8500 --name=dev-consul-client -e CONSUL_BIND_INTERFACE=eth0 -e CONSUL_UI_BETA=true consul agent -retry-join 172.17.0.20 -bind 0.0.0.0 -ui -client 0.0.0.0 这里注意 -bind 与 -client 命令是你绑定的 IP 地址，这里我直接将其与 0.0.0.0 绑定，而 -e CONSUL_UI_BETA=true 则是用于启动新版本的 WebUI 界面，-ui 是启用 WebUI 界面。\n启动完成之后我们可以访问已经启动的 Client Agent 了：\n2.客户端与服务端编写 在这里我以 Abp 框架作为演示，如何编写一个支持 Consul 的 Grpc 服务端与 Grpc 客户端，在演示当中所使用到的 Abp.Grpc.Server 包与 Abp.Grpc.Client 包可以从 NuGet 站点当中搜索安装，其源代码我托管到 GitHub 上面的，地址为：https://github.com/GameBelial/Abp.Grpc，欢迎 Star。\n2.1 Grpc 服务端编写 2.1.1 Abp 集成 首先建立一个标准的 ASP.NET Core Web Application 程序，引入 Abp、Abp.AspNetCore、Abp.Grpc.Server 包，项目取名为 Abp.Grpc.Server.Demo，类型选择空项目，在我们的 Startup 类当中编写如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 using Abp.AspNetCore; using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.DependencyInjection; using System; namespace Abp.Grpc.Server.Demo { public class Startup { // This method gets called by the runtime. Use this method to add services to the container. // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940 public IServiceProvider ConfigureServices(IServiceCollection services) { // 添加 MVC services.AddMvc(); // 添加 ABP 框架，注意更改 ConfigureServices 返回值为 IServiceProvider return services.AddAbp\u0026lt;AbpGrpcServerDemoModule\u0026gt;(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // 启用 ABP 框架中间件 app.UseAbp(); // 启用 MVC 中间件 app.UseMvc(routes =\u0026gt; { routes.MapRoute( name: \u0026#34;defaultWithArea\u0026#34;, template: \u0026#34;{area}/{controller=Home}/{action=Index}/{id?}\u0026#34;); routes.MapRoute( name: \u0026#34;default\u0026#34;, template: \u0026#34;{controller=Home}/{action=Index}/{id?}\u0026#34;); }); } } } 2.1.2 建立项目启动模块 新建一个 AbpGrpcServerDemoModule 类，并编写以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 using Abp.AspNetCore; using Abp.Grpc.Server.Extensions; using Abp.Modules; namespace Abp.Grpc.Server.Demo { // 此处依赖 ABP 的 AspNetCore 模块与我们的 GRPC 服务模块 [DependsOn(typeof(AbpAspNetCoreModule), typeof(AbpGrpcServerModule))] public class AbpGrpcServerDemoModule : AbpModule { public override void PreInitialize() { Configuration.Modules.UseGrpcService(option =\u0026gt; { // GRPC 服务绑定的 IP 地址 option.GrpcBindAddress = \u0026#34;0.0.0.0\u0026#34;; // GRPC 服务绑定的 端口号 option.GrpcBindPort = 5001; // 启用 Consul 服务注册 option.UseConsul(consulOption =\u0026gt; { // Consul 服务注册地址 consulOption.ConsulAddress = \u0026#34;10.0.75.1\u0026#34;; // Consul 服务注册端口号 consulOption.ConsulPort = 8500; // 注册到 Consul 的服务名称 consulOption.RegistrationServiceName = \u0026#34;TestGrpcService\u0026#34;; // 健康检查接口的端口号 consulOption.ConsulHealthCheckPort = 5000; }); }) .AddRpcServiceAssembly(typeof(AbpGrpcServerDemoModule).Assembly); // 扫描当前程序集的所有 GRPC 服务 } public override void Initialize() { IocManager.RegisterAssemblyByConvention(typeof(AbpGrpcServerDemoModule).Assembly); } } } 2.1.3 编写健康检查控制器 新建一个文件夹叫做 Controllers ，并且新建一个 HealthController 类，其内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 using Abp.AspNetCore.Mvc.Controllers; using Microsoft.AspNetCore.Mvc; namespace Abp.Grpc.Server.Demo.Controllers { public class HealthController : AbpController { /// \u0026lt;summary\u0026gt; /// 健康检查接口 /// \u0026lt;/summary\u0026gt; public IActionResult Check() { return Ok(\u0026#34;OJBK\u0026#34;); } } } 注意：此处应该继承自 AbpController 基类\n2.1.4 编写 RPC 服务 新建一个 RpcServices 文件夹，并且新建一个 TestGrpcService 文件，其内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using MagicOnion; using MagicOnion.Server; namespace Abp.Grpc.Server.Demo.RpcServices { public interface ITestGrpcService : IService\u0026lt;ITestGrpcService\u0026gt; { UnaryResult\u0026lt;int\u0026gt; Sum(int x, int y); } public class TestGrpcService : ServiceBase\u0026lt;ITestGrpcService\u0026gt;, ITestGrpcService { public UnaryResult\u0026lt;int\u0026gt; Sum(int x, int y) { return UnaryResult(x + y); } } } 可以看到我们编写了一个简单的 Sum 方法，该方法接收两个 int 类型的参数，计算其和并返回。\n2.1.5 编写 Dockerfile 文件 因为我们的 Consul 是放在 Docker 容器当中的，所以我们将我们的站点发布出去，并且编写一个 Dockerfile 文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 FROM microsoft/dotnet ENV ASPNETCORE_URLS http://+:5000 ## 开放 5000 网站端口 EXPOSE 5000 ## 开放 5001 RPC 端口 EXPOSE 5001 WORKDIR /app COPY ./ . ENTRYPOINT [ \u0026#34;dotnet\u0026#34;,\u0026#34;Abp.Grpc.Server.Demo.dll\u0026#34; ] 将其拷贝到发布好的站点，并且执行 docker build 命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 PS D:\\Project\\DEMO\\Abp.Grpc.Server.Demo\\Abp.Grpc.Server.Demo\\bin\\Release\\netcoreapp2.1\\publish\u0026gt; docker build -t grpc-server-demo . Sending build context to Docker daemon 29.9MB Step 1/7 : FROM microsoft/dotnet ---\u0026gt; d8381e1175a1 Step 2/7 : ENV ASPNETCORE_URLS http://+:5000 ---\u0026gt; Using cache ---\u0026gt; da7659cff6d2 Step 3/7 : EXPOSE 5000 ---\u0026gt; Using cache ---\u0026gt; 7ecfc480ad43 Step 4/7 : EXPOSE 5001 ---\u0026gt; Using cache ---\u0026gt; 75f10934ad1e Step 5/7 : WORKDIR /app ---\u0026gt; Using cache ---\u0026gt; dee9739da4cd Step 6/7 : COPY ./ . ---\u0026gt; 1a5acc1f0298 Step 7/7 : ENTRYPOINT [ \u0026#34;dotnet\u0026#34;,\u0026#34;Abp.Grpc.Server.Demo.dll\u0026#34; ] ---\u0026gt; Running in a46efbabc7fc Removing intermediate container a46efbabc7fc ---\u0026gt; 321201373ecf Successfully built 321201373ecf Successfully tagged grpc-server-demo:latest SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have \u0026#39;-rwxr-xr-x\u0026#39; permissions. It is recommended to double check and reset permissions for sensitive files and directories 构建完镜像之后，我们运行该镜像：\n1 docker run -d -p 5000:5000 -p 5001:5001 --name=grpc-server-demo grpc-server-demo 2.1.6 查看 Consul 来到 Consul 的 UI 界面查看效果：\n可以看到已经成功注册，说明已经成功了。\n2.2 Grpc 客户端编写 2.2.1 Abp 集成 首先建立一个标准的 .Net Console 程序，引入 Abp.Grpc.Client 包，在我们的 Program 类当中编写如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 using Abp.Grpc.Client.Demo.RpcServices; using Abp.Grpc.Client.Utility; using System; namespace Abp.Grpc.Client.Demo { class Program { static void Main(string[] args) { using (var bootstrapper = AbpBootstrapper.Create\u0026lt;AbpGrpcClientDemoModule\u0026gt;()) { bootstrapper.Initialize(); Console.WriteLine(\u0026#34;Press enter to stop application...\u0026#34;); Console.ReadLine(); } Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } } 2.2.2 建立项目启动模块 然后我们新建一个 AbpGrpcClientDemoModule 类，该类一样是一个启动模块，用于配置连接信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using Abp.Grpc.Client.Configuration; using Abp.Grpc.Client.Extensions; using Abp.Modules; namespace Abp.Grpc.Client.Demo { [DependsOn(typeof(AbpGrpcClientModule))] public class AbpGrpcClientDemoModule : AbpModule { public override void PreInitialize() { Configuration.Modules.UseGrpcClient(new ConsulRegistryConfiguration(\u0026#34;10.0.75.1\u0026#34;, 8500, null)); } } } 很简单，直接配置 Consul 注册的 IP 与端口号即可。\n2.2.3 建立 RPC 接口定义 要调用我们 Server 提供的 RPC 端口的话，得编写一个接口定义，就是我们在 Server 项目里面写的那个，新建一个 ITestGrpcService 接口，内容如下：\n1 2 3 4 5 6 7 8 9 using MagicOnion; namespace Abp.Grpc.Client.Demo.RpcServices { public interface ITestGrpcService : IService\u0026lt;ITestGrpcService\u0026gt; { UnaryResult\u0026lt;int\u0026gt; Sum(int x, int y); } } 2.2.4 调用 RPC 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using Abp.Grpc.Client.Demo.RpcServices; using Abp.Grpc.Client.Utility; using System; namespace Abp.Grpc.Client.Demo { class Program { static void Main(string[] args) { using (var bootstrapper = AbpBootstrapper.Create\u0026lt;AbpGrpcClientDemoModule\u0026gt;()) { bootstrapper.Initialize(); // 调用接口 var connectionUtility = bootstrapper.IocManager.Resolve\u0026lt;IGRpcConnectionUtility\u0026gt;(); var result = connectionUtility.GetRemoteService\u0026lt;ITestGrpcService\u0026gt;(\u0026#34;TestGrpcService\u0026#34;).Sum(10, 5).ResponseAsync.Result; // 展示结果 Console.WriteLine(\u0026#34;Result:\u0026#34; + result); Console.WriteLine(\u0026#34;Press enter to stop application...\u0026#34;); Console.ReadLine(); } Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } } 调用接口的话，需要注入 IGRpcConnectionUtility 工具类，使用其 GetRemoteService 方法就可以调用你的远程方法，记住一定要传入有效的服务名称。\n2.2.5 编写 Dockerfile 文件 一样的，我们新建一个 Dockerfile 文件，将我们的 client 也打包成镜像：\n1 2 3 4 5 6 FROM microsoft/dotnet WORKDIR /app COPY ./ . ENTRYPOINT [ \u0026#34;dotnet\u0026#34;,\u0026#34;Abp.Grpc.Client.Demo.dll\u0026#34; ] 内容很简单，一样的复制到发布成功的文件夹，构建镜像：\n1 docker build -t grpc-client-demo . 构建之后运行：\n1 docker run grpc-client-demo 不出意外的话会看到如下输出：\n1 2 3 4 PS D:\\Project\\DEMO\\Abp.Grpc.Client.Demo\\Abp.Grpc.Client.Demo\\bin\\Release\\netcoreapp2.1\\publish\u0026gt; docker run grpc-client-demo Result:15 Press enter to stop application... Hello World! 3.代码分析 抛开 ABP 框架部分的代码，其实要实现服务注册很简单，核心就是 ConsulClient 这个类，下面就来分析一下 Abp.Grpc 库里面的代码。\n3.1 注册服务 注册服务其核心就在于 ConsulClient.Agent.ServiceRegister() 方法，通过传入一个构造好的 AgentServiceRegistration 对象就可以成功注册一个服务到 Consul。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 _agentServiceRegistration = new AgentServiceRegistration { ID = Guid.NewGuid().ToString(),// 唯一ID Name = config.RegistrationServiceName,// 注册的服务名称 Address = currentIpAddress, // 服务提供者地址 Port = config.GrpcBindPort, // 服务提供者端口 Tags = new[] { \u0026#34;Grpc\u0026#34;, $\u0026#34;urlprefix-/{config.RegistrationServiceName}\u0026#34; }, // 注册的服务标签 Check = new AgentServiceCheck // 健康检查 { DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5), // 取消注册时间 Interval = TimeSpan.FromSeconds(10), // 检查间隔 Status = HealthStatus.Passing, // 检查通过的状态 Timeout = TimeSpan.FromSeconds(5), // 超时时间 HTTP = $\u0026#34;http://{currentIpAddress}:{config.ConsulHealthCheckPort}/health/check\u0026#34; // 健康检查接口地址 } }; 构建成功后通过 ConsulClient.Agent.ServiceRegister() 方法即可注册到 Consul。\n取消注册则是通过 ConsulClient.Agent.ServiceDeregister 方法。\n3.2 发现服务 服务发现相较于服务注册简单得多，只需要通过 ConsulClient.Catalog.Services 遍历其结果即可获得所有节点，并且通过 LINQ 来筛选出指定 tag 的服务。\n4.其他相关参考资料 田园里的蟋蟀:Docker \u0026amp; Consul \u0026amp; Fabio \u0026amp; ASP.NET Core 2.0 微服务跨平台实践)\nEdison Chou:.NET Core微服务之基于Consul实现服务治理\nCecilphillip:Using Consul for Service Discovery with ASP.NET Core\n5.所使用到的代码 Abp.Grpc 库代码：https://github.com/GameBelial/Abp.Grpc\nDEMO 代码：\nhttps://github.com/GameBelial/Abp.Grpc.Server.Demo\nhttps://github.com/GameBelial/Abp.Grpc.Client.Demo\n","date":"2018-06-11T11:34:00Z","permalink":"https://real-zony.github.io/p/implementing-magiconion-grpc-service-registration-and-discovery-based-on-consul/","title":"基于 Consul 实现 MagicOnion(GRpc) 服务注册与发现"},{"content":"平时使用 LINQ 进行一些简单的条件拼接查询一般都会这样操作：\n1 2 3 4 5 6 public class SearchInputDto { public string ConditionA { get; set; } public int? ConditionB { get; set; } public string ConditionC { get; set; } } 这里有三个条件，是前端传入的搜索条件，然后我们来编写一个查询语句：\n1 2 3 4 5 6 7 8 9 10 public Task Search(SearchInputDto input) { var queryResult = _db.Where(z=\u0026gt;(input.ConditionA == null || z.Name == input.ConditionA) \u0026amp;\u0026amp; (input.ConditionB == null || z.Number == input.ConditionB) \u0026amp;\u0026amp; (input.ConditionC == null || z.Address == input.ConditionC)); // 执行其他操作... return Task.FromResult(0); } 因为我们前端传入的条件不是固定的，所以有可能会出现有的条件没有传入的情况，如果是 SQL 的动态拼接 SQL 就可以了，而 Linq 你肯定是没法动态拼接的，只有自己构建一个表达式树传入到 IQuerable\u0026lt;T\u0026gt;.Where(Expression\u0026lt;Func\u0026lt;T,bool\u0026gt;\u0026gt; expression) 里面进行查询。\n纯手工构建表达式树也不是不可以，只是略微麻烦，而我们则可以借助 System.Linq.Dynamic.Core 来方便的实现动态查询语句拼接。\n他的常规用法如下：\n官方 WIKI 地址：https://github.com/StefH/System.Linq.Dynamic.Core/wiki/Dynamic-Expressions\n1 2 3 4 var query = db.Customers .Where(\u0026#34;City == @0 and Orders.Count \u0026gt;= @1\u0026#34;, \u0026#34;London\u0026#34;, 10) .OrderBy(\u0026#34;CompanyName\u0026#34;) .Select(\u0026#34;new(CompanyName as Name, Phone)\u0026#34;); 既然是字符串那么就可以拼接，我们来做一下改造。\n首先去 NuGet 当中搜索 System.Linq.Dynamic.Core 库，安装之后我们来重新编写之前的查询范例，首先我们来写一个构建器，用于构建我们的表达式树：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 using Abp.Runtime.Caching; using System; using System.Collections.Generic; using System.Linq; using System.Linq.Dynamic.Core; using System.Linq.Expressions; using System.Reflection; using System.Text; namespace Abp.Linq.Expressions { public class ExpressionBuilder\u0026lt;TEntity, TSearchDto\u0026gt; { // 其实这里也可以通过传入 params Expression\u0026lt;Func\u0026lt;TRelateEntity, object\u0026gt;\u0026gt;[] selectFields 来构建 public Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; Build(string[] excludeFields, TSearchDto dto) { var parameters = GenerateParametersDictionary(excludeFields, dto); StringBuilder sb = new StringBuilder(); var fieldNames = parameters.Keys.ToList(); // 动态拼接 for (int i = 0; i \u0026lt; fieldNames.Count; i++) { sb.Append(fieldNames[i]).Append($\u0026#34; == @{i}\u0026#34;).Append(\u0026#34; \u0026amp;\u0026amp; \u0026#34;); } var lambdaStr = sb.ToString(); lambdaStr = lambdaStr.Substring(0, lambdaStr.Length - \u0026#34; \u0026amp;\u0026amp; \u0026#34;.Length); // 构建表达式 return DynamicExpressionParser.ParseLambda\u0026lt;TEntity, bool\u0026gt;(new ParsingConfig(), false, lambdaStr, parameters.Values.ToArray()); } // 构建参数/值键值对，如果参数值为 NULL 则不进行构建 private Dictionary\u0026lt;string, object\u0026gt; GenerateParametersDictionary(string[] excludeFields, TSearchDto dto) { var typeInfo = typeof(TSearchDto); var properties = typeInfo.GetProperties(); var parameters = new Dictionary\u0026lt;string, object\u0026gt;(); foreach (var property in properties) { var propertyValue = property.GetValue(dto); if (propertyValue == null) continue; if (excludeFields == null) continue; if (excludeFields.Contains(property.Name)) continue; if (parameters.ContainsKey(property.Name)) continue; parameters.Add(property.Name, propertyValue); } return parameters; } } } 用法很简单，用刚才的代码作为一个例子：\n1 2 3 4 5 6 7 8 9 public Task Search(SearchInputDto input) { var builder = new ExpressionBuilder\u0026lt;EntityA,SearchInputDto\u0026gt;(); var queryResult = _db.Where(builder.Build(null,input)); // 执行其他操作... return Task.FromResult(0); } 可以看到已经变得十分简洁，这里仅仅作为抛砖引玉，其实还有更多高级的用法，这里不再赘述。\n","date":"2018-06-06T02:14:00Z","permalink":"https://real-zony.github.io/p/building-queries-with-simple-dynamic-expressions-using-dynamiclinq/","title":"利用 DynamicLinq 实现简单的动态表达式构建查询"},{"content":"文章原文来自：Code your own blockchain mining algorithm in Go! ，原始文章通过 Go 语言来实现的，这里仍然是承接上一篇文章，来使用 C# + .Net Core 实现我们的挖矿算法。\n强烈建议阅读前先阅读这篇文章 什么是加密货币挖掘？ 一个加密货币的价值体现在它的稀缺性上，如果任何人都可以任意构造一个比特币，那么比特币就毫无价值，所以比特币的区块链会让参与者完成一项“工作”，根据这个工作的最终结果还分发比特币，这个过程就被叫做“挖矿”。这就类似于一个黄金矿工花一些时间来工作，然后获得一点黄金。\n挖矿的原理 如果你百度/谷歌搜索 比特币挖矿的原理 的话，都会给你说是计算一个复杂的数学问题而已，但是这么说的话太笼统而且也太简单。采矿引擎如何工作这是一个重要的知识点，所以我们需要了解一些密码学知识和哈希算法相关的知识，才能知道挖矿的基本原理。\n哈希/散列介绍 单向加密人类能够理解的输入，例如 Hello World ，并将其扔到某个加密函数(即所谓的复杂的数学问题)，加密函数的算法越复杂，逆向工程就越困难。\n例如一个 SHA - 256 的例子，**这个网站**可以很快的计算散列值，让我们来散列 “Hello World” 看看会得到什么结果：\n不管你试验几次都会得到一样的散列值，在编程中这种被称之为幂等性。\n加密算法的一个基本特性就是，它们很难通过逆向工程来得到明文结果，但是十分容易验证他们的加密结果，例如这里的 “Hello World” 很难通过逆向工程得到他的原明文结果，比特币采用的是 Double SHA-256 也就是将明文通过 SHA-256 计算过一次之后，再拿 SHA-256 针对散列值再次进行计算，在这里我们只使用 SHA-256 来进行加密。\n工作证明 比特币通过让参与者散列随机的字母与数字的组合，直到计算出来的散列包含前导 0。\n例如我们计算 886 的散列值可以得到如下结果：\n1 000f21ac06aceb9cdd0575e82d0d85fc39bed0a7a1d71970ba1641666a44f530 它返回了 3 个 0 作为前缀的散列值，但是我们怎么知道 886 计算出来的散列结果产生了 3 个 0 呢？\n答案是我并不需要知道。。。我需要知道矿工给我的散列值前导有几个零就好了，并不需要复杂的算法来验证整个散列值的有效性。\n比特币则稍微复杂一点，它每隔 10 分钟生成一个新的区块，新区块的散列值的难度它可以动态调整，就类似于 CLR 的 GC 一样，它可以根据目前挖矿的人数来进行难度动态调整，如果挖矿的人多的话，则调高难度，少则调低。\n动手开发 1.项目配置 首先新建一个 Asp.Net Core 项目，然后选择 Empty Project(空项目) 类型，建立完成后无需进行任何配置。\n2.数据模型 这里我们来创建一个具体的区块数据模型，使用的是 Struct 结构体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public struct Block { /// \u0026lt;summary\u0026gt; /// 区块位置 /// \u0026lt;/summary\u0026gt; public int Index { get; set; } /// \u0026lt;summary\u0026gt; /// 区块生成时间戳 /// \u0026lt;/summary\u0026gt; public string TimeStamp { get; set; } /// \u0026lt;summary\u0026gt; /// 心率数值 /// \u0026lt;/summary\u0026gt; public int BPM { get; set; } /// \u0026lt;summary\u0026gt; /// 区块 SHA-256 散列值 /// \u0026lt;/summary\u0026gt; public string Hash { get; set; } /// \u0026lt;summary\u0026gt; /// 前一个区块 SHA-256 散列值 /// \u0026lt;/summary\u0026gt; public string PrevHash { get; set; } /// \u0026lt;summary\u0026gt; /// 下一个区块生成难度 /// \u0026lt;/summary\u0026gt; public int Difficulty { get; set; } /// \u0026lt;summary\u0026gt; /// 随机值 /// \u0026lt;/summary\u0026gt; public string Nonce { get; set; } } Difficulty 是一个整形，他定义了我们希望得到哈希前导 0 的数量，前导 0 越多，生成正确的散列值就越困难，我们现在从 1 开始。\nNonce 则是每次计算块散列值所需要的随机值。\n3. 工作证明 我们首先添加一个新的方法来验证生成的散列值是否包含指定数量的前导 0 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// \u0026lt;summary\u0026gt; /// 校验 Hash 是否有效 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;hashStr\u0026#34;\u0026gt;Hash 值\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;difficulty\u0026#34;\u0026gt;难度\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static bool IsHashValid(string hashStr, int difficulty) { var bytes = Enumerable.Range(0, hashStr.Length) .Where(n =\u0026gt; n % 2 == 0) .Select(n =\u0026gt; Convert.ToByte(hashStr.Substring(n, 2), 16)) .ToArray(); var bits = new BitArray(bytes); for (var i = 0; i \u0026lt; difficulty; i++) { if (bits[i]) return false; } return true; } 然后我们更改了之前区块 Hash 的生成方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /// \u0026lt;summary\u0026gt; /// 计算区块 HASH 值 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;block\u0026#34;\u0026gt;区块实例\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;计算完成的区块散列值\u0026lt;/returns\u0026gt; public static string CalculateHash(Block block) { string calculationStr = $\u0026#34;{block.Index}{block.TimeStamp}{block.BPM}{block.PrevHash}{block.Nonce}\u0026#34;; SHA256 sha256Generator = SHA256.Create(); byte[] sha256HashBytes = sha256Generator.ComputeHash(Encoding.UTF8.GetBytes(calculationStr)); StringBuilder sha256StrBuilder = new StringBuilder(); foreach (byte @byte in sha256HashBytes) { sha256StrBuilder.Append(@byte.ToString(\u0026#34;x2\u0026#34;)); } return sha256StrBuilder.ToString(); } 在这里我们新增新增了 Nonce 随机值作为散列生成的依据。\n那么我们生成新区块的时候就顺便来挖矿吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /// \u0026lt;summary\u0026gt; /// 生成新的区块 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;oldBlock\u0026#34;\u0026gt;旧的区块数据\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;BPM\u0026#34;\u0026gt;心率\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;新的区块\u0026lt;/returns\u0026gt; public static Block GenerateBlock(Block oldBlock, int BPM) { Block newBlock = new Block() { Index = oldBlock.Index + 1, TimeStamp = CalculateCurrentTimeUTC(), BPM = BPM, PrevHash = oldBlock.Hash, Difficulty = Difficulty }; // 挖矿 ing... for (int i = 0; ; i++) { newBlock.Nonce = i.ToString(\u0026#34;x2\u0026#34;); if (!IsHashValid(CalculateHash(newBlock), Difficulty)) { Console.WriteLine($\u0026#34;目前结果：{CalculateHash(newBlock)} ，正在计算中...\u0026#34;); Task.Delay(1); continue; } else { Console.WriteLine($\u0026#34;目前结果：{CalculateHash(newBlock)} ，计算完毕...\u0026#34;); newBlock.Hash = CalculateHash(newBlock); break; } } // 原有代码 // newBlock.Hash = CalculateHash(newBlock); return newBlock; } 效果 结语 其实代码并不复杂，但是这几十行代码表明了区块链挖矿的本质，后面你可以参考原文实现 P2P 与 股权权益证明方法与智能合约。\n项目代码地址：http://git.myzony.com/Zony/BlockChain.git\nPDF 文件地址：http://git.myzony.com/Zony/BlockChain/src/6ef2bdb7d9a086d8e214603c88670896de6b108c/PDF 文件/[C%23] 使用 C%23 编写自己区块链的挖矿算法.pdf\nCode a simple P2P blockchain in Go. ","date":"2018-05-07T10:55:00Z","permalink":"https://real-zony.github.io/p/write-your-own-blockchain-mining-algorithm-using-csharp/","title":"使用 C# 编写自己的区块链挖矿算法"},{"content":"一、简介 Docfx 是微软开发的一款开源的文档生成工具，其默认支持 C# 与 VB.Net 这两种项目的文档生成，支持 DotNetCore 项目，并且还可以打包成一个静态的 Web 站点，而且还支持 markdown 文件。 **这个站点**就是 ImageSharp 的 API 文档，可以去参考一下。 二、安装 下载 Docfx 是即开即用的，他基于 .Net Framework 开发，所以我们可以先在 Windows 平台上面生成 API 文档试一下，DocFx 的下载地址为 https://github.com/dotnet/docfx/releases ，选择最新版本下载即可。\n设置环境变量 然后解压其压缩包，因为这是一个命令行程序，所以我们可以将其目录添加到环境变量以便于我们在任何地方来使用。 按住 Shift 键再点击右键在当前目录弹出 cmd 命令行窗口，输入一下命令:\n1 setx PATH \u0026#34;%Path%;\u0026lt; 这里是你 docfx.exe 所在的目录\u0026gt;\u0026#34; 三、使用 初始化基础项目 在你需要生成基础项目的文件夹下打开命令行窗口，运行 docfx init -q 就回在当前目录下生成一个 docfx_project 文件夹，这里面包含了一些基本配置，稍后再讲。\n生成 API yml 文件 docfx 支持为 csproj 与 sln 来生成 API 文档，假如你的库有很多个的话，就可以直接根据 sln 解决方案来生成 API 文档。 我们来到 API 目录下面，在 csproj 文件所在目录打开命令行窗口，运行 docfx metadata ./api.csproj 命令就会在这个目录下面生成一个 _api 文件夹，这里面会包含大量像这样的 yml 文件。 将这些文件拷贝到 docfx_project 目录下的 api 文件夹内，编辑 docfx_project 根目录的 toc.yml 文件，如下： 这里面就是管理 API 站点目录结构的，可以看到这里的每一个以 - 划分的都是一个节点，也就是在 API 站点顶部导航栏所展示的内容，而 href 则是该导航栏指向的文档目录路径。homepage 则是首页的 markdown 文件。 如果你有一些自定义的文档则可以在这里添加目录结构。\n构建 API 站点 文件这些已经准备就绪，原始的站点文档都以 yml 文件与 md 文件为主，我们可以通过调用 docfx ./docfx.json 命令来将这些文件构建成一个静态的 html 站点。 预览 API 站点 如果我们想查看效果的话，可以在 docfx_project 目录执行 docfx serve ./_site 命令，它将会开启一个服务器，你也可以通过 -p 参数来指定自己的端口，例如 docfx serve ./_site -p 5000。 四、部署 如果只是自己看就没什么用了，那么我们还可以通过 Docker 来将我们的站点部署到服务器上，如何来做呢？大致思路就是一个 docker 镜像生成 _site 文件夹，一个镜像来做 Web 服务器承载站点。\n制作镜像 1.文档生成镜像 doc_generator 那么我们首先来编写生成 docker 镜像的 Dockerfile 文件：\n1 2 3 4 5 6 7 FROM mono:latest WORKDIR /work COPY ./ . # 构建 API 站点 RUN mono /work/docfx/docfx.exe /work/docfx.json \\ \u0026amp;\u0026amp; mkdir /app ENTRYPOINT [\u0026#34;cp\u0026#34;,\u0026#34;-r\u0026#34;,\u0026#34;/work/_site/*\u0026#34;,\u0026#34;/app\u0026#34;] 运行 docker build -t doc_generator . 命令生成了一个 doc_generator 镜像。\n2.Web 服务器镜像 nginx 这里 Web 服务器镜像并不需要特别的定制，直接使用 nginx 的默认镜像就可以了。\n运行镜像 那么我们来编写一个 Shell 运行我们的镜像:\n1 2 3 4 5 #!/bin/bash docker run -dti -v /temp/document_html:/app --name=doc_generator doc_generator # 移动文件，更改文件目录结构 cp -r /temp/document_html/_site/* /temp/document_html docker run --name=doc_nginx -d -p 20001:80 -v /temp/document_html:/usr/share/nginx/html nginx 执行脚本之后查看效果： 五、后记 结合 Jenkins 等 CI 你可以实现自动增量更新，这里就不再赘述了。\n","date":"2018-05-04T12:38:00Z","permalink":"https://real-zony.github.io/p/building-a-docfx-site-in-docker/","title":"在 Docker 当中搭建 Docfx 站点"},{"content":"目的 因为某些原因需要将存放在 Google Chrome 内的书签导出到本地，所幸 Google Chrome 提供了导出书签的功能。\n分析 首先在 Google Chrome 浏览器当中输入 chrome://bookmarks 来到书签管理页面，找到最右侧的三个点，选择导出书签，导出的文件是一个 HTML 文件，里面包含了所有书签的层级结构等信息。 使用 Notepad++ 打开该文件之后可以看到里面的内容如下: 粗略一看貌似没什么问题，其实在里面的 \u0026lt;DT\u0026gt; 与 \u0026lt;P\u0026gt; 都缺少了闭合标签，所以在解析的时候需要将其去除掉。去除掉之后的 HTML 文件结构大概像这样:\n1 2 3 4 5 6 7 8 9 10 \u0026lt;DL\u0026gt; \u0026lt;H3\u0026gt;文件夹标题\u0026lt;/H3\u0026gt; \u0026lt;DL\u0026gt; \u0026lt;H3\u0026gt;子文件夹标题\u0026lt;/H3\u0026gt; \u0026lt;A HREF=\u0026#34;书签地址\u0026#34;\u0026gt;子文件夹书签1\u0026lt;/A\u0026gt; \u0026lt;A HREF=\u0026#34;书签地址\u0026#34;\u0026gt;子文件夹书签2\u0026lt;/A\u0026gt; \u0026lt;/DL\u0026gt; \u0026lt;A HREF=\u0026#34;书签地址\u0026#34;\u0026gt;书签1\u0026lt;/A\u0026gt; \u0026lt;A HREF=\u0026#34;书签地址\u0026#34;\u0026gt;书签2\u0026lt;/A\u0026gt; \u0026lt;/DL\u0026gt; 可以很明显看到这里是有一个层级关系的，所以我们可以通过递归来生成一个树形模型，生成之后，再遍历这个模型来根据这个树形结构来创建 MHTML 文件，并且进行归类。\n实现 操作 HTML 文件在 .Net 下有一个很方便的第三方库，名字叫做 HtmlAgilityPack，通过这个库我们可以很方便地操作 HTML 文档，就跟 DOM 一样方便，而且它支持 XPath 选取。\n项目地址:http://html-agility-pack.net/ GitHub 地址:https://github.com/zzzprojects/html-agility-pack Nuget 地址:https://www.nuget.org/packages/HtmlAgilityPack/ 通过 Nuget 安装该包到项目当中，引入 HtmlAgilityPack 命名空间，就可以开始编写代码了。\n1.编写 HtmlResolver 解析器 建立一个 HtmlResolver 类，该类用于解析 Chrome 导出的书签:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class HtmlResolver { private HtmlDocument _htmlDocument = new HtmlDocument(); /// \u0026lt;summary\u0026gt; /// 初始化 HTML 解析器 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;htmlPath\u0026#34;\u0026gt;Google Chrome 导出的书签 HTML 路径\u0026lt;/param\u0026gt; public HtmlResolver(string htmlPath) { using (FileStream htmlFileStream = File.Open(htmlPath, FileMode.Open)) { using (StreamReader htmlReader = new StreamReader(htmlFileStream)) { // 移除干扰标签 string htmlStr = htmlReader.ReadToEnd(); htmlStr = htmlStr.Replace(@\u0026#34;\u0026lt;DT\u0026gt;\u0026#34;, string.Empty).Replace(@\u0026#34;\u0026lt;p\u0026gt;\u0026#34;, string.Empty); // 加载 HTML _htmlDocument.LoadHtml(htmlStr); } } } } 在对象初始化的时候要求提供 Google Chrome 导出的书签 HTML 文件路径，并且读入 HTML 文件数据的时候移除掉之前所说的 \u0026lt;DT\u0026gt; 与 \u0026lt;P\u0026gt; 标签，方便后面 HtmlAgilityPack 进行解析，移除之后，HtmlDocument 通过 HTML String 初始化。\n2.创建书签模型 当我们递归完成之后需要将数据存储在书签模型当中，方便后面生成 MHTML 文件的时候使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /// \u0026lt;summary\u0026gt; /// 书签模型 /// \u0026lt;/summary\u0026gt; public class BookMarkModel { /// \u0026lt;summary\u0026gt; /// 初始化书签模型 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;name\u0026#34;\u0026gt;书签名称\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;path\u0026#34;\u0026gt;书签路径\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;url\u0026#34;\u0026gt;绑定的 URL\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;childNodes\u0026#34;\u0026gt;子节点集合\u0026lt;/param\u0026gt; public BookMarkModel(string name, string path, string url = null, List\u0026lt;BookMarkModel\u0026gt; childNodes = null) { Name = name; Url = url; ChildNodes = childNodes; Path = path; } /// \u0026lt;summary\u0026gt; /// 书签名称 /// \u0026lt;/summary\u0026gt; public string Name { get; set; } /// \u0026lt;summary\u0026gt; /// 绑定的 URL /// \u0026lt;/summary\u0026gt; public string Url { get; set; } /// \u0026lt;summary\u0026gt; /// 书签路径 /// \u0026lt;/summary\u0026gt; public string Path { get; set; } /// \u0026lt;summary\u0026gt; /// 子节点集合，如果没有则为 NULL /// \u0026lt;/summary\u0026gt; public List\u0026lt;BookMarkModel\u0026gt; ChildNodes { get; set; } } 该模型是一个典型的树形结构，之后我们就开始递归生成书签模型了。\n3.递归生成树形模型 递归算法自己一直不太会写，写好这一个递归方法基本都花费了半天的时间 :P，后面打算恶补数学和算法这块了。下面先上代码再解释原理:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /// \u0026lt;summary\u0026gt; /// 递归生成书签模型 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;node\u0026#34;\u0026gt;父级节点\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parentPath\u0026#34;\u0026gt;父级节点 Path\u0026lt;/param\u0026gt; private List\u0026lt;BookMarkModel\u0026gt; RecursionGenerate(HtmlNode node, string parentPath) { List\u0026lt;BookMarkModel\u0026gt; bookMarkModels = new List\u0026lt;BookMarkModel\u0026gt;(); // 获取所有文件夹标题与其下属节点，以便递归查询其子节点 var bookMarkFolderTitles = node.SelectNodes(\u0026#34;h3\u0026#34;)?.Cast\u0026lt;HtmlNode\u0026gt;().ToList(); var bookMarkFolder = node.SelectNodes(\u0026#34;dl\u0026#34;)?.Cast\u0026lt;HtmlNode\u0026gt;().ToList(); var htmlBookMarks = node.SelectNodes(\u0026#34;a\u0026#34;); // 如果文件夹不存在则直接将所有具体书签返回 if (bookMarkFolderTitles == null || bookMarkFolder == null) { return GenerateBookMarkModels(htmlBookMarks, parentPath); } // 递归构建书签模型 for (int i = 0; i \u0026lt; bookMarkFolderTitles.Count; i++) { BookMarkModel bookMark = new BookMarkModel(bookMarkFolderTitles[i].InnerText, $@\u0026#34;{parentPath}\\{bookMarkFolderTitles[i].InnerText}.mhtml\u0026#34;); bookMark.ChildNodes = RecursionGenerate(bookMarkFolder[i], bookMark.Path); List\u0026lt;BookMarkModel\u0026gt; bookmarks = GenerateBookMarkModels(htmlBookMarks, parentPath); if (bookmarks != null) bookMark.ChildNodes?.AddRange(bookmarks); bookMarkModels.Add(bookMark); } return bookMarkModels; } 首先说说 RecursionGenerate(HtmlNode node,string parentPath) 方法，这个方法接收一个节点参数，这个节点就是需要遍历的节点，而 parentPath 则是用于生成路径的，在每次构建书签模型的时候都会根据父级路径来生成新的路径。\n如果要获取某个节点下面的子节点，肯定要拿到该节点下属的所有节点，可以参考上面的大概结构，一般一个书签文件夹下面都会有一个或多个子文件夹，也有可能会有部分书签与这些子文件夹同级。\n所以，我们先提取出当前节点的文件夹名称，也就是 \u0026lt;H3\u0026gt; 标签里面的内容，然后只要有一个 \u0026lt;H3\u0026gt; 标签，那他肯定有一个对应的 \u0026lt;DL\u0026gt; 标签表示包裹着它的子节点内容。如果某个节点它的内部没有子文件夹的话，那直接抓取其内部的具体书签，并返回出来。\n如果某个节点拥有子文件夹的话，遍历其内部，并且再次调用 RecursionGenerate 方法，将其内部节点添加到这个节点的 Childern 当中。\n注意，这里在循环内部还再次进行了获取具体书签的操作，因为有的时候某个节点内部也是拥有具体书签项的，所以这里才会有 List\u0026lt;T\u0026gt;.AddRange(IEnumerable\u0026lt;T\u0026gt; list) 操作。 具体书签生成:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// \u0026lt;summary\u0026gt; /// 将 A 标签的集合转换为 BookMarkModel 集合 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;nodes\u0026#34;\u0026gt;A 标签节点集合\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;转换完成的 Node 集合\u0026lt;/returns\u0026gt; private List\u0026lt;BookMarkModel\u0026gt; GenerateBookMarkModels(HtmlNodeCollection nodes, string parentPath) { if (nodes == null) return null; List\u0026lt;BookMarkModel\u0026gt; bookmarks = new List\u0026lt;BookMarkModel\u0026gt;(); foreach (var node in nodes) { bookmarks.Add(new BookMarkModel(node.InnerText, $@\u0026#34;{parentPath}\\{node.InnerText}.mhtml\u0026#34;, node.Attributes[\u0026#34;href\u0026#34;].Value)); } return bookmarks; } 具体书签的生成就很简单了，直接构建即可，这里会在其末尾添加 .mhtml 后缀。\n4.根据生成的书签模型来产生 MHTML 文件 这里可以参考以下实现： https://code.msdn.microsoft.com/windowsdesktop/Creating-a-MHTML-MIME-HTML-61cf5dd1\n目前程序还没有实现这一个功能，因为使用 CDO 的方法不太方便，而且生成的 MHT 文件样式丢失严重，并不像 Google Chrome 保存的 mht 文件那样完整。\n后续再来填坑。\n结尾 项目地址：http://git.myzony.com/Zony/GoogleBookmarkExportTool\n","date":"2018-03-02T14:15:00Z","permalink":"https://real-zony.github.io/p/google-chrome-bookmarks-export-and-generate-mhtml-file/","title":"Google Chrome 书签导出并生成 MHTML 文件"},{"content":"文章原文来自:Code your own blockchain in less than 200 lines of Go!，原始文章是通过 Go 语言来实现自己的区块链的，这里我们参照该文章来使用 C# + Asp.Net Core 实现自己的区块链。在这里我也参考了 这篇译文 。\n1.项目配置 首先新建一个 Asp.Net Core 项目，然后选择 Empty Project(空项目) 类型，建立完成后无需进行任何配置。\n2.数据模型 这里我们来创建一个具体的区块数据模型，使用的是 Struct 结构体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public struct Block { /// \u0026lt;summary\u0026gt; /// 区块位置 /// \u0026lt;/summary\u0026gt; public int Index { get; set; } /// \u0026lt;summary\u0026gt; /// 区块生成时间戳 /// \u0026lt;/summary\u0026gt; public string TimeStamp { get; set; } /// \u0026lt;summary\u0026gt; /// 心率数值 /// \u0026lt;/summary\u0026gt; public int BPM { get; set; } /// \u0026lt;summary\u0026gt; /// 区块 SHA-256 散列值 /// \u0026lt;/summary\u0026gt; public string Hash { get; set; } /// \u0026lt;summary\u0026gt; /// 前一个区块 SHA-256 散列值 /// \u0026lt;/summary\u0026gt; public string PrevHash { get; set; } } 这里各个字段的含义已经在注释上方标明了，这里不在过多赘述。 之后我们新建一个 BlockGenerator 静态类用于管理区块链，并且使用一个 List 保存区块链数据。\n1 2 3 4 public static class BlockGenerator { public static List\u0026lt;Block\u0026gt; _blockChain = new List\u0026lt;Block\u0026gt;(); } 我们使用散列算法（SHA256）来确定和维护链中块和块正确的顺序，确保每一个块的 PrevHash 值等于前一个块中的 Hash 值，这样就以正确的块顺序构建出链: 4.散列与生成区块 使用散列是因为可以使用极少的控件生成每一个区块的唯一标识，而且可以维持整个区块链的完整性，通过每个区块存储的前一个链的散列值，我们就可以确保区块链当中每一个区块的正确性，任何针对区块的无效更改都会导致散列值的改变，也就破坏了区块链。 那么我们就在 BlockGenerator 当中添加一个函数用于计算 Block 的 Hash 值:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /// \u0026lt;summary\u0026gt; /// 计算区块 HASH 值 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;block\u0026#34;\u0026gt;区块实例\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;计算完成的区块散列值\u0026lt;/returns\u0026gt; public static string CalculateHash(Block block) { string calculationStr = $\u0026#34;{block.Index}{block.TimeStamp}{block.BPM}{block.PrevHash}\u0026#34;; SHA256 sha256Generator = SHA256.Create(); byte[] sha256HashBytes = sha256Generator.ComputeHash(Encoding.UTF8.GetBytes(calculationStr)); StringBuilder sha256StrBuilder = new StringBuilder(); foreach (byte @byte in sha256HashBytes) { sha256StrBuilder.Append(@byte.ToString(\u0026#34;x2\u0026#34;)); } return sha256StrBuilder.ToString(); } 这里的 CalculateHash 函数接收一个 Block 实例，通过该实例当中的 Index、TimeStamp、BPM、PrevHash 的值来计算出当前块的 SHA256 Hash 值，之后我们就可以来编写一个生成块的函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// \u0026lt;summary\u0026gt; /// 生成新的区块 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;oldBlock\u0026#34;\u0026gt;旧的区块数据\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;BPM\u0026#34;\u0026gt;心率\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;新的区块\u0026lt;/returns\u0026gt; public static Block GenerateBlock(Block oldBlock, int BPM) { Block newBlock = new Block() { Index = oldBlock.Index + 1, TimeStamp = CalculateCurrentTimeUTC(), BPM = BPM, PrevHash = oldBlock.Hash }; newBlock.Hash = CalculateHash(newBlock); return newBlock; } 这个函数需要接收前一个块对象的值，用于新区块的 Index 递增以及 新的 SHA256 Hash 计算。 这里掺入了一个 CalculateCurrentTimeUTC 函数，该函数主要是用于将 DateTime.Now 时间转换为 UTC 时间，如下：\n1 2 3 4 5 6 7 8 9 10 11 /// \u0026lt;summary\u0026gt; /// 计算当前时间的 UTC 表示格式 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;UTC 时间字符串\u0026lt;/returns\u0026gt; public static string CalculateCurrentTimeUTC() { DateTime startTime = new DateTime(1970, 1, 1, 0, 0, 0, 0); DateTime nowTime = DateTime.Now; long unixTime = (long)Math.Round((nowTime - startTime).TotalMilliseconds, MidpointRounding.AwayFromZero); return unixTime.ToString(); } 5.校验区块 每一个区块都是不可信的，所以我们需要在生成新的区块的时候对其进行校验，校验规则如下：\n校验新区块与旧区块的 Index 是否正确递增 校验新区块的 Hash 值是否正确 校验新区块的 PrevHash 值是否与旧区块的 Hash 值匹配 有了上述几种条件，我们可以编写一个校验函数如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 /// \u0026lt;summary\u0026gt; /// 检验区块是否有效 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;newBlock\u0026#34;\u0026gt;新生成的区块数据\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;oldBlock\u0026#34;\u0026gt;旧的区块数据\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;有效返回 TRUE，无效返回 FALSE\u0026lt;/returns\u0026gt; public static bool IsBlockValid(Block newBlock, Block oldBlock) { if (oldBlock.Index + 1 != newBlock.Index) return false; if (oldBlock.Hash != newBlock.PrevHash) return false; if (CalculateHash(newBlock) != newBlock.Hash) return false; return true; } 除开区块校验的问题之外，如果有两个节点被分别添加到各自的区块链上，我们应该始终以最长的那一条为主线，因为最长的那一条意味着他的区块数据始终是最新的。 So，我们还需要一个更新最新区块的函数:\n1 2 3 4 5 6 7 8 9 10 11 /// \u0026lt;summary\u0026gt; /// 如果新的区块链比当前区块链更新，则切换当前区块链为最新区块链 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;newBlockChain\u0026#34;\u0026gt;新的区块链\u0026lt;/param\u0026gt; public static void SwitchChain(List\u0026lt;Block\u0026gt; newBlockChain) { if (newBlockChain.Count \u0026gt; _blockChain.Count) { _blockChain = newBlockChain; } } 6.集成到 Web 当中 现在整个区块链的基本操作已经完成，现在我们需要让他运转起来，我们来到 StartUp 当中，添加两个新的路由：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 app.Map(\u0026#34;/BlockChain\u0026#34;, _ =\u0026gt; { _.Run(async context =\u0026gt; { if (context.Request.Method == \u0026#34;POST\u0026#34;) { // 增加区块链 if (BlockGenerator._blockChain.Count == 0) { Block firstBlock = new Block() { Index = 0, TimeStamp = BlockGenerator.CalculateCurrentTimeUTC(), BPM = 0, Hash = string.Empty, PrevHash = string.Empty }; BlockGenerator._blockChain.Add(firstBlock); await context.Response.WriteAsync(JsonConvert.SerializeObject(firstBlock)); } else { int.TryParse(context.Request.Form[\u0026#34;BPM\u0026#34;][0], out int bpm); Block oldBlock = BlockGenerator._blockChain.Last(); Block newBlock = BlockGenerator.GenerateBlock(oldBlock, bpm); if (BlockGenerator.IsBlockValid(newBlock, oldBlock)) { List\u0026lt;Block\u0026gt; newBlockChain = new List\u0026lt;Block\u0026gt;(); foreach (var block in BlockGenerator._blockChain) { newBlockChain.Add(block); } newBlockChain.Add(newBlock); BlockGenerator.SwitchChain(newBlockChain); } await context.Response.WriteAsync(JsonConvert.SerializeObject(newBlock)); } } }); }); app.Map(\u0026#34;/BlockChains\u0026#34;, _ =\u0026gt; { _.Run(async context =\u0026gt; { await context.Response.WriteAsync(JsonConvert.SerializeObject(BlockGenerator._blockChain)); }); }); 7.最终效果 我们先通过 PostMan 来构建一个创世块： 然后我们尝试多添加几个之后，访问 BlockChain 来查看已经存在的区块链结构： 8.结语 通过以上代码我们完成了一个简陋的区块链，虽然十分简陋，但是已经具备了块生成，散列计算，块校验这些基本能力，你可以参考 GitHub 上面各种成熟的区块链实现来完成工作量证明、权益证明这样的共识算法，或者是智能合约、Dapp、侧链等等。\n","date":"2018-02-26T15:34:00Z","permalink":"https://real-zony.github.io/p/200-lines-of-code-to-implement-blockchain-using-csharp/","title":"200 行代码使用 C# 实现区块链"},{"content":"在编写脚本的时候经常会遇到这种情况，某些程序的命令执行的之后可能会要求用户进行输入，这个时候就需要一些特殊写法来应对这种问题了。这里参考 这篇文章提到可以使用 delimiter 分界符来解决。 也就是说在 Shell 将 delimiter 分界符之后的的所有内容都会当做输入，直到遇到第二个分界符，而最常见的分界符就是 EOF 分界符。\n1 2 3 docker container prune \u0026lt;\u0026lt; EOF y EOF 类似于上述代码。\n","date":"2018-02-12T17:36:00Z","permalink":"https://real-zony.github.io/p/automatic-interaction-of-shell-under-linux/","title":"Linux 下 Shell 的自动交互"},{"content":"在前后端分离开发的项目当中为了避免重复构建发布，我们需要部署一个持续发布环境，而目前的开发环境服务器都是基于 CentOS 的，因此每次在本地发布之后还需要打包，上传，部署，十分繁琐。故这里采用了比较成熟的Jenkins 作为持续部署环境。\n为了方便安装，我们这里使用了 Docker 来进行安装，至于 Docker 安装的步骤这里不在赘述，详情可以参考**这一篇博文**。\n上面安装的是一个较老的版本，这里推荐参考** Docker 官方文档**来进行安装。\n安装好 Docker 之后，拉取 Jenkins 的官方镜像。执行如下命令:\n1 docker pull jenkins/jenkins 拉取完毕之后我们基于这个镜像封装一个新的镜像出来，可能会问为什么不能直接使用呢？因为这儿的 jenkins镜像并不包含 docker 环境，所以我们需要封装一个新的镜像让其能够访问宿主机的 Docker 程序。 构建 Dockerfile 内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 FROM jenkins/jenkins:latest USER root #清除了基础镜像设置的源，切换成阿里云的源 RUN echo \u0026#39;\u0026#39; \u0026gt; /etc/apt/sources.list.d/jessie-backports.list \\ \u0026amp;\u0026amp; echo \u0026#34;deb http://mirrors.aliyun.com/debian jessie main contrib non-free\u0026#34; \u0026gt; /etc/apt/sources.list \\ \u0026amp;\u0026amp; echo \u0026#34;deb http://mirrors.aliyun.com/debian jessie-updates main contrib non-free\u0026#34; \u0026gt;\u0026gt; /etc/apt/sources.list \\ \u0026amp;\u0026amp; echo \u0026#34;deb http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free\u0026#34; \u0026gt;\u0026gt; /etc/apt/sources.list #更新源并安装缺少的包 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y libltdl7 ARG dockerGid=999 RUN echo \u0026#34;docker:x:${dockerGid}:jenkins\u0026#34; \u0026gt;\u0026gt; /etc/group \\ USER jenkins 完成之后执行如下命令构建新的 Docker 镜像:\n1 docker build -t docker/jenkins . 下面我们就开始运行我们的 Jenkins 容器了:\n1 2 3 4 5 docker run -d -p 8080:8080 -p 50000:50000 \\ --name=jenkins -v /root/docker/jenkins:/var/jenkins_home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v $(which docker):/usr/bin/docker \\ docker/jenkins 这里我们将 Jenkins 镜像里面的 /var/jenkins_home 映射到了宿主机的 /root/docker/jenkins 文件夹，在这个文件夹里面都存放的是 Jenkins 的一些配置项等。 注意，这里可能会出现如下错误：\n1 2 touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions? 这是因为在 docker 内部的 jenkins user 用户没有权限，因为映射的 /root/docker/jenkins/ 文件夹属于root 用户的，而 jenkins user 的 uid 为 1000,执行如下命令:\n1 sudo chown -R 1000:1000 /home/docker/jenkins 之后再次运行 Jenkins 的容器,访问 http://服务器IP:8080/ 站点，会提示你输入密钥: 我们来到宿主机执行以下 shell 命令:\n1 docker container logs jenkins 就可以看到密钥其实已经输出在终端了，复制过来，粘贴进去就可以了。之后就是选择你需要安装的插件，选择第一个默认即可，可能这里因为网络原因会安装失败，可以多重试几次，或者直接忽略掉，后面我们会将如何解决。\n安装完成之后输入用户名密码，就可以开始使用了，可能你刚才会因为网络等原因造成插件安装失败，这里我们来到\n1 Jenkins\u0026gt;\u0026gt;系统管理\u0026gt;\u0026gt;管理插件\u0026gt;\u0026gt;高级 然后将 升级站点 地址改为 http://mirror.xmission.com/jenkins/updates/current/update-center.json。之后安装之前缺失的插件。\n这里我们项目使用的是 TFS 进行源代码管理，所以我们需要安装 TFS 插件，在 Manage Jenkins 的 Manage Plugin 里面我们找到 Team Foundation Server Plug-in 插件，勾选，点击 Download now and install after restart 按钮，勾选 Restart Jenkins when installation is complete and no jobs are running 。\n安装完成之后 Jenkins 会重启，等待重启完毕之后，来到 Jenkins\u0026raquo;Manage Jenkins\u0026raquo;Configure System 查看 TFS/Team Services 然后添加你的 TFS Collection。 保存之后我们就可以新建项目了。\n首先，我们来到首页，选择 New Item: 然后选择自由风格项目，填上名称. 在 Source Code Management 上选择 TFS，并且填入你的 TFS 服务器地址，项目路径，与你的账号密码: 然后你就可以尝试构建一下，构建成功之后就会在 Workspace 看到你的项目文件被拉下来了。 那么我们的代码如何构建并且部署呢？因为我们之前在 Jenkins 的 Docker 镜像启动的时候挂载了宿主机的 Docker 程序，我们现在就可以直接基于微软的 dotnetcore 镜像来构建我们的项目。所以，我们先拉取微软的 dotnetcore 镜像，运行如下命令：\n1 docker pull microsoft/dotnet:latest 拉取镜像之后，我们来编写一个 Dockerfile 文件来让 Jenkins 来执行 Shell 构建。 如果你还不知道如何编写 Dockerfile 文件，可以参考 这篇文章。\n1 2 3 4 5 6 7 8 9 10 11 12 FROM microsoft/dotnet:latest WORKDIR /app COPY ./ . ENV ASPNETCORE_URLS http://+:5000 EXPOSE 5000 RUN cd ./HKERP.IdentityServer.Host \\ \u0026amp;\u0026amp; dotnet restore \\ \u0026amp;\u0026amp; dotnet build WORKDIR /app/HKERP.IdentityServer.Host ENTRYPOINT [\u0026#34;dotnet\u0026#34;,\u0026#34;run\u0026#34;] 然后将这个 Dockerfile 放在你的项目里面，类似于这样： 然后我们再回到刚才 Jenkins 里面，配置刚才项目，新建一个 Shell Step，就像这样： 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/sh cd /var/jenkins_home/workspace/API_IdentityServer docker container prune \u0026lt;\u0026lt; EOF y EOF docker container ls -a | grep \u0026#34;api_identityserver\u0026#34; if [ $? -eq 0 ];then docker container stop api_identityserver docker container rm api_identityserver fi docker image prune \u0026lt;\u0026lt; EOF y EOF docker build -t api_identityserver . docker run -d -p 8083:5000 --name=api_identityserver api_identityserver 步骤就是首先清理掉 docker 处于终止状态的容器，然后判断有没有叫 api_identityserver 的容器在运行，如果有就直接停掉，然后清除所有的虚悬镜像，使用当前目录的 dockerfile 构建一个新的 api_identityserver 镜像，使用 api_identityserver 镜像运行一个新的容器。\n这儿我安装了 Jenkins 的一个 Blue Ocean 插件，来看一下： 运行一下： ","date":"2018-02-07T09:29:00Z","permalink":"https://real-zony.github.io/p/continuous-integrationdeployment-for-net-core-with-jenkins/","title":"使用 Jenkins 为 .Net Core 实现持续集成/部署"},{"content":"介绍完工厂模式，现在来看一下建造者模式。建造者模式就是将一系列对象组装为一个完整对象并且返回给用户，例如汽车，就是需要由各个部件来由工人建造成一个复杂的组合实体，这个复杂实体的构造过程就被外部化到一个建造者的对象，由这个建造者对象返回创建好的实体，是不是跟工厂很像呀？ 建造者模式则主要由几个对象构成：\n抽象建造者 具体建造者 指挥者 产品角色 UML 类图如下： 抽象建造者负责定义建造者的行为，这里使用接口/抽象类均可，而具体建造者则实现了抽象建造者，负责具体的建造行为。 指挥者是针对抽象建造者进行变成，是将这些建造者的建造行为进行逻辑处理，不论你传入哪种不同的建造者，都能保证建造流程一致性。 而建造者模式则是将构造复杂对象的内部与对象的具体表现隔离开来，使得同样的建造过程可以创造出不同的表现。 上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 // 抽象建造者 public abstract class AbsBuilder { public abstract void AddHead(); public abstract void AddBody(); public abstract void AddFoot(); public abstract Product GetResult(); } // 抽象产品 public abstract class Product { public abstract void Show(); } // 字符串产品 A public class ProductA : Product { public string Content {get; set;} public override void Show() { Console.WriteLine(Content); } } // 整形产品 B public class ProductB : Product { public int Content {get; set;} public override void Show() { Console.WriteLine(Content); } } // 建造者 A，负责构建字符串产品 public class BuilderA : AbsBuilder { private ProductA _product = new ProductA(); public override void AddHead() { _product.Content += \u0026#34;This is Head\\r\\n\u0026#34;; } public override void AddBody() { _product.Content += \u0026#34;This is Body\\r\\n\u0026#34;; } public override void AddFoot() { _product.Content += \u0026#34;This is Foot\\r\\n\u0026#34;; } public override Product GetResult() { return _product; } } // 建造者 B，负责构建整形产品 public class BuilderB : AbsBuilder { private ProductB _product = new ProductB(); public override void AddHead() { _product.Content += 1; } public override void AddBody() { _product.Content += 10; } public override void AddFoot() { _product.Content += 11; } public override Product GetResult() { return _product; } } // 指挥者 public class Director { public Product Construct(AbsBuilder builder) { builder.AddHead(); builder.AddBody(); builder.AddFoot(); return builder.GetResult(); } } public class Program { public static Main() { var director = new Director(); var product = director.Construct(new BuilderA()); var productB = director.Construct(new BuilderB()); product.Show(); productB.Show(); } } 建造者模式如果需要新增一个建造者的话十分方便，符合开闭原则，只需要编写一个实现了抽象类的建造者即可，十分方便扩展。 而且对于复杂的对象的构建过程可以在具体的建造者内部进行精细化控制。\n适用于需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性； 需要生成的产品对象的属性相互依赖，需要指定其生成顺序； 独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。 ","date":"2018-02-01T04:22:00Z","permalink":"https://real-zony.github.io/p/design-patterns-creative-patterns-builder-patterns/","title":"设计模式(创建型模式)：建造者模式"},{"content":"一般来说国内家用网络没有独立IP，而且可能你还在几层内网里面，这个时候如果想在外面访问自己家里搭建的网站服务，直接用 IP 访问显然不太现实，这个时候就可以使用 FRP 或者 ngrok 这样的工具来实现内网穿透。 这里我选择使用的是 FRP，NGROK 配置十分繁琐，而 FRP 的话一般来说几分钟就可以搞定。(虽然我是搞了三个小时，原因是防火墙的问题\u0026hellip;) 首先我们需要去下载 FRP 的服务端与客户端，这个作者已经打包好了，在这个地址就可以下载：https://github.com/fatedier/frp/releases。基本囊括了主流的平台，我这里采用的服务端是 CentOs 7.x 所以我下载了 Linux x64 的版本，但是每个平台的使用方法都一样，所以不会很麻烦。 具体的使用方法可以在 GITHUB 的 README 处看到。这里我仅讲述基本步骤，首先将下载完成的服务端解压，然后编辑 frps.ini文件，进行如下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [common] # 监听的服务器地址 bind_addr = 0.0.0.0 # 监听的端口 bind_port = 7000 # HTTP 映射端口 vhost_http_port = 8080 # 仪表盘监听地址 dashboard_addr = 0.0.0.0 # 仪表盘监听端口 dashboard_port = 7500 # 仪表盘管理用户 dashboard_user = admin # 仪表盘管理用户密码 dashboard_pwd = admin # FRP 连接密钥 privilege_token = 12345678 # 授权过期时间 authentication_timeout = 900 之后运行服务端：\n1 ./frps -c /frps.ini 服务端运行成功之后，客户端配置(frpc.ini)如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [common] # 填写你服务器的 IP server_addr = *.*.*.* # 填写服务器监听的端口 server_port = 7000 # 填写连接密钥 privilege_token = 12345678 [web] # 协议类型 type = http # 本地需要映射的服务的端口，这里是我站点的端口 local_port = 5001 # 本地需要映射的服务IP local_ip = 10.0.0.2 # 域名，这里需要将这个域名解析至你的服务器 custom_domains = www.yourname.com 之后我们使用 www.yourname.com:8080 就可以访问了。 当然我在这里使用了反向代理，直接将 8080 映射到 80 端口，所以我直接可以通过 www.yourname.com 来访问我的站点。 要使用 FRP 实现内网穿透你需要准备一台服务器/VPS，当然你也可以使用免费的FRP 服务器来映射。 这里列出这些免费的 FRP 服务器：\nhttp://www.chuantou.org https://diannaobos.com/frp http://freenat.win https://www.nat.ee http://freefrp.cn 这里以 NAT.EE 为例，你只需要将 frpc.ini 更改为如下配置，直接运行即可： 1 2 3 4 5 6 7 8 9 10 [common] server_addr = nat.ee server_port = 7000 privilege_token = www.nat.ee user = 自定义用户名称 [自定义服务名称] type = http local_port = 80 local_ip = 127.0.0.1 custom_domains = 自定义域.nat.ee ","date":"2018-01-30T10:59:00Z","permalink":"https://real-zony.github.io/p/use-frp-to-achieve-intranet-penetration/","title":"使用 FRP 实现内网穿透"},{"content":"介绍了简单工厂与工厂方法之后，现在我们来看一下工厂三兄弟的最后一个 —— 抽象工厂。 那什么是抽象工厂呢？\n抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象 的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。\n说起来，抽象工厂与工厂方法类似，但与工厂不同的是抽象工厂不再提供一个单一的抽象产品创建。而是提供了同一产品族不同产品等级结构的创建方式。 这里解释一下两个名词：\n产品等级结构 在之前的工厂方法当中，一个工厂只能创建一个产品，这个产品可能会有多层继承产品。 比如说有一个抽象产品电视机，那么可能是苹果手机这一个抽象产品，但是苹果手机有 多个版本，可能会有 IPHONE5s,IPHONE6，IPHONE7，IPHONE7PLUGS。所以产品结构就 是一个产品的继承结构，比如我们之前的工厂方法只能生成苹果手机而已。 产品族 产品族指代的就是由同一个工厂生产的，但是位于不同产品结构中的一组产品。还是 举个例子，苹果公司不可能生产苹果手机，当然他还有苹果电脑，苹果手表等。所以，一 个工厂就是一个产品族。 So，在这里说白了我们就是在之前的工厂方法当中进行了一个扩展，使得抽象工厂类不再产生单一的产品结构，而是可以生产多个不同的产品结构，而实现工厂就是不同的产品族。 抽象工厂实现了开闭原则，即要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。 在这里增加产品族很方便，只需要增加一个工厂即可，对已有的代码无需任何修改。 但是增加产品结构，必须修改抽象工厂类，然后所有实现类都需要更改，不能很好的支持“开闭原则”。 接下来就上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // 电脑产品 public abstract class Computer { public abstract void Run(); } // 手机产品 public abstract class Phone { public abstract void Run(); } public class AppleComputer : Computer { public override void Run() { Console.WriteLine(\u0026#34;苹果电脑\u0026#34;); } } public class ApplePhone : Phone { public override void Run() { Console.WriteLine(\u0026#34;苹果手机\u0026#34;); } } public class MicrosoftComputer : Computer { public override void Run() { Console.WriteLine(\u0026#34;微软电脑\u0026#34;); } } public class MicrosoftPhone : Phone { public override void Run() { Console.WriteLine(\u0026#34;微软手机\u0026#34;); } } // 抽象工厂 public abstract class AbsFactory { public abstract Computer BuildComputer(); public abstract Phone BuildPhone(); } // 苹果工厂 public class AppleFactory : AbsFactory { public override Computer BuildComputer() { return new AppleComputer(); } public override Phone BuildPhone() { return new ApplePhone(); } } // 微软工厂 public class MicrosoftFactory : AbsFactory { public override Computer BuildComputer() { return new MicrosoftComputer(); } public override Phone BuildPhone() { return new MicrosoftPhone(); } } public static Program { static Main() { var microsoftFactory = new MicrosoftFactory(); Computer microsoftComputer = microsoftFactory.BuildComputer(); Phone microsoftPhone = micorosoftFactory.BuildPhone(); var appleFactory = new AppleFactory(); Computer appleComputer = appleFactory.BuildComputer(); Phone applePhone = appleFactory.BuildPhone(); microsoftComputer.Run(); microsoftPhone.Run(); appleCompurer.Run(); applePhone.Run(); } } 抽象工厂是工厂方法的进一步扩展，抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。 他们三兄弟之间并没有太大的差别。抽象工厂如果只构建一个产品等级结构的话那么他就退化成为工厂方法，当然工厂方法也可以退化为简单工厂。 抽象工厂模式适用于:\n一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节； 系统中有多于一个的产品族，而每次只使用其中某一产品族； 属于同一个产品族的产品将在一起使用； 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 ","date":"2018-01-29T10:33:00Z","permalink":"https://real-zony.github.io/p/design-patterns-creative-patterns-abstract-factory/","title":"设计模式(创建型模式)：抽象工厂"},{"content":"在 ABP 框架当中所有库以及项目都是以模块的形式存在，所有模块都是继承自AbpModule 这个抽象基类，每个模块都拥有四个生命周期。分别是：\nPreInitialze(); Initialize(); PostInitialize(): ShutDown(); AddAbp() 在初始化 ABP 框架的时候，通过 services.AddAbp\u0026lt;AbpTestMulitPageWebHostModule\u0026gt;方法将启动模块作为泛型参数传入到 AddAbp 当中。 之后根据传入的启动模块，初始化 AbpBootstrapper，在 AbpBootstrapper 初始化的时候执行拦截器注册等操作。 之后配置 Asp Net Core 相关服务，替换控制器、视图组件、过滤器等默认实现，改用ABP 框架的实现，并且将 Ioc 容器替换为 CastleWindsor。\napp.UseAbp() 之前的 AddAbp 仅仅是在 ConfigureService 注入服务，紧接着就会在 Configure方法启用 Abp 中间件。\n1 2 3 4 5 private static void InitializeAbp(IApplicationBuilder app) { var abpBootstrapper = app.ApplicationServices.GetRequiredService\u0026lt;AbpBootstrapper\u0026gt;(); abpBootstrapper.Initialize(); } 可以看到在初始化 ABP 的时候，实际上是从 Ioc 容器中解析出 AbpBootStrapper 调用它的初始化方法。\nAbpBootStrapper.Initialize() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public virtual void Initialize() { ResolveLogger(); try { RegisterBootstrapper(); IocManager.IocContainer.Install(new AbpCoreInstaller()); IocManager.Resolve\u0026lt;AbpPlugInManager\u0026gt;().PlugInSources.AddRange(PlugInSources); IocManager.Resolve\u0026lt;AbpStartupConfiguration\u0026gt;().Initialize(); _moduleManager = IocManager.Resolve\u0026lt;AbpModuleManager\u0026gt;(); _moduleManager.Initialize(StartupModule); _moduleManager.StartModules(); } catch (Exception ex) { _logger.Fatal(ex.ToString(), ex); throw; } } 首先注册了日志组件，之后再次注册了 AbpBootStarpper，可能是防止 Ioc 容器没有注册成功吧。 然后调用了 Castle 的 Install 方法，将一些核心组件通过安装器注入到容器当中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public void Install(IWindsorContainer container, IConfigurationStore store) { container.Register( Component.For\u0026lt;IUnitOfWorkDefaultOptions, UnitOfWorkDefaultOptions\u0026gt;().ImplementedBy\u0026lt;UnitOfWorkDefaultOptions\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;INavigationConfiguration, NavigationConfiguration\u0026gt;().ImplementedBy\u0026lt;NavigationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ILocalizationConfiguration, LocalizationConfiguration\u0026gt;().ImplementedBy\u0026lt;LocalizationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAuthorizationConfiguration, AuthorizationConfiguration\u0026gt;().ImplementedBy\u0026lt;AuthorizationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IValidationConfiguration, ValidationConfiguration\u0026gt;().ImplementedBy\u0026lt;ValidationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IFeatureConfiguration, FeatureConfiguration\u0026gt;().ImplementedBy\u0026lt;FeatureConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ISettingsConfiguration, SettingsConfiguration\u0026gt;().ImplementedBy\u0026lt;SettingsConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IModuleConfigurations, ModuleConfigurations\u0026gt;().ImplementedBy\u0026lt;ModuleConfigurations\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IEventBusConfiguration, EventBusConfiguration\u0026gt;().ImplementedBy\u0026lt;EventBusConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IMultiTenancyConfig, MultiTenancyConfig\u0026gt;().ImplementedBy\u0026lt;MultiTenancyConfig\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ICachingConfiguration, CachingConfiguration\u0026gt;().ImplementedBy\u0026lt;CachingConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAuditingConfiguration, AuditingConfiguration\u0026gt;().ImplementedBy\u0026lt;AuditingConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IBackgroundJobConfiguration, BackgroundJobConfiguration\u0026gt;().ImplementedBy\u0026lt;BackgroundJobConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;INotificationConfiguration, NotificationConfiguration\u0026gt;().ImplementedBy\u0026lt;NotificationConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IEmbeddedResourcesConfiguration, EmbeddedResourcesConfiguration\u0026gt;().ImplementedBy\u0026lt;EmbeddedResourcesConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAbpStartupConfiguration, AbpStartupConfiguration\u0026gt;().ImplementedBy\u0026lt;AbpStartupConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IEntityHistoryConfiguration, EntityHistoryConfiguration\u0026gt;().ImplementedBy\u0026lt;EntityHistoryConfiguration\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ITypeFinder, TypeFinder\u0026gt;().ImplementedBy\u0026lt;TypeFinder\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAbpPlugInManager, AbpPlugInManager\u0026gt;().ImplementedBy\u0026lt;AbpPlugInManager\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAbpModuleManager, AbpModuleManager\u0026gt;().ImplementedBy\u0026lt;AbpModuleManager\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;IAssemblyFinder, AbpAssemblyFinder\u0026gt;().ImplementedBy\u0026lt;AbpAssemblyFinder\u0026gt;().LifestyleSingleton(), Component.For\u0026lt;ILocalizationManager, LocalizationManager\u0026gt;().ImplementedBy\u0026lt;LocalizationManager\u0026gt;().LifestyleSingleton() ); } 下一步解析 AbpBootStrapperConfiguration 初始化所有核心模块的配置项。 之后就是最重要的初始化模块操作了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private void LoadAllModules() { Logger.Debug(\u0026#34;Loading Abp modules...\u0026#34;); List\u0026lt;Type\u0026gt; plugInModuleTypes; // 查找所有模块，封装到 List\u0026lt;Type\u0026gt; 容器 var moduleTypes = FindAllModuleTypes(out plugInModuleTypes).Distinct().ToList(); Logger.Debug(\u0026#34;Found \u0026#34; + moduleTypes.Count + \u0026#34; ABP modules in total.\u0026#34;); // 注册模块到 Ioc 容器 RegisterModules(moduleTypes); CreateModules(moduleTypes, plugInModuleTypes); _modules.EnsureKernelModuleToBeFirst(); _modules.EnsureStartupModuleToBeLast(); SetDependencies(); Logger.DebugFormat(\u0026#34;{0} modules loaded.\u0026#34;, _modules.Count); } FindAllModuleTypes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private List\u0026lt;Type\u0026gt; FindAllModuleTypes(out List\u0026lt;Type\u0026gt; plugInModuleTypes) { plugInModuleTypes = new List\u0026lt;Type\u0026gt;(); // 内部根据[DependsOn]特性来，递归获取所有模块 var modules = AbpModule.FindDependedModuleTypesRecursivelyIncludingGivenModule(_modules.StartupModuleType); foreach (var plugInModuleType in _abpPlugInManager.PlugInSources.GetAllModules()) { if (modules.AddIfNotContains(plugInModuleType)) { plugInModuleTypes.Add(plugInModuleType); } } return modules; } CreateModules 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void CreateModules(ICollection\u0026lt;Type\u0026gt; moduleTypes, List\u0026lt;Type\u0026gt; plugInModuleTypes) { foreach (var moduleType in moduleTypes) { var moduleObject = _iocManager.Resolve(moduleType) as AbpModule; if (moduleObject == null) { throw new AbpInitializationException(\u0026#34;This type is not an ABP module: \u0026#34; + moduleType.AssemblyQualifiedName); } moduleObject.IocManager = _iocManager; moduleObject.Configuration = _iocManager.Resolve\u0026lt;IAbpStartupConfiguration\u0026gt;(); // 将模块类型封装到 AbpModule 当中 var moduleInfo = new AbpModuleInfo(moduleType, moduleObject, plugInModuleTypes.Contains(moduleType)); _modules.Add(moduleInfo); // 设置启动模块 if (moduleType == _modules.StartupModuleType) { StartupModule = moduleInfo; } Logger.DebugFormat(\u0026#34;Loaded module: \u0026#34; + moduleType.AssemblyQualifiedName); } } 总的来说 CreateModules 的作用就是将之前获取到的模块类型数据再封装为 AbpModuleInfo对象。在 ModuleInfo 对象内部还包括了这个模块所依赖的模块信息。 构建好所有模块的 ModuleInfo 信息之后，对这个 List\u0026lt;ModuleInfo\u0026gt; 进行排序，将启动模块放在最后，将核心模块放在第一位，具体操作可以参考 _modules.EnsureKernelModuleToBeFirst(); 和_modules.EnsureStartupModuleToBeLast(); 这两个方法。这么做是因为要确保最核心的模块第一位初始化，然后再依次初始化他的子模块。因为是启动模块，所以他是这个依赖树的最低端，留在最后初始化。\nSetDependencies 遍历 List\u0026lt;ModuleType\u0026gt; 设置每个模块的依赖模块。回到最开始的地方，这里仅仅是初始化模块，之后调用了 StartModules 才是真正的启动模块：\n1 2 3 4 5 6 7 public virtual void StartModules() { var sortedModules = _modules.GetSortedModuleListByDependency(); sortedModules.ForEach(module =\u0026gt; module.Instance.PreInitialize()); sortedModules.ForEach(module =\u0026gt; module.Instance.Initialize()); sortedModules.ForEach(module =\u0026gt; module.Instance.PostInitialize()); } 启动模块的时候，先按照依赖项来排序，顺序是 Kernal-\u0026gt;Module1-\u0026gt;Module-\u0026gt;2-\u0026gt;StartModule。之后从 PreInitialize-\u0026gt;Initialize-\u0026gt;PostInitialize 这样遍历执行。 执行完之后所有模块就已经初始化完成了。 这里可以看到并没有 ShutDown 方法执行，ShutDown 执行的时机是在 AbpBootStrapper 被释放的时候，进行调用。\n1 2 3 4 5 6 7 8 public virtual void ShutdownModules() { Logger.Debug(\u0026#34;Shutting down has been started\u0026#34;); var sortedModules = _modules.GetSortedModuleListByDependency(); sortedModules.Reverse(); sortedModules.ForEach(sm =\u0026gt; sm.Instance.Shutdown()); Logger.Debug(\u0026#34;Shutting down completed.\u0026#34;); } 不过执行 ShutDown 方法的时候，会将模块列表反转，按照 Start-\u0026gt;Module2-\u0026gt;Module1-\u0026gt;Kernal 这样来关闭。 模块是 ABP 框架的基础单元，在 ABP 的实现当中模块大部分被当做功能库的形式存在。如果你要使用 ABP 框架的话，必须要定义一个启动模块，不然其他功能是无法正常进行初始化的。\nAbpModule 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 public abstract class AbpModule { /// \u0026lt;summary\u0026gt; /// Gets a reference to the IOC manager. /// \u0026lt;/summary\u0026gt; protected internal IIocManager IocManager { get; internal set; } /// \u0026lt;summary\u0026gt; /// Gets a reference to the ABP configuration. /// \u0026lt;/summary\u0026gt; protected internal IAbpStartupConfiguration Configuration { get; internal set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the logger. /// \u0026lt;/summary\u0026gt; public ILogger Logger { get; set; } protected AbpModule() { Logger = NullLogger.Instance; } /// \u0026lt;summary\u0026gt; /// This is the first event called on application startup. /// Codes can be placed here to run before dependency injection registrations. /// \u0026lt;/summary\u0026gt; public virtual void PreInitialize() { } /// \u0026lt;summary\u0026gt; /// This method is used to register dependencies for this module. /// \u0026lt;/summary\u0026gt; public virtual void Initialize() { } /// \u0026lt;summary\u0026gt; /// This method is called lastly on application startup. /// \u0026lt;/summary\u0026gt; public virtual void PostInitialize() { } /// \u0026lt;summary\u0026gt; /// This method is called when the application is being shutdown. /// \u0026lt;/summary\u0026gt; public virtual void Shutdown() { } public virtual Assembly[] GetAdditionalAssemblies() { return new Assembly[0]; } /// \u0026lt;summary\u0026gt; /// Checks if given type is an Abp module class. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;type\u0026#34;\u0026gt;Type to check\u0026lt;/param\u0026gt; public static bool IsAbpModule(Type type) { var typeInfo = type.GetTypeInfo(); return typeInfo.IsClass \u0026amp;\u0026amp; !typeInfo.IsAbstract \u0026amp;\u0026amp; !typeInfo.IsGenericType \u0026amp;\u0026amp; typeof(AbpModule).IsAssignableFrom(type); } /// \u0026lt;summary\u0026gt; /// Finds direct depended modules of a module (excluding given module). /// \u0026lt;/summary\u0026gt; public static List\u0026lt;Type\u0026gt; FindDependedModuleTypes(Type moduleType) { if (!IsAbpModule(moduleType)) { throw new AbpInitializationException(\u0026#34;This type is not an ABP module: \u0026#34; + moduleType.AssemblyQualifiedName); } var list = new List\u0026lt;Type\u0026gt;(); if (moduleType.GetTypeInfo().IsDefined(typeof(DependsOnAttribute), true)) { var dependsOnAttributes = moduleType.GetTypeInfo().GetCustomAttributes(typeof(DependsOnAttribute), true).Cast\u0026lt;DependsOnAttribute\u0026gt;(); foreach (var dependsOnAttribute in dependsOnAttributes) { foreach (var dependedModuleType in dependsOnAttribute.DependedModuleTypes) { list.Add(dependedModuleType); } } } return list; } public static List\u0026lt;Type\u0026gt; FindDependedModuleTypesRecursivelyIncludingGivenModule(Type moduleType) { var list = new List\u0026lt;Type\u0026gt;(); AddModuleAndDependenciesRecursively(list, moduleType); list.AddIfNotContains(typeof(AbpKernelModule)); return list; } private static void AddModuleAndDependenciesRecursively(List\u0026lt;Type\u0026gt; modules, Type module) { if (!IsAbpModule(module)) { throw new AbpInitializationException(\u0026#34;This type is not an ABP module: \u0026#34; + module.AssemblyQualifiedName); } if (modules.Contains(module)) { return; } modules.Add(module); var dependedModules = FindDependedModuleTypes(module); foreach (var dependedModule in dependedModules) { AddModuleAndDependenciesRecursively(modules, dependedModule); } } } 在 Abp 模块当中会为你注入一些必须的设施，比如 Ioc 容器，模块配置集合，日志记录器等。 如果想知道模块如何编写，可以参考 ABP 原有的功能模块实现。\n","date":"2018-01-27T05:14:00Z","permalink":"https://real-zony.github.io/p/talking-about-module-system-and-abp-framework-initialization/","title":"浅谈模块系统与 ABP 框架初始化"},{"content":" ABP在其内部实现了工作单元模式，统一地进行事务与连接管理。 其核心就是通过 Castle 的 Dynamic Proxy 进行动态代理，在组件注册的时候进行拦截器注入，拦截到实现了 Unit Of Work 特性的方法进行操作，在执行完方法之后就会关闭掉工作单元。\n其整体流程大概如下：\n首先 UOW 相关接口、拦截器等通过 IocManager 注入到 Ioc 容器当中。 监听 Ioc 注册事件，并为其添加方法拦截器。 在拦截器内部使用 using 包裹数据库操作方法，使其成为一个工作单元。 一旦在方法 procced 执行的时候，产生任何异常触发任何异常都不会执行 Complete 方法，直接抛出终止执行。 UnitOfWorkInterceptors 这是一个 Castle Interceptors 的实现，在 AbpBootStrap 的 Initialze 方法当中被注入到 Ioc 容器。\n1 2 3 4 5 6 7 8 private void AddInterceptorRegistrars() { ValidationInterceptorRegistrar.Initialize(IocManager); AuditingInterceptorRegistrar.Initialize(IocManager); EntityHistoryInterceptorRegistrar.Initialize(IocManager); UnitOfWorkRegistrar.Initialize(IocManager); AuthorizationInterceptorRegistrar.Initialize(IocManager); } 之后在 Registrar 内部针对组件注入事件进行绑定：\n1 2 3 4 5 6 7 8 9 public static void Initialize(IIocManager iocManager) { iocManager.IocContainer.Kernel.ComponentRegistered += (key, handler) =\u0026gt; { var implementationType = handler.ComponentModel.Implementation.GetTypeInfo(); HandleTypesWithUnitOfWorkAttribute(implementationType, handler); HandleConventionalUnitOfWorkTypes(iocManager, implementationType, handler); }; } 在这里的两个方法分别是针对已经实现了 UnitOfWork 特性的类进行绑定，另外一个则是针对符合命名规则的类型进行拦截器绑定。 拦截器做的事情十分简单，针对拦截到的方法进行 UOW 特性检测，如果检测通过之后则直接执行工作单元方法，并根据特性生成 Options。不过不是一个 UOW 的话，则直接继续执行原先方法内代码。\n1 2 3 4 5 6 7 8 var unitOfWorkAttr = _unitOfWorkOptions.GetUnitOfWorkAttributeOrNull(method); if (unitOfWorkAttr == null || unitOfWorkAttr.IsDisabled) { //No need to a uow invocation.Proceed(); return; } PerformUow(invocation, unitOfWorkAttr.CreateOptions()); 在创建 UOW 的时候，拦截器也会根据方法类型的不同来用不同的方式构建 UOW 。 如果是同步方法的话：\n1 2 3 4 5 6 7 8 9 10 11 12 private void PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) { // 直接从 Manager 生成一个新的工作单元 using (var uow = _unitOfWorkManager.Begin(options)) { // 继续执行原方法 // 产生异常直接进入 uow 的 Dispose 方法 invocation.Proceed(); // 如果一切正常，提交事务 uow.Complete(); } } 但如果这个工作单元被标注在异步方法上面，则操作略微复杂：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private void PerformAsyncUow(IInvocation invocation, UnitOfWorkOptions options) { // 获得一个工作单元 var uow = _unitOfWorkManager.Begin(options); // 继续执行拦截到的方法 try { invocation.Proceed(); } catch { uow.Dispose(); throw; } // 如果是异步无返回值的方法 if (invocation.Method.ReturnType == typeof(Task)) { invocation.ReturnValue = InternalAsyncHelper.AwaitTaskWithPostActionAndFinally( (Task) invocation.ReturnValue, async () =\u0026gt; await uow.CompleteAsync(), exception =\u0026gt; uow.Dispose() ); } else //Task\u0026lt;TResult\u0026gt; { invocation.ReturnValue = InternalAsyncHelper.CallAwaitTaskWithPostActionAndFinallyAndGetResult( invocation.Method.ReturnType.GenericTypeArguments[0], invocation.ReturnValue, async () =\u0026gt; await uow.CompleteAsync(), exception =\u0026gt; uow.Dispose() ); } } 以上代码在进入的时候直接执行原方法，如果产生任何异常直接进入 Dispose 方法并且抛出异常。乍一看与同步方法处理没什么区别，但重点是这里并没有执行 Complete 方法,因为这里需要对其异步返回结果更改为 UOW 异步提交之后的值，先查看第一种直接返回 Task 的情况.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static async Task AwaitTaskWithPostActionAndFinally(Task actualReturnValue, Func\u0026lt;Task\u0026gt; postAction, Action\u0026lt;Exception\u0026gt; finalAction) { Exception exception = null; try { // 原有异步任务返回值 await actualReturnValue; // 新的异步返回结果 await postAction(); } catch (Exception ex) { exception = ex; throw; } finally { finalAction(exception); } } 在内部首先等待原有任务执行完成之后再执行传入的 UOW 的 CompleteAsync() 方法，并且在执行过程中有无异常都会直接调用 UOW 的 Disopse 释放资源。 第二种则适用于有返回值的情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public static object CallAwaitTaskWithPostActionAndFinallyAndGetResult(Type taskReturnType, object actualReturnValue, Func\u0026lt;Task\u0026gt; action, Action\u0026lt;Exception\u0026gt; finalAction) { // 获得 AwaitTaskWithPreActionAndPostActionAndFinallyAndGetResult 方法，并且通过反射构造一个泛型方法，并且将自身参数传入调用。 return typeof (InternalAsyncHelper) .GetMethod(\u0026#34;AwaitTaskWithPostActionAndFinallyAndGetResult\u0026#34;, BindingFlags.Public | BindingFlags.Static) .MakeGenericMethod(taskReturnType) .Invoke(null, new object[] { actualReturnValue, action, finalAction }); } public static async Task\u0026lt;T\u0026gt; AwaitTaskWithPreActionAndPostActionAndFinallyAndGetResult\u0026lt;T\u0026gt;(Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; actualReturnValue, Func\u0026lt;Task\u0026gt; preAction = null, Func\u0026lt;Task\u0026gt; postAction = null, Action\u0026lt;Exception\u0026gt; finalAction = null) { Exception exception = null; try { if (preAction != null) { await preAction(); } var result = await actualReturnValue(); if (postAction != null) { await postAction(); } return result; } catch (Exception ex) { exception = ex; throw; } finally { if (finalAction != null) { finalAction(exception); } } } 这两个方法的作用都是确保 CompleteAsync 和 Dispose 能够在放在异步任务当中执行。\nIUnitOfWorkManager 顾名思义，这是一个 UOW 的管理器，在 ABP 内部有其一个默认实现 UnitOfWorkManager，在 AbpKernel 模块初始化的时候就已经被注入。 核心方法是 Begin 方法，在 Begin 方法当中通过 FillDefaultsForNonProvidedOptions 方法判断是否传入了配置参数，如果没有传入的话则构建一个默认参数对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public IUnitOfWorkCompleteHandle Begin(UnitOfWorkOptions options) { // 如果没有 UOW 参数，构造默认参数 options.FillDefaultsForNonProvidedOptions(_defaultOptions); var outerUow = _currentUnitOfWorkProvider.Current; // 当前是否已经存在工作单元，存在工作单元的话，构建一个内部工作单元 if (options.Scope == TransactionScopeOption.Required \u0026amp;\u0026amp; outerUow != null) { return new InnerUnitOfWorkCompleteHandle(); } // 不存在的话构建一个新的工作单元 var uow = _iocResolver.Resolve\u0026lt;IUnitOfWork\u0026gt;(); // 绑定各种事件 uow.Completed += (sender, args) =\u0026gt; { _currentUnitOfWorkProvider.Current = null; }; uow.Failed += (sender, args) =\u0026gt; { _currentUnitOfWorkProvider.Current = null; }; uow.Disposed += (sender, args) =\u0026gt; { _iocResolver.Release(uow); }; //Inherit filters from outer UOW if (outerUow != null) { options.FillOuterUowFiltersForNonProvidedOptions(outerUow.Filters.ToList()); } uow.Begin(options); //Inherit tenant from outer UOW if (outerUow != null) { uow.SetTenantId(outerUow.GetTenantId(), false); } // 设置当前工作单元为新创建的 UOW _currentUnitOfWorkProvider.Current = uow; return uow; } 这里 Begin 方法所返回的是一个 IUnitOfWorkCompleteHandle 对象，跳转到 IUnitOfWorkCompleteHandle，可以看到它有两个方法：\n1 2 3 4 5 public interface IUnitOfWorkCompleteHandle : IDisposable { void Complete(); Task CompleteAsync(); } 都是完成工作单元的方法，一个同步、一个异步，同时这个接口也实现了 IDispose 接口，从开始使用 using 就可以看出其含义。\nInnerUnitOfWorkCompleteHandle 参考其引用，可以发现有一个 IUnitOfWork 接口继承自它,并且还有一个 InnerUnitOfWorkCompleteHandle 的内部实现。这里先查看 InnerUnitOfWorkCompleteHandle 内部实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 internal class InnerUnitOfWorkCompleteHandle : IUnitOfWorkCompleteHandle { public const string DidNotCallCompleteMethodExceptionMessage = \u0026#34;Did not call Complete method of a unit of work.\u0026#34;; private volatile bool _isCompleteCalled; private volatile bool _isDisposed; public void Complete() { _isCompleteCalled = true; } public Task CompleteAsync() { _isCompleteCalled = true; return Task.FromResult(0); } public void Dispose() { if (_isDisposed) { return; } _isDisposed = true; if (!_isCompleteCalled) { if (HasException()) { return; } throw new AbpException(DidNotCallCompleteMethodExceptionMessage); } } private static bool HasException() { try { return Marshal.GetExceptionCode() != 0; } catch (Exception) { return false; } } } 其内部实现十分简单，其中 Complete 的同步和异步方法都只是对完成标识进行一个标记。并未真正的进行任何数据库事务操作。同时在他的内部也实现了 IDispose 接口，如果 complete 未被标记为已完成，那么直接抛出异常，后续操作不会执行。 现在再转到 Begin 方法内部就可以发现，在创建的时候会首先判断了当前是否已经存在了工作单元，如果存在了才会创建这样一个内部工作单元。也就是说真正那个的事务操作是在返回的 IUnitOfWork 当中实现的。 这样的话就会构建出一个嵌套的工作单元:\n1 OuterUOW-\u0026gt;InnerUow1-\u0026gt;InnerUOW2-\u0026gt;.....-\u0026gt;InnerUowN 你可以想象有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public void TestUowMethod() { using(var outerUOW = Manager.Begin()) // 这里返回的是 IOC 解析出的 IUnitOfWork { OperationOuter(); using(var innerUOW1 = Manager.Begin()) // 内部 UOW { Operation1(); using(var innerUOW2 = Manager.Begin()) // 内部 UOW { Operation2(); Complete(); } Complete(); } Complete(); } } 当代码执行的时候，如同俄罗斯套娃，从内部依次到外部执行，内部工作单元仅会在调用 Complete 方法的时候将 completed 标记为 true，但一旦操作抛出异常，Complete无法得到执行，则会直接抛出异常，中断外层代码执行。 那么 IUnitOfWork 的实现又是怎样的呢？ 在 ABP 内部针对 EF Core 框架实现了一套 UOW，其继承自 UnitOfWorkBase，而在 UnitOfWorkBase 内部有部分针对接口 IActiveUnitOfWork 的实现，同时由于 IUnifOfWork 也实现了 IUnitOfWorkCompleteHandle 接口，所以在 Begin 方法处能够向上转型。\nIActiveUnitOfWork 在 IActiveUnitOfWork 接口当中定义了工作单元的三个事件，用户在使用的时候可以针对这三个事件进行绑定。\n事件名称 触发条件 Completed 工作单元调用 Complete 方法之后触发 Failed 工作单元在调用 Complete 方法如果产生异常，则会在 Dispose 释放资源时触发。 Disposed 释放工作单元的时候触发 除了三个事件之外，在 ABP 当中的数据过滤器也是在工作单元调用的时候工作的，后面讲解 EfCoreUnitOfWork 的时候会研究，数据过滤仅包括软删除等审计字段，同时也包括多租户的租户 ID 也在工作单元当中进行设置的。 在这里也定义了两个 SaveChanges 方法，一个同步、一个异步，作用跟实体上下文的同名方法作用差不多。\nIUnitOfWork IUnitOfWork 同时继承了 IUnitOfWorkCompleteHandle 与 IActiveUnitOfWork 接口，并且增加了两个属性与一个 Begin 方法。\nUnitOfWorkBase UnitOfWorkBase 是所有工作单元的一个抽象基类，在其内部实现了 IUnitOfWork 的所有方法，其中也包括两个父级接口。 下面就一个一个属性讲解。\nId 这个 Id 是在构造函数当中初始化的，全局唯一的 Id,使用 Guid 初始化其值。\nOuter 用于标明当前工作单元的外部工作单元，其值是在 UnitOfWorkManager 创建工作单元的时候赋予的。在 Manager 的 Begin 方法当中每次针对 Current Uow 赋值的时候都会将已经存在的 UOW 关联最新的 Current Uow 的 Outer 属性上面。形成如下结构：\n1 Current Uow = Uow3.Outer = Uow2.Outer = Uow1.Outer = null 具体代码参考 ICurrentUnitOfWorkProvider 的实现。\nBegin() 在 Manager 创建好一个 Uow 之后，就会调用它的 Begin 方法，在内部首先做了一个判断，判断是否多次调用了 Begin 方法，这里可以看到并未做加锁处理。这是因为在 ABP 当中，一个线程当中共用一个工作单元。其实在 CurrentProvider 的代码当中就可以看出来如果在一个线程里面创建了多个工作单元，他会将其串联起来。 之后设置过滤器，并且开始调用 BeginUow 方法，这里并未实现，具体实现我们转到 EfUnitOfWork 可以看到。\nBeginUow()-EfCoreUnitOfWork 1 2 3 4 5 6 7 protected override void BeginUow() { if (Options.IsTransactional == true) { _transactionStrategy.InitOptions(Options); } } 覆写了父类方法，仅对设置进行初始化。 其实到这里我们就大概清楚了 ABP 整个 UOW 的工作流程，如果是两个打上 UnitOfWork 特性的方法在 A 调用 B 的时候其实就会封装成两个嵌套的 using 块。\n1 2 3 4 5 6 7 8 9 10 using(var a = Manager.Begin()) { // 操作 using(var b = Manager.Begin()) { // 操作 b.Complete(); } a.Complete(); } 而最外层的 Complete 就是真正执行了数据库事务操作的。 可以看下 EfUnitOfWork 的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 这里是 UnitOfWorkBase 的 Complete 方法 public void Complete() { PreventMultipleComplete(); try { CompleteUow(); _succeed = true; OnCompleted(); } catch (Exception ex) { _exception = ex; throw; } } // 这里是 EfUnitOfWork 的 CompleteUow 方法 protected override void CompleteUow() { SaveChanges(); CommitTransaction(); } // 遍历所有激活的 DbContext 并保存更改到数据库 public override void SaveChanges() { foreach (var dbContext in GetAllActiveDbContexts()) { SaveChangesInDbContext(dbContext); } } // 提交事务 private void CommitTransaction() { if (Options.IsTransactional == true) { _transactionStrategy.Commit(); } } ","date":"2018-01-26T15:22:00Z","permalink":"https://real-zony.github.io/p/talking-about-the-application-of-work-unit-in-the-whole-abp-framework/","title":"浅谈工作单元 在整个 ABP 框架当中的应用"},{"content":"介绍完简单工厂之后，现在就来介绍一下工厂方法模式。之前简单工厂有一个弊端就是每次你需要产生新的产品的时候都需要对创建工厂类进行更改，如同前一篇文章说过的一样最后的后果是工厂类会变得十分庞大。 而工厂方法模式就是对简单工厂的进一步抽象，引入了抽象工厂，而具体的产品则由具体的产品工厂来进行构建。从而将创建对象的工作从一个工厂当中分离出来，转而延迟到具体的产品工厂来进行实例化。 所以，在工厂方法模式当中，由这 4 个对象构成：\n抽象工厂 具体工厂 抽象产品 具体产品 抽象工厂用于用于定义创建产品等抽象方法，而具体工厂则实习现这些接口用来创建具体产品。我们用来代码来实现。 抽象工厂: 1 2 3 4 public abstract class AbsFactory { public abstract Food CreateFood(); } 具体工厂A:\n1 2 3 4 5 6 7 public class FactoryA : AbsFactory { public override Food CreateFood() { return new FoodA(); } } 具体工厂B:\n1 2 3 4 5 6 7 public class FactoryB : AbsFactory { public override Food CreateFood() { return new FoodB(); } } 抽象产品:\n1 2 3 4 public abstract class Food { public abstract void Print(); } 具体产品A:\n1 2 3 4 5 6 7 public class FoodA : Food { public override void Print() { Console.WriteLine(\u0026#34;这是具体产品A\u0026#34;); } } 具体产品B:\n1 2 3 4 5 6 7 public class FoodB : Food { public override void Pring() { Console.WriteLine(\u0026#34;这是具体产品B\u0026#34;); } } 使用：\n1 2 3 4 5 6 7 8 9 10 public class Startup { static void Main() { Food foodA = new FactoryA().CreateFood(); Food foodb = new FactoryB().CreateFood(); foodA.Print(); foodB.Print(); } } 这些工厂类别的设计模式都对用户隐藏了创建细节，用户不用关心对象是如何创建的，只需要调用工厂方法来创建即可。 而且工厂方法将具体的操作落实到具体子类，这样的话，当新增产品的时候不需要对工厂类进行任何更改，直接继承自抽象工厂即可。 不过也有不好的地方，你每次要新增一个产品，那么也就意味着你也需要增加一个相应的工厂，会造成系统复杂度提升。 工厂模式核心基本上就是，将对象的依赖由对象到工厂。\n","date":"2018-01-26T06:21:00Z","permalink":"https://real-zony.github.io/p/design-patterns-creative-patterns-factory-methods/","title":"设计模式(创建型模式)：工厂方法"},{"content":"在设计模式当中有三大工厂，分别是 简单工厂、抽象工厂、工厂方法 这三种创建实例的设计模式，这里先从简单工厂将其，从名字就可以看出这是这三种工厂模式当中最为简单的一种实现。 简单工厂一般由以下几个对象组成：\n对象 作用 工厂类 负责创建产品 抽象产品类 工厂创建出来的产品抽象 具体产品类 继承自抽象产品类，具体的产品功能 那么我们为什么不直接 new 一个对象来执行操作呢？如果有以下代码:\n1 2 3 4 5 6 7 8 public class BusinessClass { public void Process() { Car _car = new Car(); _car.Run(); } } 这么写的话，一旦我们业务逻辑发生变化，我不想创建 Car 对象了，我想创建一个 AirPlane 对象，他也具有 Run 方法，这个时候这种写法就很尴尬了，我需要在后面加一个 AirPlane air = new AirPlane() 然后再 Run。 而工厂模式则将创建与使用分离开来，用户不用关心怎么创建的，只需要告诉工厂你需要哪种类型的对象，我给你创建好，你直接调用即可。乍一看来没有什么改变，但之前直接 new 对象的方式则造成 BusinessClass 对于 Car 等对象造成了一种依赖关系。 换句话说，如果按照上面那种方式书写，BusinessClass 则是依赖于 Car 对象的，而简单工厂则是降低对象之间的耦合度(依赖)的。 在上面的例子中，我们要封装他们的改变，他们之间改变的地方在于实例的创建，那么我们封装之后就由工厂来进行创建，便有以下代码： 抽象产品类：\n1 2 3 4 public abstract class Product { void Run(); } 再有一个工厂类:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static class Factory { public static Product CreateInstance(string type) { switch(type) { case \u0026#34;Car\u0026#34;: return new Car(); case \u0026#34;AirPlane\u0026#34;: return new AirPlane(); default: return null; } } } 有了工厂类，我们再来定义两个具体的实现类:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Car : Product { public override void Run() { Console.WriteLine(\u0026#34;这是汽车\u0026#34;); } } public class AirPlane : Product { public override void Run() { Console.WriteLine(\u0026#34;这是飞机\u0026#34;); } } 之后我们再改一下刚才的 BusinessClass:\n1 2 3 4 5 6 7 8 9 10 public class BusinessClass { public void Process() { Product car = Factory.CreateInstance(\u0026#34;Car\u0026#34;); car.Run(); Product air = Factory.CreateInstance(\u0026#34;AirPlane\u0026#34;); air.Run(); } } 这里其实我们也察觉了，如果我们每增加一个具体的产品，那么我们的工厂方法逻辑也会越来越臃肿，而且工厂类一点不能正常运行，就 会造成灾难性的后果。 简单工厂仅适用于工厂类负责创建的对象，较少的话对于工厂类的逻辑也不会太复杂。而且用户仅需要知道传入工厂类的参数即可创建对象，用户不需要具体的创建过程。\n","date":"2018-01-25T09:42:00Z","permalink":"https://real-zony.github.io/p/design-patterns-creative-patterns-simple-factory/","title":"设计模式(创建型模式)：简单工厂"},{"content":"单例模式用于在整个软件系统当中保持唯一实例，在 C# 当中最能够体现此概念的就是静态类，静态类的生命周期是跟随整个程序，并且在整个程序中仅保有一个实例。\n不过在这里我们不再详细阐述单例模式与静态类有什么区别，如果有兴趣的话可以查看 这篇博文 和 这篇博文。\n这里说一下个人的理解：\n单例模式可以用实现接口与继承，而静态类是无法实现的。 单例模式可以方便进行 Mock 测试。 单例对象可以很方便的进行替换。 静态类/静态方法更多的是用于工具类方法，是无状态的。 为了保证我们的对象是全局唯一的，那么我们肯定不能够通过 new 来创建单例对象，所以我们首先要将其构造函数设为私有的，其次我们肯定要有一个 static 字段来保存我们唯一的实例化对象。 既然不能通过 new 来实例化对象，则需要提供一个全局访问点。下面我们就来看一下具体实现：\n1 2 3 4 5 6 7 8 9 10 11 public class SingletonImplementation { private static SingletonImplementation m_instance; private SingletonImplementation(){} public static SingletonImplementation GetInstance() { if(m_instance == null) m_instance = new SingletonImplementation(); return m_instance; } } 实现起来是相当简单的，这里我们将构造函数设置为私有的，然后通过 GetInstance 方法来取得对象的实例。其实这里可以改用一个静态属性来实现，更加方便。 如果考虑到线程安全的话，就需要加一个 locker 来保证访问不会重复创建对象。因为如果在多线程环境当中调用这个静态类的时候，可能在同一时间都会访问到 m_instance，这个时候 m_instance 都为空的情况下就会连续创建两次实例，这就违背了初衷。最简单的方法就是加锁，让 m_instance 在同一时间只能一个线程访问这个对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class SingletonImplementation { private static SingletonImplementation m_instance; private static readony object _locker = new object(); private SingletonImplementation(){} public static SingetonImplementation Instance { get { lock(_locker) { if(m_instance == null) m_instance = new SingetonImplementation(); } return m_instance; } } } 不过这样又产生了另外一个问题，如果线程每次访问 Instance 都会对 _locker 加锁后在访问实例是否存在，这样对性能影响十分严重。这里我们可以使用 双重检查锁定模式 来实现。\n双重检查锁定模式（也被称为\u0026quot;双重检查加锁优化\u0026quot;，\u0026ldquo;锁暗示\u0026rdquo;（Lock hint）[1]) 是一种软件设计模式用来减少并发系统中竞争和同步的开销。双重检查锁定模式 首先验证锁定条件(第一次检查)，只有通过锁定条件验证才真正的进行加锁逻辑 并再次验证条件(第二次检查)。\n也就是说我们首先验证 m_instance 是否为空，如果为空的话再进行加锁执行逻辑，否则的话直接返回已经实例化成功的 m_instance。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class SingetonImplementation { private static SingetonImplementation _instance; private static readonly object _locker = new object(); private SingetonImplementation(){} public static SingetonImplementation Instance { if(_instance == null) { locker(_locker) { if(_instance == null) _instance = new SingetonImplementation(); } } return _instance; } } ","date":"2018-01-24T06:35:00Z","permalink":"https://real-zony.github.io/p/design-pattern-creative-pattern-singleton-pattern/","title":"设计模式(创建型模式)：单例模式"},{"content":"公司出于某些原因需要自己在内部网络搭建一个私有的 Nuget 服务器，而且要运行在 Linux服务器上面。如果说 Windows 下搭建的话很简单，直接在项目当中引入 Nuget 的库就 OK，这儿的话 .Net Core 还没有相应的教程。\n不过在万能的 Docker 上面找到了一个 Simple-Nuget-Server 镜像，具体使用方式在 这里。安装方法请参考之前的 博文，安装好 Docker 按着流程走就行了。 这里记录一下发布到 Nuget 服务器的常用命令与使用方法，首先你需要得到 Nuget 官网下载 Nuget.exe 程序，地址在这儿。 那么我们新建一个库项目，这里我仅以 .NetCore 程序为例，有两种方式可以生成 .nupkg 文件：\n在项目的 .csproject 目录下打开 Shell 工具或者命令行，然后执行 dotnet pack 命令。 在项目属性右键，在 Package 这一栏当中勾选上 generate nuget package，并且在里面可以 控制包版本等其他信息。 当我们的 nupkg 文件生成成功之后就可以通过 Nuget.exe 的 push 命令来发布包文件了。 其命令如下:\n1 nuget push -Source \u0026lt;你的 NUGET 服务器地址\u0026gt; -ApiKey \u0026lt;安装时候填写的密钥\u0026gt; \u0026lt;包文件路径\u0026gt; 例如:\n1 nuget push -Source http://nuget.org -ApiKey 123456 TestLibPackage.nupkg 在填写的时候不要把尖括号的填进去了\u0026hellip;\u0026hellip; 如果你需要发布多个版本的话，改一下版本号，再执行这个命令即可。 再介绍一个命令，如果我们需要删除已经发布的包只需要执行下列命令即可:\n1 nuget delete \u0026lt;包 ID\u0026gt; \u0026lt;包版本\u0026gt; -Source \u0026lt;你的 NUGET 服务器地址\u0026gt; -ApiKey \u0026lt;你的密钥\u0026gt; 例如:\n1 nuget delete TestLibPackage 1.0.0 -Source http://nuget.org -ApiKey 123456 其他的命令可以参考 Microsoft 的官方文档： https://docs.microsoft.com/en-us/nuget/tools/nuget-exe-cli-reference\n这里还有一个坑，你在添加自己的 Nuget 源的时候记得直接填写服务器地址就可以了，后面的 Path 就不用加了。\n","date":"2018-01-23T02:54:00Z","permalink":"https://real-zony.github.io/p/nuget-build-server-and-common-commands/","title":"Nuget 构建服务器与常用命令"},{"content":"在 DotNetCore 当中不再像 MVC5 那样可以通过 HttpContext.Current 来获取到当前请求的上下文。\n不过微软提供了一个 IHttpContextAccessor 来让我们访问当前请求的 Http 上下文，其定义 如下：\n1 2 3 4 5 6 7 namespace Microsoft.AspNetCore.Http { public interface IHttpContextAccessor { HttpContext HttpContext { get; set; } } } 需要使用的话需要将其添加到 Ioc 容器当中，在 Startup 类的 ConfigureService 我们可以将其默认实现注册到 Ioc 之中。\n1 2 3 4 public void ConfigureService(IServiceCollection services) { services.TryAddSingleton\u0026lt;IHttpContextAccessor, HttpContextAccessor\u0026gt;(); } 那么我们可以来看看 HttpContextAccessor 的具体实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 using System.Threading; namespace Microsoft.AspNetCore.Http { public class HttpContextAccessor : IHttpContextAccessor { private static AsyncLocal\u0026lt;HttpContext\u0026gt; _httpContextCurrent = new AsyncLocal\u0026lt;HttpContext\u0026gt;(); public HttpContext HttpContext { get { return _httpContextCurrent.Value; } set { _httpContextCurrent.Value = value; } } } } 在其内部主要是用了一个 AsyncLocal\u0026lt;HttpContext\u0026gt; 来保存一个 HttpContext 实例，那么 Accessor 是什么时候被赋值的呢？答案就是在每次 HTTP 请求的时候会将其赋值。\nAsyncLocal\u0026lt;T\u0026gt; 是什么东西？ AsyncLocal\u0026lt;T\u0026gt; 是在 .Net 4.6 之后推出的一个对象，该对象接受一个泛型参数，其主要作用是保存异步等待上下文中共享某个变量的值。 而异步方法是基于 Task 的自动线程调度，在异步上下文切换的时候可能导致数据丢失。例如在 await 调用之前对某个变量进行了赋值，而这个变量是多个线程间共享的，当 await 调用返回之前的调用点的时候，可能调用点之后的代码还处在之前的线程上，也有可能被调度到其他线程上。\n举个例子：\n1 2 3 4 5 6 static async Task TestMethod() { Console.WriteLine($\u0026#34;当前线程ID{Thread.CurrentThread.ManagedThreadId}\u0026#34;); await Task.Delay(100); Console.WriteLine($\u0026#34;当前线程ID{Thread.CurrentThread.ManagedThreadId}\u0026#34;); } 在 await 等待任务执行完成之后，后面的代码输出的 ID 与调用之前的 ID 不一样，说明发生了线程切换：\n1 2 3 4 5 6 7 static void Main(string[] args) { Action @delegate = async () =\u0026gt; await TestMethod(); @delegate(); Console.ReadKey(); } 从代码上看他们似乎在同一个线程，但是在执行的时候就已经发生了线程切换的操作了。 而我们在这里如果使用一个 ThreadLocal\u0026lt;T\u0026gt;变量来存储的话，会发生什么事情呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static ThreadLocal\u0026lt;int\u0026gt; _threadLocal = new ThreadLocal\u0026lt;int\u0026gt;(); static AsyncLocal\u0026lt;int\u0026gt; _asyncLocal = new AsyncLocal\u0026lt;int\u0026gt;(); static void Main(string[] args) { Action @delegate = async () =\u0026gt; await TestMethod(); @delegate(); Console.ReadKey(); } static async Task TestMethod() { _threadLocal.Value = 1000; _asyncLocal.Value = 2000; Console.WriteLine($\u0026#34;当前线程ID{Thread.CurrentThread.ManagedThreadId}\u0026#34;); Console.WriteLine($\u0026#34;{nameof(_threadLocal)}，值:{_threadLocal.Value}\u0026#34;); Console.WriteLine($\u0026#34;{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\u0026#34;); await Task.Delay(100); Console.WriteLine($\u0026#34;当前线程ID{Thread.CurrentThread.ManagedThreadId}\u0026#34;); Console.WriteLine($\u0026#34;{nameof(_threadLocal)}，值:{_threadLocal.Value}\u0026#34;); Console.WriteLine($\u0026#34;{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\u0026#34;); } SO，在这里解释一下，ThreadLocal 是用于为不同的线程保存不同的变量值的，即同一个变量在不同线程当中存储的值可以不一样。在这里使用是为了保证在 TestMethod 方法中变量的唯一性，这个在同步方法用是没问题的，但这里使用了 await 关键字导致等待异步调用结束后代码已经被调度到其他的线程了，所以这里没用。而 AsyncLocal\u0026lt;T\u0026gt; 正是为了这种情况而准备的。\n","date":"2018-01-22T15:41:00Z","permalink":"https://real-zony.github.io/p/net-core-gets-httpcontextcurrent-and-asynclocal-and-threadlocal/","title":".Net Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal"},{"content":"1.Swagger UI 是什么？ Swagger UI 是一个在线的 API 文档生成与测试工具，你可以将其集成在你的 API 项目当中。\n支持 API 自动同步生成文档 高度自定义，可以自己扩展功能 前后端分离时方便前端进行 API 接口测试 2.如何应用？ 这里仅介绍在 DotNetCore 下如何集成 Swagger UI。\n新建一个 API 项目 从 NuGet 下载 Swagger UI 包 配置 Swagger UI 安装好 Swagger 之后，在需要生成 API 文档的项目当中勾选 XML documentation file. 之后我们需要在 StartUp 当中配置 Swagger 相关的设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddMvc(); services.AddSwaggerGen(options =\u0026gt; { options.SwaggerDoc(\u0026#34;v1\u0026#34;, new Info() { Title = \u0026#34;Swagger Test UI\u0026#34;, Version = \u0026#34;v1\u0026#34; }); options.CustomSchemaIds(type =\u0026gt; type.FullName); // 解决相同类名会报错的问题 options.IncludeXmlComments(Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;SwaggerUIDemo.xml\u0026#34;)); // 标注要使用的 XML 文档 }); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseStaticFiles(); app.UseSwagger(); // 在这里面可以注入 app.UseSwaggerUI(options =\u0026gt; { options.InjectOnCompleteJavaScript(\u0026#34;/swagger/ui/zh_CN.js\u0026#34;); // 加载中文包 options.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;HKERP API V1\u0026#34;); }); app.UseMvc(); } } 当然我们直接运行的时候会提示找不到 XML 文件，因为我们使用的是 Path.Combine(Directory.GetCurrentDirectory(), \u0026quot;SwaggerUIDemo.xml\u0026quot;)，SO，我们在项目变异的时候手动 COPY 过去即可，编写一个编译事件。 编写完成之后我们运行项目，访问 swagger 的页面就会显示成功了： 当然这里的注释是来自于针对 Value 控制器的注释，Swagger 会自动扫描项目所有的控制器类，并且将其展现在 Swagger UI 当中。\nDIY Swagger UI 或许到现在 Swagger 已经足够你使用，但是如果你想针对生成的页面进行自定义也是可以的，例如汉化文字？或者在旁边加一个侧边栏？ 这些统统都可以实现，细心的同学可能看到了在 StartUp 类的 Configure 方法当中注入了一个 JavaScript 文件，这个文件会在 Swagger UI 加载完成之后调用。那么我们就可以在这个 JS 里面操作 DOM 元素来进行自定义 UI 了。\n例如汉化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 \u0026#39;use strict\u0026#39;; /** * Translator for documentation pages. * * To enable translation you should include one of language-files in your index.html * after \u0026lt;script src=\u0026#39;lang/translator.js\u0026#39; type=\u0026#39;text/javascript\u0026#39;\u0026gt;\u0026lt;/script\u0026gt;. * For example - \u0026lt;script src=\u0026#39;lang/ru.js\u0026#39; type=\u0026#39;text/javascript\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; * * If you wish to translate some new texsts you should do two things: * 1. Add a new phrase pair (\u0026#34;New Phrase\u0026#34;: \u0026#34;New Translation\u0026#34;) into your language file (for example lang/ru.js). It will be great if you add it in other language files too. * 2. Mark that text it templates this way \u0026lt;anyHtmlTag data-sw-translate\u0026gt;New Phrase\u0026lt;/anyHtmlTag\u0026gt; or \u0026lt;anyHtmlTag data-sw-translate value=\u0026#39;New Phrase\u0026#39;/\u0026gt;. * The main thing here is attribute data-sw-translate. Only inner html, title-attribute and value-attribute are going to translate. * */ window.SwaggerTranslator = { _words: [], translate: function () { var $this = this; $(\u0026#39;[data-sw-translate]\u0026#39;).each(function () { $(this).html($this._tryTranslate($(this).html())); $(this).val($this._tryTranslate($(this).val())); $(this).attr(\u0026#39;title\u0026#39;, $this._tryTranslate($(this).attr(\u0026#39;title\u0026#39;))); }); }, _tryTranslate: function (word) { return this._words[$.trim(word)] !== undefined ? this._words[$.trim(word)] : word; }, learn: function (wordsMap) { this._words = wordsMap; }, }; /* jshint quotmark: double */ window.SwaggerTranslator.learn({ \u0026#34;Warning: Deprecated\u0026#34;: \u0026#34;警告：已过时\u0026#34;, \u0026#34;Implementation Notes\u0026#34;: \u0026#34;实现备注\u0026#34;, \u0026#34;Response Class\u0026#34;: \u0026#34;响应类\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;状态\u0026#34;, \u0026#34;Parameters\u0026#34;: \u0026#34;参数\u0026#34;, \u0026#34;Parameter\u0026#34;: \u0026#34;参数\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;值\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;描述\u0026#34;, \u0026#34;Parameter Type\u0026#34;: \u0026#34;参数类型\u0026#34;, \u0026#34;Data Type\u0026#34;: \u0026#34;数据类型\u0026#34;, \u0026#34;Response Messages\u0026#34;: \u0026#34;响应消息\u0026#34;, \u0026#34;HTTP Status Code\u0026#34;: \u0026#34;HTTP状态码\u0026#34;, \u0026#34;Reason\u0026#34;: \u0026#34;原因\u0026#34;, \u0026#34;Response Model\u0026#34;: \u0026#34;响应模型\u0026#34;, \u0026#34;Request URL\u0026#34;: \u0026#34;请求URL\u0026#34;, \u0026#34;Response Body\u0026#34;: \u0026#34;响应体\u0026#34;, \u0026#34;Response Code\u0026#34;: \u0026#34;响应码\u0026#34;, \u0026#34;Response Headers\u0026#34;: \u0026#34;响应头\u0026#34;, \u0026#34;Hide Response\u0026#34;: \u0026#34;隐藏响应\u0026#34;, \u0026#34;Headers\u0026#34;: \u0026#34;头\u0026#34;, \u0026#34;Try it out!\u0026#34;: \u0026#34;试一下！\u0026#34;, \u0026#34;Show/Hide\u0026#34;: \u0026#34;显示/隐藏\u0026#34;, \u0026#34;List Operations\u0026#34;: \u0026#34;显示操作\u0026#34;, \u0026#34;Expand Operations\u0026#34;: \u0026#34;展开操作\u0026#34;, \u0026#34;Raw\u0026#34;: \u0026#34;原始\u0026#34;, \u0026#34;can\u0026#39;t parse JSON. Raw result\u0026#34;: \u0026#34;无法解析JSON. 原始结果\u0026#34;, \u0026#34;Model Schema\u0026#34;: \u0026#34;模型架构\u0026#34;, \u0026#34;Model\u0026#34;: \u0026#34;模型\u0026#34;, \u0026#34;apply\u0026#34;: \u0026#34;应用\u0026#34;, \u0026#34;Username\u0026#34;: \u0026#34;用户名\u0026#34;, \u0026#34;Password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;Terms of service\u0026#34;: \u0026#34;服务条款\u0026#34;, \u0026#34;Created by\u0026#34;: \u0026#34;创建者\u0026#34;, \u0026#34;See more at\u0026#34;: \u0026#34;查看更多：\u0026#34;, \u0026#34;Contact the developer\u0026#34;: \u0026#34;联系开发者\u0026#34;, \u0026#34;api version\u0026#34;: \u0026#34;api版本\u0026#34;, \u0026#34;Response Content Type\u0026#34;: \u0026#34;响应Content Type\u0026#34;, \u0026#34;fetching resource\u0026#34;: \u0026#34;正在获取资源\u0026#34;, \u0026#34;fetching resource list\u0026#34;: \u0026#34;正在获取资源列表\u0026#34;, \u0026#34;Explore\u0026#34;: \u0026#34;浏览\u0026#34;, \u0026#34;Show Swagger Petstore Example Apis\u0026#34;: \u0026#34;显示 Swagger Petstore 示例 Apis\u0026#34;, \u0026#34;Can\u0026#39;t read from server. It may not have the appropriate access-control-origin settings.\u0026#34;: \u0026#34;无法从服务器读取。可能没有正确设置access-control-origin。\u0026#34;, \u0026#34;Please specify the protocol for\u0026#34;: \u0026#34;请指定协议：\u0026#34;, \u0026#34;Can\u0026#39;t read swagger JSON from\u0026#34;: \u0026#34;无法读取swagger JSON于\u0026#34;, \u0026#34;Finished Loading Resource Information. Rendering Swagger UI\u0026#34;: \u0026#34;已加载资源信息。正在渲染Swagger UI\u0026#34;, \u0026#34;Unable to read api\u0026#34;: \u0026#34;无法读取api\u0026#34;, \u0026#34;from path\u0026#34;: \u0026#34;从路径\u0026#34;, \u0026#34;server returned\u0026#34;: \u0026#34;服务器返回\u0026#34; }); $(function () { window.SwaggerTranslator.translate(); }); 这里我们如果想要在 Swagger UI 上针对控制器来应用注释的话，就需要自己实现一个 DocumentFiliter，这里我们直接继承自 IDocumentFiliter，来实现一个自定义的 Filiter：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class CustomDocumentFiliter : IDocumentFilter { public void Apply(SwaggerDocument swaggerDoc, DocumentFilterContext context) { SetContorllerDescription(swaggerDoc.Extensions); } private void SetContorllerDescription(Dictionary\u0026lt;string, object\u0026gt; extensionsDict) { string _xmlPath = Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;HKERP.Application.xml\u0026#34;); ConcurrentDictionary\u0026lt;string, string\u0026gt; _controllerDescDict = new ConcurrentDictionary\u0026lt;string, string\u0026gt;(); if (File.Exists(_xmlPath)) { XmlDocument _xmlDoc = new XmlDocument(); _xmlDoc.Load(_xmlPath); string _type = string.Empty, _path = string.Empty, _controllerName = string.Empty; XmlNode _summaryNode = null; foreach (XmlNode _node in _xmlDoc.SelectNodes(\u0026#34;//member\u0026#34;)) { _type = _node.Attributes[\u0026#34;name\u0026#34;].Value; if (_type.StartsWith(\u0026#34;T:\u0026#34;) \u0026amp;\u0026amp; !_type.Contains(\u0026#34;T:HKERP.HKERPAppServiceBase\u0026#34;) \u0026amp;\u0026amp; !_type.Contains(\u0026#34;T:HKERP.Net.MimeTypes.MimeTypeNames\u0026#34;)) { _summaryNode = _node.SelectSingleNode(\u0026#34;summary\u0026#34;); string[] _names = _type.Split(\u0026#39;.\u0026#39;); string _key = _names[_names.Length - 1]; if (_key.IndexOf(\u0026#34;AppService\u0026#34;, _key.Length - \u0026#34;AppService\u0026#34;.Length, StringComparison.Ordinal) \u0026gt; -1) { _key = _key.Substring(0, _key.Length - \u0026#34;AppService\u0026#34;.Length); } if (_summaryNode != null \u0026amp;\u0026amp; !string.IsNullOrEmpty(_summaryNode.InnerText) \u0026amp;\u0026amp; !_controllerDescDict.ContainsKey(_key)) { _controllerDescDict.TryAdd(_key, _summaryNode.InnerText.Trim()); } } } extensionsDict.TryAdd(\u0026#34;ControllerDescription\u0026#34;, _controllerDescDict); } } } 这里我们直接读取生成的 XML 文档，并且生成一个字典添加到 SwaggerDocument 的 Extensions 属性当中，这样的话，在 Swagger UI 加载的时候，调用的 JSON 接口就回附带上我们添加的内容，这个时候只需要在 JS 文件当中获取并且填充 UI 即可，这里有个示范：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 \u0026#39;use strict\u0026#39;; /** * Translator for documentation pages. * * To enable translation you should include one of language-files in your index.html * after \u0026lt;script src=\u0026#39;lang/translator.js\u0026#39; type=\u0026#39;text/javascript\u0026#39;\u0026gt;\u0026lt;/script\u0026gt;. * For example - \u0026lt;script src=\u0026#39;lang/ru.js\u0026#39; type=\u0026#39;text/javascript\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; * * If you wish to translate some new texsts you should do two things: * 1. Add a new phrase pair (\u0026#34;New Phrase\u0026#34;: \u0026#34;New Translation\u0026#34;) into your language file (for example lang/ru.js). It will be great if you add it in other language files too. * 2. Mark that text it templates this way \u0026lt;anyHtmlTag data-sw-translate\u0026gt;New Phrase\u0026lt;/anyHtmlTag\u0026gt; or \u0026lt;anyHtmlTag data-sw-translate value=\u0026#39;New Phrase\u0026#39;/\u0026gt;. * The main thing here is attribute data-sw-translate. Only inner html, title-attribute and value-attribute are going to translate. * */ window.SwaggerTranslator = { _words: [], translate: function () { var $this = this; $(\u0026#39;[data-sw-translate]\u0026#39;).each(function () { $(this).html($this._tryTranslate($(this).html())); $(this).val($this._tryTranslate($(this).val())); $(this).attr(\u0026#39;title\u0026#39;, $this._tryTranslate($(this).attr(\u0026#39;title\u0026#39;))); }); }, _tryTranslate: function (word) { return this._words[$.trim(word)] !== undefined ? this._words[$.trim(word)] : word; }, learn: function (wordsMap) { this._words = wordsMap; }, setControllerSummary: function () { var _str = $(\u0026#34;#input_baseUrl\u0026#34;).val(); $.ajax({ type: \u0026#34;get\u0026#34;, async: true, url: $(\u0026#34;#input_baseUrl\u0026#34;).val(), dataType: \u0026#34;json\u0026#34;, success: function (data) { //console.log(data) var toggleEndpointList = []; var summaryDict = data.ControllerDescription; var id, controllerName, strSummary; $(\u0026#39;body\u0026#39;).append(\u0026#39;\u0026lt;ul class=\u0026#34;leftMenu\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt;\u0026#39;); $(\u0026#34;#resources .resource\u0026#34;).each(function (i, item) { id = $(item).attr(\u0026#34;id\u0026#34;); if (id) { controllerName = id.substring(9); strSummary = summaryDict[controllerName]; if (strSummary) { console.log($(item)) $(item).children(\u0026#34;.heading\u0026#34;).children(\u0026#34;h2\u0026#34;).children(\u0026#39;a\u0026#39;).text(strSummary); $(item).children(\u0026#34;.heading\u0026#34;).children(\u0026#34;.options\u0026#34;).prepend(\u0026#39;\u0026lt;li class=\u0026#34;controller-summary\u0026#34; title=\u0026#34;\u0026#39; + strSummary + \u0026#39;\u0026#34;\u0026gt;\u0026#39; + strSummary + \u0026#39;\u0026lt;/li\u0026gt;\u0026#39;); $(\u0026#39;.leftMenu\u0026#39;).append(\u0026#39;\u0026lt;li class=\u0026#34;menuLi\u0026#34; title=\u0026#34;\u0026#39; + strSummary + \u0026#39;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34; class=\u0026#34;menuLiA\u0026#34;\u0026gt;\u0026#39; + strSummary + \u0026#39;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026#39;); toggleEndpointList.push($(item).attr(\u0026#39;id\u0026#39;)) } } }); for (var i = 0; i \u0026lt; document.getElementsByClassName(\u0026#39;menuLiA\u0026#39;).length;i++){ var menuLiA = document.getElementsByClassName(\u0026#39;menuLiA\u0026#39;); menuLiA[i].setAttribute(\u0026#39;href\u0026#39;, \u0026#39;#\u0026#39;+toggleEndpointList[i]) } } }); }, }; /* jshint quotmark: double */ window.SwaggerTranslator.learn({ \u0026#34;Warning: Deprecated\u0026#34;: \u0026#34;警告：已过时\u0026#34;, \u0026#34;Implementation Notes\u0026#34;: \u0026#34;实现备注\u0026#34;, \u0026#34;Response Class\u0026#34;: \u0026#34;响应类\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;状态\u0026#34;, \u0026#34;Parameters\u0026#34;: \u0026#34;参数\u0026#34;, \u0026#34;Parameter\u0026#34;: \u0026#34;参数\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;值\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;描述\u0026#34;, \u0026#34;Parameter Type\u0026#34;: \u0026#34;参数类型\u0026#34;, \u0026#34;Data Type\u0026#34;: \u0026#34;数据类型\u0026#34;, \u0026#34;Response Messages\u0026#34;: \u0026#34;响应消息\u0026#34;, \u0026#34;HTTP Status Code\u0026#34;: \u0026#34;HTTP状态码\u0026#34;, \u0026#34;Reason\u0026#34;: \u0026#34;原因\u0026#34;, \u0026#34;Response Model\u0026#34;: \u0026#34;响应模型\u0026#34;, \u0026#34;Request URL\u0026#34;: \u0026#34;请求URL\u0026#34;, \u0026#34;Response Body\u0026#34;: \u0026#34;响应体\u0026#34;, \u0026#34;Response Code\u0026#34;: \u0026#34;响应码\u0026#34;, \u0026#34;Response Headers\u0026#34;: \u0026#34;响应头\u0026#34;, \u0026#34;Hide Response\u0026#34;: \u0026#34;隐藏响应\u0026#34;, \u0026#34;Headers\u0026#34;: \u0026#34;头\u0026#34;, \u0026#34;Try it out!\u0026#34;: \u0026#34;试一下！\u0026#34;, \u0026#34;Show/Hide\u0026#34;: \u0026#34;显示/隐藏\u0026#34;, \u0026#34;List Operations\u0026#34;: \u0026#34;显示操作\u0026#34;, \u0026#34;Expand Operations\u0026#34;: \u0026#34;展开操作\u0026#34;, \u0026#34;Raw\u0026#34;: \u0026#34;原始\u0026#34;, \u0026#34;can\u0026#39;t parse JSON. Raw result\u0026#34;: \u0026#34;无法解析JSON. 原始结果\u0026#34;, \u0026#34;Model Schema\u0026#34;: \u0026#34;模型架构\u0026#34;, \u0026#34;Model\u0026#34;: \u0026#34;模型\u0026#34;, \u0026#34;apply\u0026#34;: \u0026#34;应用\u0026#34;, \u0026#34;Username\u0026#34;: \u0026#34;用户名\u0026#34;, \u0026#34;Password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;Terms of service\u0026#34;: \u0026#34;服务条款\u0026#34;, \u0026#34;Created by\u0026#34;: \u0026#34;创建者\u0026#34;, \u0026#34;See more at\u0026#34;: \u0026#34;查看更多：\u0026#34;, \u0026#34;Contact the developer\u0026#34;: \u0026#34;联系开发者\u0026#34;, \u0026#34;api version\u0026#34;: \u0026#34;api版本\u0026#34;, \u0026#34;Response Content Type\u0026#34;: \u0026#34;响应Content Type\u0026#34;, \u0026#34;fetching resource\u0026#34;: \u0026#34;正在获取资源\u0026#34;, \u0026#34;fetching resource list\u0026#34;: \u0026#34;正在获取资源列表\u0026#34;, \u0026#34;Explore\u0026#34;: \u0026#34;浏览\u0026#34;, \u0026#34;Show Swagger Petstore Example Apis\u0026#34;: \u0026#34;显示 Swagger Petstore 示例 Apis\u0026#34;, \u0026#34;Can\u0026#39;t read from server. It may not have the appropriate access-control-origin settings.\u0026#34;: \u0026#34;无法从服务器读取。可能没有正确设置access-control-origin。\u0026#34;, \u0026#34;Please specify the protocol for\u0026#34;: \u0026#34;请指定协议：\u0026#34;, \u0026#34;Can\u0026#39;t read swagger JSON from\u0026#34;: \u0026#34;无法读取swagger JSON于\u0026#34;, \u0026#34;Finished Loading Resource Information. Rendering Swagger UI\u0026#34;: \u0026#34;已加载资源信息。正在渲染Swagger UI\u0026#34;, \u0026#34;Unable to read api\u0026#34;: \u0026#34;无法读取api\u0026#34;, \u0026#34;from path\u0026#34;: \u0026#34;从路径\u0026#34;, \u0026#34;server returned\u0026#34;: \u0026#34;服务器返回\u0026#34; }); $(function () { debugger; window.SwaggerTranslator.translate(); window.SwaggerTranslator.setControllerSummary(); }); 效果图： ","date":"2018-01-10T09:54:00Z","permalink":"https://real-zony.github.io/p/swagger-ui-custom-actions-under-dotnetcore/","title":"在 DotNetCore 下的 Swagger UI 自定义操作"},{"content":"SharpZipLib 是一个优秀的开源的第三方压缩库，可以通过这个库将一些导出的文件打包到一个 ZIP 文件当中供用户下载。 GITHUB 地址：https://github.com/icsharpcode/SharpZipLib NuGet 地址：https://www.nuget.org/packages/SharpZipLib/\n具体关于库的介绍可以参考官方文档，不过也没有太多介绍的，直接引入库之后按 F12 可以看到其中的元数据，没几个方法，下面讲解一下基本用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class TestClass { public void TestMethod() { string _zipPath = Path.Combine(\u0026#34;D:\\导出.zip\u0026#34;); using (ZipFile zip = ZipFile.Create(_zipPath)) { zip.BeginUpdate(); // 这里 Add 方法接收两个参数， 分别是文件路径和实体名称 zip.Add(_allPath, Path.GetFileName(_allPath)); foreach (var item in _xlsFileNames) { zip.Add(Path.Combine(_filePath, item), Path.GetFileName(item)); } // 当然还有一个方法就是 zip.AddDirectory(\u0026#34;D:\\TempFiles\u0026#34;); // 上面这个方法可以添加一个目录，会按照层级压缩里面的文件 zip.CommitUpdate(); } } } 上面的方法适用于要压缩的文件已经存在，当然 SharpZipLib 也提供了一个 ZipStream 用于写入流数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public void TestMethod2() { using (FileStream fs = File.OpenRead(\u0026#34;D:\\\\待压缩的文件.txt\u0026#34;)) { byte[] buffer = new byte[fs.Length]; fs.Read(buffer, 0, buffer.Length); fs.Close(); using (FileStream ZipFile = File.Create(\u0026#34;D:\\\\压缩文件路径.zip\u0026#34;)) { using (ZipOutputStream ZipStream = new ZipOutputStream(ZipFile)) { string fileName = \u0026#34;名称.txt\u0026#34;; ZipEntry ZipEntry = new ZipEntry(fileName); ZipStream.PutNextEntry(ZipEntry); // 设置压缩等级 ZipStream.SetLevel(5); ZipStream.Write(buffer, 0, buffer.Length); ZipStream.Finish(); ZipStream.Close(); } } } } ","date":"2018-01-08T02:42:00Z","permalink":"https://real-zony.github.io/p/packing-data-into-zip-files-using-sharpziplib/","title":"使用 SharpZipLib 打包数据到 ZIP 文件"},{"content":"在使用.NET CORE 进行 Web 开发的时候会考虑到使用不同数据库的情况，并且在每种数据库建立表结构的时候会采用不同的命名规则。之前的解决方法是使用 [ColumnAttribute] 或者 [TableAttribute] 这种特性来显式标注不同的列名。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 [Table(\u0026#34;bas_stock_address\u0026#34;)] public class BasStockAddress : FullAuditedEntity\u0026lt;int, User\u0026gt; { /// \u0026lt;summary\u0026gt; /// 集团ID /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;group_id\u0026#34;)] public int? GroupId { get; set; } /// \u0026lt;summary\u0026gt; /// 仓库ID /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;stock_id\u0026#34;)] public int StockId { get; set; } /// \u0026lt;summary\u0026gt; /// 地址ID /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;address_id\u0026#34;)] public int? AddressId { get; set; } /// \u0026lt;summary\u0026gt; /// 详情地址 /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;complete_address\u0026#34;)] [StringLength(200)] public string CompleteAddress { get; set; } /// \u0026lt;summary\u0026gt; /// 运输方式 /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;transport_method_id\u0026#34;)] public int? TransportMethodId { get; set; } /// \u0026lt;summary\u0026gt; /// 联系人 /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;contact_person\u0026#34;)] [StringLength(20)] public string ContactPerson { get; set; } /// \u0026lt;summary\u0026gt; /// 联系电话 /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;phone\u0026#34;)] [StringLength(50)] public string Phone { get; set; } /// \u0026lt;summary\u0026gt; /// 物流公司 /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;logistics_company\u0026#34;)] [StringLength(50)] public string LogisticsCompany { get; set; } /// \u0026lt;summary\u0026gt; /// 是否默认 /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;is_default\u0026#34;)] public bool? IsDefault { get; set; } /// \u0026lt;summary\u0026gt; /// 备注 /// \u0026lt;/summary\u0026gt; [Column(\u0026#34;remark\u0026#34;)] [StringLength(200)] public string Remark { get; set; } [ForeignKey(\u0026#34;StockId\u0026#34;)] public BasStock BasStock { get; set; } } 这种情况的话就很尴尬，如果实体一多，就要对每个属性进行标注的话，工作量确实会很大。 这时候就需要 Conventions 了，在 Entity Framework 6 可以这样来操作： https://msdn.microsoft.com/en-us/library/jj819164(v=vs.113).aspx 而在 EntityFramework Core 当中则是使用 ModelBuilder.Model.GetEntityTypes() 方法来实现。 该方法可以获得所有实体对象的类型，我们只需要对起进行遍历操作，并且使用 Relational() 扩展方法来获得对象的 Annotation ,这样就可以对要生成的表结构的 TableName/ColumnName 来进行操作了。 这里使用 这个例子 来进行示范：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class ApplicationDbContext : IdentityDbContext\u0026lt;ApplicationUser\u0026gt; { public ApplicationDbContext(DbContextOptions\u0026lt;ApplicationDbContext\u0026gt; options) : base(options) { } protected override void OnModelCreating(ModelBuilder builder) { base.OnModelCreating(builder); foreach(var entity in builder.Model.GetEntityTypes()) { // Replace table names entity.Relational().TableName = entity.Relational().TableName.ToSnakeCase(); // Replace column names foreach(var property in entity.GetProperties()) { property.Relational().ColumnName = property.Name.ToSnakeCase(); } foreach(var key in entity.GetKeys()) { key.Relational().Name = key.Relational().Name.ToSnakeCase(); } foreach(var key in entity.GetForeignKeys()) { key.Relational().Name = key.Relational().Name.ToSnakeCase(); } foreach(var index in entity.GetIndexes()) { index.Relational().Name = index.Relational().Name.ToSnakeCase(); } } } } public static class StringExtensions { public static string ToSnakeCase(this string input) { if (string.IsNullOrEmpty(input)) { return input; } var startUnderscores = Regex.Match(input, @\u0026#34;^_+\u0026#34;); return startUnderscores + Regex.Replace(input, @\u0026#34;([a-z0-9])([A-Z])\u0026#34;, \u0026#34;$1_$2\u0026#34;).ToLower(); } } ","date":"2018-01-03T02:51:00Z","permalink":"https://real-zony.github.io/p/batch-custom-column-names-in-entityframeworkcore-code-first/","title":"EntityFrameworkCore Code First 当中批量自定义列名"},{"content":"一、安装与配置 1.设置阿里云镜像源 1 sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 2.安装依赖包 1 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 3.安装 Docker-CE 重建 Yum 缓存。 安装 Docker-CE ，请执行一下命令进行安装： 1 sudo yum install docker-ce 4.启动 Docker-CE 1 2 sudo systemctl enable docker sudo systemctl start docker 5.[可选] 为 Docker 建立用户组 docker 命令与 Docker 引擎通讯之间通过 UnixSocket ，但是能够有权限访问 UnixSocket 的用户只有 root 和 docker 用户组的用户才能够进行访问，所以我们需要建立一个 docker 用户组，并且将需要访问 docker 的用户添加到这一个用户组当中来。\n1. 建立 Docker 用户组 1 sudo groupadd docker 2.添加当前用户到 docker 组 1 sudo usermod -aG docker $USER 6.镜像加速配置 这里使用的是 阿里云提供的镜像加速 ，登录并且设置密码之后在左侧的 Docker Hub 镜像站点 可以找到专属加速器地址，复制下来。\n然后执行以下命令：\n1 2 3 4 5 6 7 8 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;你的加速器地址\u0026#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 之后重新加载配置，并且重启 Docker 服务\n1 2 systemctl daemon-reload systemctl restart docker 二、配置 Docker 容器与镜像 1.拉取镜像 拉取微软在 Docker 上的 aspnetcore 镜像:\n1 docker pull microsoft/aspnetcore 之后执行以下命令查看是否拉取成功:\n1 docker images 三、Docker 常用命令 1.拉取镜像 1 docker pull 2.删除容器 1 docker rm \u0026lt;容器名 or ID\u0026gt; 3.查看容器日志 1 docker logs -f \u0026lt;容器名 or ID\u0026gt; 4.查看正在运行的容器 1 2 docker ps docker ps -a # 为查看所有的容器，包括已经停止的。 5.删除所有容器 1 docker rm $(docker ps -a -q) 6.停止、启动、杀死指定容器 1 2 3 docker start \u0026lt;容器名 or ID\u0026gt; # 启动容器 docker stop \u0026lt;容器名 or ID\u0026gt; # 启动容器 docker kill \u0026lt;容器名 or ID\u0026gt; # 杀死容器 7.查看所有镜像 1 docker images 8.拉取镜像 1 2 3 docker pull \u0026lt;镜像名:tag\u0026gt; # 例如以下代码 docker pull sameersbn/redmine:latest 9.后台运行 1 2 3 docker run -d \u0026lt;Other Parameters\u0026gt; # 例如 docker run -d -p 127.0.0.1:33301:22 centos6-ssh 10.暴露端口 1 2 3 4 5 6 7 # 一共有三种形式进行端口映射 docker -p ip:hostPort:containerPort # 映射指定地址的主机端口到容器端口 # 例如：docker -p 127.0.0.1:3306:3306 映射本机3306端口到容器的3306端口 docker -p ip::containerPort # 映射指定地址的任意可用端口到容器端口 # 例如：docker -p 127.0.0.1::3306 映射本机的随机可用端口到容器3306端口 docer -p hostPort:containerPort # 映射本机的指定端口到容器的指定端口 # 例如：docker -p 3306:3306 # 映射本机的3306端口到容器的3306端口 11.映射数据卷 1 docker -v /home/data:/opt/data # 这里/home/data 指的是宿主机的目录地址，后者则是容器的目录地址 四、GUI 管理配置 这里推荐使用 Portainer 作为容器的 GUI 管理方案。\n官方地址：https://portainer.io/install.html\n安装命令：\n1 2 docker volume create portainer_data docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 访问你的 IP:9000 即可进入容器管理页面。\n如下：\n","date":"2017-10-30T03:01:00Z","permalink":"https://real-zony.github.io/p/docker-installation-and-use-under-linux/","title":"Linux 下的 Docker 安装与使用"},{"content":" ABP在其内部实现了工作单元模式，统一地进行事务与连接管理。 其核心就是通过 Castle 的 Dynamic Proxy 进行动态代理，在组件注册的时候进行拦截器注入，拦截到实现了 Unit Of Work 特性的方法进行操作，在执行完方法之后就会关闭掉工作单元。\n一、大致处理流程 1 2 3 4 5 6 7 8 9 10 11 12 13 拦截器初始化=\u0026gt;start: 拦截器初始化 注入UOW特性=\u0026gt;operation: 注入UOW特性方法 Begin=\u0026gt;operation: Begin() realAction=\u0026gt;operation: realAction() 真实业务方法 complete=\u0026gt;operation: complete() 执行完成 dispose=\u0026gt;inputoutput: dispose() 销毁并检测 是否销毁条件=\u0026gt;condition: 是否销毁成功? rollback=\u0026gt;operation: 回退结果 e=\u0026gt;end: 结束 拦截器初始化-\u0026gt;注入UOW特性-\u0026gt;Begin-\u0026gt;realAction-\u0026gt;complete-\u0026gt;dispose-\u0026gt;是否销毁条件 是否销毁条件(yes)-\u0026gt;e 是否销毁条件(no)-\u0026gt;rollback-\u0026gt;e 首先UOW拦截器先被注入到了需要UOW的类当中。 ABP在执行标注了UOW的方法(或者是显示式IUnitOfWorkManager包裹的方法)的时候，UOW拦截器首先以这种方式来执行代码：\n1 2 3 A[begin]--\u0026gt;B[realaction_method] B--\u0026gt;C[complete method] C--\u0026gt;D[dispose method] UOW拦截器是通过using这种方式调用IUnitOfWork的某个具体实现，这就确保begin 和 dispose也总是会被执行的。Complete()方法不一定会被执行，比如在complete方法被调用前方法的执行产生了异常。\n当执行一连串的操作时（A方法-\u0026gt;B方法-\u0026gt;C方法，假设这三个方法都标注了UnitOfWork特性），ABP在执行A方法前会调用Begin方法创建整个过程中唯一的IUnitOfWork对象，该对象会启动.NET事务。在执行到B，C方法只会创建InnerUnitOfWorkCompleteHandle。\nInnerUnitOfWorkCompleteHandle和IUnitOfWork对象的差异在于它不会创建真实的事务。但ABP会调用其complete，以告知ABP其对应的方法以成功完成，可以提交事务。 事务可以回滚的关键关键在于IUnitOfWork对象在被dispose时候会检查complete方法有没有被执行，没有的话就认为这个UOW标注的方法没有顺利完成，从而导致事务的回滚操作。\n整个事务的提交是通过第一个UOW（也是唯一个）的complete方法执行时提交的。\n二、文件结构说明 文件名称 说明 UnitOfWorkRegistrar 注册拦截器，实现两种默认的UnitOfWork UnitOfWorkInterceptor Unit of Work拦截器，实现以AOP的方式进行注入单元控制 IUnitOfWorkManager UnitOfWork管理对象 UnitOfWorkManager IUnitOfWorkManager默认实现 ICurrentUnitOfWorkProvider 当前UnitOfWork管理对象 CallContextCurrentUnitOfWorkProvider ICurrentUnitOfWorkProvider默认实现 IUnitOfWork 工作单元对象（Begin、SaveChanges、Complete、Dispose） UnitOfWorkBase IUnitOfWork抽象实现类，封装实际操作的前后置操作及异常处理 IActiveUnitOfWork IUnitOfWork操作对象，不包含Begin与Complete操作 IUnitOfWorkCompleteHandle 工作单元完成对象，用于实现继承工作单元功能 InnerUnitOfWorkCompleteHandle IUnitOfWorkCompleteHandle实现之一，用于继承外部工作单元 IUnitOfWorkDefaultOptions UnitOfWork默认设置 UnitOfWorkDefaultOptions IUnitOfWorkDefaultOptions默认实现 UnitOfWorkOptions UnitOfWork配置对象 UnitOfWorkAttribute 标记工作单元的特性 UnitOfWorkFailedEventArgs UnitOfWork的Failed事件参数 UnitOfWorkHelper 工具类 AbpDataFilters 数据过滤相关 DataFilterConfiguration 数据过滤相关 三、注册工作单元 Abp在AbpBootstrapper的private void AddInterceptorRegistrars()方法当中对UnitOfWorkRegistrar 调用了其初始化操作。 初始化操作代码如下：\n1 2 3 4 5 6 7 private void AddInterceptorRegistrars() { ValidationInterceptorRegistrar.Initialize(IocManager); AuditingInterceptorRegistrar.Initialize(IocManager); UnitOfWorkRegistrar.Initialize(IocManager); AuthorizationInterceptorRegistrar.Initialize(IocManager); } 在其内部对Castle的注册事件进行了关联，当每一个类型注册到容器当中的时候会触发此事件。\n1 2 3 4 5 6 7 8 9 10 public static void Initialize(IIocManager iocManager) { iocManager.IocContainer.Kernel.ComponentRegistered += (key, handler) =\u0026gt; { var implementationType = handler.ComponentModel.Implementation.GetTypeInfo(); HandleTypesWithUnitOfWorkAttribute(implementationType, handler); HandleConventionalUnitOfWorkTypes(iocManager, implementationType, handler); }; } HandleConventionalUnitOfWorkTypes()方法内部针对约束规则对默认实现了IRepository和IApplicationService的类型进行拦截器注入。 HandleTypesWithUnitOfWorkAttribute方法在新版本的ABP当中则针对实现了UnitOfWorkAttribute的类型进行拦截器注入，前提是，该类型必须通过Ioc注册，否则不会触发事件。\n四、工作单元拦截器 UnitOfWorkInterceptor实现了IInterceptor接口，在调用注册了拦截器的方法的时候，会将其方法拦截下来，去执行该拦截器的Interceptor方法，在Abp当中UnitOfWorkInterceptor的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 using System; using System.Reflection; using System.Threading.Tasks; using Abp.Threading; using Castle.DynamicProxy; namespace Abp.Domain.Uow { /// \u0026lt;summary\u0026gt; /// This interceptor is used to manage database connection and transactions. /// \u0026lt;/summary\u0026gt; internal class UnitOfWorkInterceptor : IInterceptor { private readonly IUnitOfWorkManager _unitOfWorkManager; private readonly IUnitOfWorkDefaultOptions _unitOfWorkOptions; public UnitOfWorkInterceptor(IUnitOfWorkManager unitOfWorkManager, IUnitOfWorkDefaultOptions unitOfWorkOptions) { _unitOfWorkManager = unitOfWorkManager; _unitOfWorkOptions = unitOfWorkOptions; } /// \u0026lt;summary\u0026gt; /// 拦截方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;invocation\u0026#34;\u0026gt;拦截器参数\u0026lt;/param\u0026gt; public void Intercept(IInvocation invocation) { MethodInfo method; try { method = invocation.MethodInvocationTarget; } catch { method = invocation.GetConcreteMethod(); } // 判断方法是否实现了UOW特性 var unitOfWorkAttr = _unitOfWorkOptions.GetUnitOfWorkAttributeOrNull(method); if (unitOfWorkAttr == null || unitOfWorkAttr.IsDisabled) { // 没有实现则直接实行业务方法 invocation.Proceed(); return; } //No current uow, run a new one PerformUow(invocation, unitOfWorkAttr.CreateOptions()); } private void PerformUow(IInvocation invocation, UnitOfWorkOptions options) { // 判断拦截器所拦截到的方法是异步还是同步方法 if (AsyncHelper.IsAsyncMethod(invocation.Method)) { PerformAsyncUow(invocation, options); } else { PerformSyncUow(invocation, options); } } private void PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) { using (var uow = _unitOfWorkManager.Begin(options)) { invocation.Proceed(); uow.Complete(); } } private void PerformAsyncUow(IInvocation invocation, UnitOfWorkOptions options) { // 获取一个工作单元 var uow = _unitOfWorkManager.Begin(options); /* 如果在调用业务方法的时候出现异常，则直接调用uow的Dispose方法。 * 出现异常的时候，并没有调用Complete方法，所以方法内部的_isCompleteCalled会为false，并且会抛出异常 */ try { invocation.Proceed(); } catch { uow.Dispose(); throw; } // 判断异步方法是否拥有返回值 if (invocation.Method.ReturnType == typeof(Task)) { invocation.ReturnValue = InternalAsyncHelper.AwaitTaskWithPostActionAndFinally( (Task)invocation.ReturnValue, async () =\u0026gt; await uow.CompleteAsync(), exception =\u0026gt; uow.Dispose() ); } else //Task\u0026lt;TResult\u0026gt; { invocation.ReturnValue = InternalAsyncHelper.CallAwaitTaskWithPostActionAndFinallyAndGetResult( invocation.Method.ReturnType.GenericTypeArguments[0], invocation.ReturnValue, async () =\u0026gt; await uow.CompleteAsync(), exception =\u0026gt; uow.Dispose() ); } } } } 在拦截器当中，针对拦截到的方法，会判断其是否拥有UOW特性，如果没有且被显式关闭，则不执行工作单元。否则根据其是否是异步方法，分别进行不同的操作。 在PreFormUow方法内部，有两个分支，如果是简单的同步方法，则类似于我们在应用多个时候显式使用工作单元一样，如下： 首先调用Manager，根据options开始一个新的工作单元，执行完拦截的方法体之后，调用工作单元的Complete方法。 但是如果使异步方法的话，则略微复杂一点： 在这里，如果要执行工作单元的方法是一个异步方法的话，我们必须要讲工作但与安的Complete和Dispose放在异步任务当中，保证工作单元会被dispose掉。 在这里，Abp实现了一个异步帮助类，如果是无返回值的情况的话： 则首先执行其原Task，完成后执行传入的异步CompleteAsync方法，并且使用finally，确保无论是否异常都会将uow销毁掉。 而有返回值的方法处理稍微复杂一点，如下：\n1 2 3 4 5 6 7 8 9 10 public static object CallAwaitTaskWithPostActionAndFinallyAndGetResult(Type taskReturnType, object actualReturnValue, Func\u0026lt;Task\u0026gt; action, Action\u0026lt;Exception\u0026gt; finalAction) { //有返回值的异步任务，要先通过反射来为泛型传值，然后才可调用泛型方法来重写异步返回值 return typeof(InternalAsyncHelper) // 获得内部方法 .GetMethod(\u0026#34;AwaitTaskWithPostActionAndFinallyAndGetResult\u0026#34;, BindingFlags.Public | BindingFlags.Static) // 根据返回值生成泛型方法，由于在拦截器当中获取的是TypeInfo，所以在这里需通过反射方式来调用该方法 .MakeGenericMethod(taskReturnType) .Invoke(null, new object[] { actualReturnValue, action, finalAction }); } 这里使用反射来调用帮助类的另外一个异步方法，该方法作用类似于无返回值的处理结构： 同样是将Complete与Dispose放在异步方法当中进行执行。\n注:关于特性拦截器： 如果在一个Service内部调用自身的private的方法，是无法触发拦截器的。只有当两个不同的service/repositry或者工作单元方法才能够触发被调用者的拦截器。\n五、工作单元管理器-IUnitOfWorkManager 该接口的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /// \u0026lt;summary\u0026gt; /// 工作单元管理器 /// 用于开始/控制一个工作单元 /// \u0026lt;/summary\u0026gt; public interface IUnitOfWorkManager { /// \u0026lt;summary\u0026gt; /// 获取当前活跃的工作单元，如果不存在则为NULL /// \u0026lt;/summary\u0026gt; IActiveUnitOfWork Current { get; } /// \u0026lt;summary\u0026gt; /// 开始一个新的工作单元 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;一个工作单元的句柄\u0026lt;/returns\u0026gt; IUnitOfWorkCompleteHandle Begin(); /// \u0026lt;summary\u0026gt; /// 开始一个新的工作单元 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;scope\u0026#34;\u0026gt;事务范围选项\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;一个工作单元的句柄\u0026lt;/returns\u0026gt; IUnitOfWorkCompleteHandle Begin(TransactionScopeOption scope); /// \u0026lt;summary\u0026gt; /// 开始一个新的工作单元 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;一个工作单元的句柄\u0026lt;/returns\u0026gt; IUnitOfWorkCompleteHandle Begin(UnitOfWorkOptions options); } 在ABP当中默认使用UnitOfWorkManager作为IUnitOfWork的实现类，其中Current属性可以直接取得ICurrentUnitOfWork的属性。 在IUnitOfWorkManager接口当中，这三个Begin方法都只是重载，最后都会调用第三个Begin()方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public IUnitOfWorkCompleteHandle Begin(UnitOfWorkOptions options) { options.FillDefaultsForNonProvidedOptions(_defaultOptions); var outerUow = _currentUnitOfWorkProvider.Current; if (options.Scope == TransactionScopeOption.Required \u0026amp;\u0026amp; outerUow != null) { return new InnerUnitOfWorkCompleteHandle(); } var uow = _iocResolver.Resolve\u0026lt;IUnitOfWork\u0026gt;(); uow.Completed += (sender, args) =\u0026gt; { _currentUnitOfWorkProvider.Current = null; }; uow.Failed += (sender, args) =\u0026gt; { _currentUnitOfWorkProvider.Current = null; }; uow.Disposed += (sender, args) =\u0026gt; { _iocResolver.Release(uow); }; if (outerUow != null) { options.FillOuterUowFiltersForNonProvidedOptions(outerUow.Filters.ToList()); } uow.Begin(options); if (outerUow != null) { uow.SetTenantId(outerUow.GetTenantId(), false); } _currentUnitOfWorkProvider.Current = uow; return uow; } 在本方法中，第一步首先对options进行了值检测，如果某些项没有赋值，则对其赋予默认值:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 internal void FillDefaultsForNonProvidedOptions(IUnitOfWorkDefaultOptions defaultOptions) { if (!IsTransactional.HasValue) { IsTransactional = defaultOptions.IsTransactional; } if (!Scope.HasValue) { Scope = defaultOptions.Scope; } if (!Timeout.HasValue \u0026amp;\u0026amp; defaultOptions.Timeout.HasValue) { Timeout = defaultOptions.Timeout.Value; } if (!IsolationLevel.HasValue \u0026amp;\u0026amp; defaultOptions.IsolationLevel.HasValue) { IsolationLevel = defaultOptions.IsolationLevel.Value; } } 第二步，也是最重要的一步，在方法当中会返回两种不同的对象，一种是实现了IUnitOfWorkCompleteHandle接口的InnerUnitOfWorkCompleteHandle，一种是返回一个实现了IUnitOfWork的全新单元，并且将其设置为当前工作单元。\n第一个分支条件判断options的scope是否为Required并且当前也存在了工作单元，那么就会返回一个内部对象。\n如果不是的话，则创建一个新的工作单元，并调用该工作单元的Begin方法，且设置此工作单元为当前工作单元。\n在这里的IUnitOfWork对象是直接通过容器resolve出来的，这里Abp默认是假设用户会使用一个实现了IUnitOfWork的模块，如果有多个实现的类的话，在这里是不知道会使用哪一个的。\n六、内部工作单元-IUnitOfWorkCompleteHandle和InnerUnitOfWorkCompleteHandle 接口IUnitOfWorkCompleteHandle只有两个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /// \u0026lt;summary\u0026gt; /// 用于完成一个工作单元 /// 这个接口不能够被注入或者直接使用 /// 使用 \u0026lt;see cref=\u0026#34;IUnitOfWorkManager\u0026#34;/\u0026gt; 代替. /// \u0026lt;/summary\u0026gt; public interface IUnitOfWorkCompleteHandle : IDisposable { /// \u0026lt;summary\u0026gt; /// 统一事务提交 /// \u0026lt;/summary\u0026gt; void Complete(); /// \u0026lt;summary\u0026gt; /// 统一事务提交 /// \u0026lt;/summary\u0026gt; Task CompleteAsync(); } 这两个方法意思相同，都是用来完成当前工作单元的，且其实现了IDisposable接口，结合IUnitOfWorkManager的using用法就明白其作用。 而内部工作单元InnerUnitOfWorkCompleteHandle，它只实现了IUnitOfWorkCompleteHandle接口，下面是其代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 namespace Abp.Domain.Uow { /// \u0026lt;summary\u0026gt; /// 这个操作适用于方法内部的工作单元块 /// 使用inner uow的时候应该显式地调用 \u0026lt;see cref=\u0026#34;IUnitOfWorkCompleteHandle.Complete\u0026#34;/\u0026gt; /// 如果你没有调用，那么在UOW的末尾会抛出一个异常来回滚操作 /// \u0026lt;/summary\u0026gt; internal class InnerUnitOfWorkCompleteHandle : IUnitOfWorkCompleteHandle { public const string DidNotCallCompleteMethodExceptionMessage = \u0026#34;Did not call Complete method of a unit of work.\u0026#34;; private volatile bool _isCompleteCalled; private volatile bool _isDisposed; public void Complete() { _isCompleteCalled = true; } public Task CompleteAsync() { _isCompleteCalled = true; return Task.FromResult(0); } public void Dispose() { if (_isDisposed) { return; } _isDisposed = true; if (!_isCompleteCalled) { if (HasException()) { return; } throw new AbpException(DidNotCallCompleteMethodExceptionMessage); } } private static bool HasException() { try { return Marshal.GetExceptionCode() != 0; } catch (Exception) { return false; } } } } 这个类的代码相当简单，在Complete与CompleteAsync里面都是简单地将_isCompleteCalled设置为true即可，在Dispose方法当中也仅仅使进行了一些常规性判断，例如是否已经dispose过，是否完成，是否异常等。 而这个内部工作单元并没有执行什么具体的事务操作，因为在之前Manager的判断当中，这个内部对象主要用于工作单元的嵌套，内部工作单元只要保证没有异常被抛出。\n七、事务工作单元-IUnitOfWork与IActiveUnitOfWork 实现本接口的工作单元才会在内部实际进行事务与连接管理，其IUnitOfWord定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 namespace Abp.Domain.Uow { /// \u0026lt;summary\u0026gt; /// 定义工作单元 /// 这个接口是ABP内部使用的 /// 使用 \u0026lt;see cref=\u0026#34;IUnitOfWorkManager.Begin()\u0026#34;/\u0026gt; 方法来创建一个新的工作单元。 /// \u0026lt;/summary\u0026gt; public interface IUnitOfWork : IActiveUnitOfWork, IUnitOfWorkCompleteHandle { /// \u0026lt;summary\u0026gt; /// 工作单元的唯一标识 /// \u0026lt;/summary\u0026gt; string Id { get; } /// \u0026lt;summary\u0026gt; /// 外层工作单元 /// \u0026lt;/summary\u0026gt; IUnitOfWork Outer { get; set; } /// \u0026lt;summary\u0026gt; /// 根据指定的选项开始工作单元 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;options\u0026#34;\u0026gt;工作单元选项\u0026lt;/param\u0026gt; void Begin(UnitOfWorkOptions options); } } IUnitOfWork继承了IUnitOfWorkCompleteHandle与IActiveUnitOfWork接口，他继承了IUnitOfWorkCompleted接口拥有了Complete方法，而IActiveUnitOfWork接口则主要是提供了过滤器和事件相关的方法、工作单元设置Options以及IsDisposed与同步和异步的SaveChanges()方法，其定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Abp默认实现了这个接口的只有UnitOfWorkBase，而其他具体的事务实现，例如EF，NHibernate等，在Abp具体项目下面的UOW文件夹当中有具体实现。 这个抽象类主要提供了一些前置、后置工作，以及一些异常处理，在一些方法当中做好前置工作，之后调用抽象方法，将具体实现交给下面子类。例如： /// \u0026lt;inheritdoc/\u0026gt; public void Begin(UnitOfWorkOptions options) { Check.NotNull(options, nameof(options)); // 检测是否多次重复调用 PreventMultipleBegin(); Options = options; //TODO: Do not set options like that, instead make a copy? // 过滤配置 SetFilters(options.FilterOverrides); SetTenantId(AbpSession.TenantId, false); // 子类实现方法 BeginUow(); } /// \u0026lt;inheritdoc/\u0026gt; public void Complete() { PreventMultipleComplete(); try { CompleteUow(); _succeed = true; OnCompleted(); } catch (Exception ex) { _exception = ex; throw; } } 在这里两个方法内部都有一个检测重复调用的方法，该方法 内部维护一个bool类型的变量，用于重复调用判断标识，不过在其内部使用的时候并没有用lock来锁住变量进行操作，因为一单给操作加了锁，对于系统来说性能消耗是巨大的，这个时候Abp设计上则使用了线程逻辑上下文(CallContext)+线程安全的Conncurrent.Dictionary字典来保证一个线程公用一个单元。 在Abp当中，IUnitOfWorkManager是一个简洁的IUnitOfWork管理对象，而IUnitOfWork工作单元则提供了对整个工作单元所需的所有控制，获取当前工作单元则是通过ICurrentUnitOfWorkProvider来进行控制的，在UnitOfWorkManager当中它的Current属性实际上就是ICurrentUnitOfWorkProvider所提供的Current属性。 ICurrentUnitOfWorkProvider接口定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 namespace Abp.Domain.Uow { /// \u0026lt;summary\u0026gt; /// Used to get/set current \u0026lt;see cref=\u0026#34;IUnitOfWork\u0026#34;/\u0026gt;. /// \u0026lt;/summary\u0026gt; public interface ICurrentUnitOfWorkProvider { /// \u0026lt;summary\u0026gt; /// Gets/sets current \u0026lt;see cref=\u0026#34;IUnitOfWork\u0026#34;/\u0026gt;. /// Setting to null returns back to outer unit of work where possible. /// \u0026lt;/summary\u0026gt; IUnitOfWork Current { get; set; } } } 他只有一个Current属性，在Abp框架内部具体的实现类 CallContextCurrentUnitOfWorkProvider当中这个属性的get和set方法的具体实现如下，首先是set方法： 这个方法首先判断，如果Current设置的是null，则表示要退出当前工作单元，其ExitFromCurrentUowScope实现如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 private static void ExitFromCurrentUowScope(ILogger logger) { // 根据ContextKey从线程集合中取出当前工作单元key var unitOfWorkKey = CallContext.LogicalGetData(ContextKey) as string; if (unitOfWorkKey == null) { // 没有取到值，表示当前无工作单元 logger.Warn(\u0026#34;There is no current UOW to exit!\u0026#34;); return; } IUnitOfWork unitOfWork; // UnitOfWorkDictionary类型为ConcurrentDictionary，线程安全字典，用于存储所有工作单元（单线程上最多只能有一个工作单元，但是多线程可能会有多个） if (!UnitOfWorkDictionary.TryGetValue(unitOfWorkKey, out unitOfWork)) { // 根据key没有取到value，从线程集合（CallContext）中释放该key CallContext.FreeNamedDataSlot(ContextKey); return; } // 从工作单元集合中移除当前工作单元 UnitOfWorkDictionary.TryRemove(unitOfWorkKey, out unitOfWork); if (unitOfWork.Outer == null) { // 如果当前工作单元没有外层工作单元，则从线程集合（CallContext）中释放该key CallContext.FreeNamedDataSlot(ContextKey); return; } // 这里也就表明了key实际上就是UnitOfWork的Id var outerUnitOfWorkKey = unitOfWork.Outer.Id; if (!UnitOfWorkDictionary.TryGetValue(outerUnitOfWorkKey, out unitOfWork)) { // 如果当前工作单元有外层工作单元，但是从工作单元集合中没有取到了外层工作单元，那么同样从线程集合（CallContext）中释放该key CallContext.FreeNamedDataSlot(ContextKey); return; } // 能到这里，就表示当前工作单元有外层工作单元，并且从工作单元集合中获取到了外层工作单元，那么就设外层工作单元为当前工作单元 CallContext.LogicalSetData(ContextKey, outerUnitOfWorkKey); } 如果是正常设置Current属性的话，则先获取当前工作单元的Key，如果存在Key的话，则尝试从工作单元集合当中获取这个单元，如果获得的单元与要设置的单元相同的话，则直接返回，不做任何操作，不是的话，则将当前工作单元作为本次所设置的工作单元的外部单元。 后续操作很简单，在工作单元集合当中根据要设置的工作单元ID作为Key在集合当中插入元素，添加失败，抛出异常，否则设置当前工作单元的Key为设置的最新的unitOfWorkKey。 而Get操作则较为简单了:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private static IUnitOfWork GetCurrentUow(ILogger logger) { // 获取当前工作单元key var unitOfWorkKey = CallContext.LogicalGetData(ContextKey) as string; if (unitOfWorkKey == null) { return null; } IUnitOfWork unitOfWork; if (!UnitOfWorkDictionary.TryGetValue(unitOfWorkKey, out unitOfWork)) { // 如果根据key获取不到当前工作单元，那么就从当前线程集合（CallContext）中释放key CallContext.FreeNamedDataSlot(ContextKey); return null; } if (unitOfWork.IsDisposed) { // 如果当前工作单元已经dispose，那么就从工作单元集合中移除，并将key从当前线程集合（CallContext）中释放 logger.Warn(\u0026#34;There is a unitOfWorkKey in CallContext but the UOW was disposed!\u0026#34;); UnitOfWorkDictionary.TryRemove(unitOfWorkKey, out unitOfWork); CallContext.FreeNamedDataSlot(ContextKey); return null; } return unitOfWork; } 总的来说，所有的工作单元都存储在线程安全的字典对象当中，每个主线程共用一个工作单元实现。\n八、关于工作单元嵌套使用解析/异步-同步方法 1.API Action 默认包裹了一个EF UOW。 2.在最外层Action进行最后持有事务的UOW进行Complete操作，并且在using结束后会调用Dispose方法进行异常检测。 1 2 3 4 5 6 7 8 9 10 11 12 13 1=\u0026gt;start: 最外层Action UOW 2=\u0026gt;operation: 内部UOW(N1 UOW) 3=\u0026gt;operation: 调用Dispose进行完成检查 4=\u0026gt;operation: 内部UOW(N2 UOW) 5=\u0026gt;operation: 调用Dispose进行完成检查 6=\u0026gt;condition: N2是否完成? 6x=\u0026gt;condition: N1是否完成? 7=\u0026gt;end 8=\u0026gt;operation: 回滚操作 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6 6(yes)-\u0026gt;7 6(no)-\u0026gt;8 3.AbpUowActionFilter最外部包裹了一层局部工作单元实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) { if (!context.ActionDescriptor.IsControllerAction()) { await next(); return; } var unitOfWorkAttr = _unitOfWorkDefaultOptions .GetUnitOfWorkAttributeOrNull(context.ActionDescriptor.GetMethodInfo()) ?? _aspnetCoreConfiguration.DefaultUnitOfWorkAttribute; if (unitOfWorkAttr.IsDisabled) { await next(); return; } using (var uow = _unitOfWorkManager.Begin(unitOfWorkAttr.CreateOptions())) { var result = await next(); if (result.Exception == null || result.ExceptionHandled) { await uow.CompleteAsync(); } } } 在其内部，判断方法调用的时候是否抛出异常决定是否进行回滚操作。 只要内部工作单元没有调用Complete也会抛出异常被其捕获，如果没有出现异常会使用持有事务的UOW进行统一提交，否则抛出异常信息。\n九、使用工作单元 1.使用UnitOfWork Attribute 例如某个方法，你需要使用工作单元的话，那么如下书写即可:\n1 2 3 4 5 6 [UnitOfWork] public void CreatePerson(CreatePersonInput input) { var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress }; _personRepository.Insert(person); _statisticsRepository.IncrementPeopleCount(); } 因此,CreatePerson方法转变成工作单元并且管理数据库连接和事务,两个仓储对象都使用相同的工作单元。要注意,假如这是应用服务的方法则不需要添加UnitOfWork属性。\n2.使用IUnitOfWorkManager.Begin() UnitOfWork实际上也是采用的这种方式，你可以通过这种方式来创建有限范围的工作单元，这种机制当中你可以手动调用Complete()方法，如果你不调用，通过前面对UOW实现的了解，那么Manager会认为这个语句块出现了异常会采取回滚操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class MyService { private readonly IUnitOfWorkManager _unitOfWorkManager; private readonly IPersonRepository _personRepository; private readonly IStatisticsRepository _statisticsRepository; public MyService(IUnitOfWorkManager unitOfWorkManager, IPersonRepository personRepository, IStatisticsRepository statisticsRepository) { _unitOfWorkManager = unitOfWorkManager; _personRepository = personRepository; _statisticsRepository = statisticsRepository; } public void CreatePerson(CreatePersonInput input) { var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress }; using(var unitOfWork = _unitOfWorkManager.Begin()) { _personRepository.Insert(person); _statisticsRepository.IncrementPeopleCount(); unitOfWork.Complete(); } } } ","date":"2017-10-23T06:15:00Z","permalink":"https://real-zony.github.io/p/abp-work-unit/","title":"ABP 工作单元"},{"content":"ABP领域事件/事件总线 一、文件结构 文件名称 路径 描述 IEventData.cs \\Abp\\Events\\Bus\\ 事件数据抽象接口 EventData.cs \\Abp\\Events\\Bus\\ 事件数据基本类实现 EventBusInstall.cs \\Abp\\Events\\Bus\\ 事件总线注册类 IEventBus.cs \\Abp\\Events\\Bus\\ 事件总线接口 EventBus.cs \\Abp\\Events\\Bus\\ 事件总线实现 IEventDataWithInheritableGenericArgument.cs \\Abp\\Events\\Bus\\ D6 NullEventBus.cs \\Abp\\Events\\Bus\\ D7 IEventHandler.cs \\Abp\\Events\\Bus\\Handler D7 IEventHandlerOfTEventData.cs \\Abp\\Events\\Bus\\Handler D8 ActionEventHandler.cs \\Abp\\Events\\Bus\\Hanlder\\Internals D9 DomainEventEntry.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityChangedEventData.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityChangeEntry.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityChangeEventHelper.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityChangeReport.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityChangeType.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityChangingEventData.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityCreatedEventData.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityCreatingEventData.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityDeletedEventData.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityDeletingEventData.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityEventData.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityUpdatedEventData.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. EntityUpdatingEventData.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. IEntityChangeEventHelper.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. NullEntityChangeEventHelper.cs \\Abp\\Events\\Bus\\Entities\\ 数据库实体相关事件. AbpHandledExceptionData.cs \\Abp\\Events\\Bus\\Exception\\ D26 ExceptionData.cs \\Abp\\Events\\Bus\\Exception\\ D27 IEventHandlerFactory.cs \\Abp\\Events\\Bus\\Factories\\ D28 IocHandlerFactory.cs \\Abp\\Events\\Bus\\Factories\\ D29 FactoryUnregistrar.cs \\Abp\\Events\\Bus\\Factories\\Internals\\ D30 SingleInstanceHandlerFactory.cs \\Abp\\Events\\Bus\\Factories\\Internals\\ 单例工厂 TransientEventHandlerFactory.cs \\Abp\\Events\\Bus\\Factories\\Internals\\ 瞬时工厂 二、大致流程 领域事件用于各个业务领域之间进行通信而又不相互依赖，是一种集中式的事件处理机制，各个模块之间都可以在任何地方订阅/发布事件。\n在 EventBus 内部维护一个 Dictionary ，存放所有已经注册了的 EventData 类型的工厂，工厂负责生产处理器与销毁处理器，每当调用 Tirgger 方法的时候会去查询这个字典，并且调用相应的处理类方法。\n1 2 3 4 5 6 7 8 9 10 1=\u0026gt;start: 注入 EventBus 2=\u0026gt;operation: 监听组件注册事件 3=\u0026gt;inputoutput: 注册 IEventHandler 4=\u0026gt;operation: Trigger 触发事件 5=\u0026gt;condition: 匹配处理器 6=\u0026gt;operation: 调用处理器 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 5(yes)-\u0026gt;6 5(no)-\u0026gt;4 三、具体解析 1.注册 EventBus 与 IEventHandler 事件总线通过 EventBusInstaller 来注册 EventBus 和监听事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public override void Initialize() { foreach (var replaceAction in ((AbpStartupConfiguration)Configuration).ServiceReplaceActions.Values) { replaceAction(); } // 事件总线注册 IocManager.IocContainer.Install(new EventBusInstaller(IocManager)); IocManager.RegisterAssemblyByConvention(typeof(AbpKernelModule).GetAssembly(), new ConventionalRegistrationConfig { InstallInstallers = false }); } 而 EventBusInstaller 则需要注意的是这个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private void Kernel_ComponentRegistered(string key, IHandler handler) { /* This code checks if registering component implements any IEventHandler\u0026lt;TEventData\u0026gt; interface, if yes, * gets all event handler interfaces and registers type to Event Bus for each handling event. */ if (!typeof(IEventHandler).GetTypeInfo().IsAssignableFrom(handler.ComponentModel.Implementation)) { return; } var interfaces = handler.ComponentModel.Implementation.GetTypeInfo().GetInterfaces(); foreach (var @interface in interfaces) { if (!typeof(IEventHandler).GetTypeInfo().IsAssignableFrom(@interface)) { continue; } var genericArgs = @interface.GetGenericArguments(); if (genericArgs.Length == 1) { _eventBus.Register(genericArgs[0], new IocHandlerFactory(_iocResolver, handler.ComponentModel.Implementation)); } } } 在其内部针对每次 IocContainer 注册事件进行了监听，每当注册了一个类型之后，都会判断当前类型是否实现了 IEventHandler ，之后使用 GetInterfaces() 方法获取其具体实现的每一个接口，并分别获得其具体的 EventData 类型并在 EventBus 注册。\n2.触发事件 开发人员可以在任意地方通过构造注入或者属性注入来获得 IEventBus 的实例，并使用其提供的 Trigger 方法来触发指定的事件。 在 EventBus 当中， Trigger 拥有4个重载方法， Trigger 还有一种异步实现是 TriggerAsync ，也拥有4个重载，原型分别如下：\n1 2 3 4 5 6 7 8 9 void Trigger\u0026lt;TEventData\u0026gt;(TEventData eventData) where TEventData : IEventData; void Trigger\u0026lt;TEventData\u0026gt;(object eventSource, TEventData eventData) where TEventData : IEventData; void Trigger(Type eventType, IEventData eventData); void Trigger(Type eventType, object eventSource, IEventData eventData); Task TriggerAsync\u0026lt;TEventData\u0026gt;(TEventData eventData) where TEventData : IEventData; Task TriggerAsync\u0026lt;TEventData\u0026gt;(object eventSource, TEventData eventData) where TEventData : IEventData; Task TriggerAsync(Type eventType, IEventData eventData); Task TriggerAsync(Type eventType, object eventSource, IEventData eventData); 核心是 public void Trigger(Type eventType, object eventSource, IEventData eventData) 方法，在其内部的具体调用使用了一层 try-catch 进行包裹。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public void Trigger(Type eventType, object eventSource, IEventData eventData) { var exceptions = new List\u0026lt;Exception\u0026gt;(); TriggerHandlingException(eventType, eventSource, eventData, exceptions); if (exceptions.Any()) { if (exceptions.Count == 1) { exceptions[0].ReThrow(); } throw new AggregateException(\u0026#34;More than one error has occurred while triggering the event: \u0026#34; + eventType, exceptions); } } 而在 TriggerHandlingException() 方法当中对已经注册好了的 Dictionary 进行遍历，获取工厂并生成处理方法进行调用，调用完成之后进行销毁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 private void TriggerHandlingException(Type eventType, object eventSource, IEventData eventData, List\u0026lt;Exception\u0026gt; exceptions) { //TODO: This method can be optimized by adding all possibilities to a dictionary. eventData.EventSource = eventSource; foreach (var handlerFactories in GetHandlerFactories(eventType)) { foreach (var handlerFactory in handlerFactories.EventHandlerFactories) { var eventHandler = handlerFactory.GetHandler(); try { if (eventHandler == null) { throw new Exception($\u0026#34;Registered event handler for event type {handlerFactories.EventType.Name} does not implement IEventHandler\u0026lt;{handlerFactories.EventType.Name}\u0026gt; interface!\u0026#34;); } var handlerType = typeof(IEventHandler\u0026lt;\u0026gt;).MakeGenericType(handlerFactories.EventType); // 获取处理方法 var method = handlerType.GetMethod( \u0026#34;HandleEvent\u0026#34;, new[] { handlerFactories.EventType } ); method.Invoke(eventHandler, new object[] { eventData }); } catch (TargetInvocationException ex) { exceptions.Add(ex.InnerException); } catch (Exception ex) { exceptions.Add(ex); } finally { // 销毁对象 handlerFactory.ReleaseHandler(eventHandler); } } } 四、使用方法 1.自动注册 首先需要定义你的事件数据实体，该实体用于触发事件的时候传递参数等操作。 数据实体必须实现 IEventData 接口或者继承自 EventData 。\n1 2 3 4 public class TestEventData : EventData { public string Name { get; set; } } 这里定义了一个 TestEventData 事件数据实体。 然后我们针对该事件数据实体编写处理程序。\n1 2 3 4 5 6 7 public TestHandler : IEventHandler\u0026lt;TestEventData\u0026gt;,ITransientDependency { public void HandleEvent(TestEventData eventData) { Console.WriteLine(eventData.Name); } } 注意：在此处必须继承 ITransientDependency ，否则事件处理类是无法被注册的。\n这样我们就针对 TestEventData 这种事件编写了一个处理处理程序，当程序任何地方调用 Trigger 的时候，会调用响应的事件处理方法。 在这里如果我们针对 TestEventData 注册两个处理器的话，在调用了 Trigger 之后，两个处理器都会被触发，但是先后顺序无法保证。\n同时，一个处理器可以继承多个事件的处理实现，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 public class TestEventHandlerMulit : IEventHandler\u0026lt;TestEventDataChild\u0026gt;, IEventHandler\u0026lt;TestEventData\u0026gt;, ITransientDependency { public void HandleEvent(TestEventDataOther eventData) { Console.WriteLine(eventData.Name2); } public void HandleEvent(TestEventData eventData) { Console.WriteLine(eventData.Name); } } 这里针对 TestEventDataOther 和 TestEventData 都进行了注册，在被触发相应的事件之后，便会触发对应的事件处理程序。\n2.手动注册 在具体代码实现当中也可以手动注册某些事件，手动注册无非就是将Abp在启动时进行注册的方法拿出来而已。直接使用 IEventBus 的 Register 方法即可进行注册。\n在 IEventBus 接口当中，定义了 Register 方法用于手动注册事件，一种是传入一个响应委托：\n1 2 3 4 EventBus.Register\u0026lt;TaskCompletedEventData\u0026gt;(eventData=\u0026gt; { Console.WriteLine($\u0026#34;TaskID={eventData.TaskId}\u0026#34;); }); 还有一种方法是传入一个对象，且该对象实现了 IEventHandler 接口：\n1 Eventbus.Register\u0026lt;TaskCompletedEventData\u0026gt;(new ActivityWriter()); 该方法还有另外一个泛型重载，可以直接绑定事件与处理对象：\n1 EventBus.Register\u0026lt;TaskCompletedEventData, ActivityWriter\u0026gt;(); 3.取消注册 1.显示调用 Dispose() 1 2 3 4 //注册一个事件 Var registration = EventBus.Register\u0026lt;TaskCompletedEventData\u0026gt;(eventData =\u0026gt; WriteActivity(\u0026#34;A task is completed by id = \u0026#34; + eventData.TaskId)); //取消注册一个事件 registration.Dispose(); 2.调用 UnRegister 方法 1 2 3 4 5 6 //创建一个处理器 var handler = new ActivityWriter(); //注册一个事件 EventBus.Register\u0026lt;TaskCompletedEventData\u0026gt;(handler); //取消这个事件的注册 EventBus.Unregister\u0026lt;TaskCompletedEventData\u0026gt;(handler); ","date":"2017-10-18T15:59:00Z","permalink":"https://real-zony.github.io/p/abp-domain-events/","title":"ABP 领域事件"},{"content":"OneDriver 本身没有提供对指定文件夹进行监控并自动同步的功能，需要通过 mklink 命令来创建目标文件夹与 OneDriver 映射文件夹的符号连接才行。\n具体命令如下： mklink /d [ONEDRIVER映射目录] [需监控同步的本地文件夹]\n例如，我需要对 E盘 的 Picture 文件夹进行同步，则输入一下命令即可：\n1 mklink /d D:\\OneDrive\\Picture E:\\Picture ","date":"2017-10-16T08:00:00Z","permalink":"https://real-zony.github.io/p/onedriver-specified-folder-sync/","title":"OneDriver 指定文件夹同步"},{"content":"一、ASP.Net 1 2 3 4 5 6 7 8 public class HomeController : Controller { public ActionResult Index() { var _path = Server.MapPath(\u0026#34;~/\u0026#34;); return Content(_path); } } 二、ASP.Net Core 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using Microsoft.AspNetCore.Hosting; using Microsoft.AspNetCore.Mvc; namespace MyWebsite.Controllers { public class HomeController : Controller { private readonly IHostingEnvironment _hostingEnvironment; public HomeController(IHostingEnvironment hostingEnvironment) { _hostingEnvironment = hostingEnvironment; } public ActionResult Index() { return Content($\u0026#34;WebRootPath = {_hostingEnvironment.WebRootPath}\\n\u0026#34; + $\u0026#34;ContentRootPath = {_hostingEnvironment.ContentRootPath}\u0026#34;); } } } 2.1 cshtml View 中使用 1 2 3 4 5 @using Microsoft.AspNetCore.Hosting @inject IHostingEnvironment hostingEnvironment WebRootPath = @hostingEnvironment.WebRootPath \u0026lt;br /\u0026gt; ContentRootPath = @hostingEnvironment.ContentRootPath ","date":"2017-10-16T02:02:00Z","permalink":"https://real-zony.github.io/p/aspnet-core-get-website-root-directory/","title":"ASP.Net Core 获得网站根目录"},{"content":"最近使用 ABP 框架进行数据库迁移的时候，总是在 PowerShell 当中执行 Update-Database 命令的时候出现以下情况: 总是提示项目找不到 EntityFramework 框架，最后在这里找到了答案，ef core 当中需要在你使用了 EntityFramework 框架的目录下，使用命令行工具执行以下命令即可:\n1 dotnet ef database update ","date":"2017-10-10T13:53:00Z","permalink":"https://real-zony.github.io/p/abp-code-first-cannot-perform-database-migration-problem/","title":"ABP Code First 无法进行数据库迁移问题"},{"content":"在某个项目当中，使用的使Dapper+WebApi进行构建的，在进行一些列表查询的时候需要根据不同的State来构建不同的SQL语句。之前是直接使用的switch来一个个匹配，需求增加的话，又得再加一个case。长久以往，整个查询接口臃肿不堪，离职前夕终于看不下去了，重构了一番，兹此记录。\n原结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace ConsoleTest { public class Product { public string Name { get; set; } public double Price { get; set; } } class Program { static void Main(string[] args) { } public List\u0026lt;Product\u0026gt; GetByStateToList(int ConditionState) { StringBuilder _queryString = new StringBuilder(); switch (ConditionState) { case 1: _queryString.Append(\u0026#34;查询1\u0026#34;); break; case 2: _queryString.Append(\u0026#34;查询2\u0026#34;); break; case 3: _queryString.Append(\u0026#34;查询3\u0026#34;); break; default: _queryString.Append(\u0026#34;查询4\u0026#34;); break; } var _queryResult = QueryDatabase(_queryString.ToString()); return _queryResult; } public List\u0026lt;Product\u0026gt; QueryDatabase(string queryStr) { // .....查询处理 return new List\u0026lt;Product\u0026gt;(); } } } 弊端十分明显，这里我是简化了查询语句，实际情况使每个case至少有十几行代码用于构建查询语句，随着业务变更不断加快，那么我们的GetByStateToList也会变得越来越臃肿，难以维护。\n那么如何重构呢？ 第一步，拆！！！ 臃肿的原因就是因为在这个函数内部塞了太多的语句和分支条件，那么我们首先要把每个查询语句构建分离成一个类，将查询语句的构建放在这个独立的类内部进行操作。\n第二步，统一接口 所有构建SQL语句的类都会有一个Build方法，这个方法用于构建具体的SQL语句，那么我们可以通过一个统一的接口来调用这个Build进行操作。\n第三步，自动匹配 要实现自动匹配，每个类需要在其内部维护一个State常量，这个常量用于判断什么State实例化什么构造类。\n下面我们就来实战演练了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Reflection; namespace ConsoleTest { public class Product { public string Name { get; set; } public double Price { get; set; } } public abstract class SQLBuilder { private static List\u0026lt;SQLBuilder\u0026gt; _builders = null; public int State { get; protected set; } public static ISQLBuilder GetSQLBuilder(int state) { if (_builders == null) { _builders = new List\u0026lt;SQLBuilder\u0026gt;(); var _types = Assembly.GetExecutingAssembly().GetTypes(); foreach (var _type in _types) { if (_type.GetInterface(typeof(ISQLBuilder).FullName) != null) { _builders.Add(Activator.CreateInstance(_type) as SQLBuilder); } } } var _builder = _builders.Where(x =\u0026gt; x.State == state).FirstOrDefault(); return _builder as ISQLBuilder; } } public interface ISQLBuilder { string Build(); } public class SQLBuilderNo1 : SQLBuilder, ISQLBuilder { public SQLBuilderNo1() =\u0026gt; State = 1; public string Build() =\u0026gt; \u0026#34;查询1\u0026#34;; } public class SQLBuilderNo2 : SQLBuilder, ISQLBuilder { public SQLBuilderNo2() =\u0026gt; State = 2; public string Build() =\u0026gt; \u0026#34;查询2\u0026#34;; } public class SQLBuilderNo3 : SQLBuilder, ISQLBuilder { public SQLBuilderNo3() =\u0026gt; State = 3; public string Build() =\u0026gt; \u0026#34;查询3\u0026#34;; } class Program { static void Main(string[] args) { ISQLBuilder _builder = SQLBuilder.GetSQLBuilder(2); Console.WriteLine(_builder.Build()); _builder = SQLBuilder.GetSQLBuilder(3); Console.WriteLine(_builder.Build()); Console.ReadKey(); } public List\u0026lt;Product\u0026gt; GetByStateToList(int ConditionState) { string _queryStr = string.Empty; var _queryResult = QueryDatabase(_queryStr); return _queryResult; } public List\u0026lt;Product\u0026gt; QueryDatabase(string queryStr) { // .....查询处理 return new List\u0026lt;Product\u0026gt;(); } } } 结果： ","date":"2017-09-21T13:21:00Z","permalink":"https://real-zony.github.io/p/implementation-of-automatic-sql-conditional-statement-splicing/","title":"自动SQL条件语句拼接实现"},{"content":"在VS2017当中没有像以前版本一样提供离线版的ISO镜像下载，一般是通过https://www.visualstudio.com/提供的安装工具进行在线安装。 如果你需要下载离线包的话，可以将安装工具下载下来之后，在安装工具目录按住Shift点击鼠标右键，打开命令行工具，然后执行以下命令即可下载一个离线包。 如： D:\\Downloads\u0026gt;vs_enterprise__581629770.1505661989.exe --layout D:\\Downloads\\VS_2017 --lang en-US zh-CN 这种样式。 参数说明： \u0026ndash;layout 后面跟你离线下载的目录 \u0026ndash;lang 后面跟你需要离线下载的语言包，如果要有多个语言支持，请用空格隔开即可 具体的参数列表请参考MSDN： https://docs.microsoft.com/en-us/visualstudio/install/use-command-line-parameters-to-install-visual-studio\n","date":"2017-09-18T14:44:00Z","permalink":"https://real-zony.github.io/p/visual-studio-2017-offline-package-making/","title":"Visual Studio 2017 离线包制作"},{"content":"项目当中时长会遇到进行HTTP请求的时候，遇得多了，自己写了一个简易的辅助类，通过HttpClient进行各种请求操作，毫无技术含量，仅在此分享一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 /// \u0026lt;summary\u0026gt; /// HTTP操作辅助类 /// \u0026lt;/summary\u0026gt; public class HttpMethodUtils { private readonly HttpClient m_reqClient; public HttpMethodUtils() =\u0026gt; m_reqClient = new HttpClient(); /// \u0026lt;summary\u0026gt; /// 对目标地址进行Get请求 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;url\u0026#34;\u0026gt;请求地址\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;原始参数列表\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;referer\u0026#34;\u0026gt;引用来源\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;请求结果\u0026lt;/returns\u0026gt; public string Get(string url, object parameters = null, string referer = null) { if (string.IsNullOrEmpty(url)) return null; var _req = new HttpRequestMessage() { Method = HttpMethod.Get, RequestUri = new Uri($\u0026#34;{url}{buildHttpGetParameters(parameters)}\u0026#34;) }; if (referer != null) _req.Headers.Referrer = new Uri(referer); using (HttpResponseMessage _msg = m_reqClient.SendAsync(_req).Result) { if (_msg.StatusCode != HttpStatusCode.OK) return null; return _msg.Content.ReadAsStringAsync().Result; } } /// \u0026lt;summary\u0026gt; /// 对目标地址进行POST请求 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;url\u0026#34;\u0026gt;请求地址\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;paramters\u0026#34;\u0026gt;提交的参数\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;referer\u0026#34;\u0026gt;调用来源\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mediaTypeValue\u0026#34;\u0026gt;参数类型\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;调用结果\u0026lt;/returns\u0026gt; public string Post(string url, object paramters = null, string referer = null, string mediaTypeValue = null) { if (string.IsNullOrEmpty(url)) return null; var _req = new HttpRequestMessage() { Method = HttpMethod.Post, RequestUri = new Uri(url) }; if (referer != null) _req.Headers.Referrer = new Uri(referer); if (paramters != null) { _req.Content = new StringContent(buildHttpGetParameters(paramters)); _req.Content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(mediaTypeValue); } using (var _msg = m_reqClient.SendAsync(_req).Result) { if (_msg.StatusCode != HttpStatusCode.OK) return null; return _msg.Content.ReadAsStringAsync().Result; } } /// \u0026lt;summary\u0026gt; /// 构建HTTP的GET方法的参数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;param\u0026#34;\u0026gt;传入的参数模型\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;成功返回构造成功的参数列表，失败返回String.Empty\u0026lt;/returns\u0026gt; private string buildHttpGetParameters(object param) { if (param == null) return string.Empty; var _type = param.GetType(); var _propertys = _type.GetProperties(); StringBuilder _builder = new StringBuilder(); _builder.Append(\u0026#39;?\u0026#39;); foreach (var item in _propertys) { _builder.Append($\u0026#34;{item.Name}={item.GetValue(param)}\u0026amp;\u0026#34;); } return _builder.ToString().TrimEnd(\u0026#39;\u0026amp;\u0026#39;); } } 上文当中，唯一有一点技巧的地方，就是通过反射来获得匿名对象的属性进行构造参数，这里仅作拼接，其实可以构造成一个JSON进行POST提交，某些地方需要。 调用示例：\n1 2 3 4 5 6 7 8 var _postParam = new { token = \u0026#34;xxxxxxx\u0026#34;, page = 10 } var _net = new HttpMethodUtils(); _net.Get(\u0026#34;http://www.baidu.com\u0026#34;,_postParam); ","date":"2017-09-04T14:53:00Z","permalink":"https://real-zony.github.io/p/encapsulates-simple-http-operation-classes/","title":"封装简单的HTTP操作类"},{"content":"在一个项目当中使用了log4net和Quartz，结果使用ILog.Info等方法死活无法输出日志信息， 结果一看在Quartz当中使用了Common.Logging库的，而这个库也有一个ILog接口。 原因是由于使用的智能修复，默认给我引用了Common.Logging库的ILog接口，之后改为log4net的，一切正常。\nlog4Net使用 首先在NuGet当中引入log4net的包。 之后你需要在你的App.Config或者Web.Config当中配置你的log4net的设置。\n举个栗子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;configSections\u0026gt; \u0026lt;section name=\u0026#34;log4net\u0026#34; type=\u0026#34;log4net.Config.Log4NetConfigurationSectionHandler,log4net\u0026#34; /\u0026gt; \u0026lt;/configSections\u0026gt; \u0026lt;configSections\u0026gt; \u0026lt;log4net\u0026gt; \u0026lt;root\u0026gt; \u0026lt;!--控制级别，由低到高: ALL|DEBUG|INFO|WARN|ERROR|FATAL|OFF--\u0026gt; \u0026lt;!--比如定义级别为INFO，则INFO级别向下的级别，比如DEBUG日志将不会被记录--\u0026gt; \u0026lt;!--如果没有定义LEVEL的值，则缺省为DEBUG--\u0026gt; \u0026lt;level value=\u0026#34;INFO\u0026#34; /\u0026gt; \u0026lt;appender-ref ref=\u0026#34;RollingFileAppender\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;appender name=\u0026#34;RollingFileAppender\u0026#34; type=\u0026#34;log4net.Appender.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;!--日志文件名开头--\u0026gt; \u0026lt;file value=\u0026#34;Log/Log.log\u0026#34; /\u0026gt; \u0026lt;!--多线程时采用最小锁定--\u0026gt; \u0026lt;lockingModel type=\u0026#34;log4net.Appender.FileAppender+MinimalLock\u0026#34; /\u0026gt; \u0026lt;!--日期的格式，每天换一个文件记录，如不设置则永远只记录一天的日志，需设置--\u0026gt; \u0026lt;datePattern value=\u0026#34;(yyyyMMdd)\u0026#34; /\u0026gt; \u0026lt;!--是否追加到文件,默认为true，通常无需设置--\u0026gt; \u0026lt;appendToFile value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!--变换的形式为日期，这种情况下每天只有一个日志--\u0026gt; \u0026lt;!--此时MaxSizeRollBackups和maximumFileSize的节点设置没有意义--\u0026gt; \u0026lt;!--\u0026lt;rollingStyle value=\u0026#34;Date\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!--变换的形式为日志大小--\u0026gt; \u0026lt;!--这种情况下MaxSizeRollBackups和maximumFileSize的节点设置才有意义--\u0026gt; \u0026lt;RollingStyle value=\u0026#34;Size\u0026#34; /\u0026gt; \u0026lt;!--每天记录的日志文件个数，与maximumFileSize配合使用--\u0026gt; \u0026lt;MaxSizeRollBackups value=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;!--每个日志文件的最大大小--\u0026gt; \u0026lt;!--可用的单位:KB|MB|GB--\u0026gt; \u0026lt;!--不要使用小数,否则会一直写入当前日志--\u0026gt; \u0026lt;maximumFileSize value=\u0026#34;2MB\u0026#34; /\u0026gt; \u0026lt;!--日志格式--\u0026gt; \u0026lt;layout type=\u0026#34;log4net.Layout.PatternLayout\u0026#34;\u0026gt; \u0026lt;conversionPattern value=\u0026#34;%date [%t]%-5p %c - %m%n\u0026#34; /\u0026gt; \u0026lt;/layout\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;/log4net\u0026gt; \u0026lt;/configuration\u0026gt; 然后在你要使用的地方写如下代码：\n1 2 3 4 5 6 XmlConfigurator.Configure(); Type type = MethodBase.GetCurrentMethod().DeclaringType; ILog m_log = LogManager.GetLogger(type); m_log.Info(\u0026#34;日志测试\u0026#34;); m_log.Info(\u0026#34;日志测试\u0026#34;); 然后就能在日志文件当中看到效果啦。\n","date":"2017-08-23T04:53:00Z","permalink":"https://real-zony.github.io/p/problems-with-the-use-of-log4net/","title":"Log4Net的使用的问题"},{"content":"什么是局部套用? 局部套用可以将需要接收多个参数的函数转化为一个函数链，在这个函数链的末尾，所有的参数都可以使用。\n如何在C#当中实现局部套用 我们有一个函数如下：\n1 2 3 4 5 6 7 8 9 10 public int Test(int value,int value2) { return value * value2; } public void call() { Func\u0026lt;int,int,int\u0026gt; a = Test; int _result = a(10,20); } 它的局部套用函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public Func\u0026lt;int,int\u0026gt; Test2(int par2) { return par1=\u0026gt;par1*par2; } public void call2() { Func\u0026lt;int,Func\u0026lt;int,int\u0026gt;\u0026gt; a = Test2; var _func1 = a(10); int _result = _func1(20); // or a(10)(20); } 我们可以建立一个扩展函数来直接将一个正常函数转换为一个局部套用函数：\n1 2 3 4 public static Func\u0026lt;T1,Func\u0026lt;T2,TR\u0026gt;\u0026gt; Curry\u0026lt;T1,T2,TR\u0026gt;(this Func\u0026lt;T1,T2,TR\u0026gt; func) { return par1=\u0026gt;par2=\u0026gt;func(par1,par2); } 也可以将一个局部套用格式的函数转换为正常的方法：\n1 2 3 4 public static Func\u0026lt;T1,T2,TR\u0026gt; UnCurry\u0026lt;T1,T2,TR\u0026gt;(this Func\u0026lt;T1,Func\u0026lt;T2,TR\u0026gt;\u0026gt; func) { return (par1,par2)=\u0026gt;func(par1)(par2); } 为什么要使用局部套用格式的函数？ 最主要的原因是只需要部分计算参数而不是全部参数就可以调用这个函数。该过程就是部分应用，这是一个函数 构建技术。 使用部分应用的另外的一个理由就跟建立重载函数的理由是一样的。\n","date":"2017-08-03T16:28:00Z","permalink":"https://real-zony.github.io/p/csharp-functional-programming-partial-vs-partial/","title":"C# 函数式编程：部分应用与局部套用"},{"content":"在.NetCore实现插件系统的时候，发现某些方法与在.NetFramework内的使用方法不一样，在此做一个记录供以后查阅。\nNO.1 Assembly.Load 与 AssemblyLoadContext.Default.LoadFromXXX 在.NetFramework当中，如果要加载某一个程序集的话，通过Assembly的Load的各种重载方法即可通过文件流、文件路 径等方式将其加载到当前调用方的应用程序域当中。但是在.Net Core当中则不然，它并没有在Assembly当中提供Load 方法供开发人员操作，而你则需要在Nuget里面对当前项目安装System.Runtime.Loader，然后使用其提供的 AssemblyLoadContext来进行程序集加载。\n引用自OSChina的一篇资讯：\nApp Domain\nApp Domain在CoreCLR中得以实现，但没有在.NET Native中实现。由于对App Domain的实现需要大量的运行时特性支持，因此目前还没有任何对它的支持计划。“对于代码的隔离，我们建议通过进程或容器实现。而对于程序集的动态加 载，我们建议使用新的AssemblyLoadContext类。”\n例如以下代码：\n1 2 3 4 5 6 7 8 9 10 // .NetFramework public void assemblyTestMethod() { var _asm = Assembly.Load(\u0026#34;C:\\Test.dll\u0026#34;); } // .Net Core public void assemblyTestMethodCore() { var _asm = AssemblyLoadContext.Default.LoadFromAssemblyPath(\u0026#34;C:\\Test.dll\u0026#34;); } NO.2 GetCustomAttribute() 扩展支持 在.NetFramework当中，GetCustomAttribute()方法是针对Type与TypeInfo对象的，但是在.NetCore当中如果要调用这个 方法的话，则仅能通过Type.GetTypeInfo().GetCustomAttribute()来获得对象的特性标签。\nNO.3 GetInterface与GetInterfaces方法 貌似在.NetCore当中的Type对象是没有Getinterface方法的，So\u0026hellip;你只有使用后者获得一个IEnumerable对象再来筛选啦。\n","date":"2017-08-02T08:45:00Z","permalink":"https://real-zony.github.io/p/some-differences-between-dotnetcore-and-dotnetframework/","title":".NET Core 与 .NET Framework 动态加载DLL的一些不同点"},{"content":"在使用Json.Net的时候，如果要生成一个JSON文档的话，只需要构建一个实体，并扔进SerializeObject方法即可。 那么如果我们需要将一个实体序列化为XML呢？\n这个时候我们就需要使用到XMLSerializer，根据MSDN的介绍\nXML 序列化是将对象的公共属性 (Property) 和字段转换为序列格式（这里是指 XML）以便存储或传输的过程。\n这里他会将我们的公共属性转化为序列格式，下面我们来声明一个实体模型：\n1 2 3 4 5 6 7 8 [XmlRoot(ElementName = \u0026#34;Student\u0026#34;)] public class StudentModel { [XmlElement(\u0026#34;StudentName\u0026#34;)] public string Name { get; set; } [XmlElement(\u0026#34;StudentAge\u0026#34;)] public int Age{ get; set; } } 这里的XmlRoot与XmlElement分别是对根元素名称与其序列化的XML元素节点的实际名称。\n因为在与第三方系统对接的时候，可能对方提供的一些文档与己方模型属性名称不匹配，而又不想因为第三方系统的对接而重构自己所有原有属性的名称，这个时候这两个Attribute就能够提供作用了。\n下面我们如果要将这个对象序列化，需要写一个辅助方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static string SerializeXMLObject\u0026lt;T\u0026gt;(T sourceObj) { XMLSerializer _serializer = new XMLSerializer _serializer(typeof(T)); using(MemoryStream _stream = new MemoryStream()) { _serializer.Serialize(_stream,sourceObj); _stream.Position = 0; using(StreamReader _reader = new StreamReader(_stream)) { return _reader.ReadToEnd(); } } } so,当调用SerializeXMLObject方法的时候，传入要序列化的对象即可。\n1 2 3 4 5 6 7 private void Test() { StudentModel _obj2 = new StudentModel(); _obj2.Name = \u0026#34;李四\u0026#34;; _obj2.Age = 25; MessageBox.Show(SerializerUtils.SerializeXMLObject(_obj2)); } ","date":"2017-07-31T06:43:00Z","permalink":"https://real-zony.github.io/p/serialize-the-specified-entity-into-an-xml-document/","title":"将指定实体序列化为 XML 文档"},{"content":"在Register当中有以下代码：\n1 2 3 4 5 6 7 8 9 10 private void Register() { ... _builer.RegisterType\u0026lt;BaseConnectionFactory\u0026gt;().As\u0026lt;IBaseConnectionFactory\u0026gt;().InstancePerLifetimeScope(); ... } publi abstrct class BaseConnectionFactory { //...other code... } 注册之后提示异常信息：\n1 Autofac.Core.DependencyResolutionException:“No constructors on type \u0026#39;PDL.DoubleCenter.Infrastructure.BaseConnectionFactory\u0026#39; can be found with the constructor finder \u0026#39;Autofac.Core.Activators.Reflection.DefaultConstructorFinder\u0026#39;.” 之后查阅相关资料无果，之后尝试将abstrct取消之后正常注册。\n","date":"2017-07-22T05:36:00Z","permalink":"https://real-zony.github.io/p/bug-caused-by-autofac-injecting-a-single-type/","title":"Autofac 注入单个类型引发的BUG"},{"content":"在C#当中你可以使用Neo.Lua这个第三方库来集成LUA支持，并且你的LUA当中还能够编写并且使用.Net的库。\n首先在Nuget包管理器当中下载并且安装Neo.Lua、Neo.Lua.Desktop这两个包，之后我们新建一个WinFrom项目，在这个项目上面我们拖放一个TextBox以及一个Button，在这里我们的TextBox的名字叫做textbox_LuaContent，Button的名字则为button_Test。\n建立好之后，我们在button_Test的响应函数里面编写如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private void button_Test_Click(object sender, EventArgs e) { try { using (var _lua = new Lua()) { // 初始化环境 dynamic _g = _lua.CreateEnvironment\u0026lt;LuaGlobal\u0026gt;(); // 绑定函数委托 _g.print = new Action\u0026lt;string\u0026gt;(print); // 编译代码成可执行的数据块 var _chunk = _lua.CompileChunk(textbox_LuaContent.Text, \u0026#34;Test.lua\u0026#34;, new LuaCompileOptions() { DebugEngine = LuaStackTraceDebugger.Default }); // 执行 _g.dochunk(_chunk); } } catch (System.Exception ex) { MessageBox.Show(ex.Message); } } /// \u0026lt;summary\u0026gt; /// 打印功能 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;outputContent\u0026#34;\u0026gt;要打印的内容\u0026lt;/param\u0026gt; private void print(string outputContent) { MessageBox.Show(outputContent); } 效果:\n如果看不清楚，请右键查看图片。\n","date":"2017-07-21T08:47:00Z","permalink":"https://real-zony.github.io/p/integrate-dynamic-parsing-support-for-lua-in-your-csharp-project/","title":"在你的 C# 项目当中集成对 LUA 的动态解析支持"},{"content":" 实现ICloneable 接口，自定义拷贝功能 序列化/反序列化类实现 通过反射来创建新的对象实例 No.1 实现ICloneable接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 publi class Person : ICloneable { public int Age { get; set;} public string Address { get; set; } public string Name { get; set; } public Object Clone() { Person _temp = new Person(); _temp.Address = this.Address; _temp.Age = this.Age; _temp.Name = this.Name; return _temp; } } No.2 序列化/反序列化类实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [Serializable] public class Person :ICloneable { public object Clone() { using(MemoryStream _ms = new MemoryStream(1000)) { object _cloneObject; BinaryFormatter _bf = new BinaryFormatter(null,new StreamingContext(StreamingContextStates.Clone)); _bf.Serialize(_ms,this); _ms.Seek(0,SeekOrigin.Begin); _cloneObject = _bf.Deserialize(_ms); return _cloneObject; } } } 当然还有另外一种方法，那就是通过Json.Net来进行序列化之后再反序列化对象，同样可以实现深度拷贝。\nNo.3 通过反射来创建一个新的对象实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static T ObjectClone\u0026lt;T\u0026gt;(T model) { var _oRes = default(T); var _oType = typeof(T); // 创建一个新的对象 _oRes = (T)Activator.CreateInstance(_oType); // 批量对新对象的属性进行赋值 var _propertys = _oType.GetProperties(); foreach(var _pro in _propertys) { var _oldValue = _pro.GetValue(model); _pro.SetValue(_oRes,_oldValue); } return _oRes; } 这种方法非常简单，也很容易理解。不过反射单个元素还好，如果是Clone一个集合的话，效率是一个很严重的问题。\n","date":"2017-07-19T07:07:00Z","permalink":"https://real-zony.github.io/p/three-object-deep-copy-methods-of-csharp/","title":"C# 的三种对象深拷贝方法"},{"content":"在SQLServer当中对于NText,Text,XML以及Image类型的数据没有比较机制，如果直接书写以下代码会出现错误:\n1 WHERE Descript = \u0026#39;\u0026#39; --会报错：数据类型 text 和 varchar 在 equal to 运算符中不兼容。 并且在LINQ TO SQL 当中也会提示NotSupportedException4异常：SQL Server 未处理 NText、Text、Xml 或 Image 数据类型的比较。\nSo，只能利用强制类型转换转换为nvarchar进行比较，或者判断长度是否为0这样来进行操作啦。\n","date":"2017-07-04T02:48:00Z","permalink":"https://real-zony.github.io/p/judgment-of-whether-the-text-type-is-empty-in-sql-server/","title":"SQL Server 中关于 text 类型是否为空的判断"},{"content":"在Linux下对文件或者目录赋权限的时候其实就是使用了位运算来对一个State标志位进行操作。\n因为在二进制中0001,0010,0100,1000，等以此类推，这几个数字进行按位于或者按位或操作的话会有一些神奇的事情发生。\n常见的位运算主要是，与\u0026amp;、或|、非~这三种，这三种运算符的特性跟逻辑操作服差不多，1是true,0是false而已，只不过这里运算规则是这种：\n1 \u0026amp; 0 = 0 1| 0 = 1 ~1 = 0 首先我们来建立一个枚举如下：\n1 2 3 4 5 6 7 8 [Flags] public enum TestEnum { Insert = 1, Delete = 2, Query = 4, Update = 8 } 这里的[Flags]特性的作用是让被修饰的枚举支持位运算操作，而每个枚举的值我们使用2的n次方进行赋值，那么这里就表示为了：\n0001 0010 0100 1000 然后这里的二进制位每一位1代表有某种权限，0则代表没有，例如0011则说明拥有Insert与Delete两种权限。那么我们根据位运算的法则，如果要让一个State标志位拥有两种权限，则只需要将其进行或运算即可，例如0001 | 0010 = 0011，换成代码来说如下：\n1 2 3 4 5 6 7 TestEnum permissions = TestEnum.Insert | TestEnum.Delete; // 简化写法 TestEnum permissions |= TestEnum.Delete; // 删除权限则进行与非，或者异或操作均可实现 permissions \u0026amp;= ~TestEnum.Delete; // 0011 \u0026amp; (~0010-\u0026gt;1101) = 0001 -\u0026gt; Insert 而当我们需要进行判断一个State是否拥有某种权限的时候，则需要将其与需要判断的权限进行按位于运算，如果得到的结果等于要判断的权限，则说明这个State拥有这个权限值。\n1 2 3 4 5 6 7 TestEnum permissions = TestEnum.Insert | TestEnum.Delete; if((permissions \u0026amp; TestEnum.Insert) == TestEnum.Insert) { Console.WriteLine(\u0026#34;拥有插入权限！\u0026#34;); } // 0011 \u0026amp; 0001 = 0001 ","date":"2017-06-26T05:40:00Z","permalink":"https://real-zony.github.io/p/csharp-uses-bit-operators-to-implement-simple-permission-operations/","title":"C# 使用位操作符实现简单的权限操作"},{"content":"当涉及新老系统迁移的时候，可能同一个模块的数据表结构变化十分大，则需要通过编写一些程序来进行一些转换操作，转换完之后尝尝少则几万条数据，多则几十万条，如果一条一条的插入所消耗的时间成本是十分昂贵的。\n那么在C#当中则提供了SqlBulkCopy类，它存在于System.Data.SqlClient命名空间下，该类可以进行大批量的数据插入，并且效率十分快。 经过测试，耗时时间如下：\n十万条数据:2.2051s 一万条数据:0.2188s 一千条数据:0.0187s 效率十分的高，但是该类仅支持DataTable操作，一般来说Dapper以及EF框架读出来的都是一个IEnumerable，所以我们需要通过反射来构建一个DataTable进行操作。这里我写了一个静态泛型方法，可以直接传入IEnumerbale对象来批量插入数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 static void BulkInsertAll\u0026lt;T\u0026gt;(IEnumerable\u0026lt;T\u0026gt; entities,String connectString) { var conn = new SqlConnection(connectString); conn.Open(); Type t = typeof(T); var tableAttribute = (TableAttribute)t.GetCustomAttributes(typeof(TableAttribute), false).Single(); var bulkCopy = new SqlBulkCopy(conn) { DestinationTableName = tableAttribute.Name }; var properties = t.GetMembers().Where(p =\u0026gt; { var columnAttribute = Attribute.GetCustomAttribute(p, typeof(ColumnAttribute)) as ColumnAttribute; if (columnAttribute != null) return true; return false; }).ToArray(); var table = new DataTable(); foreach (var property in properties) { Type propertyType = ((FieldInfo)property).FieldType; if (propertyType.IsGenericType \u0026amp;\u0026amp; propertyType.GetGenericTypeDefinition() == typeof(Nullable\u0026lt;\u0026gt;)) { propertyType = Nullable.GetUnderlyingType(propertyType); } table.Columns.Add(new DataColumn(property.Name, propertyType)); } foreach (var entity in entities) { var cols = properties.Select(property =\u0026gt; { var field = (FieldInfo)property; var o = field.GetValue(entity); if (o == null) return DBNull.Value; else return o; }).ToArray(); table.Rows.Add(cols); } bulkCopy.WriteToServer(table); conn.Close(); } } ","date":"2017-06-23T04:51:00Z","permalink":"https://real-zony.github.io/p/bulk-database-inserts-with-sqlbulkcopy/","title":"使用 SqlBulkCopy 进行大批量数据库插入"},{"content":"在涉及老项目数据迁移的时候，数据库结构已经完全发生变化，而且需要对老数据进行特殊字段的处理，而且数据量较大，使用Navicat导出单表之后，一个表数据大概在100多万的样子，直接导出SQL执行根本行不通，执行到一般就GG。\n之后尝试使用LINQ PAD直接操作两个数据库进行数据迁移，搜索一番，得知LINQ PAD是支持多数据库操作的，而且也是支持linked SqlServer。\n首先，我们先在新数据库的服务器上，打开SQL Server Management Studio，连接上数据库，然后在服务器对象上找到链接服务器，右键链接服务器选择新建链接服务器，如下图：\n链接服务器：填写你要关联的服务器IP地址 服务器类型：选择其他数据源。 提供程序：这里因为我是安装了Navicat for premium的，所以我直接选择的他的SQL提供程序。 数据源：这里还是填写关联服务器IP地址。\n然后我们来到安全性：\n选择使用此安全上下文建立链接，然后填上你远程服务器的登陆用户名以及密码即可。\n然后我们打开Linq Pad，这里我是使用的LINQ PAD 5，新建一个链接，一直Next，然后到这个界面：\n选择Include additional databases，之后会弹出如下界面：\n上面选择你主数据库，下面不要点Pick from list来选择数据库，会提示找不到任何链接服务器，这里你手动点击一个条目，在Server 填上你刚才添加的服务器IP，后面database填上你要附加的数据库确定即可。然后成功之后，你的连接就会成这个样子：\n然后你就可以直接用C#来进行操作了。\n","date":"2017-06-18T04:08:00Z","permalink":"https://real-zony.github.io/p/sql-server-establishes-linked-server-cross-server-database-operations/","title":"SQL Server 建立 Linked Server 跨服务器数据库操作"},{"content":"在使用Swagger的时候出现过这种异常:\n1 System.InvalidOperationException:“Conflicting schemaIds: Duplicate schemaIds detected for types PDL.SocialGovern.Mobile.Api.Controllers.SystemManager.InformationController+ListQuery and PDL.SocialGovern.Mobile.Api.Controllers.SystemManager.AppDutyController+ListQuery. See the config setting - \u0026#34;UseFullTypeNameInSchemaIds\u0026#34; for a potential workaround” 这种问题的原因是由于在Swagger2.0当中如果你在API层当中声明了多个同样名称的类型的话，就会出现ID冲突，那么你只需要在SwaggerConfig.cs当中将c.UseFullTypeNameInSchemaIds();取消注释即可。\n取消注释之后Swagger将会启用完整的类型名称。\n","date":"2017-06-05T02:23:00Z","permalink":"https://real-zony.github.io/p/swagger-has-systeminvalidoperationexception-exception/","title":"Swagger 出现System.InvalidOperationException 异常"},{"content":"按照往常一样，编译发布项目。当部署到IIS上面的时候却出现了一个\n编译错误 说明: 在编译向该请求提供服务所需资源的过程中出现错误。请检查下列特定错误详细信息并适当地修改源代码。 编译器错误消息: CS0012: 类型“System.Object”在未被引用的程序集中定义。必须添加对程序集“System.Runtime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a”的引用。\n这种错误，十分尴尬。\n搜索了一下，在web.config的\u0026lt;system.web\u0026gt;节点下面的内部添加一个引用，如下\n1 \u0026lt;add assembly=\u0026#34;System.Runtime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\u0026#34; /\u0026gt; 参考资料:http://www.lyalin.com/2014/04/25/the-type-system-object-is-defined-in-an-assembly-that-is-not-reference-mvc-pcl-issue/ 究其原因，在上述文章当中已经写明，这是一个VS的一个BUG。在StackOverflow当中也有针对这个问题的 描述。\n","date":"2017-05-30T06:17:00Z","permalink":"https://real-zony.github.io/p/missing-systemruntime-error-in-mvc-project/","title":"在 MVC 项目中出现缺少 System.Runtime 的错误"},{"content":"需要在Global.asax.cs当中重载Init方法：\n1 2 3 4 5 public override void Init() { PostAuthenticateRequest+=SessionOpen; base.Init(); } 这里的SessionOpen是一个委托，方法签名为：\n1 void Action(object sender,EventArgs e); 即：\n1 2 3 4 private void SessionOpen(object sender,EventArgs e) { HttpContext.Current.SetSessionStateBehavior(SessionStateBehavior.Required); } ","date":"2017-05-23T12:51:00Z","permalink":"https://real-zony.github.io/p/enable-session-support-for-webapi/","title":"为 WebAPI 开启 Session 支持"},{"content":"具体解决方法如下：\n打开VS的【工具】-【选项】-【调试】-【符号】，如下图：\n先取消勾选“Microsoft符号服务器” 清空符号缓存 重启VS2012 ","date":"2017-04-27T01:14:00Z","permalink":"https://real-zony.github.io/p/solutions-for-slow-loading-symbols-such-as-vs2017/","title":"VS2017 等加载符号很慢情况的解决办法"},{"content":"说白了 DBSet.Where() 有两个重载，一个是IQueryable还有一个是IEnumerable，前者则是会延迟执行，而后者则是将整个数据集加载出来之后再进行Where查询。\nIQueryable这个查询对象接收的是Expression\u0026lt;Func\u0026lt;T,bool\u0026gt;\u0026gt;，也就是一个表达式树，他将会把查询条件解析成SQL，在数据源提供器里面执行查询。\n而List是一个集合，他接收的是一个Func\u0026lt;T,bool\u0026gt;，也就是一个查询委托，他则是将整个DBSet加载出来放在内存之后，再进行查询，所以后者性能堪忧。\n详细请查看StackOverflow上面的这两篇问题：\nFunc vs Manually expression performance in C# lambda\nWhy would you use Expression rather than Func?\n","date":"2017-04-14T13:09:00Z","permalink":"https://real-zony.github.io/p/performance-issues-with-dbset-two-where-queries/","title":"DbSet 两种 Where 查询的性能问题"},{"content":"举个栗子：\n1 2 3 4 5 6 7 8 9 10 delegate T MyFunc\u0026lt;T\u0026gt;(); static void WriteResult\u0026lt;T\u0026gt;(MyFunc\u0026lt;T\u0026gt; function) { Console.WritleLine(function()); } ... WriteResult(delegate { return 5; }); 在C#2.0当中以上代码会报错，因为C#2的类型推断是单独针对每一个实参来进行的，从一个实参推断出的类型无法直接用于另外一个实参。在本例当中，function的输入值是T，返回值也是T，C#2.0的简单规则似乎无法为我们解决问题。 这个时候有两种解决办法：\n1 2 WriteResult\u0026lt;int\u0026gt;(delegate { return 5; }); // 显示指定类型实参 WriteResult((MyFunc\u0026lt;int\u0026gt;)delegate { return 5; }); // 将匿名委托强制转换为具体的委托类型，而不是泛型委托 而C#3则做了更为精致的工作，他能够像处理隐式类型数组一样来处理匿名委托的返回类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 delegate T MyFunc\u0026lt;T\u0026gt;(); static void WriteResult\u0026lt;T\u0026gt;(MyFunc\u0026lt;T\u0026gt; function) { Console.WriteLine(function()); } WriteResult(delegate { if(DateTime.Now.Hour \u0026lt; 12) { return 10; }else { return new object(); } }); 这个时候编译器会构建一个集合，包含了匿名委托当中return 当中的所有返回类型，并且检查这个集合当中所有的类型都能够隐式转换为其中一个类型。在上面的例子当中，则是int和object，int-\u0026gt;object通过装箱会存在一个隐式类型转换，而object到int则不可能，所以Object被推断为这个匿名委托的返回类型。\n辣么，我们下一个例子更加复杂的解释了两个非固定的变量如何被成功推断出来的：\n1 2 3 4 5 6 static void PrintConvertedValue\u0026lt;TInput,TOutput\u0026gt;(TInput input,Converter\u0026lt;TInput,TOutput\u0026gt; converter) { Console.WriteLine(convertrt(input)); } ... PrintConverter(\u0026#34;I am a string.\u0026#34;,x=\u0026gt;x.Length); 以上代码需要经过一下几步推断： 1.第一个参数是TInput类型，实参传递的是string类型，辣么我们可以推断出TOutput肯定存在到TInput的转换。 2.第二个参数是Converter\u0026lt;TInput,TOutput\u0026gt;类型，第二个实参则是一个饮食类型的Lambda表达式，此时不进行任何推断。 3.TInput不依赖任何非固定类型参数，所以被确定为string类型。 4.第二个实参现在有一个固定的输入类型，但是有一个非固定的输出类型，即(string x)=\u0026gt;x.Length，并推断出其返回类型为int，因此int到TOutput必定会发生一个饮食类型转换。 直到没有推断出非固定类型为止。\n辣么我们再来看一个更加复杂的例子：\n1 2 3 4 5 6 7 8 static void ConvertTwice\u0026lt;TInput,TMiddle,TOutput\u0026gt;(TInput input,Converter\u0026lt;TInput,TMiddle\u0026gt; firstConversion,Converter\u0026lt;TMiddle,TOutput\u0026gt; secondConversion) { TMiddle middle = firstConverstion(input); TOutput output = secondConversion(middle); Console.WriteLine(output); } ... ConvertTwice(\u0026#34;Another string\u0026#34;,text=\u0026gt;text.Length,lenght=\u0026gt;Math.Sqrt(lenght)); 乍看一下十分复杂，其实很简单，我们这个函数获取一个字符串，并计算出它的长度，将这个长度进行求平方根操作。 无非都是根据string这个固定变量逐步推断出TMiddle与TOutput的类型。\n","date":"2017-04-12T14:02:00Z","permalink":"https://real-zony.github.io/p/anonymous-type-inference-for-lambda-functions-in-csharp/","title":"C# 当中 Lambda 函数的匿名类型推断"},{"content":" 1 2 3 4 5 6 7 8 9 ALTER DATABASE DataBaseName SET RECOVERY SIMPLE WITH NO_WAIT ALTER DATABASE DataBaseName SET RECOVERY SIMPLE --简单模式 DBCC SHRINKFILE (N\u0026#39;DataBaseName_log\u0026#39; , 11, TRUNCATEONLY) -- 11是大小 11M ALTER DATABASE DataBaseName SET RECOVERY FULL WITH NO_WAIT ALTER DATABASE DataBaseName SET RECOVERY FULL --还原为完全模式 ","date":"2017-04-06T06:14:00Z","permalink":"https://real-zony.github.io/p/sql-server-compressed-logs/","title":"SQL Server 压缩日志"},{"content":"在blog开发的时候，下午就遇到过更新实体的时候，CreateTime自动更新的问题，当时还以为是自己代码写错了，找了半天也没有在代码找到变更日期的地方，之后又查找EF相关资料，无果，就没有管他。\n结果晚上用Navicat的数据库更改一个字段就造成了CreateTime的自动变更，这就很尴尬了。搜索了一番，才知道mysql的DateTime类型有一个自动更新时间戳选项。如图：\n取消勾选即可。\n","date":"2017-04-04T15:27:00Z","permalink":"https://real-zony.github.io/p/mysql-datetime-automatic-change-pit/","title":"MySql DateTime 自动变更的坑"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /*a标签鼠标移入*/ a:hover { border-color:white; /*边框颜色*/ color:black; /*文字颜色*/ background-color:white; /*背景变白*/ } /*移除a标签样式*/ a:link,a:visited{ text-decoration:none; } .tm-intro-link { border:2px solid; /*边框*/ color:white; /*边框及文字颜色*/ /*border-radius:50px;圆角*/ display:inline-block; padding:15px 60px; } /*渐变*/ a{ transition:all 0.3s ease } \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;tm-intro-link\u0026#34;\u0026gt;我是一个测试按钮\u0026lt;/a\u0026gt; 初学前端，感觉好难。\n","date":"2017-04-04T15:05:00Z","permalink":"https://real-zony.github.io/p/implement-a-transparent-button-with-css3/","title":"用 CSS3 实现一个透明色的按钮"},{"content":"迭代器模式是行为模式的一种，他能够有效地构建数据管道，迭代器相当于数据库当中的游标，它只能够向前移动，并且在一个数据序列当中可能会存在多个迭代器。在C#1当中你要实现一个迭代器的话，得编写相当多的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class IterationSample : IEnumerable { object[] values; int startingPoint; public IterationSample(object[] values,int startingPoint) { this.values = values; this.startingPoint; } public IEnumertor GetEnumertor() { return new IterationSampleIterator(this); } class IterationSampleIterator : IEnumertor { IterationSample parent; int position; internal IterationSampleIterator(IterationSmaple parent) { this.parent = parent; } public bool MoveNext() { if(position != parent.values.Lenght) { position++; } return position \u0026lt; parent.values.Lenght; } public object Current { get { if(position == -1 || position == parent.values.Lenght) { throw new InvalidOperationException(); } int index = positon + parent.startingPoint; index = index % parent.values.Lenght; return parent.values.Lenght[index]; } } public void Reset() { positon = -1; } } } 使用迭代器块yield的话，GetEnumertor()方法仅需这样写即可：\n1 2 3 4 5 6 7 public IEnumertor GetEnumertor() { for(int index;i\u0026lt;values.Lenght;i++) { yield return values[(index + startingPoint) % values.Lenght]; } } 其实在yield return 的时候，代码会停止执行，直到下一次调用MoveNext的时候才会恢复上次执行的状态，而代码的结束则是由MoveNext()的返回值控制的，如果超出了边界，该方法会返回false，这个时候代码就不会在执行。 当然你也可以使用yield break;语句来强制使MoveNext();返回false,退出。\n","date":"2017-03-31T13:56:00Z","permalink":"https://real-zony.github.io/p/using-csharp-iterators-and-iterator-blocks/","title":"C# 迭代器与迭代器块的使用"},{"content":" 每个封闭类型都会有一个自己的静态字段集 每个封闭类型的静态构造函数仅会执行一次。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 public class Outer\u0026lt;T\u0026gt; { public class Inner\u0026lt;U,V\u0026gt; { static Inner() { Console.WriteLine($\u0026#34;Outer\u0026lt;{typeof(T).Name}\u0026gt;,Inner\u0026lt;{typeof(U).Name},{typeof(V).Name}\u0026gt;\u0026#34;); } public void Test(){} } } 那么我们进行以下调用：\n1 2 3 Out\u0026lt;int\u0026gt;.Inner\u0026lt;string,DateTime\u0026gt;.Test(); Out\u0026lt;string\u0026gt;.Inner\u0026lt;int,object\u0026gt;.Test(); Out\u0026lt;int\u0026gt;.Innter\u0026lt;string,DateTime\u0026gt;.Test(); 那么第一二行会打印出他们类型参数的Name属性，而第三行由于**每个封闭类型的静态构造函数仅会执行一次。**的规定，所以不会产生任何输出。\n","date":"2017-03-29T15:18:00Z","permalink":"https://real-zony.github.io/p/csharp-generic-static-fields-and-static-constructors/","title":"C# 泛型静态字段与静态构造函数"},{"content":"泛型方法类型推断 有以下代码：\n1 2 3 4 5 6 static List\u0026lt;T\u0026gt; MakeList\u0026lt;T\u0026gt;(T first,T second); { ...... } List\u0026lt;string\u0026gt; list = MakeList\u0026lt;string\u0026gt;(\u0026#34;a1\u0026#34;,\u0026#34;b1\u0026#34;); 可以简写成：\n1 List\u0026lt;string\u0026gt; list = MakeList(\u0026#34;a1\u0026#34;,\u0026#34;b1\u0026#34;); 在这里就使用到了泛型类型推断，但是类型推断只适用于泛型方法。\n默认值表达式 在一个泛型类当中，你如果要知道该类型参数的默认值，不能使用null，因为类型参数可能被约束为值类型，你也不能使用0，因为也有可能被约束为引用类型。在C#2当中提供了默认值表达式default(T),就可以返回类型实参的默认值。\n1 2 3 4 5 6 7 8 9 10 static int CompareToDefault\u0026lt;T\u0026gt;(T value) where T : IComparable\u0026lt;T\u0026gt; { return value.CompareTo(default(T)); } Console.WriteLine(ComparaToDefault(\u0026#34;x\u0026#34;)); //1 Console.WriteLine(ComparaToDefault(10)); //1 Console.WriteLine(ComparaToDefault(0)); //0 Console.WriteLine(ComparaToDefault(-10)); //-1 Console.WriteLine(ComparaToDefault(DateTime.MinValue)); //0 由CompareTo文档指出，所有引用类型的值都大于null,所以返回1，CompareTo，如果比较的值比自己大则为1，相等则为0，小于则为-1。 不过如果传入的是null，以上代码会如预期的抛出NullReferenceException异常，我们可以使用IComparer\u0026lt;T\u0026gt;。\n泛型比较 如果一个类型参数是未被约束的，那么只能在泛型类直线中对该类型的值与null进行比较的时候才可以使用!=、==操作符。 如果类型参数被约束为值类型，那么就完全不能使用!=、==操作符。 如果他只是一个引用类型，则只能进行简单的引用比较，可以使用!=、==操作符。 如果他被进一步约束成继承自某个重载了的!=、==操作符的特定类型(即转换类型约束)，就会使用重载操作符。\n如果调用者指定的类型实参恰巧也进行了重载，那么这个重载操作符是不会使用的 1 2 3 4 5 6 7 8 9 10 static bool AreReferenceEqual\u0026lt;T\u0026gt;(T first,T second) where T : class { return first == second; } string name = \u0026#34;Jon\u0026#34;; string intro1 = \u0026#34;Hello \u0026#34; + name; string intro1 = \u0026#34;Hello \u0026#34; + name; Console.WriteLine(intro1 == intro2); Console.WriteLine(AreReferenceEqual(intro1,intro2)); 在这里，第一行输出为True，是因为这里使用的是string重载过的比较操作符，用于比较两个字符串是否相等。 而第二行输出为False，是因为在编译AreReferenceEqual的时候，编译器根本不知道有哪些重载可用，因为我们约束的是class，所以相当于传入的类型实参是object。 不仅仅是操作符的时候，编译器会在编译未绑定泛型类型的时候就解析好所有方法重载，而不是等到执行时。\n在对值进行比较的时，有两个相当有用的类，分别是EqualityComparer\u0026lt;T\u0026gt;和Comparer\u0026lt;T\u0026gt;，他们分别实现了IEqulalityComparer\u0026lt;T\u0026gt;和IComparaer\u0026lt;T\u0026gt;这两个接口。这两个类分别有一个Default的属性能够返回一个实现，能为特定的特定的类型才去正确的比较操作。\nIComparaer\u0026lt;T\u0026gt;和IComparable\u0026lt;T\u0026gt;用于排序，判断某个值是小于、等于、还是大于另一个值。 IEqualityComparer\u0026lt;T\u0026gt;和IEquatable\u0026lt;T\u0026gt;则是通过某种标准来比较两个项的相等型，或者查找某个项的散列值。 IComparaer\u0026lt;T\u0026gt;和IEqualityComparer\u0026lt;T\u0026gt;的实例能够比较两个不同的值。 IComparable\u0026lt;T\u0026gt;和IEquatable\u0026lt;T\u0026gt;只能比较它们本身和其他的值。 实现类似元组的泛型对值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public sealed class Pair\u0026lt;T1, T2\u0026gt; : IEquatable\u0026lt;Pair\u0026lt;T1, T2\u0026gt;\u0026gt; //这里我们实现了IEquatable，提供了一个强类型的API(Equals方法)，可以避免不必要的运行时类型检查。 { // 生成一个默认的比较器，可以自动处理null值的情况 private static readonly IEqualityComparer\u0026lt;T1\u0026gt; FirstComparer = EqualityComparer\u0026lt;T1\u0026gt;.Default; private static readonly IEqualityComparer\u0026lt;T2\u0026gt; SecondComparer = EqualityComparer\u0026lt;T2\u0026gt;.Default; private readonly T1 first; private readonly T2 second; public Pair(T1 first, T2 second) { this.first = first; this.second = second; } public T1 First { get { return first; } } public T2 Second { get { return second; } } public bool Equals(Pair\u0026lt;T1, T2\u0026gt; other) { return other != null \u0026amp;\u0026amp; FirstComparer.Equals(this.First, other.first) \u0026amp;\u0026amp; SecondComparer.Equals(this.Second, other.Second); } public override bool Equals(object obj) { return Equals(obj as Pair\u0026lt;T1, T2\u0026gt;); } public override int GetHashCode() { return FirstComparer.GetHashCode(first) * 37 + SecondComparer.GetHashCode(second); } // public static Pair\u0026lt;T1,T2\u0026gt; Of\u0026lt;T1,T2\u0026gt;(T1 first,T2 second) public static Pair\u0026lt;T1,T2\u0026gt; Of(T1 first,T2 second) { return new Pair\u0026lt;T1, T2\u0026gt;(first, second); } } ","date":"2017-03-22T14:47:00Z","permalink":"https://real-zony.github.io/p/csharp-intermediate-generics---generic-comparison-and-type-inference/","title":"C# 中级泛型-泛型比较与类型推断"},{"content":"闲的蛋疼，每天一搏，测试了一下两个集合容器之间性能的差异： ArrayList是一个弱类型的集合列表，每次对其进行操作的时候，不论是存储还是读取，我们都需要经过一次强制类型转换(“装箱/拆箱”)操作才能够正常使用，一两次没有什么问题，但到达一个数量级之后，速度成指数级别变化。 还好在C#2之后引入了强类型集合List，免除了大量数据的集合进行操作的时候性能问题。 测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ArrayList _oldList = new ArrayList(); List\u0026lt;int\u0026gt; _newList = new List\u0026lt;int\u0026gt;(); Stopwatch _timerOld = new Stopwatch(); Stopwatch _timerNew = new Stopwatch(); _timerOld.Start(); for(int i = 0;i\u0026lt;9999999;i++) { _oldList.Add(i); } for(int j = 0;j\u0026lt;_oldList.Count;j++) { _oldList[j] = (int)_oldList[j] + 1; } _timerOld.Stop(); Console.WriteLine(\u0026#34;ArrayList所用时间:{0}\u0026#34;, _timerOld.ElapsedMilliseconds); _newList.Start(); for (int i = 0;i\u0026lt;9999999;i++) { _newList.Add(i); } for (int j = 0; j \u0026lt; _newList.Count; j++) { _newList[j] = (int)_newList[j] + 1; } _timerNew.Stop(); Console.WriteLine(\u0026#34;List\u0026lt;int\u0026gt;所用时间:{0}\u0026#34;, _timerNew.ElapsedMilliseconds); ","date":"2017-03-21T13:56:00Z","permalink":"https://real-zony.github.io/p/what-is-the-difference-in-performance-between-arraylist-and-list-of-t/","title":"比较 ArrayList 与 List Of T 之间性能究竟有多大的差别"},{"content":"C#泛型是使用的最为广泛的一个特性，在基础框架中四处可见它的身影，泛型将大量C#1当中的安全检查由运行时转换为了编译时执行，在C#1当中，容器ArrayList则是一个代表，他并不是类型安全的，每次从中读取数据，都需要进行一次强制类型转换或者装箱/拆箱操作，引发的性能问题与代码问题数不胜数。 在C#2当中，泛型的引入解决了这一问题，它将类型参数化，如同函数参数一样，类型参数从属于类型，而非从属于某个特定的构造函数。 在C#当中，例如已经提供了类型实参的泛型类型则是已构造类型，没有提供的则为未绑定泛型类型。\n在其中，泛型定义的时候为我们提供了多种泛型约束方法，有以下四种：\n引用类型约束。 值类型约束。 构造函数类型约束。 转换类型约束。 引用类型约束，如下： 1 struct RefSample\u0026lt;T\u0026gt; where T : class 有效的封闭类型：\n1 2 3 RefSample\u0026lt;IDisposable\u0026gt;; RefSample\u0026lt;string\u0026gt;; RefSample\u0026lt;int[]\u0026gt;; 无效的封闭类型：\n1 2 RefSample\u0026lt;int\u0026gt;; RefSample\u0026lt;Guid\u0026gt;; 当这样约束了一个类型参数的时候，可以对类型参数进行==,!=来比较引用。\n值类型约束 1 class ValSample\u0026lt;T\u0026gt; where T : struct 有效的封闭类型：\n1 2 ValSample\u0026lt;int\u0026gt;; ValSample\u0026lt;FileMode\u0026gt;; // 可为枚举 无效的封闭类型：\n1 ValSample\u0026lt;object\u0026gt;; 当类型参数约束为值类型的时候，无法通过!=,==来进行比较。\n构造函数约束 1 2 3 4 public T CreateInstance\u0026lt;T\u0026gt; where T : new() { return new T(); } 本约束必须是所有类型参数的最后一个约束，它将会检查类型实参是否有一个可用于创建类型实例的无参构造函数。 例如以下调用，是有效的：\n1 int a = CreateInstance\u0026lt;int\u0026gt;(); 但是string是没有无参构造函数的，所以以下调用无效：\n1 string str = CreateInstance\u0026lt;string\u0026gt;(); 转换类型约束 本泛型约束是最为复杂的一种泛型约束，类型实参必须通过一致性、引用或者装箱转换隐式地转换为该类型。 例如一下几个例子：\n一致性转换 1 2 3 4 5 class Sample\u0026lt;T\u0026gt; where T : Stream // 有效-一致性转换 Sample\u0026lt;Stream\u0026gt; // 无效 Sample\u0026lt;string\u0026gt; 引用转换 1 2 3 4 5 struct Sample\u0026lt;T\u0026gt; where T : IDisposable // 有效 Sample\u0026lt;SqlConnection\u0026gt; // 无效 Sample\u0026lt;StringBuilder\u0026gt; 装箱转换 1 2 3 4 5 class Sample\u0026lt;T\u0026gt; where T : IComparable\u0026lt;T\u0026gt; // 有效 Sample\u0026lt;int\u0026gt; // 由于int是实现了IComparable接口的 // 无效 Sample\u0026lt;FileInfo\u0026gt; 引用转换 1 2 3 4 5 class Sample\u0026lt;T,U\u0026gt; where T : U // 有效 Sample\u0026lt;Stream,IDisposable\u0026gt; // 无效 Sample\u0026lt;string,IDisposable\u0026gt; 转换类型约束可以指定多个接口，但是只能指定一个类，并且指定的类不可以是结构，封闭类，或者以下几种类型：\nSystem.Object System.Enum; System.ValueType; System.Delegate; 组合类型约束 注意，值类型由于已经有了一个无参构造函数，所以不允许指定一个构造函数约束，不过T即便被约束一个成一个值类型，他仍在可以在代码内使用new T(); 如果有由多个类型转换约束，那么类应该出现在接口的前面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //有效约束 class Sample\u0026lt;T\u0026gt; where T : class,IDisposable,new() class Sample\u0026lt;T\u0026gt; where T : struct,IDisposable class Sample\u0026lt;T,U\u0026gt; where T : class where : U struct,T class Sample\u0026lt;T,U\u0026gt; where T : Stream where U : IDsposable //无效约束 class Sample\u0026lt;T\u0026gt; where T : class,struct //不能又是值类型约束又是引用类型约束 class Sample\u0026lt;T\u0026gt; where T : Stream,class class Sample\u0026lt;T\u0026gt; where T : new(),Stream //构造函数约束只能在最末位 class Sample\u0026lt;T\u0026gt; where T : IDisposable,Stream //类应该在接口前 class Sample\u0026lt;T\u0026gt; where T : XmlReader,IComparable,IComparable // 重复约束 class Sample\u0026lt;T\u0026gt; where T : struct where U : class,T class Sample\u0026lt;T,U\u0026gt; where T : struct where U : class,T class Sample\u0026lt;T,U\u0026gt; where T : Stream , U : IDisposable 组合约束可以分为主要约束(引用类型约束，值类型约束或使用类的转换类型约束)，次要约束为使用接口或者其他类型参数的转换类型约束。\n主要类型约束是可选的，但是只能有一个，次要类型约束可以有多个。\n","date":"2017-03-20T13:42:00Z","permalink":"https://real-zony.github.io/p/csharp-generic-type-constraints/","title":"C# 泛型类型约束"},{"content":"你需要在 \u0026lt;system.werbServer\u0026gt; 层级下面添加以下文本：\n1 2 3 4 5 6 7 \u0026lt;httpProtocol\u0026gt; \u0026lt;customHeaders\u0026gt; \u0026lt;add name=\u0026#34;Access-Control-Allow-Origin\u0026#34; value=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;add name=\u0026#34;Access-Control-Allow-Headers\u0026#34; value=\u0026#34;Content-Type\u0026#34; /\u0026gt; \u0026lt;add name=\u0026#34;Access-Control-Allow-Methods\u0026#34; value=\u0026#34;GET, POST, PUT, DELETE, OPTIONS\u0026#34; /\u0026gt; \u0026lt;/customHeaders\u0026gt; \u0026lt;/httpProtocol\u0026gt; ","date":"2017-03-20T07:10:00Z","permalink":"https://real-zony.github.io/p/add-cross-domain-handling-to-your-site/","title":"对你的站点增加跨域处理"},{"content":"在之前的文章 C#类与结构的区别 当中对于结构的说明存在着误区，在拜读了“深入理解C#”这本书的时候，在2.3.3节的说明当中明确指出了三种误区：\n“结构是轻量级的类”。 “引用类型保存在堆上，值类型保存在栈上”。 “对象在C#中默认是通过引用传递的”。 这三种经常是我们在平时工作和学习中是这样理解和认为的，在该书当中，作者对于第一个观点就已经提出了一个很好的反例，即 DateTime类型\n一个对象的定义是应该使用值类型或者是引用类型，具体应该参考其语义，而不是取决于该类型简单与否。产生这个误区是因为大多数人们认为值类型不需要垃圾回收与类型标识产生开销，也不需要解引用。但是引用类型在其他的地方也更加出色，例如传递参数，赋值等操作的时候，仅需要复制4/8字节，而不需要复制全部数据。\n至于第二个误区更常见，变量的值是在他声明的位置存储的，所以假定在一个类当中有一个int型的实例变量，那么在这个类的任意对象，该变量的值总是和对象的其他数据在一起，也就是存储在堆上，只有局部变量和方法参数是存储在栈上。而且对于C#2以及更高的版本，他们的某些局部变量也不都是存储在栈上的。\n例如在函数式编程内的闭包：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public Action\u0026lt;int\u0026gt; TestMethod() { int _val = 20; Action\u0026lt;int\u0026gt; _result = x =\u0026gt; Console.WriteLine(x * _val); return _action; ｝ public void Test() { var _result = TestMethod(); _result(10); _result(20); } 在这里_val是一个局部变量，但是这里返回了一个action委托，只要该委托一直存在，那么会保持对_val的引用，这个时候C#会在底层创建一个匿名内，存放在堆当中，以提供给委托使用，除非委托销毁，那么对_val的引用会一直存在。 这里是一个很明显的闭包手法，闭包的作用就是在函数的作用域内保存数据，防止数据出现在无法控制其内容的地方，避免全局变量的使用。\n第三个则是所有人误会的最多的的，举个栗子：\n1 2 3 4 5 6 public void RefChangle(StringBuilder builder) { builder = null; } StringBuilder _sb = new StringBuilder(); RefChangle(_sb); 如果是按照常规说法，builder是按引用传递的话，那么我们在RefChangle方法内部对builder改变了它的值，所以_sb现在应该是null，然而事实并不是这样的。 在这里builder仅仅是“值传递”的_sb的一个引用地址，我们对这个引用地址的更改并不会影响到调用者的对象。 如果将RefChangle的方法方法签名改为如下则是“引用传递”：\n1 2 3 4 public void RefChangle(ref StringBuilder builder) { builder = null; } ","date":"2017-03-19T06:34:00Z","permalink":"https://real-zony.github.io/p/misunderstanding-of-csharp-values-and-reference-types/","title":"C# 值与引用类型的误区"},{"content":"眼看要到测试节点了，做好的东西前台使用post传参后台却接收不到参数，十分捉急。 控制器代码：\n1 2 3 4 5 [HttpPost] public ActionResult BussinessAllAnalyze(ExtStatisticService.FrontIncomingFilterModel state) { return Content(state.state.ToString()); } 然后我们来看一下参数实体的代码：\n1 2 3 4 5 6 public class FrontIncomingFilterModel { public int state { get; set; } public DateTime? StartTime { get; set; } public DateTime? EndTime { get; set; } } 是不是看上去没有任何问题，当你使用fiddler或者postman等进行调用的时候，会抛出null异常，因为在Action方法BussinessAllAnalyze当中state实体没有被接收到。 只要将形参名称改为其他的就能够正常接收\n1 2 3 4 5 [HttpPost] public ActionResult BussinessAllAnalyze(ExtStatisticService.FrontIncomingFilterModel model) { return Content(state.state.ToString()); } 这个问题暂时还不清楚是由于什么原因引起的。\n未完待续\u0026hellip;. ","date":"2017-01-15T12:14:00Z","permalink":"https://real-zony.github.io/p/a-bug-caused-by-action-passed-in-parameters/","title":"一个由于 Action 传入参数引发的 BUG"},{"content":" 1 2 # mysql -u root -proot mysql\u0026gt;GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;youpassword\u0026#39; WITH GRANT OPTION; 之后刷新权限即可。\n1 FLUSH PRIVILEGES 服务器记得打开3306端口。\n","date":"2016-12-25T13:54:00Z","permalink":"https://real-zony.github.io/p/mysql-allows-remote-user-login-access/","title":"MySql 允许远程用户登录访问"},{"content":"AOP的定义就是，面向切面编程。\n可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。AOP实际是GoF设计模式的延续，设计模式孜孜不倦追求的是调用者和被调用者之间的解耦,提高代码的灵活性和可扩展性，AOP可以说也是这种目标的一种实现。\n它的主要功能就是将业务逻辑代码当中的公用代码提取出来，在需要的地方进行注入即可，这样能够将这些行为从逻辑代码当中分离开来，建立良好的代码体系。\n举个栗子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public bool InsertCustomer(string firstName, string lastName, int age, Dictionary\u0026lt;string, string\u0026gt; attributes) { if (string.IsNullOrEmpty(firstName)) throw new ApplicationException(\u0026#34;first name cannot be empty\u0026#34;); if (string.IsNullOrEmpty(lastName)) throw new ApplicationException(\u0026#34;last name cannot be empty\u0026#34;); if (age \u0026lt; 0) throw new ApplicationException(\u0026#34;Age must be non-zero\u0026#34;); if (null == attributes) throw new ApplicationException(\u0026#34;Attributes must not be null\u0026#34;); // 日志记录 Logger.Writer.WriteLine(\u0026#34;Inserting customer data...\u0026#34;); DateTime start = DateTime.Now; try { // 实际功能代码 CustomerData data = new CustomerData(); bool result = data.Insert(firstName, lastName, age, attributes); if (result == true) { Logger.Writer.Write(\u0026#34;Successfully inserted customer data in \u0026#34; + (DateTime.Now-start).TotalSeconds + \u0026#34; seconds\u0026#34;); } return result; } catch (Exception x) { try { CustomerData data = new CustomerData(); if (result == true) { Logger.Writer.Write(\u0026#34;Successfully inserted customer data in \u0026#34; + (DateTime.Now-start).TotalSeconds + \u0026#34; seconds\u0026#34;); } return result; } catch { // 调用失败的时候，进行重试，并且记录到日志当中 Exception current = x; int indent = 0; while (current != null) { string message = new string(Enumerable.Repeat(\u0026#39;\\t\u0026#39;, indent).ToArray()) + current.Message; Debug.WriteLine(message); Logger.Writer.WriteLine(message); current = current.InnerException; indent++; } Debug.WriteLine(x.StackTrace); Logger.Writer.WriteLine(x.StackTrace); return false; } } } 其实真正工作的逻辑代码只有两行，调用了CustomerData实例的一个方法插入了一个Customer。如果有一个新的UpdateCustomer方法，你又不得不拷贝这些样板代码。 如果你使用了AOP框架的话，你就可以这样来书写你的InsertCustomer方法：\n1 2 3 4 5 6 7 8 9 10 [EnsureNonNullParameters] [Log] [TimeExecution] [RetryOnceOnFailure] public void InsertCustomerTheCoolway(string firstName, string lastName, int age, Dictionary\u0026lt;string, string\u0026gt; attributes) { CustomerData data = new CustomerData(); data.Insert(firstName, lastName, age, attributes); } 下面我们将使用一个简单的工具类来让我们的代码变得像下面一样的简洁，而不需要使用那些庞大的第三方框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void InsertCustomerTheEasyWay(string firstName, string lastName, int age, Dictionary\u0026lt;string, string\u0026gt; attributes) { AspectF.Define .Log(Logger.Writer, \u0026#34;Inserting customer the easy way\u0026#34;) .HowLong(Logger.Writer, \u0026#34;Starting customer insert\u0026#34;, \u0026#34;Inserted customer in {1} seconds\u0026#34;) .Retry() .Do(() =\u0026gt; { CustomerData data = new CustomerData(); data.Insert(firstName, lastName, age, attributes); }); } 原文 译文\n","date":"2016-12-20T08:21:00Z","permalink":"https://real-zony.github.io/p/aop-implementation-in-csharp-functional-programming/","title":"C# 当中的 AOP 实现，函数式编程"},{"content":"最近公司年终旅游，博客也是有很久没有更新了，这次继续我们上一次的高并发服务器编程。 上一篇文章讲解了要在Linux系统上实现C1000K服务器所需要进行的系统调优操作，那么我们现在就开始来编写我们的程序吧~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;ev.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;err.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; typedef struct { int fd; // 客户端套接字 ev_io ev_read; // 读取事件监听器 }client_t; static int server_port = 10204; struct ev_loop *loop; ev_io ev_accept; // 监听器 static int userNum; static void incr_online_user() { ++userNum; printf(\u0026#34;Current Online User Num:%d\\n\u0026#34;,userNum); } static void des_online_user() { --userNum; printf(\u0026#34;Current Online User Num:%d\\n\u0026#34;,userNum); } // 设置非阻塞套接字 static int set_nonblock_socket(int fd) { int flags = fcntl(fd,F_GETFL); if(flags \u0026lt; 0) return flags; flags|=O_NONBLOCK; if(fcntl(fd,F_SETFL,flags \u0026lt; 0) return -1; return 0; } // 释放资源 static void free_res(struct ev_loop *loop.ev_io *ws) { des_online_user(); client_t *client = (client_t*)ws-\u0026gt;data; if(client == nullptr) fprintf(stderr,\u0026#34;this client is null!\u0026#34;) return; ev_io_stop(loop,*client-\u0026gt;ev_read); close(client-\u0026gt;fd); free(client); } // 监听客户端连接回调 static void accept_cb(struct ev_loop *loop,ev_io *w,int revents) { struct sockaddr_in client_addr; socklen_t client_len = sizeof(client_addr); int client_fd = accept(w-\u0026gt;fd,(struct sockaddr*)\u0026amp;client_addr,\u0026amp;client_len); if(client_fd == -1) { fprintf(stderr,\u0026#34;the client fd is null!\\n\u0026#34;); return; } client_t *client = (client_t*)malloc(sizeof(client_t)); client-\u0026gt;fd = client_fd; if(set_nonblock_socket(client-\u0026gt;fd) \u0026lt; 0) err(1, \u0026#34;failed to set client socket to non-blocking\u0026#34;); client-\u0026gt;ev_read.data = client; ev_io_init(\u0026amp;client-\u0026gt;ev_read,read_cb,client-\u0026gt;fd,EV_READ); ev_io_start(loop,\u0026amp;client-\u0026gt;ev_read); incr_online_user(); } // 读入数据回调 static void read_cb(struct ev_loop *loop,ev_io *w,int revents) { } int main(int argc,char *argv[]) { int ch; while((ch = getopt(argc,argv,\u0026#34;p:\u0026#34;)) != -1) { switch(ch) { case \u0026#39;p\u0026#39;: server_port = atoi(optarg); } } } 占位符。\n","date":"2016-12-05T16:51:00Z","permalink":"https://real-zony.github.io/p/c1000k-in-action-based-on-libev---continued/","title":"C1000K 实战，基于 Libev - 续"},{"content":"直接贴代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Program { static List\u0026lt;TcpClient\u0026gt; list = new List\u0026lt;TcpClient\u0026gt;(); static string msg = \u0026#34;我是测试数据。\u0026#34;; static DynamicBufferManager buffer = new DynamicBufferManager(0); static void Main(string[] args) { buffer.WriteInt32(Encoding.UTF8.GetByteCount(msg), true); buffer.WriteString(msg); Console.WriteLine(\u0026#34;输入创建的链接数目：\u0026#34;); int num = int.Parse(Console.ReadLine()); Console.WriteLine(\u0026#34;正在创建连接...\u0026#34;); for (int i = 0; i \u0026lt; num; i++) { list.Add(new TcpClient(\u0026#34;192.168.0.131\u0026#34;, 22222) { SendBufferSize = 1024 * 10 * 10 }); } Console.WriteLine(\u0026#34;创建连接成功，开始循环发送数据！\u0026#34;); int j = 1; for(int i = 0;i\u0026lt;20;i++) { Thread.Sleep(1000); Parallel.ForEach(list, item =\u0026gt; { item.Client.Send(buffer.Buffer); }); Console.WriteLine(\u0026#34;第{0}次发送完成!\u0026#34;, j); j++; } Console.WriteLine(\u0026#34;全部发送完成！\u0026#34;); Console.ReadKey(); } } 以上操作最后创建的链接数目并不是你实际指定的数目，因为在没有保障线程安全和串行化的运行下，实际得到的数目肯定会有差异。我们可以尝试给list.Add添加一个lock互斥锁，但是锁的引入，带来了一定的开销和性能的损耗，并降低了程序的扩展性，在并发编程中显然不适用。\n在.Net 4以后，微软提供了新的线程安全和扩展的并发集合，它们能够解决潜在的死锁问题和竞争条件问题，因此在很多复杂的情形下它们能够使得并行代码更容易编写，这些集合尽可能减少需要使用锁的次数，从而使得在大部分情形下能够优化为最佳性能，不会产生不必要的同步开销。\n他们在命名空间System.Collections.Concurrent当中，分别有以下几类：\nBlockingCollection 与经典的阻塞队列数据结构类似，能够适用于多个任务添加和删除数据，提供阻塞和限界能力。 ConcurrentBag 提供对象的线程安全的无序集合 ConcurrentDictionary 提供可有多个线程同时访问的键值对的线程安全集合 ConcurrentQueue 提供线程安全的先进先出集合 ConcurrentStack 提供线程安全的后进先出集合 这些集合通过使用比较并交换和内存屏障等技术，避免使用典型的互斥重量级的锁，从而保证线程安全和性能。\n在这里我们仅仅需要将static List\u0026lt;TcpClient\u0026gt; list = new List\u0026lt;TcpClient\u0026gt;();变成static ConcurrentBag\u0026lt;TcpClient\u0026gt; list = new ConcurrentBag\u0026lt;TcpClient\u0026gt;();即可。\n","date":"2016-11-22T02:48:00Z","permalink":"https://real-zony.github.io/p/problems-encountered-with-task-parallel-operations/","title":"对于 Task 并行操作所遇到的问题"},{"content":"最近公司接到一个新项目，是基于Socket通信的GPS实时记录系统。实际设备台数是在20W左右，但是自己并没有对实时性要求这么高的高并发服务器软件设计经验，只能硬着头皮先进行测试开发试一下。 技术选型的话，当时是直接想使用Windows下面的IOCP，因为自己对C#这块比较熟悉，不过经过测试，在WindowsServer上面的测试结果并不理想，可能是自己水平不到家吧(笑)。关于高性能的IOCP编程大家可以参考这位仁兄的文章，写得很不错，而且也有实例：(C#高性能大容量SOCKET并发（一）：IOCP完成端口例子介绍) 之后查阅了相关的技术资料和各类博客，发现Linux更适合做此类系统，所以选择了CentOS 7.x 64bit作为开发系统，高并发主要在于对Socket的监听一定要及时，所以Epoll是最好的选择。但是博主并不想直接再写一次Epoll了，相关Epoll进行高并发编程的可以参考**这篇文章**很不错的实例。所以我直接选择了Libev库作为底层的事件库，进行事件监听。\n首先我们要实现C1000K的话，得对Linux的内核参数进行调优，怎么调？ 第一步，调整系统单个进程最大打开的文件句柄数量：\n1 vim /etc/security/limits.conf 在最末尾加入：\n1 2 * soft nofile 1048576 * hard nofile 1048576 因为Linux下面一皆文件，即便是我们的Socket网络套接字也是属于文件句柄这个范畴的，默认大小可以通过ulimit -n查看，默认是1024个，对于我们百万并发的服务器来说显然是不够的。 这里的星号(*)代表的是对所有用户生效，当然你也可以手动指定用户，soft是警告阀值，而hard则是实际生效的阀值，在这里我们为了方便直接都改成一样的就可以了。\n第二步，设置系统所有进程最多同时打开的句柄数量限制：\n1 echo \u0026#34;fs.file-max = 1048576\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf 之后执行以下命令使其生效：\n1 sysctl -p 第三步，TCP参数调优：\n1 2 3 echo \u0026#34;net.ipv4.tcp_mem = 786432 2097152 3145728\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf echo \u0026#34;net.ipv4.tcp_rmem = 4096 4096 16777216\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf echo \u0026#34;net.ipv4.tcp_wmem = 4096 4096 16777216\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf tcp_rmem是TCP读取缓冲区，tcp_wmem是发送缓冲区，他们的单位都是字节，第一个是最小值，第二个是默认值，第三个是最大值，这里分别设置为4K,4K,16MB。 tcp_mem是TCP内存大小，单位是页，一页为4096字节。\nlow：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。 pressure：当TCP使用了超过该值的内存页面数量时，TCP试图稳定其内存使用，进入pressure模式，当内存消耗低于low值时则退出pressure状态。 high：允许所有tcp sockets用于排队缓冲数据报的页面量，当内存占用超过此值，系统拒绝分配socket，后台日志输出“TCP: too many of orphaned sockets”。 一般情况下这些值是在系统启动时根据系统内存数量计算得到的。 根据当前tcp_mem最大内存页面数是1864896，当内存为(1864896*4)/1024K=7284.75M时，系统将无法为新的socket连接分配内存，即TCP连接将被拒绝。 实际测试环境中，据观察大概在99万个连接左右的时候(零头不算)，进程被杀死，触发out of socket memory错误（dmesg命令查看获得）。每一个连接大致占用7.5K内存（下面给出计算方式），大致可算的此时内存占用情况（990000 * 7.5 / 1024K = 7251M)。\n未完待续\n","date":"2016-11-21T13:49:00Z","permalink":"https://real-zony.github.io/p/c1000k-in-action-based-on-libev/","title":"C1000K 实战，基于 Libev"},{"content":"经常我们在模拟HTTP请求的时候，需要对提交的参数进行URL编码。 在这里我们通过实现一个简单的扩展方法来完成这个功能~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static class StringExplend { public static string ToURLEncoding(this string value) { if(!string.IsNullOrEmpty(value) { byte[] _strBytes = Encoding.UTF8.GetBytes(value); StringBuilder _sb = new StringBuilder(); foreach(var item in _strBytes) { _sb.Append(@\u0026#34;%\u0026#34;,Convert.ToString(item,16)); // 当然在这里也可以使用 // _sb.Append(@\u0026#34;%\u0026#34; + item.ToString(\u0026#34;x2\u0026#34;)); } return _sb.ToString(); }else return string.Empty; } } 注意，这个方法有一个弊端，就是会将英文字符也进行转换，所以你需要手动过滤掉英文/数字。这里建议你选择使用在 System.Web 命名空间下的 HttpUtility 对象，使用方法很简单，如下：\n1 2 3 4 public string URL_Encoding(string srcText, Encoding encoding) { return HttpUtility.UrlEncode(srcText, encoding); } ","date":"2016-11-18T01:15:00Z","permalink":"https://real-zony.github.io/p/how-does-csharp-implement-url-encoding/","title":"C# 如何实现URL编码？"},{"content":"在常用的缓存设计模式当中，LRU是比较简单且常见的一种缓存设计方案，简单说来就是在缓存队列当中，使用频率越低的对象，越会被踢出队列。原理的话很简单，我们有一个字典容器，还有一个双向链表。 字典容器则是我们缓存对象真正存储的地方，双向链表的作用则是用来记录当前缓存队列的使用频率情况，当用户命中一个缓存对象的时候，双向链表就回将这个对象的键ID放在最前面，这样就能够保证使用率最低的对象是存放在最末位。如果当我们添加了一个新的缓存对象的时候，但是字典容器满了，这个时候我们只需要找到双向链表当中最末位的那个缓存对象将其踢出队列，之后再将新的缓存对象存放到字典容器当中。\n说了这么多，还是上代码吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 public class LRUCache\u0026lt;TKey,TValue\u0026gt; { private Dictionary\u0026lt;TKey,TValue\u0026gt; m_cache; private LinkedList\u0026lt;TKey\u0026gt; m_list; private ReaderWriterLockSlim m_locker; private int m_cacheSize; private const int Default_Size = 255; public LRUCache() : this(Default_Size){} public LRUCache(int cacheSize) { m_cache = new Dictionary\u0026lt;TKey,TValue\u0026gt;(); m_list = new LinkedList\u0026lt;TKey\u0026gt;(); m_locker = new ReaderWriterLockSlim(); m_cacheSize = cacheSize \u0026gt; 0 ? cacheSize : Default_Size; } public void Set(TKey key,TValue value) { m_locker.EnterWriteLock(); try { m_cache[Key] = value; m_list.Remove(key); m_list.AddFirst(key); if(m_list.Count \u0026gt; m_cacheSize) { m_cache.Remove(m_list.Last.Value); m_list.RemoveLast(); } }finally { m_locker.ExitWriteLock(); } } public bool TryGetValue(TKey key,out TValue value) { m_locker.EnterUpgradeableReadLock(); try { bool _b = m_cache.TryGetValue(key,out value); if(_b) { m_locker.EnterWriteLock(); try { m_list.Remove(key); m_list.AddFirst(key); }finally{ m_locker.ExitWriteLock();} } return _b; }finally { m_locker.ExitUpgradeableReadLock(); } } public bool ContainKey(TKey key) { m_locker.EnterReadLock(); try { retrun m_cache.ContainKey(key); }finally { m_locker.ExitReadLock(); } } public int Count { get { m_lokcer.EnterReadLock(); try { return m_cache.Count; }finllay { m_locker.ExitReadLock(); } } } public int CacheSize { get { m_locker.EnterReadLock(); try { return m_cacheSize; }finally { m_locker.EnterReadLock(); } } set { m_locker.EnterUpgradeableReadLock(); try { if(value \u0026gt; 0 \u0026amp;\u0026amp; m_cacheSize != value) { m_locker.EnterReadLock(); try { m_cacheSize = value; while(m_list.Count \u0026gt; m_cacheSize) { m_list.RemoveLast(); } }finally { m_locker.ExitReadLock(); } } }finally{m_locker.ExitUpgradeableReadLock();} } } public ICollection\u0026lt;TKey\u0026gt; Keys { get { m_locker.EnterReadLock(); try { return m_cache.Keys; }finally{m_locker.ExitReadLock();} } } public ICollection\u0026lt;TValue\u0026gt; Values { get { m_locker.EnterReadLock(); try { return m_cache.Values; }finally{m_locker.ExitReadLock();} } } } 关于缓存基础和更多的认识，可以参考以下文章： http://blog.jobbole.com/30940/\n","date":"2016-11-18T01:15:00Z","permalink":"https://real-zony.github.io/p/implementing-lru-cache-in-csharp/","title":"在 C# 当中实现 LRU Cache"},{"content":"在网络编程的开发环境当中经常会使用缓冲区来进行数据的接收与发送，但是当我们需要发一段连续的数据的时候，使用\n1 byte[] _buffer= new byte[lenght]; 显然很死板，我们需要一个更加“智能”的缓冲区来管理这些数据。 ok,我们可以编写一个动态缓冲区管理器，它在内部维护一个byte[]类型的缓冲区，还有一个数据指针，以及已使用的字节空间的计数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class DynamicBufferManager { public int DataCount {get;private set;} public int DataPointer {get;private set;} public byte[] Buffer {get;private set;} public DynamicBufferManager(int size) { DataCount = 0; DataPointer = 0; BUffer = new byte[size]; } } 我们的动态缓冲管理器主要就是由一个内部缓冲区还有一个数据指针和已用数据计数器来构成的。我们的主要思路是，我们的动态缓冲区可以随时设置新的大小，可以清除指定大小/全部的数据。当然我们也可以向缓冲区内写入/读取我们所需要的数据。\n下面我们来实现大小与清除数据:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class DynamicBufferManager { public void SetBufferSize(int newSize) { if(newSize \u0026gt; Buffer.Lenght) // 如果新缓冲区大小大于内部缓冲区大小则扩容 { byte[] _tmpBuffer = new byte[newSize]; Array.Copy(Buffer,_tmpBuffer,DataCount); Buffer = _tmpBuffer; } } public void Clean() { DataCount = 0; } public void Clean(int count) { if(count \u0026gt; DataCount) { DataCount = 0; }else // 所有数据前移count位置 { for(int i = 0;i \u0026lt; DataCount - count;i++) { Buffer[i] = Buffer[i + count]; } DataCount-=count; } } } 好了，现在让我们来开始向内部缓冲区写入数据吧~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class DynamicBufferManager { // 获得可用字节数 public int ReserveCount { get { return Buffer.Lenght - DataCount; } } public void WriteBytes(byte[] buffer,int offset,int lenght) { if(ReserveCount \u0026gt; lenght) // 如果内部缓冲区能够存放的话 { Array.Copy(buffer,offset,Buffer,DataCount,lenght); DataCount+=lenght; }else // 扩展缓冲区 { int _newSize = Buffer.Lenght + lenght - ReserveCount; byte[] _tmpBytes = new byte[_newSize]; Array.Copy(Buffer,_tmpBytes,DataCount); Array.Copy(buffer,offset,_tmpBytes,DataCount,lenght); Buffer = _tmpBytes; DataCount+=lenght; } } public void WriteBytes(byte[] buffer) { WriteBytes(buffer,0,buffer.Lenght); } } 下面我们来演示从读取/写入整形的一个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class DynamicBufferManager { public void WriteInt32(bool IsNetBytes,int value) { if(IsNetBytes) value = Systsem.Net.IPAdress.HostToNetworkOrder(value); WriteBytes(BitConverter.GetBytes(value)); } public int ReadToInt32(bool IsNetBytes) { int _value = BitConvert.ToInt32(Buffer,DataPointer); DataPointer+=4; if(IsNetBytes) _value = System.Net.IPAdress.NetworkToHostOrder(_value); return _value; } } ","date":"2016-11-17T01:41:00Z","permalink":"https://real-zony.github.io/p/implementation-of-csharp-dynamic-buffer/","title":"C# 动态缓冲区的实现"},{"content":"每个游戏当中都会有很多的对象存在，例如玩家、敌人、非玩家角色(NPC)、陷阱、子弹等。将这些游戏对象关联起来是一项很复杂的工作，如果没有一个可靠的基础框架的话，我们的游戏会越来越笨拙，代码结构也会越来越混乱。所以我们可以完全利用面向对象编程(OOP)的力量来帮助我们实现可靠的基础框架。 我们将会在这一章介绍以下内容：\n使用继承 实现多态 使用抽象基类 有效继承设计 使用继承 继承是OOP第一种强大的特性，这个特性可以帮助我们开发可复用的基础框架。通过使用继承，我们可以从现有类型当中创建新的子类。我们在这里不会花太多篇幅去讨论继承的细节，而是着重于如何将这个特性应用到我们的框架当中。\n正如前面所提到的，每个游戏有各种类型的对象。在大多数情况下，这些对象拥有很多相似的数据与类似的功能。下面我们举个栗子来说明一下：\n几乎所有的对象都需要被绘制到屏幕上面，所以我们需要一个draw函数来进行绘制对象。 我们的对象绘制肯定需要使用x,y来定位，所以他们肯定都会有一个x,y变量。 除非是静态图片，否则我们希望我们的对象能够对自己进行更新，所以肯定会有一个update函数进行对象更新。 对象不再被使用的时候，我们也希望他能够清理掉不使用的资源，所以我们可能会需要一个clean函数来进行资源清理。 OK，这是一个很好的开始，让我们继续创建和完善我们的“GameObject”类。\n1 2 3 4 5 6 7 8 9 10 class GameObject { public: void draw(){std::cout\u0026lt;\u0026lt;\u0026#34;draw game object\u0026#34;;} void update(){std::cout\u0026lt;\u0026lt;\u0026#34;update game object\u0026#34;;} void clean(){std::cout\u0026lt;\u0026lt;\u0026#34;clean game object\u0026#34;;} protected: int m_x; int m_y; }; 现在我们有了第一个游戏对象类了，下面我们创建一个玩家类继承自该类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Player : public GameObject { public: void draw() { GameObject::draw(); std::cout\u0026lt;\u0026lt;\u0026#34;draw player\u0026#34;; } void update() { GameObject::update(); std::cout\u0026lt;\u0026lt;\u0026#34;update player\u0026#34;; } void clean() { GameObject::clean(); std::cout\u0026lt;\u0026lt;\u0026#34;clean player\u0026#34;; } } 现在我们可以复用基类函数与对象的成员了，当然我们也可以在调用父类实现的功能的同时，扩展自身的功能。\n1 2 3 4 5 6 7 void update() { GameObject::update(); std::cout\u0026lt;\u0026lt;\u0026#34;update player\u0026#34;; m_x = 10; m_y = 20; } ","date":"2016-11-08T07:46:00Z","permalink":"https://real-zony.github.io/p/sdl-tutorial-series-chapter-3-game-object-design/","title":"SDL系列教程：第三章 游戏对象设计"},{"content":" 首先以管理员方式运行\u0026quot;cmd\u0026quot;命令控制台。 之后键入以下代码： 1 cd c:\\windows\\system32\\inetsrv 下面就开始我们的备份了 1 appcmd add backup \u0026#34;xxxxx\u0026#34; 或者是不指定备份名称将会自动以当前时间创建一个新的备份：\n1 appcmd add backup 例如：\n1 appcmd add backup \u0026#34;20150408\u0026#34; 创建的备份文件将保存在C:\\Windows\\System32\\inetsrv\\backup下\n还原IIS备份 1 appcmd restore backup \u0026#34;20150408\u0026#34; 后面跟的是你的backup的备份文件夹名称。 ","date":"2016-10-28T07:40:00Z","permalink":"https://real-zony.github.io/p/batch-export-and-backup-of-iis-sites/","title":"IIS 的站点批量导出与备份"},{"content":" 首先我们先下载最新版本的Visual Studio 2015，网上一搜一大把。 然后我们去这里下载.NET Core 1.0.1 - VS 2015 Tooling Preview 2，安装即可。 注意: 在这里可能会碰到安装失败的情况，请参照以下方法： http://bbs.csdn.net/topics/391991963 https://q.cnblogs.com/q/86210/\n本文参照:http://www.cnblogs.com/gaobing/p/5663012.html重新完善。 安装完成后打开VS新建项目会发现多了.Net Core的选项： 找到工程根目录下 \u0026ldquo;project.json\u0026rdquo; 4.1 禁用 \u0026ldquo;type\u0026rdquo; 4.2 注释 \u0026ldquo;scripts\u0026quot;节点 4.3 添加 \u0026ldquo;runtimes\u0026quot;节点，centos7.1服务器 在工程文件夹目录，按住shift右键，弹出cmd窗口。 输入以下命令： 1 dotnet restore 发布 1 dotnet publish -r centos.7-x64 发布后的目录如下： 1 \\bin\\Debug\\netcoreapp1.0\\centos.7-x64\\publish 在你的Linux服务器上部署.Net Core环境，请参照https://www.microsoft.com/net/core#centos进行操作。 9.1 安装jexus5.8.2 1 2 3 4 5 6 cd /tmp wget linuxdot.net/down/jexus-5.8.2-x64.tar.gz tar zxvf jexus-5.8.2-x64.tar.gz cd jexus/ cd siteconf/ vi default 9.2 添加AppHost 1 2 3 4 5 6 7 (jexus作者介绍AppHost) AppHost的配置格式是： AppHost={CmdLine=应用程序命令行; workRoot=应用程序工作目录; Port=应用程序HTTP侦听端口}，其中： \u0026#34;CmdLine\u0026#34; 表示启动应用程序的命令行，如：dotnet /var/www/site1/app.dll； \u0026#34;workRoot\u0026#34;表示应用程序工作目录，如：/var/www/site1； \u0026#34;Port\u0026#34;表示这个HTTP应用程序所使用的侦听端口，如：5000（Asp.Core默认端口是5000）。 9.3 将发布的程序拷贝到服务器(\\bin\\Debug\\netcoreapp1.0\\centos.7-x64\\publish) 9.4 将你的主程序权限设置为可执行: 1 2 3 cd /var/www/default sudo chmod a+x CoreApp ls 9.5 启动jexus\n1 2 cd ../ ./jws start 9.6 完成 ","date":"2016-10-20T02:26:00Z","permalink":"https://real-zony.github.io/p/visual-studio-for-developing-net-core-sites/","title":"Visual Studio 开发 .NET Core 站点"},{"content":"首先，单元格背景颜色的Style里面的属性不是\u0026quot;FillBackgroundColor\u0026quot;，正确的应该是FillForegroundColor。 其次我们不仅仅需要设置颜色，而且还要设置该style的FillPattern。 下面是代码：\n1 2 3 4 ICellStyle style = workbook.CreateCellStyle(); style.FillForegroundColor = NPOI.HSSF.Util.HSSFColor.Red.Index; style.FillPattern = FillPattern.SolidForeground; ICell cell = workbook.CreateSheet().CreateRow(0).CreateCell(0);cell.CellStyle = style; ","date":"2016-09-29T07:54:00Z","permalink":"https://real-zony.github.io/p/npoi-custom-cell-background-color/","title":"NPOI 自定义单元格背景颜色"},{"content":"1.为什么要使用定时任务池？ 任务池可以让我们将某些需要程序循环定时执行的一系列方法自动地执行，你只需要将想要定时执行的任务扔进任务池即可，而任务池则会自动并行地调用你想要执行的方法。\n2.实现 首先我们任务池的生命周期是跟程序绑定的话，我们在开始设计的时候最好将其设计为一个静态类。\n1 2 3 4 5 6 7 public static TaskPool { private static int m_loopTime; private static List\u0026lt;CallBackFunc\u0026gt; m_taskPool; private Thread m_daemonThread; private bool m_running; } 在上面我们声明了一些必须的变量，例如循环调用间隔，任务池列表，以及守护线程和运行状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public static class TimerPool { /// \u0026lt;summary\u0026gt; /// 回调委托 /// \u0026lt;/summary\u0026gt; public delegate void CallBackFunc(); private static int m_loopTime; private static List\u0026lt;CallBackFunc\u0026gt; m_taskPool; private static Thread m_daemonThread; private static bool m_running; private static void CallFunction() { while(m_running) { Thread.Sleep(m_loopTime); Parallel.ForEach(m_taskPool, (item)=\u0026gt; { item(); }); } } /// \u0026lt;summary\u0026gt; /// 添加一个新的定时任务 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;func\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public static void AddFunc(CallBackFunc func) { m_taskPool.Add(func); } /// \u0026lt;summary\u0026gt; /// 清除所有定时任务 /// \u0026lt;/summary\u0026gt; public static void ClearAll() { m_taskPool.Clear(); } /// \u0026lt;summary\u0026gt; /// 设置新的定时时间 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;looptime\u0026#34;\u0026gt;定时时间\u0026lt;/param\u0026gt; public static void SetLoopTime(int looptime) { m_loopTime = looptime; } /// \u0026lt;summary\u0026gt; /// 停止任务池的运行 /// \u0026lt;/summary\u0026gt; public static void Stop() { m_running = false; } /// \u0026lt;summary\u0026gt; /// 开启任务轮询 /// \u0026lt;/summary\u0026gt; public static void Start() { m_running = true; } /// \u0026lt;summary\u0026gt; /// 初始化操作，5分钟的CD时间。 /// \u0026lt;/summary\u0026gt; static TimerPool() { m_dbSession = new DBSession(); m_taskPool = new List\u0026lt;CallBackFunc\u0026gt;(); m_running = true; m_loopTime = 60000 * 5; if(m_daemonThread == null) { m_daemonThread = new Thread(CallFunction); m_daemonThread.Start(); } } } ","date":"2016-09-21T06:38:00Z","permalink":"https://real-zony.github.io/p/scheduled-event-task-pool/","title":"定时事件任务池"},{"content":"换了一家公司，当天便接到一个统计模块的开发，要求是从数据库当中提取到指定时间段的数据，并按照前端给的分割单位时间进行数据返回，统计什么呢？就是统计这些记录在某一天有几条，某一周有几条，以此类推。\n例如： 0 2016/8/12 12:00 xxxxxxx 1 2016/8/12 14:51 xxxxxxx 2 2016/8/13 01:52 xxxxxxx 3 2016/8/18 20:14 xxxxxxx 4 2016/8/18 20:16 xxxxxxx 5 2016/8/13 12:08 xxxxxxx\n提取数据简单，因为用的EF框架，所以直接从DBSession当中用linq抓取数据即可，我们将这些日期数据存储在List容器内。\n不过后面才是正题，数据是抓取到了，不过我们又该怎样从这一堆数据当中，按照天、周、月、季度、年来分割数据呢？\n首先我们先要获取到这个时间段的相差天数： 开始时间为StartTime,结束时间为EndTime,由于这两个都是属于DateTime类型的变量，所以我们直接用EndTime减去StartTime就可以获得一个TimeSpan对象，直接获取该对象的Day属性，就能获得他们相差的天数了。 下面就是重点了，我们这里的目标 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private List\u0026lt;resultModel\u0026gt; getAllDays(int diffDay, string StartTime, List\u0026lt;DateTime\u0026gt; dateList) { var _num_Date_List = new List\u0026lt;resultModel\u0026gt;(diffDay); var d1 = Convert.ToDateTime(StartTime); for (int i = 0; i \u0026lt; diffDay; i++) { int count = 0; for (int j = 0; j \u0026lt; dateList.Count; j++) { if (d1.Date == dateList[j].Date) count++; } // 仅保留年月日，不储存详细时间信息 string _time = string.Format(\u0026#34;{0}年{1}月{2}日\u0026#34;, d1.Year, d1.Month, d1.Day); _num_Date_List.Add(new resultModel { Time = _time, Count = count }); d1 = d1.AddDays(1); } return _num_Date_List; } 好了，我们来解析一下上面代码的意思，首先我们用一个List来存储即将要返回的结果列表，这里的resultModel其实很简单，里面只有两个属性，一个Time用于保存具体事件，一个Count用于保存该时间有几条记录。\n下面我们使用了一个DateTime d1来进行日期计数，默认是从这个时间段的开始时间开始进行统计。\n主要代码是一个双重循环，外循环遍历这个时间段，内循环则从dateList当中取出记录，将其日期与d1进行比较，如果日期相同则count计数自增1，结束内循环之后将符合d1这个日期的数据进行统计，放入_num_Date_List返回结果当中。 并且d1随着外循环的不断进行，自己也会从第一天遍历到指定时间段的最后一天。\n周统计： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 private List\u0026lt;resultModel\u0026gt; getWeeks(int diffDay,string StartTime,List\u0026lt;DateTime\u0026gt; dateList) { var _days = getAllDays(diffDay, StartTime, dateList); var _result = new List\u0026lt;resultModel\u0026gt;(); int _week_count = 1,_count = 1,sum = 0,_global = 0; for(int i=0;i\u0026lt;(diffDay/7)*7;i++,_count++) { _global++; if (_count == 7) { sum += _days[i].Count; _result.Add(new resultModel { Time = string.Format(\u0026#34;第{0}周\u0026#34;, _week_count), Count = sum }); _week_count++; // 重置 sum = 0; _count = 1; continue; } sum += _days[i].Count; } int _week_out = diffDay % 7; if (_result.Count == 0) _global = 0; int _week_out_sum = 0; for(int i=0;i\u0026lt;_week_out;i++) { _week_out_sum+=_days[_global].Count; _global++; } if(_week_out_sum \u0026gt;0) { _result.Add(new resultModel { Time = string.Format(\u0026#34;第{0}周\u0026#34;, _week_count), Count = _week_out_sum }); } return _result; } 在这里按周统计要复杂得多，原理很简单，因为一周有7天，如果你选择的这个时间段小于七天则只按一周来进行计算，如果你选的时间是18天，你只需要对其进行除以操作，就能得到有几周，剩下的天数则可以用这个间隔时间对7取模来得到。\n月统计： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private List\u0026lt;resultModel\u0026gt; getMonths(int diffDay,string StartTime,List\u0026lt;DateTime\u0026gt; dateList) { var _days = getAllDays(diffDay, StartTime, dateList); var _result = new List\u0026lt;resultModel\u0026gt;(); var _tmp = new Dictionary\u0026lt;string, int\u0026gt;(); // 月份分割结果 for(int i = 0;i\u0026lt;diffDay;i++) { var _time = Convert.ToDateTime(_days[i].Time); var _strTime = string.Format(\u0026#34;{0}年{1}月\u0026#34;, _time.Year, _time.Month); // 检测该月份的数据是否存在 if(_tmp.ContainsKey(_strTime)) { _tmp[_strTime]+=_days[i].Count; } else { _tmp.Add(_strTime, _days[i].Count); } } foreach(var item in _tmp) { _result.Add(new resultModel { Time = item.Key, Count = item.Value }); } return _result; } 相对而言后面这些统计就十分简单了，在这里我们直接使用的一个字典来存储。结合之前的方法，我们可以很轻松地获得这个时间段所有天数的记录条数有多少。\n那么我们直接使用年+月作为键，每当从字典中如果有这个键存在的话，就将其相对应的值进行增加即可。\n","date":"2016-09-03T10:49:00Z","permalink":"https://real-zony.github.io/p/returns-the-corresponding-statistics-according-to-day-week-month-quarter-year-in-a-list-of-dates/","title":"在一个日期列表当中根据天、周、月、季度、年返回相应的统计数据"},{"content":"锁原理 互斥锁：线程会从sleep（加锁）——\u0026gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销。 自旋锁：线程一直是running(加锁——\u0026gt;解锁)，死循环检测锁的标志位，机制不复杂。\n锁区别 互斥锁的起始原始开销要高于自旋锁，但是基本是一劳永逸，临界区持锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着持锁时间，加锁的开销是线性增长。\n锁应用 互斥锁用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑\n临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 单核处理器 至于自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下。\n","date":"2016-08-17T10:06:00Z","permalink":"https://real-zony.github.io/p/mutex-and-spin-lock/","title":"互斥锁与自旋锁"},{"content":"英文则是：No owin.Environment item was found in the context 这个错误源自于:\n1 2 3 4 5 private IAuthenticationManager AuthenticationManager { get { return HttpContext.GetOwinContext().Authentication; } } 使用的是ASP.NET Identity身份认证系统，在使用AuthenticationManager的时候，发生了一个异常。提示“在上下文中找不到 owin.Environment 项”，百度谷歌半天无果。 之后感觉是自己缺少Startup类的原因，在项目根目录加入了一个cs文件，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 using Microsoft.Owin; using Owin; [assembly: OwinStartupAttribute(typeof(NovelSite.Startup))] namespace NovelSite { public partial class Startup { public void Configuration(IAppBuilder app) { ConfigureAuth(app); } } } 运行，仍然抛出异常，按照ASP.NET Identity登录原理一文中所说：\n每一个OWin的应用程序都需要有一个start up的类，用来声明我们要使用的OWin组件（即中间件)。Start up 类有以下几种声明方式。\n命名约定: Owin会扫描在程序集的根下名叫 startup的类作为默认启动配置类 OwinStartup 标签 1 [assembly: OwinStartup(typeof(StartupDemo.TestStartup))] 我在web.config已经加了和，Startup.cs也加了OwinStarup标签，仍然出错。 之后仔细看了一下AutomaticAppStartup的意思，这个是OWIN的自动发现，结果是false关闭，删掉这条之后，成功运行。\n","date":"2016-08-11T14:51:00Z","permalink":"https://real-zony.github.io/p/aspnet-mvc-cannot-find-the-owinenvironment-item-in-the-context/","title":"ASP.NET MVC 在上下文中找不到 owin.Environment 项。"},{"content":" 下载Mysql for VisualStudiohttp://dev.mysql.com/downloads/windows/visualstudio/ 下载连接器http://dev.mysql.com/downloads/connector/net/ 使用Nuget安装EF。 使用Nuget安装Mysql.Data 修改web.config的connectionStrings连接字符串如下： 1 2 3 \u0026lt;connectionStrings\u0026gt; \u0026lt;add name=\u0026#34;DefaultConnection\u0026#34; connectionString=\u0026#34;Data Source=服务器IP;port=3306;Initial Catalog=数据库名称;user id=用户名;password=密码;\u0026#34; providerName=\u0026#34;MySql.Data.MySqlClient\u0026#34; /\u0026gt; \u0026lt;/connectionStrings\u0026gt; 重要一定要在entityFramework节上增加codeConfigurationType=\u0026ldquo;MySql.Data.Entity.MySqlEFConfiguration, MySql.Data.Entity.EF6\u0026quot;属性。 1 2 3 4 5 6 7 8 9 10 \u0026lt;entityFramework codeConfigurationType=\u0026#34;MySql.Data.Entity.MySqlEFConfiguration, MySql.Data.Entity.EF6\u0026#34;\u0026gt; \u0026lt;defaultConnectionFactory type=\u0026#34;System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework\u0026#34;\u0026gt; \u0026lt;parameters\u0026gt; \u0026lt;parameter value=\u0026#34;mssqllocaldb\u0026#34; /\u0026gt; \u0026lt;/parameters\u0026gt; \u0026lt;/defaultConnectionFactory\u0026gt; \u0026lt;providers\u0026gt; \u0026lt;provider invariantName=\u0026#34;System.Data.SqlClient\u0026#34; type=\u0026#34;System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer\u0026#34; /\u0026gt; \u0026lt;provider invariantName=\u0026#34;MySql.Data.MySqlClient\u0026#34; type=\u0026#34;MySql.Data.MySqlClient.MySqlProviderServices, MySql.Data.Entity.EF6, Version=6.9.9.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d\u0026#34;\u0026gt;\u0026lt;/provider\u0026gt;\u0026lt;/providers\u0026gt; \u0026lt;/entityFramework\u0026gt; ","date":"2016-08-11T09:21:00Z","permalink":"https://real-zony.github.io/p/aspnet-uses-mysql-as-database/","title":"ASP.NET + 使用Mysql作为数据库"},{"content":"当我们的Area区域有一个HomeController控制器，根目录也有一个HomeController控制器的时候，我们访问主页会出现如下问题： 出现这个问题的原因是因为路由系统进行匹配的时候出现了Controller同名的歧义。 当Area被注册的时候，Area中定义的路由被限制了只寻找 Area 中的Controller，所以我们请求 /Admin/Home/Index 时能正常得到 MvcApplication1.Areas.Admin.Controllers 命名空间的 HomeController。然而我们在RouteConfig.cs文件的RegisterRoutes方法中定义的路由并没有类似的限制。\n为了解决这个问题，我们需要在RouteConfig.cs文件中定义的路由中加上对应的 namespaces 参数。RouteConfig.cs 中修改后的路由如下：\n1 2 3 4 5 6 7 8 9 10 public static void RegisterRoutes(RouteCollection routes) { routes.IgnoreRoute(\u0026#34;{resource}.axd/{*pathInfo}\u0026#34;); routes.MapRoute( name: \u0026#34;Default\u0026#34;, url: \u0026#34;{controller}/{action}/{id}\u0026#34;, defaults: new { controller = \u0026#34;Home\u0026#34;, action = \u0026#34;Index\u0026#34;, id = UrlParameter.Optional }, namespaces: new[] { \u0026#34;你根目录项目的命名空间.Controllers\u0026#34; } ); } 添加了 namespaces 参数后，路由系统在对这个路由进行匹配时，优先匹配指定命名空间的controller，如果匹配到则即刻停止查找，如果在指定的命名空间下没有匹配到对应的controller，再按照一般的方式进行匹配。\n生成Area URL的连接 关于Area的URL链接生成，可以分为这么三种情况：第一种是在当前Area生成指向当前Area的链接；第二种是生成指向其他Area的链接；第三种是在某个Area中生成指向根目录的链接。下面是这三种情况生成链接的方法，使用的路由定义是系统默认的。 如果要在Area中生成当前Area的URL链接，直接用下面的方法就行：\n1 @Html.ActionLink(\u0026#34;Click me\u0026#34;, \u0026#34;About\u0026#34;) 它根据当前所在的Area和Controller会生成如下Html代码：\n1 \u0026lt;a href=\u0026#34;/Admin/Home/About\u0026#34;\u0026gt;Click me\u0026lt;/a\u0026gt; 如果要生成其他Area的URL链接，则需要在Html.ActionLink方法的匿名参数中使用一个名为area的变量来指定要生成链接的Area名称，如下：\n1 @Html.ActionLink(\u0026#34;Click me to go to another area\u0026#34;, \u0026#34;Index\u0026#34;, new { area = \u0026#34;Support\u0026#34; }) 它会根据被指定的Area去找路由的定义，假定在Support Area中定义了对应的路由，那么它会生成如下链接：\n1 \u0026lt;a href=\u0026#34;/Support/Home/Index\u0026#34;\u0026gt;Click me to go to another area\u0026lt;/a\u0026gt; 如果要在当前Area生成指根目录某个controller的链接，那么只要把area变量置成空字符串就行，如下：\n1 @Html.ActionLink(\u0026#34;Click me to go to top-level part\u0026#34;, \u0026#34;Index\u0026#34;, new { area = \u0026#34;\u0026#34; }) 它会生成如下Html链接：\n1 \u0026lt;a href=\u0026#34;/Home/Index\u0026#34;\u0026gt;Click me to go to top-level part\u0026lt;/a\u0026gt; 参考：《Pro ASP.NET MVC 4 4th Edition》\n","date":"2016-08-07T11:14:00Z","permalink":"https://real-zony.github.io/p/homecontroller-ambiguity-problem-encountered-by-aspnet-using-area/","title":"ASP.Net 使用Area遇到的HomeController歧义问题"},{"content":".NET 支持的泛型约束有以下五种:\nwhere T : struct | T必须是一个结构类型 where T : class T必须是一个类（class）类型 where T : new() | T必须要有一个无参构造函数 where T : NameOfBaseClass | T必须继承名为NameOfBaseClass的类 where T : NameOfInterface | T必须实现名为NameOfInterface的接口 ","date":"2016-08-06T05:01:00Z","permalink":"https://real-zony.github.io/p/csharp-generic-type-parameters-and-constraints/","title":"C# 泛型类型参数与约束"},{"content":"Ajax的ActionLink方法 在Razor视图中，Ajax辅助方法可以通过Ajax属性访问，例如ActionLink方法可以创建一个具有异步行为的锚标签。 假如为Music Store创建一个“Daily Deal”链接，这个锚标签点击之后是在当页显示折扣专辑的详细信息，而不是 在一个新的页面显示。\n那么我们可以这样写：\n1 2 3 4 5 6 7 8 9 \u0026lt;div id=\u0026#34;dailydeal\u0026gt; @Ajax.ActionLink(\u0026#34;点击这里获得折扣信息\u0026#34;, \u0026#34;Daily Deal\u0026#34;, new AjaxOptions{ UpdateTargetId=\u0026#34;dailydeal\u0026#34;, InsertionMode=InsertionMode.Replace, HttpMethod=\u0026#34;GET\u0026#34; }) \u0026lt;/div\u0026gt; 第一个参数指定了链接文本，第二个参数指定了要异步调用的方法名称，第三个参数指定了发送请求和处理服务器 返回结果的方式。在这个示例当中，AjaxOption参数的选项指定了要使用来自服务器的响应元素替换id值为“dailydeal” 元素，为了得到服务器的响应，需要在控制器HomeController添加一个DailyDeal操作。\n1 2 3 4 5 6 7 8 9 10 11 12 public ActionResult DailyDeal() { var albums = GetDailyDeal(); return PartialView(\u0026#34;_DailyDeal\u0026#34;,albums); } private Album GetDailyDeal() { return storeDB.Albums .OrderBy(a =\u0026gt; a.Price) .First(); } Ajax操作链接的目标操作的返回值是纯文本或者HTML，在这个示例当中将会通过渲染一个部分视图来返回HTML。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;p\u0026gt; \u0026lt;img alt = \u0026#34;@Model.Title\u0026#34; src = @Model.AlbumArtUrl\u0026#34;/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;div id = \u0026#34;album-detalils\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;em\u0026gt;Artist:\u0026lt;/em\u0026gt; @String.Format(\u0026#34;{0:F},Model.Price\u0026#34;) \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;button\u0026gt; @Html.ActionLink(\u0026#34;Add to cart\u0026#34;,\u0026#34;AddToCart\u0026#34;, \u0026#34;ShoppingCart\u0026#34;,new {id = Model.AlbumId},\u0026#34;\u0026#34;) \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ","date":"2016-07-31T10:56:00Z","permalink":"https://real-zony.github.io/p/aspnet-mvc-ajax-helper-methods/","title":"ASP.Net MVC AJax辅助方法"},{"content":"威胁概述 ASP.Net模型绑定通过重复提交成为了另外一种攻击媒介，例如：\n我们有一个允许用户提交评价意见的商店商品页面：\n1 2 3 4 5 6 7 8 public class Review{ public int ReviewID {get;set;} public int ProductID {get;set;} public Product Product {get;set;} public string Name {get;set;} public string Comment {get;set;} public bool Approved {get;set;} } 我们想向用户展示一个简单的表单，其中只包含字段Name和Comment：\nName:@Html.TextBox(\u0026ldquo;Name\u0026rdquo;)\nComment:@Html.TextBox(\u0026ldquo;Comment\u0026rdquo;)\n我们不希望用户自己能够审核通过自己的评论，然而有大量Web工具可以恶意的向表单添加\u0026quot;Approved=true\u0026quot;。\n然而模型绑定器并不知道提交的表单包含哪些字段，并且还会将Approved属性设置为true。\n更糟糕的是Review类当中还有一个Product属性，因此还可能会更改掉Product.Price的字段值，这样可能会改变表中的一些值，这些值的修改最终超出了用户的权限。\n防范 使用Bind特性防御重复提交攻击 Bind特性可用于控制器也可以用户控制器操作参数当中，可以白名单来指定允许绑定的字段，例如： [Bind(Include=\u0026ldquo;Name,Comment\u0026rdquo;)] 也可以使用黑名单，例如： [Bind(Exclute=\u0026ldquo;ReviewID,ProductID,Product,Approved\u0026rdquo;)]\n诚然使用白名单的方法更加简单安全。\n","date":"2016-07-31T10:55:00Z","permalink":"https://real-zony.github.io/p/aspnet-mvc-duplicate-submission/","title":"ASP.Net MVC 重复提交"},{"content":"CSRF跨站请求伪造 什么是混淆代理？ 引用自Wikipedia的概念：\n混淆代理是一个计算机程序，它被其他部分程序无辜地愚弄，以至于错误地使用自己的权限。它是特权扩大的一个具体类型。\n在此类情形当中，代理就是浏览器，它受到了愚弄以至于误用其权限，将用户呈献给远程 网站。\n本质很简单，CSRF是利用浏览器存储在本地的A站点cookie，在伪造的B站点中伪造请求， 再由浏览器打开新站点并且利用伪造的请求，读取A站点cookie，从而达到目的。\n如何防止CSRF？ 令牌验证 使用@Html.AntiForgeryToken辅助方法将会产生一个加密值作为隐藏的输入元素。 该值将与作为会话cookie存储在用户浏览器中的另外一个值相匹配，在提交表单 时，ActionFilter就回验证这两个值是否匹配。\n幂等的GET请求 如果一个操作是幂等的，就可以重复执行多次而不改变执行结果，一般来说仅通过 使用POST请求修改数据库或者网站上的内容，就可以有效地防御全部CSRF攻击。\nHttpReferrer验证 ","date":"2016-07-30T06:22:00Z","permalink":"https://real-zony.github.io/p/aspnet-mvc-csrf-cross-site-request-forgery-prevention/","title":"ASP.Net MVC CSRF跨站请求伪造 防范"},{"content":"XSS攻击的防范 什么是XSS攻击？ XSS攻击中文为跨站脚本攻击，这种攻击方式分为两种：\n被动注入 在被动注入当中，用户将“不干净”的内容输入到文本框中，这些数据又会保存在数据库中，以后又重新在页面上面显示。\n主动注入 用户把内容输入到文本框当中，这些内容会立即在屏幕当中显示出来。\nMVC中如何阻止XSS攻击？ 对所有内容进行HTML编码 只需要在视图当中使用@Html.Encode与@Html.AttributeEncode方法对特性值的编码转换。 对于已经“净化”或者来自信任的数据源，我们可以使用@Html.Raw(Model.HtmlContent)辅助输出。\n使用AntiXSS库作为ASP.Net的默认编码器 Install-Packeg AntiXSS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @using Microsoft.Security.Application @{ ViewBag.Title = \u0026#34;HomePage\u0026#34; } @section featured{ \u0026lt;section class=\u0026#34;featured\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;hgroup class=\u0026#34;content-wrapper\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;@ViewBag.Title.\u0026lt;/h1\u0026gt; \u0026lt;h2 id=\u0026#34;welcome-message\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/hgroup\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; } @section scripts{ @if(ViewBag.UserName != null){ \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; $(function(){ var msg = \u0026#39;Welcome,@Encoder.JavaScriptEncode(ViewBag.UserName,false)!\u0026#39;; $(\u0026#34;#welcome-message\u0026#34;).html(msg).hide().show(\u0026#39;slow\u0026#39;); }); \u0026lt;/script\u0026gt; } } ","date":"2016-07-30T06:15:00Z","permalink":"https://real-zony.github.io/p/prevention-of-xss-attacks-in-aspnet-mvc/","title":"ASP.Net MVC 当中XSS攻击的防范"},{"content":"什么是控制器？ MVC当中的控制器主要负责响应用户的输入，并且在响应的时候修改模型。也就是说在MVC模式当中的控制器需要关注的是应用程序流，输入数据的处理，以及对相关视图输出数据的提供。\n控制器的方法 控制器通过URL来响应不同的控制器方法并进行相应的处理。 例如 TestController 内有一个Index()方法。 那么在访问 www.myzony.com/Test 或者 www.myzony.com/Test/Index的时候会自动调用该方法。\n控制器参数 我们可以通过对控制器方法添加一个新的参数来动态的响应URL传进来的参数。\n1 2 3 4 5 public string Browse(string genre) { string message = HttpUtility.HtmlEncode(\u0026#34;你选择的流派是:\u0026#34; + genre); // 通过HTMLEncode可以对传进来的参数进行编码，防止代码注入。 return message; } 我们通过 http://www.myzony.com/控制器名/Browse?Genre=参数1 访问 那么在浏览器会显示： 你选择的流派是:参数1\n除此之外控制器默认的会将URL后面这个片段作为参数，传入方法：\n1 2 3 4 5 public string Deatils(int id) { string message = \u0026#34;你选择的id是:\u0026#34; + id; return message; } 我们访问 http://www.myzony.com/控制器名/Deatils/5 那么在浏览器会显示： 你选择的id是：5\n与视图的交互 控制器与视图的交互主要是通过方法的返回值来呈现新的视图。\n","date":"2016-07-28T01:41:00Z","permalink":"https://real-zony.github.io/p/aspnet-mvc4-learning---beginner-mvc-controller/","title":"ASP.Net MVC4学习 - 初学MVC控制器"},{"content":"什么是慢系统调用？ 慢系统调用指的是那些可能永远阻塞的系统调用，永远阻塞的系统调用意味着该调用永远无法返回，而多数网络支持函数都属于这一类系统调用。就如同**accept()**函数，如果没有客户连接，那么该调用将会一直阻塞。\n读写‘慢’设备（包括pipe，终端设备，网络连接等）。读时，数据不存在，需要等待；写时，缓冲区满或其他原因，需要等待。读写磁盘文件一般不会阻塞。 当打开某些特殊文件时，需要等待某些条件，才能打开。例如：打开中断设备时，需要等到连接设备的modem响应才能完成。 pause和wait函数。pause函数使调用进程睡眠，直到捕获到一个信号。wait等待子进程终止。 某些ioctl操作。 某些IPC操作。 EINTR介绍 早期的Unix系统，如果进程在一个慢系统调用(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个系统调用被中断，调用返回错误，设置errno为EINTR（相应的错误描述为“Interrupted system call”）。\n不同函数产生EINTR错误，所代表的含义也不尽相同。\n系统调用函数 errno为EINTR表征的意义 write 由于信号中断，没有成功任何数据。 open 由于信号中断，没有读到任何数据。 recv 由于信号中断返回，没有任何数据可用。 sem_wait 函数调用被信号处理函数终端。 如何处理被中断的系统调用 既然系统调用会被中断，那么别忘了要处理被中断的系统调用。有三种处理方式：\n人为重启被中断的系统调用\n人为当碰到EINTR错误的时候，有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。例如：accept、read、write、select、和open之类的函数来说，是可以进行重启的。不过对于套接字编程中的connect函数我们是不能重启的，若connect函数返回一个EINTR错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对connect不能重启的处理方法是，必须调用select来等待连接完成。 这里的“重启”怎么理解？\n一些IO系统调用执行时，如 read 等待输入期间，如果收到一个信号，系统将中断read， 转而执行信号处理函数. 当信号处理返回后， 系统遇到了一个问题： 是重新开始这个系统调用， 还是让系统调用失败？早期UNIX系统的做法是， 中断系统调用，并让系统调用失败， 比如read返回 -1， 同时设置 errno 为EINTR中断了的系统调用是没有完成的调用，它的失败是临时性的，如果再次调用则可能成功，这并不是真正的失败，所以要对这种情况进行处理， 典型的方式为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 again: if ((n = read(fd， buf， BUFFSIZE)) \u0026lt; 0) { if (errno == EINTR) goto again; /* just an interrupted system call */ /* handle other errors */ } …… while ((r = read (fd， buf， len)) \u0026lt; 0 \u0026amp;\u0026amp; errno == EINTR) /*do nothing*/ ; …… ssize_t Read(int fd， void *ptr， size_t nbytes) { ssize_t n; again: if((n = read(fd， ptr， nbytes)) == -1){ if(errno == EINTR) goto again; else return -1; } return n; } 安装信号时设置 SA_RESTART属性（该方法对有的系统调用无效）\n我们还可以从信号的角度来解决这个问题， 安装信号的时候， 设置 SA_RESTART属性，那么当信号处理函数返回后， 不会让系统调用返回失败，而是让被该信号中断的系统调用将自动恢复。\n1 2 3 4 5 6 7 8 9 struct sigaction action; action.sa_handler = handler_func; sigemptyset(\u0026amp;action.sa_mask); action.sa_flags = 0; /* 设置SA_RESTART属性 */ action.sa_flags |= SA_RESTART; sigaction(SIGALRM, \u0026amp;action, NULL); 但注意，并不是所有的系统调用都可以自动恢复。如msgsnd喝msgrcv就是典型的例子，msgsnd/msgrcv以block方式发送/接收消息时，会因为进程收到了信号而中断。此时msgsnd/msgrcv将返回-1，errno被设置为EINTR。且即使在插入信号时设置了SA_RESTART，也无效。在man msgrcv中就有提到这点：\nmsgsnd and msgrcv are never automatically restarted after being interrupted by a signal handler, regardless of the setting of the SA_RESTART flag when establishing a signal handler.\n忽略信号（让系统不产生信号中断）\n当然最简单的方法是忽略信号，在安装信号时，明确告诉系统不会产生该信号的中断。\n1 2 3 4 5 6 struct sigaction action; action.sa_handler = SIG_IGN; sigemptyset(\u0026amp;action.sa_mask); sigaction(SIGALRM, \u0026amp;action, NULL); 文章转载自：http://blog.csdn.net/benkaoya/article/details/17262053\n","date":"2016-07-22T12:39:00Z","permalink":"https://real-zony.github.io/p/eintr---signaled-interrupts-and-slow-system-calls/","title":"EINTR-信号中断与慢系统调用"},{"content":" Collection 是集合类的上级接口，继承它的接口主要有set和list. Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索，排序，线程安全化等操作。 ","date":"2016-07-19T10:09:00Z","permalink":"https://real-zony.github.io/p/csharp-collection--collection/","title":"C# Collection 与 Collection"},{"content":" HashTable的方法是同步的，HashMap的方法是未同步的，所以在多线程场合需要手动同步。 HashTable不允许null值，而HashMap则是允许null值存在的。 HashTable有一个contains(Object value)，功能和containsValue(Object value)功能一样。 HashTable使用Enumeration，HashMap使用Iterator。 以上只是表面的不同，它们的实现也有很大的不同。 HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 哈希值的使用不同。 简要区别：\nHashtable是Dictionary的子类，HashMap是Map接口的一个实现类。 Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。即是说，在多线程应用程序中，不用专门的操作就安全地可以使用Hashtable了；而对于HashMap，则需要额外的同步机制。但HashMap的同步问题可通过Collections的一个静态方法得到解决： 1 Map Collections.synchronizedMap(Map m); 这个方法返回一个同步的Map，这个Map封装了底层的HashMap的所有方法，使得底层的HashMap即使是在多线程的环境中也是安全的。\n在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。 ","date":"2016-07-19T10:04:00Z","permalink":"https://real-zony.github.io/p/difference-between-csharp-hashtable-and-hashmap/","title":"C# HashTable与HashMap的区别"},{"content":"这个问题可能很多初学者都知道，用C#写了这么久的程序，类和结构用了很久却并不知道他们之间的本质区别。 在很多时候，他们只是声明的时候关键字的不同，一个是class，一个是struct而已。 本质上的区别在于：\n类 类是属于引用类型，引用类型是在堆上面分配地址。 类对象之间的赋值是通过复制引用实现的。\n除非明确的对类进行了sealed，否则类是可以继承其他类和接口且本身也可被继承。 内部结构区别: 有默认的构造函数。 有析构函数。 可以使用abstract和sealed。 有protected修饰符。 必须使用new初始化。 结构 结构属于值类型，值类型在堆栈上分配地址。 所有基类型都是结构类型，如int 对应的是System.int32结构。 堆栈的执行效率更高，但资源有限，不适合处理逻辑复杂的对象。 结构体对象之间赋值是创建新的结构。 不能从另外的结构继承，本身也不能够被继承 内部结构区别: 没有默认的构造函数，但是能够添加构造函数。 没有abstract和sealed。 不能有protected修饰符。 可以不使用new初始化。 在结构初始化实例字段是错误的。 谈了这么多，那么什么时候使用类，什么时候使用结构体呢？\n堆栈空间有限，对于有大量逻辑的对象，使用类比结构体好一些。 在表示抽象和多级别层次的对象时，使用类是更好的选择。 在大多数情况下对象的类型只是数据时，使用结构是最好的选择。 ","date":"2016-07-19T09:57:00Z","permalink":"https://real-zony.github.io/p/difference-between-csharp-class-and-structure/","title":"C# 类与结构的区别"},{"content":"由于工程需要在线程当中加载一个新的WinForm窗口，但是直接在线程中加载会立即闪退，我认为是线程执行完成之后自动销毁了new的窗口。\n1 new Thread(()=\u0026gt;{new Form2().Show();}).Start(); 之后谷歌了一番，有人提到使用异步委托在线程中来加载新的窗口：\n1 new Thread(()=\u0026gt;{BeginInvoke(new MethodInvoker(()=\u0026gt; { new Form2().Show(); }));}).Start(); 使用如上方法能够正常运行。\n","date":"2016-05-25T13:44:00Z","permalink":"https://real-zony.github.io/p/winform-starts-a-new-window-in-a-thread/","title":"WinForm 在线程中启动新的窗口"},{"content":"在平常的应用开发过程当中，插件化的软件更容易维护与扩展，插件作者只需要遵循指定的接口规范即可快速为软件添加新的功能。而在C#当中我们更能够轻松实现上述的功能，首先我们定义一个软件与插件所遵循的接口：\n1 2 3 4 public interface IPlug { public int Func1(int a,int b); } 之后我们新建一个类库，用于实现我们的插件功能，我们仅需要在类库中实现上述接口即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /*加法插件*/ public class addclass : IPlug { public int Func1(int a,int b) { return a+b; } } /*减法插件*/ public class subclass : IPlug { public int Func1(int a,int b) { return a-b; } } 现在我们有两个插件了，那么我们怎么才能在主程序当中动态加载这些插件并且调用呢？ 这里我们就需要用到C#的反射特性了，通过反射我们能够知道一个对象他有什么字段，有什么方法。\n我们来编写一个插件管理类，叫做PlugManager.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public static class PlugManager { // 用于存放加载成功的插件 public static List\u0026lt;IPlug\u0026gt; m_PlugsList = new List\u0026lt;IPlug\u0026gt;(); public static int Load() { m_PlugList.Clear(); // 检测存放插件的目录是否存在 if (!Directory.Exists(Environment.CurrentDirectory + @\u0026#34;\\Plugins\u0026#34;)) return 0; string[] files = Directory.GetFiles(Environment.CurrentDirectory + @\u0026#34;\\Plugins\u0026#34;); foreach(string file in files) { string ext = file.Substring(file.LastIndexOf(\u0026#34;.\u0026#34;)); // 获得文件后缀 if (ext != \u0026#34;.dll\u0026#34;) continue; try { Assembly tmp = Assembly.LoadFile(file); Type[] types = tmp.GetTypes(); // 遍历实例，获得实现接口的类 foreach (Type t in types) { if (t.GetInterface(\u0026#34;IPlugin\u0026#34;) != null) { IPlugin plugin = (IPlugin)tmp.CreateInstance(t.FullName); m_PlugList.Add(plugin); } } } catch(Exception) { return 0; } } return m_PlugList.Count; } } 上述的管理类能够加载DLL后缀的插件，并且将其添加到列表中来。 调用的时候，我们直接这样调用即可。\n1 PlugManager.m_PlugList[0].Func1(1,1); ","date":"2016-05-14T16:54:00Z","permalink":"https://real-zony.github.io/p/csharp-implements-plug-in-function/","title":"C# 实现插件功能"},{"content":" 该文章转载自http://my.oschina.net/liubin/blog/27795\n究竟什么是用户态，什么是内核态，这两个基本概念以前一直理解得不是很清楚，根本原因个人觉得是在于因为大部分时候我们在写程序时关注的重点和着眼的角度放在了实现的功能和代码的逻辑性上，先看一个 1.例子：\n1 2 3 4 5 6 7 8 9 void testfork() { if(0 == fork()) { printf(\u0026#34;create new process success!\\n\u0026#34;); } printf(\u0026#34;testfork ok\\n\u0026#34;); } 这段代码很简单，从功能的角度来看，就是实际执行了一个fork()，生成一个新的进程，从逻辑的角度看，就是判断了如果fork()返回的是则打印相关语句，然后函数最后再打印一句表示执行完整个testfork()函数。代码的执行逻辑和功能上看就是如此简单，一共四行代码，从上到下一句一句执行而已，完全看不出来哪里有体现出用户态和进程态的概念。\n如果说前面两种是静态观察的角度看的话，我们还可以从动态的角度来看这段代码，即它被转换成CPU执行的指令后加载执行的过程，这时这段程序就是一个动态执行的指令序列。而究竟加载了哪些代码，如何加载就是和操作系统密切相关了。\n2.特权级 熟悉Unix/Linux系统的人都知道，fork的工作实际上是以系统调用的方式完成相应功能的，具体的工作是由sys_fork负责实施。其实无论是不是Unix或者Linux，对于任何操作系统来说，创建一个新的进程都是属于核心功能，因为它要做很多底层细致地工作，消耗系统的物理资源，比如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录页表等等，这些显然不能随便让哪个程序就能去做，于是就自然引出特权级别的概念，显然，最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。\n特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查，相关的概念有 CPL、DPL和RPL，这里不再过多阐述。硬件已经提供了一套特权级使用的相关机制，软件自然就是好好利用的问题，这属于操作系统要做的事情，对于 Unix/Linux来说，只使用了0级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。\n3.用户态和内核态 现在我们从特权级的调度来理解用户态和内核态就比较好理解了，当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在级特权级上时，就可以称之为运行在内核态。\n虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如上面例子中的testfork()就不能直接调用 sys_fork()，因为前者是工作在用户态，属于用户态程序，而sys_fork()是工作在内核态，属于内核态程序。\n当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发 sys_fork()的执行时，就切换到了内核态。\n4.用户态与内核态切换的三种方式\n系统调用 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 外围设备中断 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。\n5.具体的切换操作 从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：\n从当前进程的描述符中提取其内核栈的ss0及esp0信息。 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始 执行中断处理程序，这时就转到了内核态的程序执行了。 ","date":"2016-05-04T02:09:00Z","permalink":"https://real-zony.github.io/p/user-mode-and-kernel-mode/","title":"用户态与内核态"},{"content":"mmap是Unix提供的一个有用的功能，这个功能允许程序共享内存，也被称为内存映射。这个函数的作用是建立一段可以被两个或者更多个程序读写的内存，一个程序对它的修改可以被其他程序所看见。\n这个功能经常被用于读写硬盘上的文件，mmap可以将文件映射到内存，这样你可以更加方便的对文件内容进行更新操作。\nmmap函数原型：\n1 2 3 #include \u0026lt;sys/mman.h\u0026gt; void *mmap(void *addr,size_t len,int prot,int flags,int fildes,off_t off); addr：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。\nlen：映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理\nprot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过位或运算合理地组合在一起 PROT_EXEC //页内容可以被执行 PROT_READ //页内容可以被读取 PROT_WRITE //页可以被写入 PROT_NONE //页不可访问\nflags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体 MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。 MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到**msync()**或者**munmap()*被调用，文件实际上*不会被更新。 MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。 MAP_DENYWRITE //这个标志被忽略。 MAP_EXECUTABLE //同上 MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。 MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。 MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。 MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。 MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。 MAP_FILE //兼容标志，被忽略。 MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。 MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。 MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。\nfildes：有效的文件描述词。一般是由open()函数返回，其值也可以设置为-1，此时需要指定flags参数中的MAP_ANON,表明进行的是匿名映射。\noff：被映射对象内容的起点。\n你可以对addr参数来请求使用某个特定的地址，如果他的取值为零将会自动进行分配，这是一种推荐的做法否则会降低程序的可移植性，因为在不同的系统上的可用地址范围是不一样的。\n下面我们介绍第二个函数，他的作用是把某个部分或整段中的修改写回被映射的文件中。(或者从映射文件中读出)\n1 2 #include \u0026lt;sys/mman.h\u0026gt; int msync(void *addr,size_t len,int flags); addr：文件映射到进程空间的地址；\nlen：映射空间的大小；\nflags：刷新的参数设置，可以取值MS_ASYNC/ MS_SYNC/ MS_INVALIDATE 取值为MS_ASYNC（异步）时，调用会立即返回，不等到更新的完成； 取值为MS_SYNC（同步）时，调用会等到更新完成之后返回； 取MS_INVALIDATE（通知使用该共享区域的进程，数据已经改变）时，在共享内容更改之后，使得文件的其他映射失效，从而使得共享该文件的其他进程去重新获取最新值；\n还有munmap函数，他的作用是释放内存段。\n1 2 #include \u0026lt;sys/mman.h\u0026gt; int munmap(void *addr,size_t len); 下面我们通过一个实例来使用mmap。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NRECORDS (100) typedef struct{ int integer; char chars[24]; } RECORD; int main() { RECORD record, *mapped; FILE *fp; fp = fopen(\u0026#34;records.dat\u0026#34;, \u0026#34;w+\u0026#34;); for (int i = 0; i \u0026lt; NRECORDS; i++) { record.integer = i; sprintf(record.chars, \u0026#34;RECORD-%d\u0026#34;, i); fwrite(\u0026amp;record, sizeof(record), 1, fp); } fclose(fp); fp = fopen(\u0026#34;records.dat\u0026#34;, \u0026#34;r+\u0026#34;); fseek(fp, 43 * sizeof(record), SEEK_SET); fread(\u0026amp;record, sizeof(record), 1, fp); printf(\u0026#34;%d\\n\u0026#34;,record.integer); record.integer = 413; sprintf(record.chars, \u0026#34;RECORD-%d\u0026#34;, record.integer); fseek(fp, 43 * sizeof(record), SEEK_SET); fwrite(\u0026amp;record, sizeof(record), 1, fp); fclose(fp); int fd = open(\u0026#34;records.dat\u0026#34;, O_RDWR); mapped = (RECORD*)mmap(0, NRECORDS * sizeof(record), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); mapped[43].integer = 243; printf(\u0026#34;%d\\n\u0026#34;, mapped[43].integer); sprintf(mapped[43].chars, \u0026#34;RECORD-%d\u0026#34;, mapped[43].integer); msync((void*)mapped, NRECORDS*sizeof(record), MS_SYNC); munmap((void*)mapped, NRECORDS*sizeof(record)); close(fd); exit(0); } ","date":"2016-05-02T12:00:00Z","permalink":"https://real-zony.github.io/p/a-brief-introduction-to-the-use-of-mmap/","title":"mmap 的使用浅解"},{"content":"经常听到缓冲区的概念，但始终对它的作用与具体实现有很多疑问，最近拜读了《Linux程序设计》 4TH之后，总算有了大概的理解。 该书举了一个例子，对一个10M文件的复制操作三种不同的实现，速度有不同的体现。 首先包含头文件：\n1 2 3 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; 首先看第一个实现，直接使用read与write的系统底层调用进行文件复制：\n1 2 3 4 5 6 7 8 9 10 11 int Func1() { char c; int in,out; in = open(\u0026#34;file.in\u0026#34;,O_RDONLY); out = open(\u0026#34;file.out\u0026#34;,O_WRONLY|O_CREAT,S_IRUSR|S_IWUSR); while(read(in,\u0026amp;c,1)==1) { write(out,\u0026amp;c,1); } } 以上程序运行之后会将file.in文件复制到file.out文件当中，我们使用TIMEFORMAT=\u0026quot;\u0026quot; time ./Test\n1.19user 39.37system 0:41.63elapsed 97%CPU (0avgtext+0avgdata 1172maxresident)k 0inputs+24984outputs (0major+63minor)pagefaults 0swaps\n也就是我们花了39.37秒才完成了文件复制操作。 我们每次读入1个字节调用一次read函数，10M=1024KB=1048576byte，也就是我们调用了10万次read函数。\n我们看下第二个实现，这个实现采用了一个1K的缓冲区：\n1 2 3 4 5 6 7 8 9 10 11 12 int Func2() { char buffer[1024]; int in,out; int nread; in = open(\u0026#34;file.in\u0026#34;,O_RDONLY); out = open(\u0026#34;file.out\u0026#34;,O_WRONLY|O_CREAT,S_IRUSR|S_IWUSR); while((nread = read(in,\u0026amp;buffer,1024))\u0026gt;0) { write(out,buffer,nread); } } 0.00user 0.07system 0:00.08elapsed 89%CPU (0avgtext+0avgdata 1112maxresident)k 0inputs+24976outputs (0major+62minor)pagefaults 0swaps\n第二个实现则仅仅需要1秒不到的时间即可实现文件复制功能，因为只需要执行1024次操作即可。\n下面第三个实现则是使用的标准库里面的文件操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int Func3() { FILE* in,*out; int c; in = fopen(\u0026#34;file.in\u0026#34;,\u0026#34;r\u0026#34;); out = fopen(\u0026#34;file.out\u0026#34;,\u0026#34;w\u0026#34;); while((c=fgetc(in) != EOF) { fputc(c,out); } } 0.40user 0.07system 0:00.52elapsed 92%CPU (0avgtext+0avgdata 1380maxresident)k 0inputs+24976outputs (0major+70minor)pagefaults 0swaps\n这种实现所消耗的时间与第二种实现相差不多，但为什么同样是读取一个字符却跟第一个差距这么大，因为在stdio库当中的FILE结构当中实现了一个缓冲区，只有当缓冲区满的时候才会进行调用。\n根据上面三个实现，体现了不同的实现效率与性能的极大差异，所以在实际的程序开发当中应该找到性能与稳定的平衡点。\n","date":"2016-04-25T13:25:00Z","permalink":"https://real-zony.github.io/p/the-role-of-the-buffer/","title":"缓冲区的作用"},{"content":"VMware 如果要安装 Mac OS X 10.11 的话，就需要打 unlocker208补丁，安装 unlocker208 的时候必须保证你的电脑安装了 python 的 2.x 版本，这里建议安装 python2.7.9版本，请不要安装3.x版本。\n如果在 Windows10 上面安装好 VMware12 之后打 unlocker 补丁的时候可能会出现 unlocker.exe 停止运行，这个时候请使用记事本方式打开 windows-install.cmd，将 unlocker.exe 改为 python unlocker.py 之后保存并且双击运行这个cmd文件即可。\n","date":"2016-04-15T02:00:00Z","permalink":"https://real-zony.github.io/p/the-solution-to-the-failure-of-windows-10-to-play-the-unlocker208-patch-for-vmare12/","title":"Windows10 对于 Vmare12 打unlocker208补丁失败的解决办法"},{"content":"在我们的实际应用当中,字符串分割是很重要的一个功能,但是 C++ 的 string 并没有为我们提供这个功能,所以说我们只有自己动手实现.实现代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; splitString(string str,string pattern) { string::size_type pos; // 查找到的位置 vector\u0026lt;string\u0026gt; result; // 返回的字符串 str+=pattern; int size=str.size(); for(int i=0;i\u0026lt;size;i++) { pos = str.find(pattern,i); if(pos\u0026lt;size) { string s = str.substr(i,pos-i); result.push_back(s); i = pos+pattern.size()-1; } } return result; } ","date":"2016-03-30T01:08:00Z","permalink":"https://real-zony.github.io/p/using-stl-standard-library-to-realize-string-segmentation/","title":"利用STL标准库实现字符串分割"},{"content":"在之前博客的文章当中当中忽略了对中文字符串的处理.例如以下代码:\n1 2 string str = \u0026#34;我a\u0026#34;; return str.Lenght; 以上代码会返回2，乍一看似乎是没有错的,我们数据包head的lenght会被置为2. 然后我们的对端C++服务器会读取两字节的数据来,最后的结果会出现截断的情况,这是为什么呢? 因为在UTF-8里面我们汉字是占用的3字节空间,str的长度实际为4,所以我们在C#客户端发送数据的时候应该这样来获取字符长度.\n1 2 3 4 public static int getLenght(string str,Encoding encode) { return encode.GetByteCount(str); } ","date":"2016-03-30T00:58:00Z","permalink":"https://real-zony.github.io/p/talking-about-the-coding-of-csharp-and-c-communication-again/","title":"再谈C#与C++通信之编码"},{"content":"本博客作者保留翻译著作权，转载请联系作者。 原著链接：PacktPub.SDL.Game.Development.Jun.2013.pdf\n为什么选择SDL？ 不同的操作系统都有自己的绘图方式，自己的一套事件处理机制，而SDL则为我们提供了一套统一的接口来调用。这样我们只需要集中精力开发游戏，而不需要为游戏的可移植性担心。游戏编程是一项十分复杂的工作。但是SDL则极大的减轻了我们的工作量，加快游戏的开发速度。\n在Windows下面开发一个游戏，然后在Linux或者OS X上面运行，SDL则提供了这样一次开发四处运行的特性。\nSDL拥有庞大的用户群体帮助更新和维护，同时SDL社区也是十分活跃，所以你可以经常访问一下SDL的官网看看有没有最新的版本。\n总的来说，SDL提供了一套很完善的游戏开发库，让你专注于游戏本身，而不是再为不同的平台所烦恼。\nSDL2.0是什么？ SDL2.0是SDL1.2的更新版本，后者仍然在维护，2.0则提供了一些新的功能，这些新的功能详见wiki.libsdl.org/moin.cgi/Roadmap，主要有以下特点：\n3D图像的加速渲染 2D硬件加速 支持Render Target 支持多窗口 提供对剪贴板访问的API 支持多个输入设备 支持7.1 声道 支持多个音频设备 提供对力反馈操纵杆的API 支持水平滚轮鼠标 提供多点触控的API 支持音频捕获 对多线程的改进 虽然以上特性我们后面的游戏编程不一定都会用到，但是这些新的特性都会使SDL成为一个良好的游戏框架。在后面我们将会用到里面的2D硬件加速来使我们的游戏拥有出色的表现。\nSDL2.0 扩展库 SDL 框架有一些单独的扩展库，我们可以使用这些库来使我们的游戏变得更加完善，这些扩展库不放在前面讲述是尽量让SDL框架不显得那么臃肿。只有在我们有必要的时候，才会考虑使用这些扩展库。下面列举了一些十分常用的扩展库以及他们的用途，这些扩展库已经从原来的SDL1.2/1.3更新到支持最新的SDL 2.0：\nSDL_image　这是一个用于加载图像的库，支持BMP，GIF，PNG，TGA，PCX以及其他格式。 SDL_net　这是一个跨平台的网络支持库。 SDL_mixer　这是一个音频支持库，他支持MP3，MIDI，OGG这三种格式。 SDL_ttf　这个库可以让你在游戏当中使用TrueType字体。 SDL_rtf　这是一个可以让SDL支持富文本渲染的库。 在Visual C++ Express 2010当中配置SDL 下面我们会讲解如何在Visual C++ Express当中配置SDL2.0，Visual C++ Express这个IDE他为我们提供了一个免费的游戏开发环境，当然你用Visual Studio也是可以的，因为VS包含了VC++。Visual C++ Express可以在这个地方免费下载，如果说你已经成功安装了这个IDE，那么我们就可以去下载SDL2.0，如果你不使用Visual C++ Express来开发你的游戏或者说你不打算在Windows下面开发的话，后面的这些步骤你可能需要根据实际情况做一些调整。\nSDL 2.0还在发展，所以现在还没有正式发布，你可以有两种方式来获得源码：\n你可以下载最新源码的快照，来快速构建你的游戏。（最简单） 你也可以使用mercurial来clone源码。（能够与最新版本保持一致） 这两种方式可以在这里找到：http://www.libsdl.org/hg.php 当然，在Windows当中使用SDL2.0开发，必须使你的Direct X SDK保持最新版本，你可以在[这里](http://www.microsoft.com/en-gb/download/details. aspx?id=6812)找到最新的SDK。\n在Windows下使用Mercurial获得SDL2.0 直接从不断更新的代码库来获得SDL2.0是最好的方式，可以确保你的SDL2.0是最新版本，任何的错误修复都会在上面第一时间提交。关于Mercurial的GUI工具有很多，这里我们使用tortoisehg.bitbucket.org提供的程序，我们安装了这个程序之后就能够即时的获取到最新的SDL2.0版本。\n建立一个新的SDL2.0克隆 1.打开TortoiseHg Workbench窗口： 2.按下Ctrl + Shift + N 来打开克隆对话框。 3.输入远程仓库的源路径，这里我们直接填入：http://hg.libsdl.org/SDL即可。 4.输入或者按下\u0026quot;Browse\u0026quot;(浏览)选择一个本地路径作为SDL2.0的本地仓库，如C:\\SDL2。 5.点击\u0026quot;Clone\u0026quot;按钮，并且允许远程库复制到本地。 6.在C:\\SDL2的文件夹下面会有一个VisualC的文件夹，里面会有一个Visual C++ 2010的解决方案，我们使用Visual C++ Express 来打开。 7.打开的时候可能会提示一些警告信息，这是由于不同版本解决方案所造成的，这些可以忽略掉，并不影响我们SDL2.0的使用。 8.根据你的系统来改变构建配置。 9.右键点击SDL，选择\u0026quot;Build\u0026quot;(构建)。 10.现在我们便有了一个SDL 2.0的库，它位于C: SDL2\\VisualC\\SDL\\Win32(or x64)\\Release\\SDL.lib这个位置。 11.我们还需要构建SDL的主库文件，所以在\u0026quot;SDLmain\u0026quot;上面右键，点击\u0026quot;Build\u0026quot;(构建)，这个文件位于： C:\\SDL2\\VisualC SDLmain\\Win32(or x64)\\Release\\SDLmain.lib 12.创建一个文件夹，重命名为lib，将C:\\SDL2里面的SDL.lib和SDLmain.lib这两个文件复制进去。 我现在有了SDL库，还需要做什么？ 现在我们的Viusal C++ 2010 创建工程之后就可以和SDL库进行链接，下面就是链接步骤：\n1.在Visual C++ Express里面创建一个新的工程并为其命名，例如SDL-Game。 2.创建之后在\u0026quot;Solution Explorer\u0026quot;(解决方案资源管理器)当中右键工程，点击属性。 3.在\u0026quot;Configuration\u0026quot;的下拉列表当中选择\u0026quot;All Configurations\u0026quot;。 4.在VC++ Directories里面选择\u0026quot;Include Directories\u0026quot;(包含目录)这个项目，双击他。 5.在里面你可以选择一个新位置，你可以选择C:\\SDL2\\include，并点击确定。 6.这一步则是做同样的事情，不过是在\u0026quot;library directories\u0026quot;(库目录)选项内添加我们库文件所在的目录。(C:\\SDL2\\lib) 7.选择\u0026quot;Linker\u0026quot;(链接器),在这个Linker下面会有一个\u0026quot;Input\u0026quot;(输入)，点击进去会看到有一个\u0026quot;Additional Dependencies type\u0026quot;(附加依赖项)，在附加依赖项里面我们添加上SDL.lib和SDLmain.lib，记得每个要换行哦。 8.也是在\u0026quot;Linker\u0026quot;下面选择\u0026quot;System\u0026quot;(系统)选项，然后在\u0026quot;SubSystem\u0026quot;(子系统)里面选择\u0026quot;Windows(/SUBSYSTEM:WINDOWS)\u0026quot;(窗口(/SUBSYSTEM:WINDOWS)) 9.点击确定即完成了我们所有的操作。 Hello SDL 我们的空项目通过上面的步骤已经引入了SDL的库，所以是时候开始进行游戏开发了。点击\u0026quot;Source Files\u0026quot;(源文件)，右键添加新项目（或者使用Ctrl+Shift+A）,选择cpp源文件，命名为main.cpp。创建完成之后在里面键入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;SDL.h\u0026gt; SDL_Window *g_pWindow=0; SDL_Renderer *g_pRenderer=0; int main(int argc,char *args[]) { // 初始化SDL if(SDL_Init(SDL_INIT_EVERYTHING) \u0026gt;= 0) { // 初始化成功后创建一个窗口 g_pWindow = SDL_CreateWindow(\u0026#34;Chapter 1:Setting up SDL\u0026#34;, SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED, 640,480, SDL_WINDOW_SHOWN); // 窗口创建成功后，创建一个渲染器 if(g_pWindow != 0) { g_pRenderer = SDL_CreateRenderer(g_pWindow,-1,0); } } else { return 1; // SDL初始化失败 } // 当所有初始化工作成功后，我们将渲染器颜色置为黑色 // 该函数支持Alpha通道 SDL_SetRenderDrawColor(g_pRenderer,0,0,0,255); // 清空屏幕 SDL_RenderClear(g_pRenderer); // 刷新屏幕 SDL_RenderPresent(g_pRenderer); // 延迟5秒退出 SDL_Delay(5000); // 退出 SDL_Quit(); return 0; } 现在我们可以尝试构建我们第一个SDL程序了，右键点击该项目，选择\u0026quot;Build\u0026quot;(构建)。会提示一个错误，说没有找到SDL.dll文件： 在尝试\u0026quot;Release\u0026quot;或者\u0026quot;Debug\u0026quot;构建你的程序时，应该在你Visual Studio的工程目录下将SDL.dll复制到对应的文件夹里面。(Release 或者 Debug文件夹内)这个DLL文件通常位于C:\\SDL2\\VisualC\\SDL\\Win32(或者x64)\\Release\\SDL.dll，当你想发布你的游戏的时候，需要将SDL.dll放在你exe的文件夹内。现在我们编译我们的程序，运行之后会显示一个SDL窗口，并且在5秒后关闭。\nHello SDL 的概述 我们来看看Hello SDL 的代码： 1.首先，我们包含了SDL.h 的头文件，这样我们就获得了SDL的所有功能函数。\n1 #include \u0026lt;SDL.h\u0026gt; 2.然后我们创建了一些全局变量，一个是SDL_Window指针，通过SDL_CreateWindow函数赋值来初始化，还有一个是SDL_Renderer指针，通过SDL_CreateRenderer函数赋值来初始化：\n1 2 SDL_Window* g_pWindow = 0; SDL_Renderer* g_pRenderer = 0; 3.现在我们可以来初始化SDL，这个实例初始化SDL子系统使用的是SDL_INIT_EVERYTHING标志，但是这不是必须的。(参见SDL初始化标志)\n1 2 3 4 5 int main(int argc,char args[]) { // 初始化SDL if(SDL_Init(SDL_INIT_EVERYTHING) \u0026gt;= 0) { 4.如果SDL初始化成功了的话，我们便可以对g_pWindow 进行初始化。SDL_CreateWindow函数将会根据我们所提供参数来创建一个窗口，并且返回一个SDL_Window指针。函数第一个参数是窗口的标题，第二参数是窗口出现的位置，第三个参数是窗口的宽度，第四个参数是窗口的高度，以及所需要的SDL初始化标志(在本章的后面将会讲解这些标志的作用)。SDL_WINDOWPOS_CENTERED即是让我们的窗口的位置将会在屏幕的中心:\n1 2 3 4 // if succeeded create our window g_pWindow = SDL_CreateWindow(\u0026#34;Chapter 1: Setting up SDL\u0026#34;, SDL_ WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_ SHOWN); 5.完成以上步骤以后，为了程序的健壮性，我们需要检测一下窗口创建是否成功。如果窗口创建成功的话，那么我们会继续初始化我们的渲染器。SDL_CreateRenderer函数第一个参数是目标窗口，是一个SDL_Window指针，这里我们传入g_pWindow指针，第二个参数是渲染器的驱动索引，我们传入-1来确保我们的渲染器是第一个驱动的，最后一个是标志，这里我们使用SDL_RendererFlag(见SDL渲染标志):\n1 2 3 4 5 6 7 8 9 // if the window creation succeeded create our renderer if(g_pWindow != 0) { g_pRenderer = SDL_CreateRenderer(g_pWindow, -1, 0); } else { return 1; // sdl could not initialize } 6.如果一切顺利，现在我们将创建并显示窗口:\n1 2 3 4 5 6 7 8 9 10 11 // everything succeeded lets draw the window // set to black SDL_SetRenderDrawColor(g_pRenderer, 0, 0, 0, 255); // clear the window to black SDL_RenderClear(g_pRenderer); // show the window SDL_RenderPresent(g_pRenderer); // set a delay before quitting SDL_Delay(5000); // clean up SDL SDL_Quit(); SDL初始化标志 对于事件处理、文件I/O以及多线程这些子系统都使用默认初始化，其他的子系统可以使用以下标志进行初始化:\nSDL_INIT_HAPTIC　力反馈子系统 SDL_INIT_AUDIO　音频子系统 SDL_INIT_VIDEO　视频子系统 SDL_INIT_TIMER　时钟子系统 SDL_INIT_JOYSTICK　操纵杆子系统 SDL_INIT_EVERYTHING　所有子系统 SDL_INIT_NOPARACHUTE　不捕获致命信号 我们也可以用位与操作符(|)来初始化两个或者多个子系统。只初始化音频和视频子系统的话，我们可以这么写：\n1 SDL_Init(SDL_INIT_AUDIO | SDL_INIT_VIDEO); 检测某个子系统是否已经激活，可以使用SDL_WasInit()函数:\n1 2 3 4 if(SDL_WasInit(SDL_INIT_VIDEO) != 0) { cout \u0026lt;\u0026lt; \u0026#34;视频子系统未初始化\u0026#34;; } SDL渲染标志 我们在初始化一个SDL_Renderer的时候，我们可以通过一个标志来确定其行为:\nSDL_RENDERER_SOFTWARE　使用软件渲染 SDL_RENDERER_ACCELERATED　使用硬件加速 SDL_RENDERER_PRESENTVSYNC　渲染器与屏幕刷新率同步 SDL_RENDERER_TARGETTEXTURE　支持渲染纹理 如何制作一个游戏 在设计一个游戏的时候，本质上是各子系统之间的相互作用，如图像子系统、游戏逻辑、与用户输入。图像子系统不应该干涉游戏逻辑的实现，反之亦然，我们认为一个游戏的结构应该如下: 一旦游戏被初始化，它就开始一个循环用于检测用户的输入。用户退出游戏的时候，这个循环会跳出，并且清理掉所有资源。这是一个游戏编程的基本框架，在本书当中我们也会遵循以上框架进行编程。\n我们将会构建一个可重用的框架，这样在创建新项目的时候我们可以节省大量的时间。现在，我们将会重构之前的Hello SDL代码，将分成多个单独的部分。这个过程有助于我们思考如何将代码分解成独立的模块，而不是将所有的代码都放在一个文件里面，显得杂乱无章。\n分离Hello SDL的代码 我们可以将之前的代码根据不同的功能来封装成多个函数：\n1 bool g_bRunning = false; // 游戏运行状态 按照下面的步骤来逐步分解我们的代码：\n创建一个init函数用来初始化我们的游戏窗口，SDL_CreateWindow所需要的参数在init当中封装一次。 1 2 3 4 5 6 7 8 9 10 11 bool init(const char* title,int xpos,int ypos,int height,int width,int flags) { // 初始化SDL if(SDL_Init(SDL_INIT_EVERYTHING \u0026gt;= 0) { g_pWindow = SDL_CreateWindow(title,xpos,ypos,height,width,flags); // 判断是否成功创建了窗口 if(g_pWindow != 0) { } ","date":"2016-02-16T14:15:00Z","permalink":"https://real-zony.github.io/p/sdl-tutorial-series-chapter-1-getting-started-with-sdl/","title":"SDL系列教程：第一章 开始使用SDL"},{"content":"在服务器开发压力测试的时候，发现超过 1000 个链接便会造成 errno:24 的错误，这个错误解释就是 Too many open files。 这个错误发生的原因便是 Linux 默认会有一个链接限制。 之前一直以为最大链接限制是在这里看的。\n1 cat/proc/sys/fs/file-max Google了一番找到了问题的根源。 以下内容摘取自：http://www.cnblogs.com/tankaixiong/p/4064708.html\nLinux 服务器大并发调优时，往往需要预先调优 Linux 参数，其中修改 Linux 最大文件句柄数是最常修改的参数之一。\n在 Linux 中执行 ulimit -a 即可查询 Linux 相关的参数，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [root@mongodb11 ~]# ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 256324 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 10240 cpu time (seconds, -t) unlimited max user processes (-u) 256324 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 默认情况下，Linux 最大文件句柄数为 1024 个。当你的服务器在大并发达到极限时，就会报出 \u0026ldquo;too many open files\u0026rdquo;。\n那么如何修改 Linux 最大文件句柄数呢？其实很简单：\n1 ulimit -n 2048 这命令就可以修改 Linux 最大文件句柄数，修改以后使用 ulimit -a 查看修改的状态，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@mongodb11 ~]# ulimit -n 2048 [root@mongodb11 ~]# ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 256324 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 2048 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 10240 cpu time (seconds, -t) unlimited max user processes (-u) 256324 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 但是，这种方法只针对当前进程有效。重新打开一个 Shell 或者开启一个进程，你就会发现参数还是 ulimit -n xx 修改之前的数字。那么有没有一劳永逸的方法呢？\n当然有！那就是修改系统参数。\n2、修改 Linux 系统参数，vi /etc/security/limits.conf 添加\n1 2 - soft　nofile　65536 - hard　nofile　65536 修改以后保存，注销当前用户，重新登录，执行 ulimit -a ,ok ,参数生效了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [root@localhost ~]# ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 256600 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 65536 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 10240 cpu time (seconds, -t) unlimited max user processes (-u) 256600 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 硬限制表明 soft 限制中所能设定的最大值。 soft 限制指的是当前系统生效的设置值。 hard 限制值可以被普通用户降低。但是不能增加。 soft 限制不能设置的比 hard 限制更高。 只有 root 用户才能够增加 hard 限制值。\n可以最大设到: 655350\n","date":"2016-02-11T16:18:00Z","permalink":"https://real-zony.github.io/p/about-epoll-concurrent-link-limit-under-linux/","title":"Linux 下关于 epoll 并发链接限制"},{"content":"经过测试只能在Windows7 下正常使用，在Win8或者Xp下面无法正常显示毛玻璃效果。 首先你要先创建一个结构体如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [StructLayout(LayoutKind.Sequential)] public struct MARGINS { public MARGINS(Thickness t) { Left = (int)t.Left; Right = (int)t.Right; Top = (int)t.Top; Bottom = (int)t.Bottom; } public int Left; public int Right; public int Top; public int Bottom; } 之后再创建一个辅助类:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class GlassHelper { [DllImport(\u0026#34;dwmapi.dll\u0026#34;, PreserveSig = false)] static extern void DwmExtendFrameIntoClientArea( IntPtr hWnd, ref MARGINS pMarInset); [DllImport(\u0026#34;dwmapi.dll\u0026#34;, PreserveSig = false)] static extern bool DwmIsCompositionEnabled(); public static bool ExtendGlassFrame(Window window, Thickness margin) { if (!DwmIsCompositionEnabled()) return false; IntPtr hwnd = new WindowInteropHelper(window).Handle; if (hwnd == IntPtr.Zero) throw new InvalidOperationException( \u0026#34;The Window must be shown before extending glass.\u0026#34;); // 将Win32或者WPF程序背景设置为透明 window.Background = Brushes.Transparent; HwndSource.FromHwnd(hwnd).CompositionTarget.BackgroundColor = Colors.Transparent; MARGINS margins = new MARGINS(margin); DwmExtendFrameIntoClientArea(hwnd, ref margins); return true; } } 然后你只需要重写 OnSourceInitialized 方法即可。\n1 2 3 4 5 protected override void OnSourceInitialized(EventArgs e) { base.OnSourceInitialized(e); GlassHelper.ExtendGlassFrame(this, new Thickness(-1)); } 效果图:\n","date":"2016-02-06T02:50:00Z","permalink":"https://real-zony.github.io/p/to-achieve-the-frosted-glass-effect/","title":"实现毛玻璃效果"},{"content":"什么是缺页中断? 当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作:\n1、检查要访问的虚拟地址是否合法。\n2、查找/分配一个物理页。\n3、填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）。\n4、建立映射关系（虚拟地址到物理地址）。\n重新执行发生缺页中断的那条指令\n如果第3步，需要读取磁盘，那么这次缺页中断就是 majflt，否则就是 minflt。\n内存分配的原理 从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk 和 mmap（不考虑共享内存）。\nbrk 是将数据段(.data)的最高地址指针 _edata 往高地址推； mmap 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生 缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。\n在标准C库中，提供了malloc/free函数分配释放内存，其实这两个函数底层是由 brk、mmap、munmap 这些系统调用实现的。\n下面以一个例子来说明内存分配的原理： 1.malloc 小于 128k 的内存，使用 brk 分配内存，将 _edata 往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核 缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：\n进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。\n其中，mmap 内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。\n_edata 指针（glibc 里面定义）指向数据段的最高地址。\n进程调用 A=malloc(30K)以后，内存空间如图2：\nmalloc 函数会调用 brk 系统调用，将 _edata 指针往高地址推30K，就完成虚拟内存分配。\n你可能会问：只要把 _edata+30K 就完成内存分配了？\n事实是这样的，_edata+30K 只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A 对应的物理页是不会被分配的。\n进程调用 B=malloc(40K) 以后，内存空间如图3。\n2.malloc 大于128k的内存，使用 mmap 分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：\n进程调用 C=malloc(200K) 以后，内存空间如图1：\n默认情况下，malloc 函数分配内存，如果请求内存大于 128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推 _edata 指针了，而是利用 mmap 系统调用，从堆和栈的中间分配一块虚拟内存。\n这样子做主要是因为:\nbrk 分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而 mmap 分配的内存可以单独释放。\n当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看 glibc 里面 malloc 的代码了。\n进程调用 D=malloc(100K) 以后，内存空间如图2。\n进程调用 free(C) 以后，C对应的虚拟内存和物理内存一起释放，图3。\n进程调用 free(B) 以后，如图4所示：\nB对应的虚拟内存和物理内存都没有释放，因为只有一个 _edata 指针，如果往回推，那么 D 这块内存怎么办呢？\n当然，B 这块内存，是可以重用的，如果这个时候再来一个 40K 的请求，那么 malloc 很可能就把B这块内存返回回去了。\n进程调用 free(D) 以后，如图5所示：\nB 和 D 连接起来，变成一块140K的空闲内存。\n默认情况下：\n当最高地址空间的空闲内存超过 128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图6所示。\n","date":"2016-02-04T03:38:00Z","permalink":"https://real-zony.github.io/p/the-principle-of-malloc-and-the-reasons-for-memory-fragmentation/","title":"malloc 的原理与产生内存碎片的原因"},{"content":"最近在开发程序的时候遇到一个小问题，就是当数据包到达时，如何根据传入的参数自动调用相应的处理函数。 奈何博主愚钝，并没有找到很好的解决方法，参照 Epoll 的思想，是否自己也能实现一种事件轮询的机制，之后便实验了一番，确实可行，故书博文一篇，记述一下自己的过程。\n首先我们准备一个容器，用来存放已经注册了的事件集合，这里我选择了队列来作为这个容器的实现。\n1 2 3 4 5 6 typedef struct FuncObject { int type; // 事件类型/标识符 void (CallBack*)(void *arg); //事件回调 struct FuncObject *next; }FuncObject_t; 在以上代码我们定义了一个节点，用于存放我们注册了的事件。\n1 2 3 4 5 typedef struct FuncQueue { FuncObject_t *head; FuncObject_t *tail; }FuncQueue_t; 定义一个典型的队列。 下面我们就来定义一下这个队列的操作，在这里我习惯了使用面向对象的思想来编写C程序。\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct FuncQueueObject { FuncQueue_t __queue; //私有队列 void(*Init)(struct FuncQueueObject *instance); void(*Add)(struct FuncQueueObject *instance,FuncObject_t *object); FuncObject_t *(*Set)(void(*CallBack)(void *arg),int type); void(*Set_Ex)(struct FuncQueueObject *instance, void(*CallBack)(void *package), int type); void(*Delete)(struct FuncQueueObject *instance, int type); } extern FuncQueueObject_t *FuncQueueObject_New(); extern void FuncQueueObject_Delete(FuncQueueObject_t *object); 以上实现了我们的一个队列容器，用于存放/修改/删除我们的注册的事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026#34;FuncQueue.h\u0026#34; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 申请指定T类型大小的内存空间并返回 #define NEW(T)(T*)memset(malloc(sizeof(T)),0,sizeof(T)) void Init(FuncQueueObject_t *instance) { (instance-\u0026gt;__queue).head = NULL; (instance-\u0026gt;__queue).tail = NULL; } void Add(FuncQueueObject_t *instance, FuncObject_t *object) { if ((instance-\u0026gt;__queue).head == NULL) { (instance-\u0026gt;__queue).head = object; (instance-\u0026gt;__queue).tail = object; } else { (instance-\u0026gt;__queue).tail-\u0026gt;next = object; (instance-\u0026gt;__queue).tail = object; } object-\u0026gt;next = NULL; } FuncObject_t *Set(void(*CallBack)(void *package), int type) { FuncObject_t *tmp = (FuncObject_t *)malloc(sizeof(FuncObject_t)); tmp-\u0026gt;CallBack = CallBack; tmp-\u0026gt;type = type; tmp-\u0026gt;next = NULL; return tmp; } void Delete(FuncQueueObject_t *instance, int type) { FuncObject_t *p = (instance-\u0026gt;__queue).head; FuncObject_t *tmp = NULL; if (p-\u0026gt;type == type) { (instance-\u0026gt;__queue).head = p-\u0026gt;next; free(p); return; } while (p-\u0026gt;next != NULL) { if (p-\u0026gt;next-\u0026gt;type == type) { break; } else{ p = p-\u0026gt;next; } } tmp = p-\u0026gt;next; p-\u0026gt;next = tmp-\u0026gt;next; if (tmp == (instance-\u0026gt;__queue).tail) { (instance-\u0026gt;__queue).tail = p; } free(tmp); } void Set_Ex(FuncQueueObject_t *instance,void(*CallBack)(void *package), int state) { FuncObject_t *tmp = instance-\u0026gt;Set(CallBack, state); instance-\u0026gt;Add(instance, tmp); } FuncQueueObject_t *FuncQueueObject_New() { FuncQueueObject_t *tmp = NEW(FuncQueueObject_t); tmp-\u0026gt;Init = Init; tmp-\u0026gt;Add = Add; tmp-\u0026gt;Set = Set; tmp-\u0026gt;Set_Ex = Set_Ex; tmp-\u0026gt;Delete = Delete; return tmp; } void FuncQueueObject_Delete(FuncQueueObject_t *object) { free(object); } 如此我们核心的地方已经实现完成了。 下面我们来具体看看这个是如何使用的。\n1 2 3 4 FuncQueueObject_t *FuncEvents; FuncEvents = FuncQueueObject_New(); FuncEvents-\u0026gt;Init(FuncEvents); FuncEvents-\u0026gt;Set_Ex(FuncEvents, Func1, 1); 上面的代码添加了一个对事件标识为1的响应事件。 我们只需要在需要开始响应事件的地方加一个轮询就能够根据事件标识调用我们需要的函数了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void DataDeal(struct Package *package) { FuncObject_t *p = (FuncEvents-\u0026gt;__queue).head; if (p-\u0026gt;type == (package-\u0026gt;head).type) { p-\u0026gt;CallBack(package); return; } while (p-\u0026gt;next != NULL) { if (p-\u0026gt;next-\u0026gt;type == (package-\u0026gt;head).type) { p-\u0026gt;CallBack(package); break; } } } ","date":"2016-01-16T07:15:00Z","permalink":"https://real-zony.github.io/p/a-humble-event-poll/","title":"一个简陋的事件轮询"},{"content":"首先注明，接口是无法是无法实现实例化，但是可以声明一个接口引用，指向实现该接口的类。 格式如下：\n接口名称 对象名称 = new 具体实现类名\n因为面向对象语言都具有多态性，可以向上转型，例如某个类实现了IBark接口，假如这个类的名称是dog，那么则可以有如下书写方式：\n1 IBark Interface_Test = new dog; 又或者有一个类名叫做cat，同样实现了IBark接口，那么也可将Interface_Test指向Cat，例如：\n1 Interface_Test = new cat; 声明接口引用可以实现统一访问(统一接口)。\n","date":"2015-12-24T06:47:00Z","permalink":"https://real-zony.github.io/p/the-role-of-csharp-interface-instantiation/","title":"C#接口实例化的作用"},{"content":"首先注明，接口是无法是无法实现实例化，但是可以声明一个接口引用，指向实现该接口的类。 格式如下：\n接口名称 对象名称 = new 具体实现类名\n因为面向对象语言都具有多态性，可以向上转型，例如某个类实现了IBark接口，假如这个类的名称是dog，那么则可以有如下书写方式：\n1 IBark Interface_Test = new dog; 又或者有一个类名叫做cat，同样实现了IBark接口，那么也可将Interface_Test指向Cat，例如：\n1 Interface_Test = new cat; 声明接口引用可以实现统一访问(统一接口)。\n","date":"2015-12-24T06:47:00Z","permalink":"https://real-zony.github.io/p/c-sharp-interface/","title":"CSharp 接口实例化的作用"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: HookMyAttack(); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 进程映射 - DLL_PROCESS_ATTACH 大家都知道，一个程序要调用Dll里的函数，首先要先把DLL文件映射到进程的地址空间。要把一个DLL文件映射到进程的地址空间，有两种方法：静态链接和动态链接的LoadLibrary或者LoadLibraryEx，另外还可以通过注入方式来进行加载。 当一个DLL文件被映射到进程的地址空间时，系统调用该DLL的DllMain函数，传递的fdwReason参数为DLL_PROCESS_ATTACH，这种调用只会发生在第一次映射时。如果同一个进程后来为已经映射进来的DLL再次调用LoadLibrary或者LoadLibraryEx，操作系统只会增加DLL的使用次数，它不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。不同进程用LoadLibrary同一个DLL时，每个进程的第一次映射都会用DLL_PROCESS_ATTACH调用DLL的DllMain函数。 可参考DllMainTest的DLL_PROCESS_ATTACH_Test函数。\n进程卸载 - DLL_PROCESS_DETACH 当DLL被从进程的地址空间解除映射时，系统调用了它的DllMain，传递的fdwReason值是DLL_PROCESS_DETACH。当DLL处理该值时，它应该执行进程相关的清理工作。 那么什么时候DLL被从进程的地址空间解除映射呢？两种情况： ◆FreeLibrary解除DLL映射（有几个LoadLibrary，就要有几个FreeLibrary） ◆进程结束而解除DLL映射，在进程结束前还没有解除DLL的映射，进程结束后会解除DLL映射。（如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。） 注意：当用DLL_PROCESS_ATTACH调用DLL的DllMain函数时，如果返回FALSE，说明没有初始化成功，系统仍会用DLL_PROCESS_DETACH调用DLL的DllMain函数。因此，必须确保清理那些没有成功初始化的东西。 可参考DllMainTest的DLL_PROCESS_DETACH_Test函数。\n线程映射 - DLL_THREAD_ATTACH 当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，并用值DLL_THREAD_ATTACH调用DLL的DllMain函数。 新创建的线程负责执行这次的DLL的DllMain函数，只有当所有的DLL都处理完这一通知后，系统才允许进程开始执行它的线程函数。 注意跟DLL_PROCESS_ATTACH的区别，我们在前面说过，第n(n\u0026gt;=2)次以后地把DLL映像文件映射到进程的地址空间时，是不再用DLL_PROCESS_ATTACH调用DllMain的。而DLL_THREAD_ATTACH不同，进程中的每次建立线程，都会用值DLL_THREAD_ATTACH调用DllMain函数，哪怕是线程中建立线程也一样。\n线程卸载 - DLL_THREAD_DETACH 如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread），系统查看当前映射到进程空间中的所有DLL文件映像，并用DLL_THREAD_DETACH来调用DllMain函数，通知所有的DLL去执行线程级的清理工作。 注意：如果线程的结束是因为系统中的一个线程调用了TerminateThread，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。\n","date":"2015-12-24T06:45:00Z","permalink":"https://real-zony.github.io/p/detailed-explanation-of-dll-main-function-under-windows/","title":"Windows下 DLL Main 函数详解"},{"content":"1.该例题出自于6.7节的While的循环的使用(P178页) 1 2 3 4 5 6 7 8 9 int arr1[5]={0,1,2,3,4}; int *source=arr1; size_t sz = sizeof(arr1)/sizeof(*arry1); int *dest=new int[sz](0); while(source != arr1+sz) { *dest++=*source++; } delete []dest; // 错误代码 注意，最后一句调用将会出现运行时错误，因为现在dest指针指向的是dest[5]，即第6个不存在的元素，如果现在使用delete删除dest指向的数组的话，将会删除未知的内存位置，解决办法是使用一个临时变量来保存dest指针的初始位置。\n1 2 3 4 5 6 7 8 9 10 11 12 int arr1[5]={0,1,2,3,4}; int *source=arr1; size_t sz = sizeof(arr1)/sizeof(*arry1); int *dest=new int[sz](0); int *temp=dest; while(source != arr1+sz) { *dest++=*source++; } delete []temp; dest=null; 2.这一个例题出现在8.2的P248页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int val; while(cin\u0026gt;\u0026gt;val,!cin.eof()) { if(cin.bad()) { throw runtime_error(\u0026#34;IO stream corruped!\u0026#34;); } if(cin.fail()) { cerr\u0026lt;\u0026lt;\u0026#34;bad data,try agin!\u0026#34;; cin,clear(istream::failbit); cin.ignore(numeric_limits\u0026lt;streamsize\u0026gt;::max(),\u0026#39;\\n\u0026#39;); continue; } } 如果输入一个无效的整形数据流，将会造成无限循环，问题的根源是在缓冲区并没有被完全清除。 请参考 http://www.cppreference.com/wiki/io/clear\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /*void stream::clear( iostate flags = ios::goodbit );The function clear() does two things: it clears all io_stream_state_flags associated with the current stream, and sets the flags denoted by flags*/ int val; while(cin\u0026gt;\u0026gt;val,!cin.eof()) { if(cin.bad()) { throw runtime_error(\u0026#34;IO stream corruped!\u0026#34;); } if(cin.fail()) { cerr\u0026lt;\u0026lt;\u0026#34;bad data,try agin!\u0026#34;; cin,clear(istream::goodbit); cin.ignore(numeric_limits\u0026lt;streamsize\u0026gt;::max(),\u0026#39;\\n\u0026#39;); continue; } } ","date":"2015-12-15T05:42:00Z","permalink":"https://real-zony.github.io/p/errors-caused-by-imprecise-examples-of-c-primer/","title":"C++ Primer 例题不严谨导致的错误"},{"content":" 约定 入栈顺序 函数类型 _cdecl 右→左 母函数 _fastcall 右→左 子函数 _stdcall 右→左 子函数 如果不指定调用约定的话，默认为_stdcall函数调用函数顺序\n参数从右到左依次入栈。 返回地址入栈：将当前代码下一条指令入栈，以确保返回后能够继续执行余下指令。 代码区跳转：CPU将当前代码跳转到函数区域。 栈帧调整。 如：\n1 2 3 4 5 6 7 push3;函数参数从右到左依次入栈push2 push 1 call 函数地址; 向当前栈压入当前所在地址；跳转 push ebp;保存旧栈底部 movebp,esp;设置新栈底部 sub ebp,XXX;设置栈顶 ","date":"2015-12-15T05:36:00Z","permalink":"https://real-zony.github.io/p/function-stacking-order/","title":"函数入栈顺序"},{"content":"说起结构体与byte[]之间的转换，主要是为了能够让结构体通过socket进行传输，实现通信。 首先我们来看看C下面的一个结构体:\n1 2 3 4 5 6 7 #prgrma pack(1) struct pack { uint8_t type; uint32_t lenght; } #prgrma pack() 这里我们需要字节对齐，以保证两个平台之间数据传输的正确性。\n1 2 3 4 5 6 7 [Serializable] [StructLayout(LayoutKind.Sequential,Pack=1)] public struct pack { byte type; int lenght; } 下面上一张表，以表示在C#下面的数据类型与C/C++的不同：\n如果我们是在C/C++下面使用send/recv接收数据的话，直接将指针传递给函数就可以了，但是在c#下面显然行不通，c#的socket.send方法与socket.recive方法都只能接受或者发送byte[]类型，如果我们需要发送结构体，就需要将结构体转换为byte[]类型或者将字节数组转换为我们需要的结构体。 我们可以编写两个函数来实现两种不同类型的转换，在编写的时候我们需要:\n1 using System.Runtime.InteropServices; 下面我们就来写这两个函数，StructToBytes和BytesToStruct:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public byte[] StructToBytes(object obj) { int size = Marshal.SizeOf(obj); byte[] bytes = new byte[size]; IntPtr structptr = Marshal.AllocHGlobal(size); Marshal.StructureToPtr(obj, structptr, false); Marshal.Copy(structptr, bytes, 0, size); //Marshal.FreeHGlobal(structPtr); return bytes; } public object BytesToStruct(byte[] bytes,Type type) { int size = Marshal.SizeOf(type); if (size \u0026gt; bytes.Length) { //返回空 return null; } IntPtr structPtr = Marshal.AllocHGlobal(size); //将byte数组拷到分配好的内存空间 Marshal.Copy(bytes, 0, structPtr, size); //将内存空间转换为目标结构 object obj = Marshal.PtrToStructure(structPtr, type); //释放内存空间 Marshal.FreeHGlobal(structPtr); //返回结构 return obj; } ","date":"2015-12-08T08:22:00Z","permalink":"https://real-zony.github.io/p/conversion-between-csharp-structure-and-byte-and-communication-between-csharp-and-cc-server/","title":"C# 结构体与byte[]之间的转换，以及C#与C/C++服务器之间的通信"},{"content":"我们首先来看看sqlite3_exec()函数的原型：\n1 2 3 4 5 6 7 SQLITE_API int SQLITE_STDCALL sqlite3_exec( sqlite3*, /* An open database */ const char *sql, /* SQL to be evaluated */ int (*callback)(void*,int,char**,char**), /* Callback function */ void *, /* 1st argument to callback */ char **errmsg /* Error msg written here */ ); 第一个参数是打开sqlite3数据库句柄，第二个参数是你要执行的sql语句，第三个参数是每次查询所调用的回调函数，第四个参数是我们传入的参数，假如说我们在回调函数中找到了我们需要的数据，那么我们就可以通过这个指针来反馈给我们的调用者，第五个参数是调用sqlite3_exec发生错误时候的描述。\n1 int (*callback)(void*,int,char**,char**); 我们这次碰到的问题就是在第三个参数和第四个参数之间的传递问题，我设计了一个查询函数，他将会调用sqlite3_exec()来查询，并且在callback函数当中通过void *这个指针来反馈我们需要的信息。\nOK，知道了这些我们就来写一个实例来查询，为了简化我们的程序，不必要的错误判断已经略过：\n1 2 3 4 5 6 7 8 9 10 void query() { sqlite3 *pDB=NULL; char *result;/*反馈信息*/ char *cErrMsg; int nRes=sqlite3_open(\u0026#34;/home/xxx/u.db\u0026#34;,\u0026amp;pDB); const char *sqlstr=\u0026#34;SELECT * FROM \u0026#39;info\u0026#39;\u0026#34;; int res=sqlite3_exec(pDB,sqlstr,CB,result,\u0026amp;cErrMsg); printf(\u0026#34;%s\\n\u0026#34;,result); } 下面使我们的回调函数实现：\n1 2 3 4 5 6 7 8 9 10 11 int CB(void *param,int argc,char **value,char **ColName) { for(int i=0;i\u0026lt;argc;i++) { if(!strcmp(ColName[i],\u0026#34;url\u0026#34;)) { param=value[i]; } } return 0; } 调用的时候，printf出来的结果是错误的。。。 这是为什么呢？ 回到之前的代码，我们传给回调函数的是一个char *指针，而value[i]也是一个char *指针，指向的是我们需要的值，那么我们这样操作应该是没问题的啊？我们会想，是不是因为函数销毁了局部变量呢? 我们改成如下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int CB(void *param,int argc,char **value,char **ColName) { for (int i = 0; i \u0026lt; argc; i++) { if (!strcmp(azColName[i], \u0026#34;url\u0026#34;)) { char *tmp = (char *)malloc(sizeof(char)*strlen(value[i])); tmp = value[i]; param = tmp; } } return 0; } 运行之后仍然是错误的，那是为什么呢？ 百思不得其解之后，在stackoverflow上面找到一篇被删除的问题：\nYou are writing the pointer to the newly allocated memory into res, but that variable is a local variable inside select_callback, so sql_exec will not know about it. The same applies to the param parameter: it is just a copy of sqlite3_exec\u0026rsquo;s fourth parameter.\nTo ensure that your changes to the string are seen, you have to pass a pointer to the string itself (which is a pointer in C, or could be a string object in C++), similar to the error message. For C:\n1 2 3 4 5 6 7 8 9 char *result_str = ...; rc = sqlite3_exec(..., \u0026amp;result_str, ...); ... int callback(void *param, ...) { char **result_str = (char **)param; *result_str = (char *)realloc(*result_str, ...); strcpy(*result_str, ...); } 大概的问题主要是这样的，刚开始我们直接传的是result,但是result是NULL的，而且result代表的是result这个char指针指向的第一个元素位置，这里明显为0x00000000，而我们传给callback函数的就是这个0x00000000地址，因此我们在callback函数里面result=value[i]的含义就是将value[i]的值复制给0x0000000这个不存在的地址，所以肯定不行啦。 我们对之前的程序作如下改动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int CB(void *param,int argc,char **value,char **ColName) { for(int i=0;i\u0026lt;argc;i++) { if(!strcmp(ColName[i],\u0026#34;url\u0026#34;)) { char **tmp=(char **)param; *param=value[i]; } } return 0; } void query() { sqlite3 *pDB=NULL; char *result;/*反馈信息*/ char *cErrMsg; int nRes=sqlite3_open(\u0026#34;/home/xxx/u.db\u0026#34;,\u0026amp;pDB); const char *sqlstr=\u0026#34;SELECT * FROM \u0026#39;info\u0026#39;\u0026#34;; int res=sqlite3_exec(pDB,sqlstr,CB,\u0026amp;result,\u0026amp;cErrMsg); printf(\u0026#34;%s\\n\u0026#34;,result); } 在新的程序里面，我们传入的是result的地址，即char result; 然后在callback函数里面我们则强制转换param为char,然后再对其进行解引用操作就可以将内容传出去了。\n","date":"2015-12-05T15:49:00Z","permalink":"https://real-zony.github.io/p/bloody-case-caused-by-sqlite3exec-function/","title":"sqlite3_exec()函数引发的血案"},{"content":"早先在博客文章 《在Linux下获得程序运行的绝对路径》 当中写到的获取当前运行路径的程序，在编译的时候会提示:\nwarning : address of local variable ‘current_path’ returned [-Wreturn-local-addr]\n大概意思就是说current_path是局部指针，如果返回的话，因为函数结束后会释放掉指针指向的地址空间，所以提示这个警告。 举个例子:\n1 2 3 4 5 6 char *Func() { char buff[50]; buff=\u0026#34;fuckyou\u0026#34;; return buff; } 最后调用这个函数并不会返回我们指定的字符串，但是在我们获得路径的程序里面却能够正常返回，这是为什么呢？ 回想之前文章里面为保存路径所分配的数组大小是 1024，缩小成 50 也是会得到如上错误。 其实这个写法本身就是错误的，因为我们的程序只是恰好在访问到未被覆盖的内存地址而已。 引用 CSDN C 语言版主 paschen 的 说法\n这是一种不确定行为，你输出的值和函数中的一样只能说明他该值还未被其他值覆盖，如果你调用其他函数等，之前指针所指的内存可能就被其他数据覆盖了，所以不要返回局部变量的指针\n所以请严格按照 C++ Primer 4th 的 p214~p215 的说法，千万不要返回局部对象的引用或者局部对象的指针，因为一旦函数执行完毕之后会销毁掉！\n","date":"2015-12-05T03:08:00Z","permalink":"https://real-zony.github.io/p/thoughts-on-function-returning-local-pointer-variables/","title":"关于函数返回局部指针变量的思考"},{"content":"我们要在 Linux 下使用 C 语言获得当前程序路径的话，需要使用到 readlink() 函数，这个函数在头文件 unistd.h 当中定义，使用的时候记得一定要引用哦。\n原理很简单，因为 Linux 系统中有个符号链接: /proc/self/exe 它代表当前程序,所以我们使用函数 readlink() 就能读取到当前程序运行时的绝对路径了。\nreadlink() 函数有三个参数，第一个为路径，第二个为保存信息的 char buffer,第三个为 buffer 的长度,他的返回值是不包含字符串结尾(\\0)的长度。\n","date":"2015-12-04T13:35:00Z","permalink":"https://real-zony.github.io/p/get-the-absolute-path-of-the-program-running-under-linux/","title":"在Linux下获得程序运行的绝对路径"},{"content":"Clion 是 Jetbrains公司所推出的新一代跨平台 C++ IDE，弥补了 Linux 平台上面 IDE 不强的局面。 Clion 基于 CMAKE 进行编译操作，但是 Clion 与 Intellij 不同，Clion 并没有图形化的第三方库引用界面，只有通过对 CMakeList.txt 进行手动链接才可以引用第三方库。\n我们这里以 Libev 库为例：\n1 2 link_libraries(/usr/local/lib) target_link_libraries(Shadowsocks_libev -lev) 第一次编译的时候会报错：\nError While Loading Shared Libraries, Cannot Open Shared Object File weighttp: error while loading shared libraries: libev.so.4: cannot open shared object file: No such file or directory\n有时候 MySQL 明明指定了静态库却也会出现上述情况。 原因很简单: 因为我们编译的时候默认是存放在 /usr/local 下面的，这是为了 UNIX 的稳定性，防止覆盖之前的库文件。 解决方法:\n1 sudo ln -s /usr/local/lib/libev.so.4 /usr/lib/libev.so.4 建立符号链接到 /usr/lib 即可。\n其他解决办法在: http://www.tuicool.com/articles/Qr2aye 就已经提出了解决方案。\n","date":"2015-11-23T12:29:00Z","permalink":"https://real-zony.github.io/p/clion-references-third-party-libraries/","title":"Clion 引用第三方库"},{"content":"经常我们使用C#开发windows窗体程序的时候，会使用到图标，但经常会碰到这样一个问题。 如果我们在项目属性中设定了一个50kb的ico图标，但是我们为了每个窗体的美观都需要在每个窗体又要使用相同的图标文件，这样的话，如果我们有3个窗体，就需要3个图标150KB，加上项目图标就是200KB，如果你有很多窗口的话，那么就会更加蛋疼。\n解决办法就是在每个窗体的ico图标我们直接使用项目的那个50kb的图标就行了，避免重复添加。 只需要在每个窗口的laod事件里面手动加载图标即可。\n1 2 3 4 5 private void Form1_Load(object sender, EventArgs e) { // 加载图标 this.Icon = Zony_Lrc_Download_2._0.Resource1._6; } ","date":"2015-11-22T05:53:00Z","permalink":"https://real-zony.github.io/p/winform-icon-reuse-to-reduce-exe-file-size/","title":"WinForm 图标复用，减少exe文件体积"},{"content":"一般我们如果碰到如下代码一般都会认为是错误的。\n1 2 int a=10; int array[a]; 因为我们的书上明确说过，定义数组的时候，数组维度必须为常量表达式或者const的常量。 就像下面一样：\n1 2 3 int array[10]; const int lenght=10; int array2[lenght]; 第一次我看到第一段代码的时候认为绝壁编译无法通过，刚好我又在Linux下开发程序，抱着怀疑的心态编译了一下，结果竟然通过了。当时我的人生观、价值观、世界观就被颠覆了，便在网上四处搜索答案，之后在 http://www.cnblogs.com/hazir/p/variable_length_array.html 找到了答案。\n在 ISO/IEC9899 标准的 6.7.5.2 Array declarators 中明确说明了数组的长度可以为变量的，称为变长数组（VLA，variable length array）。（注：这里的变长指的是数组的长度是在运行时才能决定，但一旦决定在数组的生命周期内就不会再变。） 在 GCC 标准规范的 6.19 Arrays of Variable Length 中指出，作为编译器扩展，GCC 在 C90 模式和 C++ 编译器下遵守 ISO C99 关于变长数组的规范。 GCC 中允许使用零长数组，把它作为结构体的最后一个元素非常有用，下面例子出自 gcc 官方文档。\n1 2 3 4 5 6 7 struct line { int length; char contents[0]; }; struct line *thisline = (struct line *) malloc (sizeof (struct line) + this_length); thisline-\u0026gt;length = this_length; 从上例就可以看出，零长数组在有固定头部的可变对象上非常适用，我们可以根据对象的大小动态地去分配结构体的大小。\n","date":"2015-11-18T14:23:00Z","permalink":"https://real-zony.github.io/p/gcc-zero-length-arrays-and-variable-length-arrays/","title":"GCC零长数组与变长数组"},{"content":"在自己开发服务器软件的时候遇到的问题，如果使用纯粹的char或者文本进行数据通信的话，可读性差不说，而且很容易被截取破解，所以萌生了一个开发自己通信协议的想法，本文章的思路借鉴了 Charles0429 在github上的项目的思想。\n在本文章里面，我们数据通信统一采用一个结构体来进行数据通信与传输，它包含一个标志头，数据体与校验码，校验码来保证数据传输的正确性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define HEAD_SIZE sizeof(package_head_t) #define PACKAGE_SIZE sizeof(package_t) #define CS_SIZE (16 * sizeof(uint8_t)) typedef struct package_head { uint8_t type; /*表明数据类型*/ uint32_t lenght /*表明整个数据的长度*/ }package_head_t; typedef struct package { package_head_t head; char* data; /*传输的具体数据*/ uint8_t CS[16]; /*MD5数据校验，可选*/ }package_t; 以上代码需要包含以下头文件：\n1 2 3 4 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; 有了基本的结构定义，那么我们就要对这些进行具体操作了，首先来看看我们的第一个函数。\n1 package_t *package_read(int socket_fd); 这个函数拥有一个package_t指针，用来指向已经读取完成了的package。他还有一个参数socket_fd,用来确定从哪个套接字描述符来读取package。 下面我们来看看具体的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package_t *package_read(int socket_fd) { int recv_len; /*已经接收到的总字节数*/ int data_len; /*数据体的长度*/ int len; /*recv接收到的字节数*/ package_t *tmp = (package_t*)malloc(PACKAGE_SIZE); /*接受头部信息*/ while(recv_len\u0026lt;HEAD_SIZE) { len=recv(socket_fd,tmp,HEAD_SIZE-recv_len,0); if(len\u0026gt;0) { recv_len+=len; } } recv_len=0; data_lenght=get_lenght(tmp); /*获取数据长度*/ /*初始化数据体*/ tmp-\u0026gt;data=(char*)malloc(sizeof(char)*data_lenght); /*接受数据体*/ while(recv_len\u0026lt;data_lenght) { len=recv(socket_fd,tmp,data_lenght-recv_len,0); if(len\u0026gt;0) { recv_len+=len; } } recv_len=0; while(recv_len\u0026lt;CS_SIZE) { len=recv(socket_fd,tmp_data,CS_SIZE-recv_len,0); if(len\u0026gt;0) { recv_len+=len; } } } 上面用到了一个函数get_lenght()，实际就是取package的数据体长度。\n1 2 3 4 uint32_t get_lenght(package_t *pack) { return pack-\u0026gt;data_lenght; } 这个代码思路很简单，依次使用recv读取到数据，每次读取之后的len长度相加，直到读取完成。 下面再写一个发送package_t的函数，用户将我们的数据发送给 服务端/客户端。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void package_write(int socket_fd,void *package) { int send_len; int len; int data_lenght; package_t *tmp = (package_t*)package; while(send_len\u0026lt;HIDE_SIZE) { len=send(socket_fd,tmp,HEAD_SIZE-send_len); if(len\u0026gt;0) { send_len+=len; } } send_len=0; data_lenght=get_lenght(tmp); while(send_len\u0026lt;data_lenght) { len=send(socket_fd,tmp-\u0026gt;data,data_lenght-send_len); if(len\u0026gt;0) { send+=len; } } send_len=0; while(send_len\u0026lt;CS_SIZE) { len=send(socket_fd,tmp-\u0026gt;CS,CS_SIZE-send_len); if(len\u0026gt;0) { send_len+=len; } } } ","date":"2015-11-10T13:06:00Z","permalink":"https://real-zony.github.io/p/implement-a-simple-communication-protocol-in-c/","title":"用 C++ 实现一个简单的通信协议"},{"content":"单例模式也称为单件模式、单子模式，可能是使用最广泛的设计模式。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。 单例模式有许多种实现方法，在C++中，甚至可以直接用一个全局变量做到这一点，但这样的代码显的很不优雅。 使用全局对象能够保证方便地访问实例，但是不能保证只声明一个对象——也就是说除了一个全局实例外，仍然能创建相同类的本地实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CSingleton *CSingleton::m_pInstance; class CSingleton { private: CSingleton() //构造函数是私有的 { } static CSingleton *m_pInstance; public: static CSingleton * GetInstance() { if(m_pInstance == NULL) //判断是否第一次调用 m_pInstance = new CSingleton(); return m_pInstance; } }; 我们知道，程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。如下面的代码中的CGarbo类（Garbo意为垃圾工人）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class CSingleton { private: CSingleton() { } static CSingleton *m_pInstance; class CGarbo //它的唯一工作就是在析构函数中删除CSingleton的实例 { public: ~CGarbo() { if(CSingleton::m_pInstance) delete CSingleton::m_pInstance; } }; static CGarbo Garbo; //定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数 public: static CSingleton * GetInstance() { if(m_pInstance == NULL) //判断是否第一次调用 m_pInstance = new CSingleton(); return m_pInstance; } }; 转自：http://blog.csdn.net/hackbuteer1/article/details/7460019\n","date":"2015-11-09T04:42:00Z","permalink":"https://real-zony.github.io/p/implementation-of-the-singleton-pattern/","title":"单例模式的实现"},{"content":".Net 的 HttpWebRequest 或者 WebClient 在多线程情况下存在并发连接限制，这个限制在桌面操作系统如 windows xp , windows 7 下默认是2，在服务器操作系统上默认为10. 如果不修改这个并发连接限制，那么客户端同时可以建立的 http 连接数就只有2个或10个。对于一些诸如浏览器或网络蜘蛛的应用，2个或10个并发数量实在太少，大大影响应用的性能。之所以有这个并发连接限制，是因为 http 1.0 和 http 1.1 标准规定并发连接数最大为2. 不过目前主流的浏览器都已经不遵循这个规则了，但 .net framework 依然默认遵循这个规则。 很多文章说用异步方式访问 HttpWebRequest 可以提高并发性能，但我测试下来，如果不修改这个默认并发连接数，同步或异步方式访问性能都很不好。\n调整这个默认并发连接限制的方法很简单\n只要在程序中设置：\n1 System.Net.ServicePointManager.DefaultConnectionLimit = 512; 这个值最好不要超过1024。\n我们也可以在app.config 中对最大并发连接数进行设置，方法如下：\n1 2 3 4 5 6 7 8 \u0026lt;configuration\u0026gt; \u0026lt;system.net\u0026gt; \u0026lt;connectionManagement\u0026gt; \u0026lt;add address = \u0026#34;http://www.google.com\u0026#34; maxconnection = \u0026#34;512\u0026#34; /\u0026gt; \u0026lt;add address = \u0026#34;*\u0026#34; maxconnection = \u0026#34;512\u0026#34; /\u0026gt; \u0026lt;/connectionManagement\u0026gt; \u0026lt;/system.net\u0026gt; \u0026lt;/configuration\u0026gt; 修改了这个设置后，并发性能明显提高，从原来每秒钟20次直接上升到每秒钟1000多次。\n","date":"2015-11-03T14:30:00Z","permalink":"https://real-zony.github.io/p/concurrent-connection-limit-for-calling-httpwebrequest-in-a-multi-threaded-environment/","title":"多线程环境下调用 HttpWebRequest 并发连接限制"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import sys, urllib,string import re,os import threading url=raw_input(\u0026#39;input url:\u0026#39;) s=url.find(\u0026#34;index.html\u0026#34;) str=url[0:s] content = urllib.urlopen(url).read() #获取链接与章节目录 re_result=re.compile(r\u0026#39;(?\u0026lt;=\u0026lt;a href=\u0026#34;)\\d+.html(?=\u0026#34;)\u0026#39;) lianjie=re.findall(re_result,content) #获取小说名称 re_title=re.compile(r\u0026#39;(?\u0026lt;=\u0026lt;div id=\u0026#34;title\u0026#34;\u0026gt;).+(?=\u0026lt;/)\u0026#39;) re_title_result=re.findall(re_title,content) # 章节重新排序 lianjie.sort() #获取文章链接 i=0 wzsj=[] for j in lianjie: wzsj.append(str+lianjie[i]) i=i+1 # 获取文章内容 fb=open(\u0026#34;d:\\\\\u0026#34;+ re_title_result[0]+\u0026#34;.txt\u0026#34;,\u0026#34;w\u0026#34;) for b in wzsj: nr=urllib.urlopen(b).read() #获取文章标题 title_re=re.compile(r\u0026#39;(?\u0026lt;=\u0026lt;div id=\u0026#34;title\u0026#34;\u0026gt;).+(?=\u0026lt;/)\u0026#39;) title=re.findall(title_re,nr) #获取正文内容 b2=re.compile(r\u0026#39;(?\u0026lt;=\u0026lt;div id=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;div id=\u0026#34;adright\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;)[\\s|\\S]*(?=\u0026lt;/div\u0026gt;)\u0026#39;) nr2=re.findall(b2,nr) #空白符与换行符处理 t=nr2[0].replace(r\u0026#39;\u0026lt;br /\u0026gt;\u0026#39;,\u0026#39;\\n\u0026#39;) t2=t.replace(r\u0026#39;\u0026amp;nbsp;\u0026#39;,\u0026#39;\u0026#39;) print(\u0026#34;Now DownLoad\u0026amp;#65306;\u0026#34;+title[0]) fb.write(\u0026#34;\\n\\n\\n\u0026#34;+title[0]+\u0026#34;\\n\\n\u0026#34;+t2) fb.close() 以上代码需要python-2.7.3支持。\n","date":"2015-11-02T13:48:00Z","permalink":"https://real-zony.github.io/p/bxwx-novel-download-widget/","title":"bxwx小说下载小工具"},{"content":"从网上下载的一般都是 SQLite3.dll 和 SQLite3.def 文件。 生成的方法是：\n第一步：找到 LIB.EXE 所在目录 一般都在 C:\\Program Files\\Microsoft Visual Studio\\VC98\\Bin 下(如果VC是装在C盘的话)，在 \u0026ldquo;运行\u0026rdquo; 中输入 cmd，然后切换到该目录下\n第二步：使用 LIB 命令生成 .lib 文件 很多网页上都介绍，使用 LIB /DEF:sqlite3.def /machine:IX86 即可生成，可是我使用它时遇到一些小问题。 这里就不说了，说说应该注意的几点问题吧。\n第一个，你的 sqlite3.def 要是没有在 C:\\Program Files\\Microsoft Visual Studio\\VC98\\Bin 下，需要写全路径； 第二，为了清楚起见，你需要注明 .lib 文件的输出路径。下面我给出一个完整的命令行： C:\\Program Files\\Microsoft Visual Studio\\VC98\\Bin\u0026gt;LIB /out:D:\\test\\sqlite3.lib /MACHINE:IX86 /DEF:D:\\test\\sqlite3.def 运行完这个命令后，你会在 D:\\test\\ 下发现 sqlite3.lib 和 sqlite3.exp 两个文件。\n","date":"2015-11-02T13:41:00Z","permalink":"https://real-zony.github.io/p/sqlite-lib-generation-method/","title":"SQLite Lib 生成方法"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;mysql.h\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; static int count = 0; static struct itimerval oldtv; static int state = 0; MYSQL *conn_ptr; int res; void set_timer() { struct itimerval itv; itv.it_interval.tv_sec = 60; itv.it_interval.tv_usec = 0; itv.it_value.tv_sec = 60; itv.it_value.tv_usec = 0;\tsetitimer(ITIMER_REAL, \u0026amp;itv, \u0026amp;oldtv); } void signal_handler(int m) { time_t rawtime; struct tm * timeinfo; time(\u0026amp;rawtime); timeinfo = localtime(\u0026amp;rawtime); if (timeinfo-\u0026gt;tm_hour == 0\u0026amp;\u0026amp;state==0)\t{ if (conn_ptr) { res = mysql_query(conn_ptr, \u0026#34;UPDATE miduser SET sate = 0 WHERE sate = 1\u0026#34;); if (!res) { //输出受影响的行数 printf(\u0026#34;Inserted %lu rows\\n\u0026#34;, (unsigned long)mysql_affected_rows(conn_ptr)); }\telse { //打印出错误代码及详细信息 fprintf(stderr, \u0026#34;Insert error %d: %sn\u0026#34;, mysql_errno(conn_ptr), mysql_error(conn_ptr)); } }\telse { printf(\u0026#34;Connection failed\\n\u0026#34;);\t} state += 1; } if (timeinfo-\u0026gt;tm_hour == 1)state = 0; int main() { conn_ptr = mysql_init(NULL); if (!conn_ptr) { printf(\u0026#34;mysql_init failed\\n\u0026#34;); return EXIT_FAILURE;\t}\tconn_ptr = mysql_real_connect(conn_ptr, \u0026#34;115.28.xx.xx\u0026#34;, \u0026#34;xxxx\u0026#34;, \u0026#34;xxxx\u0026#34;, \u0026#34;fuzhu\u0026#34;, 3306, NULL, 0); signal(SIGALRM, signal_handler); set_timer(); getchar(); mysql_close(conn_ptr);\treturn 1; } ","date":"2015-11-02T10:40:00Z","permalink":"https://real-zony.github.io/p/the-server-updates-the-database-at-000-every-day/","title":"服务器每天零点更新数据库"},{"content":"1：如何包含SQLite3的*.h与*.cpp文件。\n首先去http://www.sqlite.org/download.html下载sqlite-amalgamation-3081101.zip，解压之后会得到如下文件：\n之后在VS里面右键你的项目，点击“VisualGDB Project Properties” ，点击Add Local选中你刚才解压的文件目录。\n这样就可以在你的工程里面使用SQLite3的头文件了。\n2：如果仅仅是实现如上操作并不能正常通过编译，会报出以下错误。\n这个时候你需要在工程设置里面指定makefile要包含的目录。\n以上工作做完之后，继续编译，却发现仍然出现了错误。\n出现以上问题的原因，就是因为我们仅仅是下载包含了头文件，但是并没有相应的静态库。\n我们再去刚才的http://www.sqlite.org/download.html，下载sqlite-autoconf-3081101.tar.gz ，将其解压之后，来到他的根目录，打开终端，输入以下语句：\n./configure \u0026ndash;prefix=/home/sqlite-3.3.8-ix86\n注意，这里的 /home/sqlite-3.3.8-ix86 指的是你所解压到的文件夹路径。\n之后编译并且生成帮助文档：\nmake \u0026amp;\u0026amp; make install \u0026amp;\u0026amp; make doc\n如果你发生了错误，请可以先安装ActiveTcl以解决.假如你不需要tcl支持,那么这个错误可以这样避免:\n./configure \u0026ndash;disable-tcl \u0026ndash;prefix=/home/sqlite-3.3.8-ix86 之后进行以下设置即可。\n之后便能够正常编译了~~~~~~\n","date":"2015-11-02T08:06:00Z","permalink":"https://real-zony.github.io/p/visualgdb-ru-he-shi-yong-di-san-fang-ku-li-sqlite3/","title":"VisualGDB 如何使用第三方库(例：SQLITE3)"}]